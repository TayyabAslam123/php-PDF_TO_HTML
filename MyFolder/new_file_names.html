<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><HTML>
<HEAD>
<TITLE></TITLE>
</HEAD>
<BODY>
<A name=1></a><IMG src="new_file_name-1_1.jpg"><br>
<hr>
<A name=2></a><hr>
<A name=3></a><b>Digital Design</b><br>
With an Introduction to the Verilog HDL<br>
<hr>
<A name=4></a><i>This page intentionally left blank </i><br>
<hr>
<A name=5></a><b> <br>Digital Design </b><br>
 <br>With an Introduction to the Verilog HDL <br>
 <br>FIFTH EDITION <br>
 <br>M. Morris   Mano <br>
<i> <br>Emeritus Professor of Computer Engineering </i><br>
<i> <br>California State University, Los Angeles  </i><br>
 <br>Michael D.   Ciletti <br>
<i> <br>Emeritus Professor of Electrical and Computer Engineering </i><br>
<i> <br>University of Colorado at Colorado Springs  </i><br>
 <br>Upper Saddle River Boston Columbus San Franciso New York<br>
Indianapolis London Toronto Sydney Singapore Tokyo Montreal<br>
Dubai Madrid Hong Kong Mexico City Munich Paris Amsterdam Cape Town<br>
 <br>
<hr>
<A name=6></a>Vice President and Editorial Director, ECS: <br>
Cover Designer: <i>Jayne Conte</i><br>
  <i>Marcia J. Horton</i><br>
Cover Photo: <i>Michael D. Ciletti</i><br>
Executive Editor: <i>Andrew Gilfillan</i><br>
Composition: <i>Jouve India Private Limited</i><br>
Vice-President, Production: <i>Vince O'Brien</i><br>
Full-Service Project Management: <i>Jouve India Private </i><br>
Executive Marketing Manager: <i>Tim Galligan</i><br>
<i> Limited</i><br>
Marketing Assistant: <i>Jon Bryant</i><br>
Printer/Binder: <i>Edwards Brothers</i><br>
Permissions Project Manager: <i>Karen Sanatar</i><br>
Typeface: Times Ten 10/12<br>
Senior Managing Editor: <i>Scott Disanno<br></i>Production Project Manager/Editorial Production <br> Manager: <br>
<i>Greg Dulles</i><br>
<b>Copyright � 2013, 2007, 2002, 1991, 1984 Pearson Education, Inc., publishing as Prentice Hall, One Lake Street, Upper <br>Saddle River, New Jersey 07458.</b> All rights reserved. Manufactured in the United States of America. This publication is <br>protected by Copyright, and permission should be obtained from the publisher prior to any prohibited reproduction, <br>storage in a retrieval system, or transmission in any form or by any means, electronic, mechanical, photocopying, <br>recording, or likewise. To obtain permission(s) to use material from this work, please submit a written request to <br>Pearson Education, Inc., Permissions Department, One Lake Street, Upper Saddle River, New Jersey 07458.<br>
Many of the designations by manufacturers and seller to distinguish their products are claimed as trademarks. Where <br>those designations appear in this book, and the publisher was aware of a trademark claim, the designations have been <br>printed in initial caps or all caps.<br>
All rights reserved. No part of this book may be reproduced, in any form or by any means, without permission in writing <br>from the publisher.<br>
Verilogger Pro and SynaptiCAD are trademarks of SynaptiCAD, Inc., Blacksburg, VA 24062�0608.<br>
The author and publisher of this book have used their best efforts in preparing this book. These efforts include the <br>development, research, and testing of the theories and programs to determine their effectiveness. The author and <br>publisher make no warranty of any kind, expressed or implied, with regard to these programs or the documentation <br>contained in this book. The author and publisher shall not be liable in any event for incidental or consequential <br>damages in connection with, or arising out of, the furnishing, performance, or use of these programs.  <br>
About the cover: "Spider Rock in Canyon de Chelley," Chinle, Arizona, USA, January 2011. Photograph courtesy of mdc <br>Images, LLC (www.mdcilettiphotography.com). Used by permission.<br>
<b>    Library  of  Congress  Cataloging-in-Publication  Data  </b><br>
 <br>Mano, M. Morris, 1927� <br>  Digital design : with an introduction to the verilog hdl / M. Morris Mano, Michael D. Ciletti.--5th ed. <br> <br>
   <br>
p. <br>
cm. <br>
   Includes  index. <br>   ISBN-13:  978-0-13-277420-8 <br>   ISBN-10:  0-13-277420-8 <br>  1.  Electronic digital computers--Circuits. 2.  Logic circuits. 3.  Logic design. 4.  Digital integrated <br>circuits.  I. Ciletti, Michael D. II. Title. <br>   TK7888.3.M343  2011 <br>   621.39'5--dc23 <br>
 2011039094     <br>
10 9 8 7 6 5 4 3 2 1<br>
ISBN-13: 978-0-13-277420-8<br>ISBN-10:         0-13-277420-8<br>
<hr>
<A name=7></a> <br>Contents <br>
<b> <br>P r e f a c e  </b><br>
<i><b>i x</i> </b><br>
<b> <br>1     D i g i t a l   S y s t e m s   a n d   B i n a r y   N u m b e r s  </b><br>
<b> <br><i>1</i> </b><br>
 <br> 1.1 Digital <br>
Systems <br>
 <br>
 <br><i>1</i> <br>
 <br> 1.2 Binary <br>
Numbers <br>
 <br>
 <br><i>3</i> <br>
 <br> 1.3 NumberBase <br>
Conversions <br>
 <br>
 <br><i>6</i> <br>
 <br>
1.4 <br>
Octal and Hexadecimal Numbers  <br>
 <br><i>8</i> <br>
 <br>
1.5 <br>
Complements of Numbers  <br>
 <br><i>10</i> <br>
 <br>
1.6 <br>
Signed Binary Numbers  <br>
 <br><i>14</i> <br>
 <br> 1.7 Binary <br>
Codes <br>
 <br>
 <br>18  <br>
 <br>
1.8 <br>
Binary Storage and Registers  <br>
 <br><i>27</i> <br>
 <br> 1.9 Binary <br>
Logic <br>
 <br>
 <br><i>30</i> <br>
<b> <br>2     B o o l e a n   A l g e b r a   a n d   L o g i c   G a t e s  </b><br>
<b> <br><i>3 8</i> </b><br>
 <br> 2.1 Introduction <br>
 <br>
 <br><i>38</i> <br>
 <br> 2.2 Basic <br>
Definitions <br>
 <br>
 <br><i>38</i> <br>
 <br>
2.3 <br>
Axiomatic Definition of Boolean Algebra  <br>
 <br><i>40</i> <br>
 <br>
2.4 <br>
Basic Theorems and Properties of Boolean Algebra  <br>
 <br><i>43</i> <br>
 <br> 2.5 Boolean <br>
Functions <br>
 <br>
 <br><i>46</i> <br>
 <br>
2.6 <br>
Canonical and Standard Forms  <br>
 <br><i>51</i> <br>
 <br>
2.7 <br>
Other Logic Operations  <br>
 <br><i>58</i> <br>
 <br>
2.8 <br>
Digital Logic Gates  <br>
 <br><i>60</i> <br>
 <br> 2.9 Integrated <br>
Circuits <br>
 <br>
 <br><i>66</i> <br>
<b>v</b><br>
<hr>
<A name=8></a><b>vi    Contents</b><br>
<b> <br>3     G a t e  L e v e l  </b><br>
<b>M i n i m i z a t i o n  </b><br>
<b> </b><br>
<b> <br><i>7 3</i> </b><br>
 <br> 3.1 Introduction <br>
 <br>
 <br><i>73</i> <br>
 <br>
3.2 <br>
The Map Method  <br>
 <br><i>73</i> <br>
 <br> 3.3 FourVariable <br>
K-Map <br>
 <br>
 <br><i>80</i> <br>
 <br> 3.4 ProductofSums <br>
Simplification <br>
 <br>
 <br><i>84</i> <br>
 <br> 3.5 Don'tCare <br>
Conditions <br>
 <br>
 <br><i>88</i> <br>
 <br>
3.6 <br>
NAND and NOR Implementation  <br>
 <br><i>90</i> <br>
 <br>
3.7 <br>
Other TwoLevel Implementations  <br>
 <br><i>97</i> <br>
 <br> 3.8 ExclusiveOR <br>
Function <br>
 <br>
 <br><i>103</i> <br>
 <br>
3.9 <br>
Hardware Description Language  <br>
 <br><i>108</i> <br>
<b> <br>4     C o m b i n a t i o n a l  </b><br>
<b>L o g i c  </b><br>
<b> </b><br>
<b> <br><i>1 2 5</i> </b><br>
 <br> 4.1 Introduction <br>
 <br>
 <br><i>125</i> <br>
 <br> 4.2 Combinational <br>
Circuits <br>
 <br>
 <br><i>125</i> <br>
 <br> 4.3 Analysis <br>
Procedure <br>
 <br>
 <br><i>126</i> <br>
 <br> 4.4 Design <br>
Procedure <br>
 <br>
 <br><i>129</i> <br>
 <br> 4.5 Binary <br>
Adder�Subtractor <br>
 <br>
 <br><i>133</i> <br>
 <br> 4.6 Decimal <br>
Adder <br>
 <br>
 <br><i>144</i> <br>
 <br> 4.7 Binary <br>
Multiplier <br>
 <br>
 <br><i>146</i> <br>
 <br> 4.8 Magnitude <br>
Comparator <br>
 <br>
 <br><i>148</i> <br>
 <br> 4.9 Decoders <br>
 <br>
 <br><i>150</i> <br>
 <br> 4.10 <br>
Encoders <br>
 <br>
 <br><i>155</i> <br>
 <br> 4.11 <br>
Multiplexers <br>
 <br>
 <br><i>158</i> <br>
 <br>
4.12 <br>
HDL Models of Combinational Circuits  <br>
 <br><i>164</i> <br>
<b> <br>5     S y n c h r o n o u s  </b><br>
<b>S e q u e n t i a l  </b><br>
<b>L o g i c  </b><br>
<b> </b><br>
<b> <br><i>1 9 0</i> </b><br>
 <br> 5.1 Introduction <br>
 <br>
 <br><i>190</i> <br>
 <br> 5.2 Sequential <br>
Circuits <br>
 <br>
 <br><i>190</i> <br>
 <br>
5.3 <br>
Storage Elements: Latches  <br>
 <br><i>193</i> <br>
 <br>
5.4 <br>
Storage Elements: FlipFlops  <br>
 <br><i>196</i> <br>
 <br>
5.5 <br>
Analysis of Clocked Sequential Circuits  <br>
 <br><i>204</i> <br>
 <br>
5.6 <br>
Synthesizable HDL Models of Sequential Circuits  <br>
 <br><i>217</i> <br>
 <br>
5.7 <br>
State Reduction and Assignment  <br>
 <br><i>231</i> <br>
 <br> 5.8 Design <br>
Procedure <br>
 <br>
 <br><i>236</i> <br>
<b> <br>6     R e g i s t e r s  </b><br>
<b>a n d  </b><br>
<b>C o u n t e r s  </b><br>
<b> </b><br>
<b> <br><i>2 5 5</i> </b><br>
 <br> 6.1 Registers <br>
 <br>
 <br><i>255</i> <br>
 <br> 6.2 Shift <br>
Registers <br>
 <br>
 <br><i>258</i> <br>
 <br> 6.3 Ripple <br>
Counters <br>
 <br>
 <br><i>266</i> <br>
 <br> 6.4 Synchronous <br>
Counters <br>
 <br>
 <br><i>271</i> <br>
 <br> 6.5 Other <br>
Counters <br>
 <br>
 <br><i>278</i> <br>
 <br>
6.6 <br>
HDL for Registers and Counters  <br>
 <br><i>283</i> <br>
<hr>
<A name=9></a><b>Contents    vii</b><br>
<b> <br>7     M e m o r y   a n d   P r o g r a m m a b l e   L o g i c  </b><br>
<b> <br><i>2 9 9</i> </b><br>
 <br> 7.1 Introduction <br>
 <br>
 <br><i>299</i> <br>
 <br> 7.2 RandomAccess <br>
Memory <br>
 <br>
 <br><i>300</i> <br>
 <br> 7.3 Memory <br>
Decoding <br>
 <br>
 <br><i>307</i> <br>
 <br>
7.4 <br>
Error Detection and Correction  <br>
 <br><i>312</i> <br>
 <br> 7.5 ReadOnly <br>
Memory <br>
 <br>
 <br><i>315</i> <br>
 <br>
7.6 <br>
Programmable Logic Array  <br>
 <br><i>321</i> <br>
 <br>
7.7 <br>
Programmable Array Logic  <br>
 <br><i>325</i> <br>
 <br>
7.8 <br>
Sequential Programmable Devices  <br>
 <br><i>329</i> <br>
<b> <br>8      </b><br>
<b>D e s i g n   a t   t h e   R e g i s t e r <br>Tr a n s f e r   L e v e l  </b><br>
<b> <br><i>3 5 1</i> </b><br>
 <br> 8.1 Introduction <br>
 <br>
 <br><i>351</i> <br>
 <br>
8.2 <br>
Register Transfer Level Notation  <br>
 <br><i>351</i> <br>
 <br>
8.3 <br>
Register Transfer Level in HDL  <br>
 <br><i>354</i> <br>
 <br>
8.4 <br>
Algorithmic State Machines (ASMs)  <br>
 <br><i>363</i> <br>
 <br>
8.5 <br>
Design Example (ASMD Chart)  <br>
 <br><i>371</i> <br>
 <br>
8.6 <br>
HDL Description of Design Example  <br>
 <br><i>381</i> <br>
 <br>
8.7 <br>
Sequential Binary Multiplier  <br>
 <br><i>391</i> <br>
 <br> 8.8 Control <br>
Logic <br>
 <br>
 <br><i>396</i> <br>
 <br>
8.9 <br>
HDL Description of Binary Multiplier  <br>
 <br><i>402</i> <br>
 <br>
8.10 <br>
Design with Multiplexers  <br>
 <br><i>411</i> <br>
 <br>
8.11 <br>
RaceFree Design (Software Race Conditions)  <br>
 <br><i>422</i> <br>
 <br>
8.12 <br>
LatchFree Design (Why Waste Silicon?)  <br>
 <br><i>425</i> <br>
 <br>
8.13 <br>
Other Language Features  <br>
 <br><i>426</i> <br>
<b> <br>9      </b><br>
<b>L a b o r a t o r y   E x p e r i m e n t s <br>w i t h   S t a n d a r d   I C s   a n d   F P G A s  </b><br>
<b> <br><i>4 3 8</i> </b><br>
 <br>
9.1 <br>
Introduction to Experiments  <br>
 <br><i>438</i> <br>
 <br>
9.2 <br>
Experiment 1: Binary and Decimal Numbers  <br>
 <br><i>443</i> <br>
 <br>
9.3 <br>
Experiment 2: Digital Logic Gates  <br>
 <br><i>446</i> <br>
 <br>
9.4 <br>
Experiment 3: Simplification of Boolean Functions  <br>
 <br><i>448</i> <br>
 <br>
9.5 <br>
Experiment 4: Combinational Circuits  <br>
 <br><i>450</i> <br>
 <br>
9.6 <br>
Experiment 5: Code Converters  <br>
 <br><i>452</i> <br>
 <br>
9.7 <br>
Experiment 6: Design with Multiplexers  <br>
 <br><i>453</i> <br>
 <br>
9.8 <br>
Experiment 7: Adders and Subtractors  <br>
 <br><i>455</i> <br>
 <br>
9.9 <br>
Experiment 8: FlipFlops  <br>
 <br><i>457</i> <br>
 <br>
9.10 <br>
Experiment 9: Sequential Circuits  <br>
 <br><i>460</i> <br>
 <br>
9.11 <br>
Experiment 10: Counters  <br>
 <br><i>461</i> <br>
 <br>
9.12 <br>
Experiment 11: Shift Registers  <br>
 <br><i>463</i> <br>
 <br>
9.13 <br>
Experiment 12: Serial Addition  <br>
 <br><i>466</i> <br>
 <br>
9.14 <br>
Experiment 13: Memory Unit  <br>
 <br><i>467</i> <br>
 <br>
9.15 <br>
Experiment 14: Lamp Handball  <br>
 <br><i>469</i> <br>
<hr>
<A name=10></a><b>viii    Contents</b><br>
 <br>
9.16 <br>
Experiment 15: ClockPulse Generator  <br>
 <br><i>473</i> <br>
 <br>
9.17 <br>
Experiment 16: Parallel Adder and Accumulator  <br>
 <br><i>475</i> <br>
 <br>
9.18 <br>
Experiment 17: Binary Multiplier  <br>
 <br><i>478</i> <br>
 <br> 9.19 <br>
 <br>
Verilog HDL Simulation Experiments <br>and Rapid Prototyping with FPGAs  <br>
 <br><i>480</i> <br>
<b> <br>1 0     S t a n d a r d  </b><br>
<b>G r a p h i c  </b><br>
<b>S y m b o l s  </b><br>
<b> </b><br>
<b> <br><i>4 8 8</i> </b><br>
 <br> 10.1 <br>
RectangularShape <br>
Symbols <br>
 <br>
 <br><i>488</i> <br>
 <br> 10.2 <br>
Qualifying <br>
Symbols <br>
 <br>
 <br><i>491</i> <br>
 <br> 10.3 <br>
Dependency <br>
Notation <br>
 <br>
 <br><i>493</i> <br>
 <br>
10.4 <br>
Symbols for Combinational Elements  <br>
 <br><i>495</i> <br>
 <br>
10.5 <br>
Symbols for FlipFlops  <br>
 <br><i>497</i> <br>
 <br>
10.6 <br>
Symbols for Registers  <br>
 <br><i>499</i> <br>
 <br>
10.7 <br>
Symbols for Counters  <br>
 <br><i>502</i> <br>
 <br>
10.8 <br>
Symbol for RAM  <br>
 <br><i>504</i> <br>
<b> <br>A p p e n d i x  </b><br>
<b> <br><i>5 0 7</i> </b><br>
<b> <br>A n s w e r s   t o   S e l e c t e d   P r o b l e m s  </b><br>
<b> <br><i>5 2 1</i> </b><br>
<b> <br>I n d e x  </b><br>
<b> <br><i>5 3 9</i> </b><br>
<hr>
<A name=11></a> Preface <br>
 <br>Since the fourth edition of  <i>Digital Design</i>,  the commercial availability of devices using <br>digital technology to receive, manipulate, and transmit information seems to have <br>exploded. Cell phones and handheld devices of various kinds offer new, competing <br>features almost daily. Underneath the attractive graphical user interface of all of these <br>devices sits a digital system that processes data in a binary format. The theoretical <br>foundations of these systems have not changed much; indeed, one could argue that <br>the stability of the core theory, coupled with modern design tools, has promoted the <br>widespread response of manufacturers to the opportunities of the marketplace. Con-<br>sequently, our refinement of our text has been guided by the need to equip our grad-<br>uates with a solid understanding of digital machines and to introduce them to the <br>methodology of modern design. <br>
 <br>This edition of  <i>Digital Design</i>  builds on the previous four editions, and the feedback <br>
of the team of reviewers who helped set a direction for our presentation. The focus of <br>the text has been sharpened to more closely reflect the content of a foundation course <br>in digital design and the mainstream technology of today's digital systems: CMOS <br>circuits. The intended audience is broad, embracing students of computer science, com-<br>puter engineering, and electrical engineering. The key elements that the book focuses <br>include (1) Boolean logic, (2) logic gates used by designers, (3) synchronous finite state <br>machines, and (4) datapath controller design--all from a perspective of designing dig-<br>ital systems. This focus led to elimination of material more suited for a course in elec-<br>tronics. So the reader will not find here content for asynchronous machines or <br>descriptions of bipolar transistors. Additionally, the widespread availability of web<br>based ancillary material prompted us to limit our discussion of field programmable <br>gate arrays (FPGAs) to an introduction of devices offered by only one manufacturer, <br>rather than two. Today's designers rely heavily on hardware description languages <br>
<b>ix</b><br>
<hr>
<A name=12></a><b>x    Preface</b><br>
(HDLs), and this edition of the book gives greater attention to their use and presents <br>what we think is a clear development of a design methodology using the Verilog HDL. <br>
<b> <br>M U L T I  M O D A L   L E A R N I N G </b><br>
 <br><i>Digital Design</i>  supports a multimodal approach to learning. The socalled VARK char-<br>acterization of learning modalities identifies four major modes by which humans learn: <br>(V) visual, (A) aural, (R) reading, and (K) kinesthetic. In hindsight, we note that the <br>relatively high level of illustrations and graphical content of our text addresses the visual <br>(V) component of VARK; discussions and numerous examples address the reading (R) <br>component. Students who exploit the availability of free simulators to work assignments <br>are led through a kinesthetic (K) learning experience, including the positive feedback <br>and delight of designing a logic system that works. The remaining element of VARK, the <br>aural/auditory (A) experience, is left to the instructor. We have provided an abundance <br>of material and examples to support classroom lectures. Thus, a course in digital design, <br>using  <i>Digital Design</i>,  can provide a rich, balanced learning experience and address all <br>the modes identified by VARK. <br>
 <br>For those who might still question the presentation and use of HDLs in a first course <br>
in digital design, we note that industry has largely abandoned schematicbased design <br>entry, a style which emerged in the 1980s, during the nascent development of CAD tools <br>for integrated circuit (IC) design. Schematic entry creates a representation of functional-<br>ity that is implicit in the layout of the schematic. Unfortunately, it is difficult for anyone <br>in a reasonable amount of time to determine the functionality represented by the sche-<br>matic of a logic circuit without having been instrumental in its construction, or without <br>having additional documentation expressing the design intent. Consequently, industry <br>has migrated to HDLs (e.g., Verilog) to describe the functionality of a design and to serve <br>as the basis for documenting, simulating, testing, and synthesizing the hardware imple-<br>mentation of the design in a standard cellbased ASIC or an FPGA. The utility of a <br>schematic depends on the careful, detailed documentation of a carefully constructed <br>hierarchy of design modules. In the old paradigm, designers relied upon their years of <br>experience to create a schematic of a circuit to implement functionality. In today's design <br>flow, designers using HDLs can express functionality directly and explicitly, without years <br>of accumulated experience, and use synthesis tools to generate the schematic as a by<br>product, automatically. Industry practices arrived here because schematic entry dooms <br>us to inefficiency, if not failure, in understanding and designing large, complex ICs. <br>
 <br>We note, again in this edition, that introducing HDLs in a first course in designing <br>
digital circuits is not intended to replace fundamental understanding of the building blocks <br>of such circuits or to eliminate a discussion of manual methods of design. It is still essential <br>for a student to understand  <i>how hardware works</i> .Thus, we retain a thorough treatment of <br>combinational and sequential logic devices. Manual design practices are presented, and <br>their results are compared with those obtained with a HDLbased paradigm. What we are <br>presenting, however, is an emphasis on  <i>how hardware is designed</i>,  to better prepare a <br>student for a career in today's industry, where HDLbased design practices are dominant. <br>
<hr>
<A name=13></a><b>Preface    xi</b><br>
<b> <br>F L E X I B I L I T Y </b><br>
 <br>The sequence of topics in the text can accommodate courses that adhere to traditional, <br>manualbased, treatments of digital design, courses that treat design using an HDL, and <br>courses that are in transition between or blend the two approaches. Because modern <br>synthesis tools automatically perform logic minimization, Karnaugh maps and related <br>topics in optimization can be presented at the beginning of a treatment of digital design, <br>or they can be presented after circuits and their applications are examined and simulated <br>with an HDL. The text includes both manual and HDLbased design examples. Our end<br>ofchapter problems further facilitate this flexibility by cross referencing problems that <br>address a traditional manual design task with a companion problem that uses an HDL <br>to accomplish the task. Additionally, we link the manual and HDLbased approaches by <br>presenting annotated results of simulations in the text, in answers to selected problems <br>at the end of the text, and in the solutions manual. <br>
<b> <br>N E W   T O   T H I S   E D I T I O N </b><br>
 <br>This edition of  <i>Digital Design</i>  uses the latest features of IEEE Standard 1364, but only <br>insofar as they support our pedagogical objectives. The revisions and updates to the <br>text include: <br>
 <br>
�  Elimination of specialized circuitlevel content not typically covered in a first <br>
course in logic circuits and digital design (e.g., RTL, DTL, and emittercoupled <br>logic circuits)  <br>
 <br>
�  Addition of "Web Search Topics" at the end of each chapter to point students to <br>
additional subject matter available on the web  <br>
 <br>
�  Revision of approximately onethird of the problems at the end of the chapters  <br>
 <br>
�  A printed solution manual for entire text, including all new problems  <br>
 <br>
�  Streamlining of the discussion of Karnaugh maps  <br>
 <br>
�  Integration of treatment of basic CMOS technology with treatment of logic gates  <br>
 <br>
�  Inclusion of an appendix introducing semiconductor technology  <br>
<b> <br>D E S I G N   M E T H O D L O G Y </b><br>
 <br>This text presents a systematic methodology for designing a state machine to control <br>the datapath of a digital system. Moreover, the framework in which this material is pre-<br>sented treats the realistic situation in which status signals from the datapath are used by <br>the controller, i.e., the system has feedback. Thus, our treatment provides a foundation <br>for designing complex and interactive digital systems. Although it is presented with an <br>emphasis on HDLbased design, the methodology is also applicable to manualbased <br>approaches to design. <br>
<hr>
<A name=14></a><b>xii    Preface</b><br>
<b> <br>J U S T   E N O U G H   H D L </b><br>
 <br>We present only those elements of the Verilog language that are matched to the level and <br>scope of this text. Also, correct syntax does not guarantee that a model meets a functional <br>specification or that it can be synthesized into physical hardware. So, we introduce stu-<br>dents to a disciplined use of industrybased practices for writing models to ensure that a <br>behavioral description can be synthesized into physical hardware, and that the behavior <br>of the synthesized circuit will match that of the behavioral description. Failure to follow <br>this discipline can lead to software race conditions in the HDL models of such machines, <br>race conditions in the test bench used to verify them, and a mismatch between the results <br>of simulating a behavioral model and its synthesized physical counterpart. Similarly, fail-<br>ure to abide by industry practices may lead to designs that simulate correctly, but which <br>have hardware latches that are introduced into the design accidentally as a consequence <br>of the modeling style used by the designer. The industrybased methodology we present <br>leads to racefree and latchfree designs. It is important that students learn and follow <br>industry practices in using HDL models, independent of whether a student's curriculum <br>has access to synthesis tools. <br>
<b> <br>V E R I F I C AT I O N </b><br>
 <br>In industry, significant effort is expended to verify that the functionality of a circuit is <br>correct. Yet not much attention is given to verification in introductory texts on digital <br>design, where the focus is on design itself, and testing is perhaps viewed as a secondary <br>undertaking. Our experience is that this view can lead to premature "highfives" and <br>declarations that "the circuit works beautifully." Likewise, industry gains repeated returns <br>on its investment in an HDL model by ensuring that it is readable, portable, and reusable. <br>We demonstrate naming practices and the use of parameters to facilitate reusability and <br>portability. We also provide test benches for all of the solutions and exercises to (1) verify <br>the functionality of the circuit, (2) underscore the importance of thorough testing, and <br>(3) introduce students to important concepts, such as selfchecking test benches. Advo-<br>cating and illustrating the development of a  <i>test plan</i>  to guide the development of a test <br>bench, we introduce test plans, albeit simply, in the text and expand them in the solutions <br>manual and in the answers to selected problems at the end of the text. <br>
<b> <br>H D L   C O N T E N T </b><br>
 <br>We have ensured that all examples in the text and all answers in the solution manual <br>conform to accepted industry practices for modeling digital hardware. As in the previ-<br>ous edition, HDL material is inserted in separate sections so that it can be covered or <br>skipped as desired, does not diminish treatment of manualbased design, and does not <br>dictate the sequence of presentation. The treatment is at a level suitable for beginning <br>students who are learning digital circuits and a HDL at the same time. The text prepares <br>
<hr>
<A name=15></a><b>Preface    xiii</b><br>
students to work on signficant independent design projects and to succeed in a later <br>course in computer architecture and advanced digital design. <br>
<b> <br>Instructor Resources </b><br>
 <br>Instructors can download the following classroomready resources from the publisher's <br>website for the text (www.pearsonhighered.com/mano): <br>
 <br>
�  Source code and test benches for all Verilog HDL examples in the test  <br>
 <br>
�  All figures and tables in the text  <br>
 <br>
�  Source code for all HDL models in the solutions manual  <br>
 <br>
�   A downloadable solutions manual with graphics suitable for classroom presentation <br>
<b> <br>HDL Simulators </b><br>
 <br>The Companion Website identifies web URLs to two simulators provided by Synapti-<br>CAD. The first simulator is  <i>VeriLogger Pro</i>,  a traditional Verilog simulator that can be <br>used to simulate the HDL examples in the book and to verify the solutions of HDL <br>problems. This simulator accepts the syntax of the IEEE1995 standard and will be <br>useful to those who have legacy models. As an interactive simulator,  <i>Verilogger Ex-<br>treme</i>  accepts the syntax of IEEE2001 as well as IEEE1995, allowing the designer to <br>simulate and analyze design ideas before a complete simulation model or schematic is <br>available. This technology is particularly useful for students because they can quickly <br>enter Boolean and  <i>D</i>  flipflop or latch input equations to check equivalency or to ex-<br>periment with flipflops and latch designs. Students can access the Companion Website <br>at www.pearsonhighered.com/mano. <br>
<b> <br>Chapter Summary </b><br>
 <br>The following is a brief summary of the topics that are covered in each chapter. <br>
 <br><b>Chapter  1</b>  presents the various binary systems suitable for representing information <br>
in digital systems. The binary number system is explained and binary codes are illus-<br>trated. Examples are given for addition and subtraction of signed binary numbers and <br>decimal numbers in binarycoded decimal (BCD) format. <br>
 <br><b>Chapter  2</b>  introduces the basic postulates of Boolean algebra and shows the correla-<br>
tion between Boolean expressions and their corresponding logic diagrams. All possible <br>logic operations for two variables are investigated, and the most useful logic gates used <br>in the design of digital systems are identified. This chapter also introduces basic CMOS <br>logic gates. <br>
 <br><b>Chapter  3</b>  covers the map method for simplifying Boolean expressions. The map <br>
method is also used to simplify digital circuits constructed with ANDOR, NAND, or <br>NOR gates. All other possible twolevel gate circuits are considered, and their method <br>of implementation is explained. Verilog HDL is introduced together with simple exam-<br>ples of gatelevel models. <br>
<hr>
<A name=16></a><b>xiv    Preface</b><br>
 <br><b>Chapter  4</b>  outlines the formal procedures for the analysis and design of combina-<br>
tional circuits. Some basic components used in the design of digital systems, such as <br>adders and code converters, are introduced as design examples. Frequently used digital <br>logic functions such as parallel adders and subtractors, decoders, encoders, and multi-<br>plexers are explained, and their use in the design of combinational circuits is illustrated. <br>HDL examples are given in gatelevel, dataflow, and behavioral models to show the <br>alternative ways available for describing combinational circuits in Verilog HDL. The <br>procedure for writing a simple test bench to provide stimulus to an HDL design is <br>presented. <br>
 <br><b>Chapter  5 </b>  outlines the formal procedures for analyzing and designing clocked (syn-<br>
chronous) sequential circuits. The gate structure of several types of flipflops is presented <br>together with a discussion on the difference between level and edge triggering. Specific <br>examples are used to show the derivation of the state table and state diagram when <br>analyzing a sequential circuit. A number of design examples are presented with empha-<br>sis on sequential circuits that use Dtype flipflops. Behavioral modeling in Verilog HDL <br>for sequential circuits is explained. HDL Examples are given to illustrate Mealy and <br>Moore models of sequential circuits. <br>
 <br><b>Chapter  6 </b>  deals with various sequential circuit components such as registers, shift <br>
registers, and counters. These digital components are the basic building blocks from <br>which more complex digital systems are constructed. HDL descriptions of shift registers <br>and counter are presented. <br>
 <br><b>Chapter  7 </b>  deals with random access memory (RAM) and programmable logic <br>
devices. Memory decoding and error correction schemes are discussed. Combinational <br>and sequential programmable devices such as ROMs, PLAs, PALs, CPLDs, and FPGAs <br>are presented. <br>
 <br><b>Chapter  8 </b>  deals with the register transfer level (RTL) representation of digital sys-<br>
tems. The algorithmic state machine (ASM) chart is introduced. A number of examples <br>demonstrate the use of the ASM chart, ASMD chart, RTL representation, and HDL <br>description in the design of digital systems. The design of a finite state machine to con-<br>trol a datapath is presented in detail, including the realistic situation in which status <br>signals from the datapath are used by the state machine that controls it. This chapter is <br>the most important chapter in the book as it provides the student with a systematic <br>approach to more advanced design projects. <br>
 <br><b>Chapter  9 </b>  outlines experiments that can be performed in the laboratory with hard-<br>
ware that is readily available commercially. The operation of the ICs used in the <br>experiments is explained by referring to diagrams of similar components introduced <br>in previous chapters. Each experiment is presented informally and the student is <br>expected to design the circuit and formulate a procedure for checking its operation <br>in the laboratory. The lab experiments can be used in a standalone manner too and <br>can be accomplished by a traditional approach, with a breadboard and TTL circuits, <br>or with an HDL/synthesis approach using FPGAs. Today, software for synthesizing <br>an HDL model and implementing a circuit with an FPGA is available at no cost from <br>vendors of FPGAs, allowing students to conduct a significant amount of work in their <br>personal environment before using prototyping boards and other resources in a lab. <br>
<hr>
<A name=17></a><b>Preface    xv</b><br>
Circuit boards for rapid prototyping circuits with FPGAs are available at a nominal <br>cost, and typically include push buttons, switches, sevensegment displays, LCDs, key-<br>pads, and other I/O devices. With these resources, students can work prescribed lab <br>exercises or their own projects and get results immediately. <br>
 <br><b>Chapter  10 </b>  presents the standard graphic symbols for logic functions recommended <br>
by an ANSI/IEEE standard. These graphic symbols have been developed for smallscale <br>integration (SSI) and mediumscale integration (MSI) components so that the user can <br>recognize each function from the unique graphic symbol assigned. The chapter shows <br>the standard graphic symbols of the ICs used in the laboratory experiments. <br>
<b> <br>A C K N O W L E D G M E N T S </b><br>
 <br>We are grateful to the reviewers of  <i>Digital Design</i>,  5e. Their expertise, careful reviews, <br>and suggestions helped shape this edition. <br>
 <br>Dmitri Donetski, Stony Brook University  <br>
 <br>Ali Amini, California State University, Northridge  <br>
 <br>Mihaela Radu, Rose Hulman Institute of Technology  <br>
 <br>Stephen J Kuyath, University of North Carolina, Charlotte  <br>
 <br>Peter Pachowicz, George Mason University  <br>
 <br>David Jeff Jackson, University of Alabama  <br>
 <br>A. John Boye, University of Nebraska, Lincoln  <br>
 <br>William H. Robinson, Vanderbilt University  <br>
 <br>Dinesh Bhatia, University of Texas, Dallas   <br>
 <br>We also wish to express our gratitude to the editorial and publication team at Prentice <br>Hall/Pearson Education for supporting this edition of our text. We are grateful, too, for <br>the ongoing support and encouragement of our wives, Sandra and Jerilynn. <br>
   M.  Morris  Mano <br>
<i> <br>Emeritus Professor of Computer Engineering </i><br>
<i> <br>California State University, Los Angeles  </i><br>
  Michael  D.  Ciletti <br>
<i> <br>Emeritus Professor of Electrical and Computer Engineering </i><br>
<i> University  of  Colorado  at  Colorado  Springs      </i><br>
<hr>
<A name=18></a><i>This page intentionally left blank </i><br>
<hr>
<A name=19></a> <br>Chapter 1 <br>
<b> <br>Digital Systems and Binary Numbers </b> <br>
<b> <br>1 . 1       D I G I TA L   S Y S T E M S </b><br>
 <br>Digital systems have such a prominent role in everyday life that we refer to the present <br>technological period as the <i>digital age</i>. Digital systems are used in communication, busi-<br>ness transactions, traffic control, spacecraft guidance, medical treatment, weather mon-<br>itoring, the Internet, and many other commercial, industrial, and scientific enterprises. <br>We have digital telephones, digital televisions, digital versatile discs, digital cameras, <br>handheld devices, and, of course, digital computers. We enjoy music downloaded to our <br>portable media player (e.g., iPod TouchTM) and other handheld devices having high<br>resolution displays. These devices have graphical user interfaces (GUIs), which enable <br>them to execute commands that appear to the user to be simple, but which, in fact, <br>involve precise execution of a sequence of complex internal instructions. Most, if not all, <br>of these devices have a specialpurpose digital computer embedded within them. The <br>most striking property of the digital computer is its generality. It can follow a sequence <br>of instructions, called a program, that operates on given data. The user can specify and <br>change the program or the data according to the specific need. Because of this flexibil-<br>ity, generalpurpose digital computers can perform a variety of informationprocessing <br>tasks that range over a wide spectrum of applications. <br>
 <br>One characteristic of digital systems is their ability to represent and manipulate dis-<br>
crete elements of information. Any set that is restricted to a finite number of elements <br>contains discrete information. Examples of discrete sets are the 10 decimal digits, the <br>26  letters of the alphabet, the 52 playing cards, and the 64 squares of a chessboard. Early <br>digital computers were used for numeric computations. In this case, the discrete ele-<br>ments were the digits. From this application, the term <i>digital</i> computer emerged. Dis-<br>crete elements of information are represented in a digital system by physical quantities <br>
<b>1</b><br>
<hr>
<A name=20></a><b>2    Chapter 1  Digital Systems and Binary Numbers</b><br>
called signals. Electrical signals such as voltages and currents are the most common. <br>Electronic devices called transistors predominate in the circuitry that implements these <br>signals. The signals in most presentday electronic digital systems use just two discrete <br>values and are therefore said to be <i>binary</i>. A binary digit, called a <i>bit,</i> has two values: 0 <br>and 1. Discrete elements of information are represented with groups of bits called <i>binary</i> <br><i>codes</i>. For example, the decimal digits 0 through 9 are represented in a digital system <br>with a code of four bits (e.g., the number 7 is represented by 0111). How a pattern of <br>bits is interpreted as a number depends on the code system in which it resides. To make <br>this distinction, we could write (0111) 2  to indicate that the pattern 0111 is to be inter-<br>preted in a binary system, and (0111) 10  to indicate that the reference system is decimal. <br>Then 0111 2 = 7 10 , which is not the same as 0111 10 , or one hundred eleven. The subscript <br>indicating the base for interpreting a pattern of bits will be used only when clarification <br>is needed. Through various techniques, groups of bits can be made to represent discrete <br>symbols, not necessarily numbers, which are then used to develop the system in a digital <br>format. Thus, a digital system is a system that manipulates discrete elements of informa-<br>tion represented internally in binary form. In today's technology, binary systems are most <br>practical because, as we will see, they can be implemented with electronic components. <br>
 <br>Discrete quantities of information either emerge from the nature of the data being <br>
processed or may be quantized from a continuous process. On the one hand, a payroll <br>schedule is an inherently discrete process that contains employee names, social security <br>numbers, weekly salaries, income taxes, and so on. An employee's paycheck is processed <br>by means of discrete data values such as letters of the alphabet (names), digits (salary), <br>and special symbols (such as $). On the other hand, a research scientist may observe a <br>continuous process, but record only specific quantities in tabular form. The scientist is <br>thus quantizing continuous data, making each number in his or her table a discrete <br>quantity. In many cases, the quantization of a process can be performed automatically <br>by an analogtodigital converter, a device that forms a digital (discrete) representation <br>of a analog (continuous) quantity. <br>
 <br>The generalpurpose digital computer is the bestknown example of a digital system. <br>
The major parts of a computer are a memory unit, a central processing unit, and input�<br>output units. The memory unit stores programs as well as input, output, and intermedi-<br>ate data. The central processing unit performs arithmetic and other dataprocessing <br>operations as specified by the program. The program and data prepared by a user are <br>transferred into memory by means of an input device such as a keyboard. An output <br>device, such as a printer, receives the results of the computations, and the printed results <br>are presented to the user. A digital computer can accommodate many input and output <br>devices. One very useful device is a communication unit that provides interaction with <br>other users through the Internet. A digital computer is a powerful instrument that can <br>perform not only arithmetic computations, but also logical operations. In addition, it can <br>be programmed to make decisions based on internal and external conditions. <br>
 <br>There are fundamental reasons that commercial products are made with digital cir-<br>
cuits. Like a digital computer, most digital devices are programmable. By changing the <br>program in a programmable device, the same underlying hardware can be used for many <br>different applications, thereby allowing its cost of development to be spread across a <br>wider customer base. Dramatic cost reductions in digital devices have come about <br>
<hr>
<A name=21></a><b>Section 1.2  Binary Numbers    3</b><br>
because of advances in digital integrated circuit technology. As the number of transistors <br>that can be put on a piece of silicon increases to produce complex functions, the cost per <br>unit decreases and digital devices can be bought at an increasingly reduced price. Equip-<br>ment built with digital integrated circuits can perform at a speed of hundreds of millions <br>of operations per second. Digital systems can be made to operate with extreme reli-<br>ability by using errorcorrecting codes. An example of this strategy is the digital versa-<br>tile disk (DVD), in which digital information representing video, audio, and other data <br>is recorded without the loss of a single item. Digital information on a DVD is recorded <br>in such a way that, by examining the code in each digital sample before it is played back, <br>any error can be automatically identified and corrected. <br>
 <br>A digital system is an interconnection of digital modules.  <b>To understand the opera-</b><br>
<b>tion of each digital module, it is necessary to have a basic knowledge of digital circuits <br>and their logical function.</b> The first seven chapters of this book present the basic tools <br>of digital design, such as logic gate structures, combinational and sequential circuits, and <br>programmable logic devices.  Chapter   8   introduces digital design at the register transfer <br>level (RTL) using a modern hardware description language (HDL).  Chapter   9   concludes <br>the text with laboratory exercises using digital circuits. <br>
 <br>A major trend in digital design methodology is the use of a HDL to describe and simulate <br>
the functionality of a digital circuit. An HDL resembles a programming language and is <br>suitable for describing digital circuits in textual form. It is used to simulate a digital system <br>to verify its operation before hardware is built. It is also used in conjunction with logic syn-<br>thesis tools to automate the design process. Because  <b>it is important that students become <br>familiar with an HDLbased design methodology</b> <b>,</b> HDL descriptions of digital circuits are <br>presented throughout the book. While these examples help illustrate the features of an HDL, <br>they also demonstrate the best practices used by industry to exploit HDLs. Ignorance of <br>these practices will lead to cute, but worthless, HDL models that may simulate a phenom-<br>enon, but that cannot be synthesized by design tools, or to models that waste silicon area or <br>synthesize to hardware that cannot operate correctly. <br>
 <br>As previously stated, digital systems manipulate discrete quantities of information <br>
that are represented in binary form. Operands used for calculations may be expressed <br>in the binary number system. Other discrete elements, including the decimal digits and <br>characters of the alphabet, are represented in binary codes. Digital circuits, also referred <br>to as logic circuits, process data by means of binary logic elements (logic gates) using <br>binary signals. Quantities are stored in binary (twovalued) storage elements (flipflops). <br>The purpose of this chapter is to introduce the various binary concepts as a frame of <br>reference for further study in the succeeding chapters. <br>
<b> <br>1 . 2       B I N A R Y   N U M B E R S </b><br>
 <br>A decimal number such as 7,392 represents a quantity equal to 7 thousands, plus 3 hun-<br>dreds, plus 9 tens, plus 2 units. The thousands, hundreds, etc., are powers of 10 implied <br>by the position of the coefficients (symbols) in the number. To be more exact, 7,392 is a <br>shorthand notation for what should be written as <br>
 <br>7 * 103 + 3 * 102 + 9 * 101 + 2 * 100 <br>
<hr>
<A name=22></a><b>4    Chapter 1  Digital Systems and Binary Numbers</b><br>
 <br>However, the convention is to write only the numeric coefficients and, from their posi-<br>tion, deduce the necessary powers of 10 with powers increasing from right to left. In <br>general, a number with a decimal point is represented by a series of coefficients: <br>
 <br><i>a</i>5<i>a</i>4<i>a</i>3<i>a</i>2<i>a</i>1<i>a</i>0. <i>a</i>-1<i>a</i>-2<i>a</i>-3 <br>
 The  coefficients     <i>aj</i>  are any of the 10 digits   (0, 1, 2, c , 9),     and  the  subscript  value  <i>j</i> gives <br>the place value and, hence, the power of 10 by which the coefficient must be multiplied. <br>Thus, the preceding decimal number can be expressed as <br>
 <br>105<i>a</i>5 + 104<i>a</i>4 + 103<i>a</i>3 + 102<i>a</i>2 + 101<i>a</i>1 + 100<i>a</i>0 + 10-1<i>a</i>-1 + 10-2<i>a</i>-2 + 10-3<i>a</i>-3 <br>
 with  <i>a</i> 3 = 7, <i>a</i> 2 = 3, <i>a</i> 1 = 9, and <i>a</i> 0 = 2. <br>
 <br>The decimal number system is said to be of <i>base,</i> or <i>radix,</i> 10 because it uses 10 digits <br>
and the coefficients are multiplied by powers of 10. The <i>binary</i> system is a different <br>number system. The coefficients of the binary number system have only two possible <br>values: 0 and 1. Each coefficient   <i>aj</i>  is multiplied by a power of the radix, e.g.,   2<i>j</i>,     and <br>the results are added to obtain the decimal equivalent of the number. The radix <br>point (e.g., the decimal point when 10 is the radix) distinguishes positive powers of <br>10 from negative powers of 10. For example, the decimal equivalent of the binary <br>number 11010.11 is 26.75, as shown from the multiplication of the coefficients by <br>powers of 2: <br>
 <br>1 * 24 + 1 * 23 + 0 * 22 + 1 * 21 + 0 * 20 + 1 * 2-1 + 1 * 2-2 = 26.75   <br>
 <br>There are many different number systems. In general, a number expressed in a base<i>r</i> <br>system has coefficients multiplied by powers of <i>r</i>: <br>
 <br><i>an </i># <i>rn </i>+ <i>an</i>-1 # <i>rn</i>-1 + g + <i>a</i>2 # <i>r</i>2 + <i>a</i>1 # <i>r </i>+ <i>a</i>0 + <i>a</i>-1 # <i>r</i>-1<br>
+ <i>a</i>-2 # <i>r</i>-2 + g + <i>a</i>-<i>m </i># <i>r</i>-<i>m</i> <br>
 The  coefficients     <i>aj</i>  range in value from 0 to   <i>r </i>- 1. To distinguish between numbers of <br>different bases, we enclose the coefficients in parentheses and write a subscript equal to <br>the base used (except sometimes for decimal numbers, where the content makes it obvi-<br>ous that the base is decimal). An example of a base5 number is <br>
   <br>(4021.2)5 = 4 * 53 + 0 * 52 + 2 * 51 + 1 * 50 + 2 * 5-1 = (511.4)10 <br>
 <br>The coefficient values for base 5 can be only 0, 1, 2, 3, and 4. The octal number system <br>is a base8 system that has eight digits: 0, 1, 2, 3, 4, 5, 6, 7. An example of an octal number <br>is 127.4. To determine its equivalent decimal value, we expand the number in a power <br>series with a base of 8: <br>
   <br>(127.4)8 = 1 * 82 + 2 * 81 + 7 * 80 + 4 * 8-1 = (87.5)10 <br>
 <br>Note that the digits 8 and 9 cannot appear in an octal number. <br>
 <br>It is customary to borrow the needed <i>r</i> digits for the coefficients from the decimal <br>
system when the base of the number is less than 10.  <b>The letters of the alphabet are used <br>to supplement the 10 decimal digits when the base of the number is greater than 10.</b>   For <br>example, in the <i>hexadecimal</i> (base16) number system, the first 10 digits are borrowed <br>
<hr>
<A name=23></a><b>Section 1.2  Binary Numbers    5</b><br>
from the decimal system. The letters A, B, C, D, E, and F are used for the digits 10, 11, <br>12, 13, 14, and 15, respectively. An example of a hexadecimal number is <br>
   <br>(B65F)16 = 11 * 163 + 6 * 162 + 5 * 161 + 15 * 160 = (46,687)10 <br>
 <br>The hexadecimal system is used commonly by designers to represent long strings of bits <br>in the addresses, instructions, and data in digital systems. For example, B65F is used to <br>represent 1011011001010000. <br>
 <br>As noted before, the digits in a binary number are called <i>bits</i>. When a bit is equal to <br>
0, it does not contribute to the sum during the conversion. Therefore, the conversion <br>from binary to decimal can be obtained by adding only the numbers with powers of two <br>corresponding to the bits that are equal to 1. For example, <br>
   <br>(110101)2 = 32 + 16 + 4 + 1 = (53)10 <br>
 <br>There are four 1's in the binary number. The corresponding decimal number is the sum <br>
of the four powers of two. Zero and the first 24 numbers obtained from 2 to the power of <br><i>n</i> are listed in  Table   1.1 . In computer work,   210  is referred to as K (kilo),   220     as  M  (mega), <br> <br>230  as G (giga), and   240     as  T  (tera). Thus,     4K = 212 = 4,096     and     16M = 224 = 16,777,216.    <br>Computer capacity is usually given in bytes. A <i>byte</i> is equal to eight bits and can accom-<br>modate (i.e., represent the code of) one keyboard character. A computer hard disk with <br>four gigabytes of storage has a capacity of   4G = 232  bytes (approximately 4 billion bytes). <br>A terabyte is 1024 gigabytes, approximately 1 trillion bytes. <br>
 <br>Arithmetic operations with numbers in base <i>r</i> follow the same rules as for decimal <br>
numbers. When a base other than the familiar base 10 is used, one must be careful to <br>use only the <i>r</i>allowable digits. Examples of addition, subtraction, and multiplication of <br>two binary numbers are as follows: <br>
augend:<br>
101101<br>
minuend:    <br>
101101<br>
multiplicand:<br>
1011<br>
addend:<br>
+ 100111<br>
subtrahend:<br>
- 100111<br>
multiplier:     <br>
* 101<br>
sum:      <br>
1010100<br>
difference:   <br>
000110<br>
1011<br>
0000  <br>
partial product:<br>
1011    <br>
 <br>
product:       <br>
    110111 <br>
<b> <br>Table 1.1 <br><i> <br>Powers of Two </b></i><br>
<i><b> <br>n </b></i><br>
<i><b> <br>2n </b></i><br>
<i><b> <br>n </b></i><br>
<i><b> <br>2n </b></i><br>
<i><b> <br>n </b></i><br>
<i><b> <br>2n </b></i><br>
 0 <br>
 1 <br>
 8 <br>
 256 <br>
 16 <br>
 65,536 <br>
 1 <br>
 2 <br>
 9 <br>
 512 <br>
 17 <br>
 131,072 <br>
 2 <br>
 4 <br>
 10 <br>
 1,024  (1K) <br>
 18 <br>
 262,144 <br>
 3 <br>
 8 <br>
 11 <br>
 2,048 <br>
 19 <br>
 524,288 <br>
 4 <br>
 16 <br>
 12 <br>
 4,096  (4K) <br>
 20 <br>
 1,048,576  (1M) <br>
 5 <br>
 32 <br>
 13 <br>
 8,192 <br>
 21 <br>
 2,097,152 <br>
 6 <br>
 64 <br>
 14 <br>
 16,384 <br>
 22 <br>
 4,194,304 <br>
 7 <br>
 128 <br>
 15 <br>
 32,768 <br>
 23 <br>
 8,388,608 <br>
<hr>
<A name=24></a><b>6    Chapter 1  Digital Systems and Binary Numbers</b><br>
 <br>The sum of two binary numbers is calculated by the same rules as in decimal, except <br>
that the digits of the sum in any significant position can be only 0 or 1. Any carry <br>obtained in a given significant position is used by the pair of digits one significant posi-<br>tion higher. Subtraction is slightly more complicated. The rules are still the same as in <br>decimal, except that the borrow in a given significant position adds 2 to a minuend digit. <br>(A borrow in the decimal system adds 10 to a minuend digit.) Multiplication is simple: <br>The multiplier digits are always 1 or 0; therefore, the partial products are equal either <br>to a shifted (left) copy of the multiplicand or to 0. <br>
<b> <br>1 . 3       N U M B E R  B A S E   C O N V E R S I O N S </b><br>
 <br>Representations of a number in a different radix are said to be equivalent if they have <br>the same decimal representation. For example, (0011) 8  and (1001) 2  are equivalent--both <br>have decimal value 9. The conversion of a number in base <i>r</i> to decimal is done by <br>expanding the number in a power series and adding all the terms as shown previously. <br>We now present a general procedure for the reverse operation of converting a decimal <br>number to a number in base <i>r</i>. If the number includes a radix point, it is necessary to <br>separate the number into an integer part and a fraction part, since each part must be <br>converted differently. The conversion of a decimal integer to a number in base <i>r</i> is done <br>by dividing the number and all successive quotients by <i>r</i> and accumulating the remain-<br>ders. This procedure is best illustrated by example. <br>
<b> <br>EXAMPLE 1.1 </b><br>
 <br>Convert decimal 41 to binary. First, 41 is divided by 2 to give an integer quotient of 20 <br>and a remainder of   1. Then the quotient is again divided by 2 to give a new quotient and <br>
2<br>
remainder. The process is continued until the integer quotient becomes 0. The <i>coefficients</i> <br>of the desired binary number are obtained from the <i>remainders</i> as follows: <br>
<b>  </b><br>
<b> Integer </b><br>
<b>  </b><br>
<b> Remainder </b><br>
<b> Coefficient </b><br>
<b>Quotient </b><br>
 <br>41&gt;2 =  <br>
 <br>20 <br>
 +  <br>
 <br>1 <br>
 <br><i>a</i><br>
2<br>
0 = 1    <br>
 <br>20&gt;2 =  <br>
 <br>10 <br>
 +  <br>
 <br>0 <br>
 <br><i>a</i>1 = 0    <br>
 <br>10&gt;2 =  <br>
 <br>5 <br>
 +  <br>
 <br>0 <br>
 <br><i>a</i>2 = 0    <br>
 <br>5&gt;2 =  <br>
 <br>2 <br>
 +  <br>
 <br>1 <br>
 <br><i>a</i><br>
2<br>
3 = 1    <br>
 <br>2&gt;2 =  <br>
 <br>1 <br>
 +  <br>
 <br>0 <br>
 <br><i>a</i>4 = 0    <br>
 <br>1&gt;2 =  <br>
 <br>0 <br>
 +  <br>
 <br>1 <br>
 <br><i>a</i><br>
2<br>
5 = 1    <br>
 <br>Therefore, the answer is   (41)10 = (<i>a</i>5<i>a</i>4<i>a</i>3<i>a</i>2<i>a</i>1<i>a</i>0)2 = (101001)2.    <br>
<hr>
<A name=25></a><b>Section 1.3  NumberBase Conversions    7</b><br>
 <br>The arithmetic process can be manipulated more conveniently as follows: <br>
<b> Integer </b><br>
<b> Remainder </b><br>
 41 <br>
  <br>
 20 <br>
 1 <br>
 10 <br>
 0 <br>
 5 <br>
 0 <br>
 2 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
    1 <br>
101001 = answer    <br>
 <br>Conversion from decimal integers to any base<i>r</i> system is similar to this example, except <br>that division is done by <i>r</i> instead of 2. <br>
<br>
<b> <br>EXAMPLE 1.2 </b><br>
 <br>Convert decimal 153 to octal. The required base <i>r</i> is 8. First, 153 is divided by 8 to give <br>an integer quotient of 19 and a remainder of 1. Then 19 is divided by 8 to give an integer <br>quotient of 2 and a remainder of 3. Finally, 2 is divided by 8 to give a quotient of 0 and <br>a remainder of 2. This process can be conveniently manipulated as follows: <br>
 153 <br>
  <br>
 19 <br>
 1 <br>
 2 <br>
 3 <br>
 0 <br>
 <br>2 = (231)8 <br>
 <br>The conversion of a decimal <i>fraction</i> to binary is accomplished by a method similar <br>
to that used for integers. However, multiplication is used instead of division, and integers <br>instead of remainders are accumulated. Again, the method is best explained by example. <br>
<br>
<b> <br>EXAMPLE 1.3 </b><br>
 Convert     (0.6875)10  to binary. First, 0.6875 is multiplied by 2 to give an integer and a fraction. <br>Then the new fraction is multiplied by 2 to give a new integer and a new fraction. The process <br>is continued until the fraction becomes 0 or until the number of digits has sufficient <br> <br>accuracy. The coefficients of the binary number are obtained from the integers as follows: <br>
<i> </i><br>
<b> Integer </b><br>
<b>  </b><br>
<b> Fraction </b><br>
<b> Coefficient </b><br>
    <br>0.6875 * 2 =  <br>
 <br>1 <br>
 +     <br>
 0.3750 <br>
    <br><i>a</i>-1 = 1    <br>
    <br>0.3750 * 2 =  <br>
 <br>0 <br>
 +     <br>
 0.7500 <br>
    <br><i>a</i>-2 = 0    <br>
    <br>0.7500 * 2 =  <br>
 <br>1 <br>
 +  <br>
 <br>0.5000 <br>
 <br><i>a</i>-3 = 1    <br>
    <br>0.5000 * 2 =  <br>
 <br>1 <br>
 +     <br>
 0.0000 <br>
    <br><i>a</i>-4 = 1    <br>
<hr>
<A name=26></a><b>8    Chapter 1  Digital Systems and Binary Numbers</b><br>
 <br>Therefore, the answer is   (0.6875)10 = (0. <i>a</i>-1 <i>a</i>-2 <i>a</i>-3 <i>a</i>-4)2 = (0.1011)2.    <br>
 <br>To convert a decimal fraction to a number expressed in base <i>r,</i> a similar procedure is <br>
used. However, multiplication is by <i>r</i> instead of 2, and the coefficients found from the <br>integers may range in value from 0 to   <i>r </i>- 1  instead of 0 and 1. <br>
<br>
<b> <br>EXAMPLE 1.4 </b><br>
 Convert     (0.513)10     to  octal. <br>
   <br>  0.513 * 8 = 4.104<br> 0.104 * 8 = 0.832<br> 0.832 * 8 = 6.656<br> 0.656 * 8 = 5.248<br> 0.248 * 8 = 1.984<br> 0.984 * 8 = 7.872   <br>
 <br>The answer, to seven significant figures, is obtained from the integer part of the products: <br>
   <br>(0.513)10 = (0.406517 c )8 <br>
 <br>The conversion of decimal numbers with both integer and fraction parts is done by <br>
converting the integer and the fraction separately and then combining the two answers. <br>Using the results of Examples 1.1 and 1.3, we obtain <br>
   <br>(41.6875)10 = (101001.1011)2 <br>
 <br>From Examples 1.2 and 1.4, we have <br>
   <br>(153.513)10 = (231.406517)8 <br>
<br>
<b> <br>1 . 4       O C TA L   A N D   H E X A D E C I M A L   N U M B E R S </b><br>
 <br>The conversion from and to binary, octal, and hexadecimal plays an important role in digi-<br>tal computers, because shorter patterns of hex characters are easier to recognize than long <br>patterns of 1's and 0's. Since   23 = 8     and     24 = 16,  each octal digit corresponds to three <br>binary digits and each hexadecimal digit corresponds to four binary digits. The first 16 num-<br>bers in the decimal, binary, octal, and hexadecimal number systems are listed in  Table   1.2  . <br>
 <br>The conversion from binary to octal is easily accomplished by partitioning the binary <br>
number into groups of three digits each, starting from the binary point and proceeding <br>to the left and to the right. The corresponding octal digit is then assigned to each group. <br>The following example illustrates the procedure: <br>
(10<br>
110<br>
001<br>
101<br>
011<br>
#<br>
111<br>
100<br>
000<br>
110)<br>
 <br>
2 = (26153.7406)8 <br>
2<br>
6<br>
1<br>
5<br>
3<br>
7<br>
4<br>
0<br>
6<br>
<hr>
<A name=27></a><b>Section 1.4  Octal and Hexadecimal Numbers    9</b><br>
<b> <br>Table 1.2 <br><i> <br>Numbers with Different Bases </b></i><br>
<b> <br>Decimal </b><br>
<b> <br>Binary </b><br>
<b> <br>Octal </b><br>
<b> <br>Hexadecimal </b><br>
<b>(base 10) </b><br>
<b>(base 2) </b><br>
<b>(base 8) </b><br>
<b>(base 16) </b><br>
 00 <br>
 0000 <br>
 00 <br>
 0 <br>
 01 <br>
 0001 <br>
 01 <br>
 1 <br>
 02 <br>
 0010 <br>
 02 <br>
 2 <br>
 03 <br>
 0011 <br>
 03 <br>
 3 <br>
 04 <br>
 0100 <br>
 04 <br>
 4 <br>
 05 <br>
 0101 <br>
 05 <br>
 5 <br>
 06 <br>
 0110 <br>
 06 <br>
 6 <br>
 07 <br>
 0111 <br>
 07 <br>
 7 <br>
 08 <br>
 1000 <br>
 10 <br>
 8 <br>
 09 <br>
 1001 <br>
 11 <br>
 9 <br>
 10 <br>
 1010 <br>
 12 <br>
 A <br>
 11 <br>
 1011 <br>
 13 <br>
 B <br>
 12 <br>
 1100 <br>
 14 <br>
 C <br>
 13 <br>
 1101 <br>
 15 <br>
 D <br>
 14 <br>
 1110 <br>
 16 <br>
 E <br>
 15 <br>
 1111 <br>
 17 <br>
 F <br>
 <br>Conversion from binary to hexadecimal is similar, except that the binary number is <br>divided into groups of <i>four</i> digits: <br>
(10<br>
1100<br>
0110<br>
1011<br>
#<br>
1111<br>
0010)<br>
 <br>
2 = (2C6B.F2)16 <br>
2<br>
C<br>
6<br>
B<br>
F<br>
2<br>
 <br>The corresponding hexadecimal (or octal) digit for each group of binary digits is easily <br>remembered from the values listed in  Table   1.2  . <br>
 <br>Conversion from octal or hexadecimal to binary is done by reversing the preceding <br>
procedure. Each octal digit is converted to its threedigit binary equivalent. Similarly, <br>each hexadecimal digit is converted to its fourdigit binary equivalent. The procedure is <br>illustrated in the following examples: <br>
(673.124)<br>
 <br>
8 = (110<br>
111<br>
011<br>
#<br>
001<br>
010<br>
100)2 <br>
6<br>
7<br>
3<br>
1<br>
2<br>
4<br>
 and <br>
(306.D)<br>
 <br>
16 = (0011<br>
0000<br>
0110<br>
#<br>
1101)2 <br>
3<br>
0<br>
6<br>
D<br>
 <br>Binary numbers are difficult to work with because they require three or four times <br>
as many digits as their decimal equivalents. For example, the binary number 111111111111 <br>is equivalent to decimal 4095. However, digital computers use binary numbers, and it is <br>sometimes necessary for the human operator or user to communicate directly with the <br>
<hr>
<A name=28></a><b>10    Chapter 1  Digital Systems and Binary Numbers</b><br>
machine by means of such numbers. One scheme that retains the binary system in the <br>computer, but reduces the number of digits the human must consider, utilizes the rela-<br>tionship between the binary number system and the octal or hexadecimal system. By this <br>method, the human thinks in terms of octal or hexadecimal numbers and performs the <br>required conversion by inspection when direct communication with the machine is nec-<br>essary. Thus, the binary number 111111111111 has 12 digits and is expressed in octal as <br>7777 (4 digits) or in hexadecimal as FFF (3 digits). During communication between <br>people (about binary numbers in the computer), the octal or hexadecimal representa-<br>tion is more desirable because it can be expressed more compactly with a third or a <br>quarter of the number of digits required for the equivalent binary number. Thus,  <b>most <br>computer manuals use either octal or hexadecimal numbers to specify binary quantities</b> <b>.</b> <br>The choice between them is arbitrary, although hexadecimal tends to win out, since it <br>can represent a byte with two digits. <br>
<b> <br>1 . 5       C O M P L E M E N T S   O F   N U M B E R S </b><br>
 <br>Complements are used in digital computers to  <b>simplify the subtraction operation</b>  and for <br>logical manipulation. Simplifying operations leads to simpler, less expensive circuits to <br>implement the operations. There are two types of complements for each base<i>r</i> system: <br>the radix complement and the diminished radix complement. The first is referred to as <br>the <i>r</i>'s complement and the second as the   (<i>r </i>- 1)&gt;s  complement. When the value of the <br>base <i>r</i> is substituted in the name, the two types are referred to as the 2's complement and <br>1's complement for binary numbers and the 10's complement and 9's complement for <br>decimal numbers. <br>
<b> <br>Diminished Radix Complement </b><br>
 <br>Given a number <i>N</i> in base <i>r</i> having <i>n</i> digits, the   (<i>r </i>- 1)&gt;s     complement  of   <i>N</i> <i>,</i> i.e., its <br>diminished radix complement, is defined as   (<i>r n </i>- 1) - <i>N</i>.     For  decimal  numbers,     <i>r </i>= 10<br>   and     <i>r </i>- 1 = 9,  so the 9's complement of <i>N</i> is   (10<i>n </i>- 1) - <i>N</i>.     In  this  case,     10<i>n</i>     represents <br>a number that consists of a single 1 followed by <i>n</i> 0's.   10 <i>n </i>- 1  is a number represented <br>by <i>n</i> 9's. For example, if   <i>n </i>= 4,     we  have     104 = 10,000     and     104 - 1 = 9999.     It  follows <br>that the 9's complement of a decimal number is obtained by subtracting each digit from 9. <br>Here are some numerical examples: <br>
 <br>The 9&gt;s complement of 546700 is 999999 - 546700 = 453299.<br>
The 9&gt;s complement of 012398 is 999999 - 012398 = 987601.   <br>
 <br>For binary numbers,   <i>r </i>= 2     and     <i>r </i>- 1 = 1,  so the 1's complement of <i>N</i> is   (2<i>n </i>- 1) - <i>N</i>.    <br>
Again, 2<i>n</i> is represented by a binary number that consists of a 1 followed by <i>n</i> 0's.   2<i>n </i>- 1    <br>is a binary number represented by <i>n</i> 1's. For example, if   <i>n </i>= 4,     we  have     24 = (10000)2 <br>and     24 - 1 = (1111)2. Thus, the 1's complement of a binary number is obtained by <br>subtracting each digit from 1. However, when subtracting binary digits from 1, we can <br>
<hr>
<A name=29></a><b>Section 1.5  Complements of Numbers    11</b><br>
have either   1 - 0 = 1 or  1 - 1 = 0,  which causes the bit to change from 0 to 1 or from <br>1 to 0, respectively. Therefore,  <b>the 1's complement of a binary number is formed by <br>changing 1's to 0's and 0's to 1's.</b> The following are some numerical examples: <br>
  The  1's  complement  of  1011000  is  0100111.       <br>
 <br>The 1's complement of 0101101 is 1010010. <br>
 The     (<i>r </i>- 1)&gt;s  complement of octal or hexadecimal numbers is obtained by subtracting <br>
each digit from 7 or F (decimal 15), respectively. <br>
<b> <br>Radix Complement </b><br>
 The  <i>r</i>'s complement of an <i>n</i>digit number <i>N</i> in base <i>r</i> is defined as   <i>r n </i>- <i>N</i>     for     <i>N</i><br>
0     and <br>
as 0 for   <i>N </i>= 0.     Comparing  with  the     (<i>r </i>- 1)&gt;s  complement, we note that the r's complement <br>is obtained by adding 1 to the   (<i>r </i>- 1)&gt;s     complement,  since     <i>rn </i>- <i>N </i>= [(<i>r n </i>- 1) - <i>N</i>] + 1. <br>Thus, the 10's complement of decimal 2389 is   7610 + 1 = 7611     and is obtained by adding <br>1 to the 9's complement value. The 2's complement of binary 101100 is   010011 + 1 = 010100    <br>and is obtained by adding 1 to the 1'scomplement value. <br>
 <br>Since   10  is a number represented by a 1 followed by <i>n</i> 0's,   10 <i>n </i>- <i>N</i>,  which is the 10's <br>
complement of <i>N</i>, can be formed also by leaving all least significant 0's unchanged, <br>subtracting the first nonzero least significant digit from 10, and subtracting all higher <br>significant digits from 9. Thus, <br>
 <br>the 10's complement of 012398 is 987602  <br>
 and <br>
 <br>the 10's complement of 246700 is 753300  <br>
 <br>The 10's complement of the first number is obtained by subtracting 8 from 10 in the least <br>significant position and subtracting all other digits from 9. The 10's complement of the <br>second number is obtained by leaving the two least significant 0's unchanged, subtract-<br>ing 7 from 10, and subtracting the other three digits from 9. <br>
 <br>Similarly, the 2's complement can be formed by leaving all least significant 0's and <br>
the first 1 unchanged and replacing 1's with 0's and 0's with 1's in all other higher sig-<br>nificant digits. For example, <br>
 <br>the 2's complement of 1101100 is 0010100 <br>
 and <br>
 <br>the 2's complement of 0110111 is 1001001 <br>
 <br>The 2's complement of the first number is obtained by leaving the two least significant <br>0's and the first 1 unchanged and then replacing 1's with 0's and 0's with 1's in the other <br>four most significant digits. The 2's complement of the second number is obtained by <br>leaving the least significant 1 unchanged and complementing all other digits. <br>
<hr>
<A name=30></a><b>12    Chapter 1  Digital Systems and Binary Numbers</b><br>
 <br>In the previous definitions, it was assumed that the numbers did not have a radix point. <br>
If the original number <i>N</i> contains a radix point, the point should be removed temporarily <br>in order to form the <i>r</i>'s or   (<i>r </i>- 1)&gt;s  complement. The radix point is then restored to the <br>complemented number in the same relative position. It is also worth mentioning that  <b>the <br>complement of the complement restores the number to its original value</b> <b>.</b> To see this <br>relationship, note that the <i>r</i>'s complement of <i>N</i> is   <i>r n </i>- <i>N</i>,  so that the complement of the <br>complement is   <i>r n </i>- (<i>rn </i>- <i>N</i>) = <i>N</i>  and is equal to the original number. <br>
<b> <br>Subtraction with Complements </b><br>
 <br>The direct method of subtraction taught in elementary schools uses the borrow concept. <br>In this method, we borrow a 1 from a higher significant position when the minuend digit <br>is smaller than the subtrahend digit. The method works well when people perform sub-<br>traction with paper and pencil. However, when subtraction is implemented with digital <br>hardware, the method is less efficient than the method that uses complements. <br>
 <br>The subtraction of two <i>n</i>digit unsigned numbers   <i>M </i>- <i>N</i>     in  base  <i>r</i> can be done as <br>
follows: <br>
 <br><b> 1. </b><br>
  Add  the  minuend  <i>M</i> to the <i>r</i>'s complement of the subtrahend <i>N</i>. Mathematically, <br> <br><i>M </i>+ (<i>r n </i>- <i>N</i>) = <i>M </i>- <i>N </i>+ <i>rn</i>. <br>
 <br><b> 2. </b><br>
 <br>If  <i>M </i>� <i>N</i>,  the sum will produce an end carry   <i>rn</i>,  which can be discarded; what is <br>left is the result   <i>M </i>- <i>N</i>. <br>
 <br><b> 3. </b><br>
 <br>If  <i>M</i> 6 <i>N</i>,  the sum does not produce an end carry and is equal to   <i>rn </i>- (<i>N </i>- <i>M</i>), <br>which is the <i>r</i>'s complement of   (<i>N </i>- <i>M</i>). To obtain the answer in a familiar form, <br>take the <i>r</i>'s complement of the sum and place a negative sign in front. <br>
 <br>The following examples illustrate the procedure: <br>
<b> <br>EXAMPLE 1.5 </b><br>
 <br>Using 10's complement, subtract   72532 - 3250.    <br>
 <br><i>M </i>=     72532<br>
10&gt;s complement of <i>N </i>= +   96750<br>
Sum =     169282<br>
Discard end carry 105 = - 100000 <br>
<i>Answer </i>=     69282<br>
 Note  that  <i>M</i> has five digits and <i>N</i> has only four digits. Both numbers must have the same <br>number of digits, so we write <i>N</i> as 03250. Taking the 10's complement of <i>N</i> produces a <br>9 in the most significant position. The occurrence of the end carry signifies that   <i>M </i>� <i>N</i> <br>and that the result is therefore positive. <br>
<br>
<hr>
<A name=31></a><b>Section 1.5  Complements of Numbers    13</b><br>
<b> <br>EXAMPLE 1.6 </b><br>
 <br>Using 10's complement, subtract   3250 - 72532.    <br>
 <br><i>M </i>=     03250<br>
10&gt;s complement of <i>N </i>= + 27468<br>
Sum =     30718 <br>
 <br>There is no end carry. Therefore, the answer is   -(10&gt;s complement of 30718) = -69282.    <br>
 <br>Note that since   3250  6  72532,     the result is negative. Because we are dealing with <br>
unsigned numbers, there is really no way to get an unsigned result for this case. When <br>subtracting with complements, we recognize the negative answer from the absence <br>of the end carry and the complemented result. When working with paper and pencil, <br>we can change the answer to a signed negative number in order to put it in a famil-<br>iar form. <br>
 <br>Subtraction with complements is done with binary numbers in a similar manner, using <br>
the procedure outlined previously. <br>
<br>
<b> <br>EXAMPLE 1.7 </b><br>
 <br>Given the two binary numbers   <i>X </i>= 1010100     and     <i>Y </i>= 1000011,     perform the subtraction <br><b>(a)</b>  <i>X </i>- <i>Y</i>     and  <b>(b)</b>  <i>Y </i>- <i>X</i>  by using 2's complements. <br>
 (a) <br>
  <i>X </i>=<br>
1010100      <br>
 <br>
2&gt;s complement of <i>Y </i>=   + 0111101<br>
 Sum =      10010001<br> <br>
Discard end carry 27<br>
 <br>
= - 10000000<br>
 <br>
<i>Answer</i>: <i>X </i>- <i>Y </i>=       0010001 <br>
  (b)<b> </b><br>
 <br><i>Y </i>=       1000011<br>
 <br>
2&gt;s complement of <i>X </i>=   + 0101100<br>
 Sum =         1101111     <br>
 <br>There is no end carry. Therefore, the answer is   <i>Y </i>- <i>X </i>= -(2&gt;s complement of 1101111) =  <br> -0010001.     <br>
<br>
 <br>Subtraction of unsigned numbers can also be done by means of the   (<i>r </i>- 1)&gt;s     com-<br>plement. Remember that the   (<i>r </i>- 1)&gt;s  complement is one less than the <i>r</i>'s comple-<br>ment. Because of this, the result of adding the minuend to the complement of the <br>subtrahend produces a sum that is one less than the correct difference when an end <br>carry occurs. Removing the end carry and adding 1 to the sum is referred to as an <br><i>endaround carry. </i><br>
<hr>
<A name=32></a><b>14    Chapter 1  Digital Systems and Binary Numbers</b><br>
<b> <br>EXAMPLE 1.8 </b><br>
 <br>Repeat Example 1.7, but this time using 1's complement. <br>
 <br><b> (a) </b><br>
 <br><i>X </i>- <i>Y </i>= 1010100 - 1000011<br>
<i>X </i>=       1010100<br>
1&gt;s complement of <i>Y </i>= +   0111100<br>
Sum =      10010000<br>
End@around carry  = +    <br>
 1<br>
<i>Answer</i>: <i>X </i>- <i>Y </i>=      0010001 <br>
 <br><b> (b) </b><br>
 <br><i>Y </i>- <i>X </i>= 1000011 - 1010100<br>
<i>Y </i>=      1000011<br>
1&gt;s complement of <i>X </i>= +  0101011<br>
Sum =      1101110 <br>
 <br>There is no end carry. Therefore, the answer is   <i>Y </i>- <i>X </i>= -(1&gt;s complement of 1101110) = <br> -0010001.     <br>
<br>
 <br>Note that the negative result is obtained by taking the 1's complement of the sum, since <br>this is the type of complement used. The procedure with endaround carry is also appli-<br>cable to subtracting unsigned decimal numbers with 9's complement. <br>
<b> <br>1 . 6       S I G N E D   B I N A R Y   N U M B E R S </b><br>
 <br>Positive integers (including zero) can be represented as unsigned numbers. However, to <br>represent negative integers, we need a notation for negative values. In ordinary arith-<br>metic, a negative number is indicated by a minus sign and a positive number by a plus <br>sign. Because of hardware limitations, computers must represent everything with binary <br>digits. It is customary to represent the sign with a bit placed in the leftmost position of <br>the number. The convention is to make the sign bit 0 for positive and 1 for negative. <br>
 <br>It is important to realize that both signed and unsigned binary numbers consist of a <br>
string of bits when represented in a computer. The user determines whether the number <br>is signed or unsigned. If the binary number is signed, then the leftmost bit represents the <br>sign and the rest of the bits represent the number. If the binary number is assumed to <br>be unsigned, then the leftmost bit is the most significant bit of the number. For example, <br>the string of bits 01001 can be considered as 9 (unsigned binary) or as   +9     (signed  binary) <br>because the leftmost bit is 0. The string of bits 11001 represents the binary equivalent of <br>25 when considered as an unsigned number and the binary equivalent of   -9     when  con-<br>sidered as a signed number. This is because the 1 that is in the leftmost position designates <br>a negative and the other four bits represent binary 9. Usually, there is no confusion in <br>interpreting the bits if the type of representation for the number is known in advance. <br>
<hr>
<A name=33></a><b>Section 1.6  Signed Binary Numbers    15</b><br>
 <br>The representation of the signed numbers in the last example is referred to as the <br>
<i>signedmagnitude</i> convention. In this notation, the number consists of a magnitude and <br>a symbol (  + or  - ) or a bit (0 or 1) indicating the sign. This is the representation of signed <br>numbers used in ordinary arithmetic. When arithmetic operations are implemented in <br>a computer, it is more convenient to use a different system, referred to as the <i>signed<br>complement </i>system, for representing negative numbers. In this system, a negative num-<br>ber is indicated by its complement. Whereas the signedmagnitude system negates a <br>number by changing its sign, the signedcomplement system negates a number by taking <br>its complement. Since positive numbers always start with 0 (plus) in the leftmost posi-<br>tion, the complement will always start with a 1, indicating a negative number. The <br>signedcomplement system can use either the 1's or the 2's complement, but the 2's <br>complement is the most common. <br>
 <br>As an example, consider the number 9, represented in binary with eight bits.   +9     is <br>
represented with a sign bit of 0 in the leftmost position, followed by the binary equiva-<br>lent of 9, which gives 00001001. Note that all eight bits must have a value; therefore, 0's <br>are inserted following the sign bit up to the first 1. Although there is only one way to <br>represent      +9,  there are three different ways to represent   -9     with  eight  bits: <br>
  signedmagnitude  representation: <br>
10001001 <br>
 signed1'scomplement  representation: <br>
11110110 <br>
 signed2'scomplement  representation: <br>
11110111  <br>
 In  signedmagnitude,      -9     is  obtained  from     +9  by changing only the sign bit in the leftmost <br>position from 0 to 1. In signed1's-complement,   -9  is obtained by complementing all the <br>bits of   +9,  including the sign bit. The signed2'scomplement representation of   -9     is <br>obtained by taking the 2's complement of the positive number, including the sign bit. <br>
 <br>Table   1.3   lists all possible fourbit signed binary numbers in the three representations. <br>
The equivalent decimal number is also shown for reference. Note that the positive num-<br>bers in all three representations are identical and have 0 in the leftmost position. The <br>signed2'scomplement system has only one representation for 0, which is always posi-<br>tive. The other two systems have either a positive 0 or a negative 0, something not <br>encountered in ordinary arithmetic. Note that all negative numbers have a 1 in the <br>leftmost bit position; that is the way we distinguish them from the positive numbers. <br>With four bits, we can represent 16 binary numbers. In the signedmagnitude and the <br>1'scomplement representations, there are eight positive numbers and eight negative <br>numbers, including two zeros. In the 2'scomplement representation, there are eight <br>positive numbers, including one zero, and eight negative numbers. <br>
 <br>The signedmagnitude system is used in ordinary arithmetic, but is awkward when <br>
employed in computer arithmetic because of the separate handling of the sign and the <br>magnitude. Therefore, the signedcomplement system is normally used. The 1's com-<br>plement imposes some difficulties and is seldom used for arithmetic operations. It is <br>useful as a logical operation, since the change of 1 to 0 or 0 to 1 is equivalent to a <br>logical complement operation, as will be shown in the next chapter. The discussion of <br>signed binary arithmetic that follows deals exclusively with the signed2'scomplement <br>
<hr>
<A name=34></a><b>16    Chapter 1  Digital Systems and Binary Numbers</b><br>
<b> <br>Table 1.3 <br><i> <br>Signed Binary Numbers </b></i><br>
<b> <br>Signed2's </b><br>
<b> <br>Signed1's </b><br>
<b> <br>Signed </b><br>
<b> <br>Decimal </b><br>
<b>Complement </b><br>
<b>Complement </b><br>
<b>Magnitude </b><br>
 +7    <br>
 0111 <br>
 0111 <br>
 0111 <br>
 +6    <br>
 0110 <br>
 0110 <br>
 0110 <br>
 +5    <br>
 0101 <br>
 0101 <br>
 0101 <br>
 +4    <br>
 0100 <br>
 0100 <br>
 0100 <br>
 +3    <br>
 0011 <br>
 0011 <br>
 0011 <br>
 +2    <br>
 0010 <br>
 0010 <br>
 0010 <br>
 +1    <br>
 0001 <br>
 0001 <br>
 0001 <br>
 +0    <br>
 0000 <br>
 0000 <br>
 0000 <br>
 -0    <br>
 -- <br>
 1111 <br>
 1000 <br>
 -1    <br>
 1111 <br>
 1110 <br>
 1001 <br>
 -2    <br>
 1110 <br>
 1101 <br>
 1010 <br>
 -3    <br>
 1101 <br>
 1100 <br>
 1011 <br>
 -4    <br>
 1100 <br>
 1011 <br>
 1100 <br>
 -5    <br>
 1011 <br>
 1010 <br>
 1101 <br>
 -6    <br>
 1010 <br>
 1001 <br>
 1110 <br>
 -7    <br>
 1001 <br>
 1000 <br>
 1111 <br>
 -8    <br>
 1000 <br>
 -- <br>
 -- <br>
representation of negative numbers. The same procedures can be applied to the <br>signed1'scomplement system by including the endaround carry as is done with <br>unsigned numbers. <br>
<b> <br>Arithmetic Addition </b><br>
 <br>The addition of two numbers in the signedmagnitude system follows the rules of <br>ordinary arithmetic. If the signs are the same, we add the two magnitudes and give <br>the sum the common sign. If the signs are different, we subtract the smaller magni-<br>tude from the larger and give the difference the sign of the larger magnitude. For <br>example,     ( +25) + (-37) = -(37 - 25) = -12  is done by subtracting the smaller mag-<br>nitude, 25, from the larger magnitude, 37, and appending the sign of 37 to the result. <br>This is a process that requires a comparison of the signs and magnitudes and then per-<br>forming either addition or subtraction. The same procedure applies to binary numbers <br>in signedmagnitude representation. In contrast, the rule for adding numbers in the <br>signedcomplement system does not require a comparison or subtraction, but only <br>addition. The procedure is very simple and can be stated as follows for binary numbers: <br>
 <br><b>The addition of two signed binary numbers with negative numbers represented in</b> <br>
<b>signed</b> <b>2'scomplement form is obtained from the addition of the two numbers, includ-<br>ing their sign</b> <b> bits.  A carry out of the signbit position is discarded.</b> <br>
<hr>
<A name=35></a><b>Section 1.6  Signed Binary Numbers    17</b><br>
 <br>Numerical examples for addition follow: <br>
+ 6<br>
00000110<br>
- 6<br>
11111010<br>
+ 13<br>
00001101<br>
+ 13<br>
00001101<br>
+ 19<br>
00010011<br>
+ 7<br>
00000111<br>
 <br>
+ 6<br>
00000110<br>
- 6<br>
11111010<br>
- 13<br>
11110011<br>
- 13<br>
11110011<br>
- 7<br>
11111001<br>
- 19<br>
11101101 <br>
 <br>Note that negative numbers must be initially in 2'scomplement form and that if the sum <br>obtained after the addition is negative, it is in 2'scomplement form. For example, -7 is <br>represented as 11111001, which is the 2s complement of +7. <br>
 <br>In each of the four cases, the operation performed is addition with the sign bit <br>
included. Any carry out of the signbit position is discarded, and negative results are <br>automatically in 2'scomplement form. <br>
 <br>In order to obtain a correct answer, we must ensure that the result has a sufficient <br>
number of bits to accommodate the sum. If we start with two <i>n</i>bit numbers and the sum <br>occupies     <i>n </i>+ 1  bits, we say that an overflow occurs. When one performs the addition with <br>paper and pencil, an overflow is not a problem, because we are not limited by the width <br>of the page. We just add another 0 to a positive number or another 1 to a negative number <br>in the most significant position to extend the number to   <i>n </i>+ 1  bits and then perform the <br>addition. Overflow is a problem in computers because the number of bits that hold a <br>number is finite, and a result that exceeds the finite value by 1 cannot be accommodated. <br>
 <br>The complement form of representing negative numbers is unfamiliar to those used <br>
to the signedmagnitude system. To determine the value of a negative number in signed2's <br>complement, it is necessary to convert the number to a positive number to place it in a <br>more familiar form. For example, the signed binary number 11111001 is negative because <br>the leftmost bit is 1. Its 2's complement is 00000111, which is the binary equivalent of <br> +7. We therefore recognize the original negative number to be equal to   -7. <br>
<b> <br>Arithmetic Subtraction </b><br>
 <br>Subtraction of two signed binary numbers when negative numbers are in 2'scomplement <br>form is simple and can be stated as follows: <br>
 <br>Take the 2's complement of the subtrahend (including the sign bit) and add it to the <br>
minuend (including the sign bit). A carry out of the signbit position is discarded. <br>
 <br>This procedure is adopted because a subtraction operation can be changed to an addi-<br>tion operation if the sign of the subtrahend is changed, as is demonstrated by the <br>following relationship: <br>
 ( {<i>A</i>) - (+<i>B</i>) = ({<i>A</i>) + (-<i>B</i>);<br>
( {<i>A</i>) - (-<i>B</i>) = ({<i>A</i>) + (+<i>B</i>). <br>
 <br>But changing a positive number to a negative number is easily done by taking the 2's <br>complement of the positive number. The reverse is also true, because the complement <br>
<hr>
<A name=36></a><b>18    Chapter 1  Digital Systems and Binary Numbers</b><br>
of a negative number in complement form produces the equivalent positive number. To <br>see this, consider the subtraction   ( -6) - (-13) = +7.  In binary with eight bits, this <br>operation is written as   (11111010 - 11110011). The subtraction is changed to addition <br>by taking the 2's complement of the subtrahend   (-13),     giving     (+13).  In binary, this is <br>   <br>11111010 + 00001101 = 100000111.     Removing the end carry, we obtain the correct <br>answer:     00000111 ( +7). <br>
 <br>It is worth noting that binary numbers in the signedcomplement system are added <br>
and subtracted by the same basic addition and subtraction rules as unsigned numbers. <br>Therefore,  <b>computers need only one common hardware circuit to handle both types of <br>arithmetic .  </b>This consideration has resulted in the signedcomplement system being used <br>in virtually all arithmetic units of computer systems. The user or programmer must <br>interpret the results of such addition or subtraction differently, depending on whether <br>it is assumed that the numbers are signed or unsigned. <br>
<b> <br>1 . 7       B I N A R Y   C O D E S </b><br>
 <br>Digital systems use signals that have two distinct values and circuit elements that <br>have two stable states. There is a direct analogy among binary signals, binary circuit <br>elements, and binary digits. A binary number of <i>n</i> digits, for example, may be repre-<br>sented by <i>n</i> binary circuit elements, each having an output signal equivalent to 0 or 1. <br>Digital systems represent and manipulate not only binary numbers, but also many <br>other discrete elements of information. Any discrete element of information that is <br>distinct among a group of quantities can be represented with a binary code (i.e., a <br>pattern of 0's and 1's). The codes must be in binary because, in today's technology, <br>only circuits that represent and manipulate patterns of 0's and 1's can be manufac-<br>tured economically for use in computers. However, it must be realized that binary <br>codes merely change the symbols, not the meaning of the elements of information <br>that they represent. If we inspect the bits of a computer at random, we will find that <br>most of the time they represent some type of coded information rather than binary <br>numbers. <br>
 An  <i>n</i>bit binary code is a group of <i>n</i> bits that assumes up to   2<i>n</i>     distinct  combinations <br>
of 1's and 0's, with each combination representing one element of the set that is being <br>coded. A set of four elements can be coded with two bits, with each element assigned <br>one of the following bit combinations: 00, 01, 10, 11. A set of eight elements requires a <br>threebit code and a set of 16 elements requires a fourbit code. The bit combination of <br>an <i>n</i>bit code is determined from the count in binary from 0 to   2<i>n </i>- 1.     Each  element <br>must be assigned a unique binary bit combination, and no two elements can have the <br>same value; otherwise, the code assignment will be ambiguous. <br>
 Although  the  <i>minimum</i> number of bits required to code   2<i>n</i>     distinct  quantities  is  <i>n</i>, <br>
there is no <i>maximum </i>number of bits that may be used for a binary code. For example, <br>the 10 decimal digits can be coded with 10 bits, and each decimal digit can be assigned <br>a bit combination of nine 0's and a 1. In this particular binary code, the digit 6 is assigned <br>the bit combination 0001000000. <br>
<hr>
<A name=37></a><b>Section 1.7  Binary Codes    19</b><br>
<b> <br>Binary-Coded Decimal Code </b><br>
 <br>Although the binary number system is the most natural system for a computer because <br>it is readily represented in today's electronic technology, most people are more accus-<br>tomed to the decimal system. One way to resolve this difference is to convert decimal <br>numbers to binary, perform all arithmetic calculations in binary, and then convert the <br>binary results back to decimal. This method requires that we store decimal numbers in <br>the computer so that they can be converted to binary. Since the computer can accept <br>only binary values, we must represent the decimal digits by means of a code that contains <br>1's and 0's. It is also possible to perform the arithmetic operations directly on decimal <br>numbers when they are stored in the computer in coded form. <br>
 <br>A binary code will have some unassigned bit combinations if the number of elements <br>
in the set is not a multiple power of 2. The 10 decimal digits form such a set. A binary <br>code that distinguishes among 10 elements must contain at least four bits, but 6 out of <br>the 16 possible combinations remain unassigned. Different binary codes can be obtained <br>by arranging four bits into 10 distinct combinations. The code most commonly used for <br>the decimal digits is the straight binary assignment listed in  Table   1.4  . This scheme is <br>called <i>binarycoded decimal </i>and is commonly referred to as BCD. Other decimal codes <br>are possible and a few of them are presented later in this section. <br>
 <br>Table   1.4   gives the fourbit code for one decimal digit. A number with <i>k</i> decimal <br>
digits will require 4<i>k</i> bits in BCD. Decimal 396 is represented in BCD with 12 bits as <br>0011 1001 0110, with  <b>each group of 4 bits representing one decimal digit.</b>   A  decimal <br>number in BCD is the same as its equivalent binary number only when the number is <br>between 0 and 9. A BCD number greater than 10 looks different from its equivalent <br>binary number, even though both contain 1's and 0's. Moreover,  <b>the binary combina-<br>tions 1010 through 1111 are not used and have no meaning in BCD.</b>  Consider decimal <br>185 and its corresponding value in BCD and binary: <br>
   <br>(185)10 = (0001 1000 0101)BCD = (10111001)2 <br>
<b> <br>Table 1.4 <br><i> <br>BinaryCoded Decimal (BCD) </b></i><br>
<b> <br>Decimal </b><br>
<b> <br>BCD </b><br>
<b>Symbol </b><br>
<b>Digit </b><br>
 0 <br>
 0000 <br>
 1 <br>
 0001 <br>
 2 <br>
 0010 <br>
 3 <br>
 0011 <br>
 4 <br>
 0100 <br>
 5 <br>
 0101 <br>
 6 <br>
 0110 <br>
 7 <br>
 0111 <br>
 8 <br>
 1000 <br>
 9 <br>
 1001 <br>
<hr>
<A name=38></a><b>20    Chapter 1  Digital Systems and Binary Numbers</b><br>
 <br>The BCD value has 12 bits to encode the characters of the decimal value, but the equiv-<br>alent binary number needs only 8 bits. It is obvious that the representation of a BCD <br>number needs more bits than its equivalent binary value. However, there is an advantage <br>in the use of decimal numbers, because computer input and output data are generated <br>by people who use the decimal system. <br>
 <br>It is important to realize that BCD numbers are decimal numbers and not binary <br>
numbers, although they use bits in their representation. The only difference between a <br>decimal number and BCD is that decimals are written with the symbols 0, 1, 2,   c ,     9 <br>and BCD numbers use the binary code 0000, 0001, 0010,   c ,     1001.  The  decimal  value <br>is exactly the same. Decimal 10 is represented in BCD with eight bits as 0001 0000 and <br>decimal 15 as 0001 0101. The corresponding binary values are 1010 and 1111 and have <br>only four bits. <br>
<b> <br>BCD Addition </b><br>
 <br>Consider the addition of two decimal digits in BCD, together with a possible carry <br>from a previous less significant pair of digits. Since each digit does not exceed 9, the <br>sum cannot be greater than   9 + 9 + 1 = 19,  with the 1 being a previous carry. Sup-<br>pose we add the BCD digits as if they were binary numbers. Then the binary sum will <br>produce a result in the range from 0 to 19. In binary, this range will be from 0000 to <br>10011, but in BCD, it is from 0000 to 1 1001, with the first (i.e., leftmost) 1 being a <br>carry and the next four bits being the BCD sum. When the binary sum is equal to or <br>less than 1001 (without a carry), the corresponding BCD digit is correct. However, <br>when the binary sum is greater than or equal to 1010, the result is an invalid BCD <br>digit. The addition of   6 = (0110)2  to the binary sum converts it to the correct digit and <br>also produces a carry as required. This is because a carry in the most significant bit <br>position of the binary sum and a decimal carry differ by   16 - 10 = 6.     Consider  the <br>following three BCD additions: <br>
4<br>
0100<br>
4<br>
0100<br>
8<br>
1000<br>
+ 5<br>
+ 0101<br>
+ 8<br>
+ 1000<br>
+ 9<br>
 1001<br>
9<br>
1001<br>
12<br>
1100<br>
17<br>
10001<br>
+ 0110<br>
+ 0110<br>
 <br>
10010<br>
10111 <br>
 <br>In each case, the two BCD digits are added as if they were two binary numbers. If the <br>binary sum is greater than or equal to 1010, we add 0110 to obtain the correct BCD sum <br>and a carry. In the first example, the sum is equal to 9 and is the correct BCD sum. In <br>the second example, the binary sum produces an invalid BCD digit. The addition of 0110 <br>produces the correct BCD sum, 0010 (i.e., the number 2), and a carry. In the third <br>example, the binary sum produces a carry. This condition occurs when the sum is greater <br>than or equal to 16. Although the other four bits are less than 1001, the binary sum <br>requires a correction because of the carry. Adding 0110, we obtain the required BCD <br>sum 0111 (i.e., the number 7) and a BCD carry. <br>
<hr>
<A name=39></a><b>Section 1.7  Binary Codes    21</b><br>
 <br>The addition of two <i>n</i>digit unsigned BCD numbers follows the same procedure. <br>
Consider the addition of   184 + 576 = 760     in  BCD: <br>
BCD     <br>
1<br>
1<br>
0001<br>
1000<br>
0100<br>
184<br>
+ 0101<br>
0111<br>
0110<br>
+ 576<br>
Binary sum<br>
0111<br>
10000<br>
1010<br>
Add 6     <br>
    <br>
  0110<br>
0110<br>
      <br>
 BCD sum <br>
0111<br>
0110<br>
0000<br>
760 <br>
 <br>The first, least significant pair of BCD digits produces a BCD digit sum of 0000 and a <br>carry for the next pair of digits. The second pair of BCD digits plus a previous carry <br>produces a digit sum of 0110 and a carry for the next pair of digits. The third pair of <br>digits plus a carry produces a binary sum of 0111 and does not require a correction. <br>
<b> <br>Decimal Arithmetic </b><br>
 <br>The representation of signed decimal numbers in BCD is similar to the representation <br>of signed numbers in binary. We can use either the familiar signedmagnitude system or <br>the signedcomplement system. The sign of a decimal number is usually represented <br>with four bits to conform to the fourbit code of the decimal digits. It is customary to <br>designate a plus with four 0's and a minus with the BCD equivalent of 9, which is 1001. <br>
 <br>The signedmagnitude system is seldom used in computers. The signedcomplement <br>
system can be either the 9's or the 10's complement, but the 10's complement is the one <br>most often used. To obtain the 10's complement of a BCD number, we first take the 9's <br>complement and then add 1 to the least significant digit. The 9's complement is calcu-<br>lated from the subtraction of each digit from 9. <br>
 <br>The procedures developed for the signed2'scomplement system in the previous <br>
section also apply to the signed10'scomplement system for decimal numbers. Addition <br>is done by summing all digits, including the sign digit, and discarding the end carry. This <br>operation assumes that all negative numbers are in 10'scomplement form. Consider the <br>addition   ( +375) + (-240) = +135,  done in the signedcomplement system: <br>
0<br>
375<br>
+ 9<br>
760<br>
  0<br>
135 <br>
 <br>The 9 in the leftmost position of the second number represents a minus, and 9760 is <br>the 10's complement of 0240. The two numbers are added and the end carry is dis-<br>carded to obtain   +135.  Of course, the decimal numbers inside the computer, including <br>the sign digits, must be in BCD. The addition is done with BCD digits as described <br>previously. <br>
 <br>The subtraction of decimal numbers, either unsigned or in the signed10'scomplement <br>
system, is the same as in the binary case: Take the 10's complement of the subtrahend and <br>add it to the minuend. Many computers have special hardware to perform arithmetic <br>
<hr>
<A name=40></a><b>22    Chapter 1  Digital Systems and Binary Numbers</b><br>
calculations directly with decimal numbers in BCD. The user of the computer can specify <br>programmed instructions to perform the arithmetic operation with decimal numbers <br>directly, without having to convert them to binary. <br>
<b> <br>Other Decimal Codes </b><br>
 <br>Binary codes for decimal digits require a minimum of four bits per digit. Many different <br>codes can be formulated by arranging four bits into 10 distinct combinations. BCD and <br>three other representative codes are shown in  Table   1.5  . Each code uses only 10 out of <br>a possible 16 bit combinations that can be arranged with four bits. The other six unused <br>combinations have no meaning and should be avoided. <br>
 <br>BCD and the 2421 code are examples of weighted codes. In a weighted code, each bit <br>
position is assigned a weighting factor in such a way that each digit can be evaluated by <br>adding the weights of all the 1's in the coded combination. The BCD code has weights <br>of 8, 4, 2, and 1, which correspond to the poweroftwo values of each bit. The bit assign-<br>ment 0110, for example, is interpreted by the weights to represent decimal 6 because <br> <br>8 * 0 + 4 * 1 + 2 * 1 + 1 * 0 = 6. The bit combination 1101, when weighted by the <br>respective digits 2421, gives the decimal equivalent of   2 * 1 + 4 * 1 + 2 * 0 + 1 * 1 = 7. <br>Note that some digits can be coded in two possible ways in the 2421 code. For instance, <br>decimal 4 can be assigned to bit combination 0100 or 1010, since both combinations add <br>up to a total weight of 4. <br>
<b> <br>Table 1.5 <br><i> <br>Four Different Binary Codes for the Decimal Digits </b></i><br>
<b> <br>Decimal </b><br>
<b> <br>BCD </b><br>
<b>Digit </b><br>
<b>8421  </b><br>
<b>2421  </b><br>
<b>Excess3  </b><br>
<b>8, 4,  2,  1  </b><br>
 0 <br>
 0000 <br>
 0000 <br>
 0011 <br>
 0000 <br>
 1 <br>
 0001 <br>
 0001 <br>
 0100 <br>
 0111 <br>
 2 <br>
 0010 <br>
 0010 <br>
 0101 <br>
 0110 <br>
 3 <br>
 0011 <br>
 0011 <br>
 0110 <br>
 0101 <br>
 4 <br>
 0100 <br>
 0100 <br>
 0111 <br>
 0100 <br>
 5 <br>
 0101 <br>
 1011 <br>
 1000 <br>
 1011 <br>
 6 <br>
 0110 <br>
 1100 <br>
 1001 <br>
 1010 <br>
 7 <br>
 0111 <br>
 1101 <br>
 1010 <br>
 1001 <br>
 8 <br>
 1000 <br>
 1110 <br>
 1011 <br>
 1000 <br>
 9 <br>
 1001 <br>
 1111 <br>
 1100 <br>
 1111 <br>
  <br>
 1010 <br>
 0101 <br>
 0000 <br>
 0001 <br>
 Unused   <br>
 1011 <br>
 0110 <br>
 <br>0001  <br>
0010 <br>
 bit <br>
 1100 <br>
 0111 <br>
 0010 <br>
 0011 <br>
 combi- <br>
 1101 <br>
 1000 <br>
 1101 <br>
 1100 <br>
 nations <br>
 1110 <br>
 1001 <br>
 1110 <br>
 1101 <br>
  <br>
 1111 <br>
 1010 <br>
 1111 <br>
 1110 <br>
<hr>
<A name=41></a><b>Section 1.7  Binary Codes    23</b><br>
 <br>BCD adders add BCD values directly, digit by digit, without converting the numbers <br>
to binary. However, it is necessary to add 6 to the result if it is greater than 9. BCD <br>adders require significantly more hardware and no longer have a speed advantage of <br>conventional binary adders [5]. <br>
 <br>The 2421 and the excess3 codes are examples of selfcomplementing codes. Such <br>
codes have the property that the 9's complement of a decimal number is obtained <br>directly by changing 1's to 0's and 0's to 1's (i.e., by complementing each bit in the pat-<br>tern). For example, decimal 395 is represented in the excess3 code as 0110 1100 1000. <br>The 9's complement of 604 is represented as 1001 0011 0111, which is obtained simply <br>by complementing each bit of the code (as with the 1's complement of binary numbers). <br>
 <br>The excess3 code has been used in some older computers because of its self<br>
complementing property.  <b>Excess3 is an unweighted code in which each coded com-<br>bination is obtained from the corresponding binary value plus 3.</b>  Note that the BCD <br>code is not selfcomplementing. <br>
 <br>The 8, 4,   -2, -1  code is an example of assigning both positive and negative weights <br>
to a decimal code. In this case, the bit combination 0110 is interpreted as decimal 2 and <br>is calculated from   8 * 0 + 4 * 1 + (-2) * 1 + (-1) * 0 = 2. <br>
<b> <br>Gray Code </b><br>
 <br>The output data of many physical systems are quantities that are continuous. These <br>data must be converted into digital form before they are applied to a digital system. <br>Continuous or analog information is converted into digital form by means of an ana-<br>logtodigital converter. It is sometimes convenient to use the Gray code shown in <br> <br>Table   1.6   to represent digital data that have been converted from analog data. The <br>advantage of the Gray code over the straight binary number sequence is that only <br>one bit in the code group changes in going from one number to the next. For example, <br>in going from 7 to 8, the Gray code changes from 0100 to 1100. Only the first bit <br>changes, from 0 to 1; the other three bits remain the same. By contrast, with binary <br>numbers the change from 7 to 8 will be from 0111 to 1000, which causes all four bits <br>to change values. <br>
 <br>The Gray code is used in applications in which the normal sequence of binary numbers <br>
generated by the hardware may produce an error or ambiguity during the transition from <br>one number to the next. If binary numbers are used, a change, for example, from 0111 to <br>1000 may produce an intermediate erroneous number 1001 if the value of the rightmost <br>bit takes longer to change than do the values of the other three bits. This could have seri-<br>ous consequences for the machine using the information. The Gray code eliminates this <br>problem, since only one bit changes its value during any transition between two numbers. <br>
 <br>A typical application of the Gray code is the representation of analog data by a con-<br>
tinuous change in the angular position of a shaft. The shaft is partitioned into segments, <br>and each segment is assigned a number. If adjacent segments are made to correspond <br>with the Graycode sequence, ambiguity is eliminated between the angle of the shaft <br>and the value encoded by the sensor. <br>
<hr>
<A name=42></a><b>24    Chapter 1  Digital Systems and Binary Numbers</b><br>
<b> <br>Table 1.6 <br><i> <br>Gray Code </b></i><br>
<b> <br>Gray </b><br>
<b> <br>Decimal </b><br>
<b>Code </b><br>
<b>Equivalent </b><br>
 0000 <br>
   0 <br>
 0001 <br>
   1 <br>
 0011 <br>
   2 <br>
 0010 <br>
   3 <br>
 0110 <br>
   4 <br>
 0111 <br>
   5 <br>
 0101 <br>
   6 <br>
 0100 <br>
   7 <br>
 1100 <br>
   8 <br>
 1101 <br>
   9 <br>
 1111 <br>
 10 <br>
 1110 <br>
 11 <br>
 1010 <br>
 12 <br>
 1011 <br>
 13 <br>
 1001 <br>
 14 <br>
 1000 <br>
 15 <br>
<b> <br>ASCII Character Code </b><br>
 <br>Many applications of digital computers require the handling not only of numbers, but <br>also of other characters or symbols, such as the letters of the alphabet. For instance, <br>consider a hightech company with thousands of employees. To represent the names <br>and other pertinent information, it is necessary to formulate a binary code for the let-<br>ters of the alphabet. In addition, the same binary code must represent numerals and <br>special characters (such as $). An alphanumeric character set is a set of elements that <br>includes the 10 decimal digits, the 26 letters of the alphabet, and a number of special <br>characters. Such a set contains between 36 and 64 elements if only capital letters are <br>included, or between 64 and 128 elements if both uppercase and lowercase letters are <br>included. In the first case, we need a binary code of six bits, and in the second, we need <br>a binary code of seven bits. <br>
 <br>The standard binary code for the alphanumeric characters is the American Standard <br>
Code for Information Interchange (ASCII), which uses seven bits to code 128 charac-<br>ters, as shown in  Table   1.7 . The seven bits of the code are designated by   <i>b</i>1     through     <i>b</i>7,    <br>with     <i>b</i>7  the most significant bit. The letter <i>A</i>, for example, is represented in ASCII as <br>1000001 (column 100, row 0001). The ASCII code also contains 94 graphic characters <br>that can be printed and 34 nonprinting characters used for various control functions. <br>The graphic characters consist of the 26 uppercase letters (A through Z), the 26 lower-<br>case letters (a through z), the 10 numerals (0 through 9), and 32 special printable char-<br>acters, such as %,   *,     and  $.  <br>
<hr>
<A name=43></a><b>Section 1.7  Binary Codes    25</b><br>
<b> <br>Table 1.7 <br><i> <br>American Standard Code for Information Interchange (ASCII) </b></i><br>
<b> <br><i>b7b6b5</i> </b><br>
<b> <br><i>b4b3b2b1</i> </b><br>
<b> <br>000  </b><br>
<b>001  </b><br>
<b>010  </b><br>
<b>011  </b><br>
<b>100  </b><br>
<b>101  </b><br>
<b>110  </b><br>
<b>111 </b><br>
 0000 <br>
 <br>NUL <br>
 DLE <br>
 SP <br>
 0 <br>
 @ <br>
 P <br>
 ` <br>
 p <br>
 0001 <br>
 <br>SOH <br>
 DC1 <br>
 ! <br>
 1 <br>
 A <br>
 Q <br>
 a <br>
 q <br>
 0010 <br>
 STX <br>
 DC2 <br>
 " <br>
 2 <br>
 B <br>
 R <br>
 b <br>
 r <br>
 0011 <br>
 ETX <br>
 DC3 <br>
 # <br>
 3 <br>
 C <br>
 S <br>
 c <br>
 s <br>
 0100 <br>
 EOT <br>
 DC4 <br>
 $ <br>
 4 <br>
 D <br>
 T <br>
 d <br>
 t <br>
 0101 <br>
 ENQ <br>
 NAK <br>
 % <br>
 5 <br>
 E <br>
 U <br>
 e <br>
 u <br>
 0110 <br>
 ACK <br>
 SYN <br>
 &amp; <br>
 6 <br>
 F <br>
 V <br>
 f <br>
 v <br>
 0111 <br>
 BEL <br>
 ETB <br>
 ` <br>
 7 <br>
 G <br>
 W <br>
 g <br>
 w <br>
 1000 <br>
 BS <br>
 CAN <br>
 ( <br>
 8 <br>
 H <br>
 X <br>
 h <br>
 x <br>
 1001 <br>
 HT <br>
 EM <br>
 ) <br>
 9 <br>
 I <br>
 Y <br>
 i <br>
 y <br>
 1010 <br>
 LF <br>
 SUB <br>
 * <br>
 : <br>
 J <br>
 Z <br>
 j <br>
 z <br>
 1011 <br>
 VT <br>
 ESC <br>
     +  <br>
 <br>; <br>
 <br>K <br>
 <br>[ <br>
 <br>k <br>
 <br>{<br>
 1100 <br>
 FF <br>
 FS <br>
 , <br>
      <br>&lt;    <br>
 L <br>
 \ <br>
 l <br>
 | <br>
 1101 <br>
 CR <br>
 GS <br>
-<br>
  =     <br>
 M <br>
 ] <br>
 m <br>
}  <br>
 1110 <br>
 SO <br>
 RS <br>
 . <br>
  <br>&gt;<br>
 N <br>
     �  <br>
 <br>n <br>
~ <br>
 1111 <br>
 SI <br>
 US <br>
 / <br>
 ? <br>
 O <br>
   -<br>
 o <br>
 DEL <br>
<b> <br>Control Characters </b><br>
 NUL <br>
 Null <br>
 DLE <br>
 Datalink  escape <br>
 SOH <br>
 Start  of  heading <br>
 DC1 <br>
 Device  control  1 <br>
 STX <br>
 Start  of  text <br>
 DC2 <br>
 Device  control  2 <br>
 ETX <br>
 End  of  text <br>
 DC3 <br>
 Device  control  3 <br>
 EOT <br>
 End  of  transmission <br>
 DC4 <br>
 Device  control  4 <br>
 ENQ <br>
 Enquiry <br>
 NAK <br>
 Negative  acknowledge <br>
 ACK <br>
 Acknowledge <br>
 SYN <br>
 Synchronous  idle <br>
 BEL <br>
 Bell <br>
 ETB <br>
 Endoftransmission  block <br>
 BS <br>
 Backspace <br>
 CAN <br>
 Cancel <br>
 HT <br>
 Horizontal  tab <br>
 EM <br>
 End  of  medium <br>
 LF <br>
 Line  feed <br>
 SUB <br>
 Substitute <br>
 VT <br>
 Vertical  tab <br>
 ESC <br>
 Escape <br>
 FF <br>
 Form  feed <br>
 FS <br>
 File  separator <br>
 CR <br>
 Carriage  return <br>
 GS <br>
 Group  separator <br>
 SO <br>
 Shift  out <br>
 RS <br>
 Record  separator <br>
 SI <br>
 Shift  in <br>
 US <br>
 Unit  separator <br>
 SP <br>
 Space <br>
 DEL <br>
 Delete <br>
 <br>The 34 control characters are designated in the ASCII table with abbreviated names. They <br>
are listed again below the table with their functional names. The control characters are used <br>for routing data and arranging the printed text into a prescribed format. There are three types <br>of control characters: format effectors, information separators, and communicationcontrol <br>
<hr>
<A name=44></a><b>26    Chapter 1  Digital Systems and Binary Numbers</b><br>
characters. Format effectors are characters that control the layout of printing. They include <br>the familiar word processor and typewriter controls such as backspace (BS), horizontal tabu-<br>lation (HT), and carriage return (CR). Information separators are used to separate the data <br>into divisions such as paragraphs and pages. They include characters such as record separator <br>(RS) and file separator (FS). The communicationcontrol characters are useful during <br>the transmission of text between remote devices so that it can be distinguished from other <br>messages using the same communication channel before it and after it. Examples of <br> <br>communicationcontrol characters are STX (start of text) and ETX (end of text), which are <br>used to frame a text message transmitted through a communication channel. <br>
 <br>ASCII is a sevenbit code, but most computers manipulate an eightbit quantity <br>
as a single unit called a <i>byte</i>. Therefore, ASCII characters most often are stored one <br>per byte. The extra bit is sometimes used for other purposes, depending on the appli-<br>cation. For example, some printers recognize eightbit ASCII characters with the <br>most significant bit set to 0. An additional 128 eightbit characters with the most <br>significant bit set to 1 are used for other symbols, such as the Greek alphabet or italic <br>type font. <br>
<b> <br>ErrorDetecting Code </b><br>
 <br>To detect errors in data communication and processing, an eighth bit is sometimes added <br>to the ASCII character to indicate its parity. A <i>parity bit</i> is an extra bit included with a <br>message to make the total number of 1's either even or odd. Consider the following two <br>characters and their even and odd parity: <br>
<b> </b><br>
<b> </b><br>
<b>With even parity </b><br>
<b>With odd parity</b><br>
 ASCII <br>
A = 1000001 01000001 11000001<br>
 ASCII <br>
T = 1010100 11010100 <br>
01010100<br>
 <br>In each case, we insert an extra bit in the leftmost position of the code to produce an <br>even number of 1's in the character for even parity or an odd number of 1's in the char-<br>acter for odd parity. In general, one or the other parity is adopted, with even parity being <br>more common. <br>
 <br>The parity bit is helpful in detecting errors during the transmission of information <br>
from one location to another. This function is handled by generating an even parity bit <br>at the sending end for each character. The eightbit characters that include parity bits <br>are transmitted to their destination. The parity of each character is then checked at the <br>receiving end. If the parity of the received character is not even, then at least one bit has <br>changed value during the transmission. This method detects one, three, or any odd com-<br>bination of errors in each character that is transmitted. An even combination of errors, <br>however, goes undetected, and additional error detection codes may be needed to take <br>care of that possibility. <br>
 <br>What is done after an error is detected depends on the particular application. One <br>
possibility is to request retransmission of the message on the assumption that the error <br>was random and will not occur again. Thus, if the receiver detects a parity error, it sends <br>
<hr>
<A name=45></a><b>Section 1.8  Binary Storage and Registers    27</b><br>
back the ASCII NAK (negative acknowledge) control character consisting of an even<br>parity eight bits 10010101. If no error is detected, the receiver sends back an ACK <br>(acknowledge) control character, namely, 00000110. The sending end will respond to an <br>NAK by transmitting the message again until the correct parity is received. If, after a <br>number of attempts, the transmission is still in error, a message can be sent to the oper-<br>ator to check for malfunctions in the transmission path. <br>
<b> <br>1 . 8       B I N A R Y   S T O R A G E   A N D   R E G I S T E R S </b><br>
 <br>The binary information in a digital computer must have a physical existence in some <br>medium for storing individual bits. A <i>binary cell </i>is a device that possesses two stable <br>states and is capable of storing one bit (0 or 1) of information. The input to the cell <br>receives excitation signals that set it to one of the two states. The output of the cell is <br>a physical quantity that distinguishes between the two states. The information stored <br>in a cell is 1 when the cell is in one stable state and 0 when the cell is in the other stable <br>state. <br>
<b> <br>Registers </b><br>
 A  <i>register </i>is a group of binary cells. A register with <i>n</i> cells can store any discrete quantity <br>of information that contains <i>n</i> bits. The state of a register is an <i>n</i>tuple of 1's and 0's, with <br>each bit designating the state of one cell in the register. The content of a register is a <br>function of the interpretation given to the information stored in it. Consider, for example, <br>a 16bit register with the following binary content: <br>
   <br>1100001111001001   <br>
 <br>A register with 16 cells can be in one of   216  possible states. If one assumes that the con-<br>tent of the register represents a binary integer, then the register can store any binary <br>number from 0 to   216 - 1.  For the particular example shown, the content of the register <br>is the binary equivalent of the decimal number 50,121. If one assumes instead that the <br>register stores alphanumeric characters of an eightbit code, then the content of the <br>register is any two meaningful characters. For the ASCII code with an even parity placed <br>in the eighth most significant bit position, the register contains the two characters C (the <br>leftmost eight bits) and I (the rightmost eight bits). If, however, one interprets the con-<br>tent of the register to be four decimal digits represented by a fourbit code, then the <br>content of the register is a fourdigit decimal number. In the excess3 code, the register <br>holds the decimal number 9,096. The content of the register is meaningless in BCD, <br>because the bit combination 1100 is not assigned to any decimal digit. From this exam-<br>ple, it is clear that a register can store discrete elements of information and that the same <br>bit configuration may be interpreted differently for different types of data depending <br>on the application. <br>
<hr>
<A name=46></a><b>28    Chapter 1  Digital Systems and Binary Numbers</b><br>
<b> <br>Register Transfer </b><br>
 <br>A digital system is characterized by its registers and the components that perform data <br>processing. In digital systems, a <i>register transfer</i> operation is a basic operation that con-<br>sists of a transfer of binary information from one set of registers into another set of <br>registers. The transfer may be direct, from one register to another, or may pass through <br>dataprocessing circuits to perform an operation.  Figure   1.1   illustrates the transfer of infor-<br>mation among registers and demonstrates pictorially the transfer of binary information <br>from a keyboard into a register in the memory unit. The input unit is assumed to have a <br>keyboard, a control circuit, and an input register. Each time a key is struck, the control <br>circuit enters an equivalent eightbit alphanumeric character code into the input register. <br>We shall assume that the code used is the ASCII code with an oddparity bit. The informa-<br>tion from the input register is transferred into the eight least significant cells of a processor <br>register. After every transfer, the input register is cleared to enable the control to insert a <br>new eightbit code when the keyboard is struck again. Each eightbit character transferred <br>to the processor register is preceded by a shift of the previous character to the next eight <br>cells on its left. When a transfer of four characters is completed, the processor register is <br>full, and its contents are transferred into a memory  register. The content stored in the <br>
MEMORY UNIT<br>
<i>J</i><br>
<i>O</i><br>
<i>H</i><br>
<i>N</i><br>
Memory<br>
01001010010011111100100011001110<br>
Register<br>
PROCESSOR UNIT<br>
Processor<br>
8 cells<br>
8 cells<br>
8 cells<br>
8 cells<br>
Register<br>
INPUT UNIT<br>
Input<br>
8 cells<br>
Register<br>
<i>J</i><br>
<i>O</i><br>
Keyboard<br>
CONTROL<br>
<i>H</i><br>
<i>N</i><br>
<b> <br>FIGURE 1.1 <br> <br>Transfer of information among registers  </b><br>
<hr>
<A name=47></a><b>Section 1.8  Binary Storage and Registers    29</b><br>
memory register shown in  Fig.   1.1   came from the transfer of the characters "J," "O," "H," <br>and "N" after the four appropriate keys were struck. <br>
 <br>To process discrete quantities of information in binary form, a computer must be <br>
provided with devices that hold the data to be processed and with circuit elements that <br>manipulate individual bits of information.  <b>The device most commonly used for holding <br>data is a register.</b>  Binary variables are manipulated by means of digital logic circuits. <br> <br>Figure   1.2   illustrates the process of adding two 10bit binary numbers. The memory unit, <br>which normally consists of millions of registers, is shown with only three of its registers. <br>The part of the processor unit shown consists of three registers--<i>R1</i>,  <i>R2</i>, and <i>R3</i>--<br>together with digital logic circuits that manipulate the bits of <i>R1</i> and <i>R2</i> and transfer into <br><i>R3</i> a binary number equal to their arithmetic sum. Memory registers store information <br>and are incapable of processing the two operands. However, the information stored in <br>memory can be transferred to processor registers, and the results obtained in processor <br>registers can be transferred back into a memory register for storage until needed again. <br>The diagram shows the contents of two operands transferred from two memory registers <br>
MEMORY UNIT<br>
Sum<br>
0 0 0 0 0 0 0 0 0 0<br>
Operand 1<br>
0 0 1 1 1 0 0 0 0 1<br>
Operand 2<br>
0 0 0 1 0 0 0 0 1 0<br>
0 0 0 1 0 0 0 0 1 0 R1<br>
Digital logic<br>
circuits for<br>
0 1 0 0 1 0 0 0 1 1 R3<br>
binary addition<br>
0 0 1 1 1 0 0 0 0 1 R2<br>
PROCESSOR UNIT<br>
<b> <br>FIGURE 1.2   <br> <br>Example of binary information processing  </b><br>
<hr>
<A name=48></a><b>30    Chapter 1  Digital Systems and Binary Numbers</b><br>
into <i>R1</i> and <i>R2</i>. The digital logic circuits produce the sum, which is transferred to register <br><i>R3</i>. The contents of <i>R3</i> can now be transferred back to one of the memory registers. <br>
 <br>The last two examples demonstrated the informationflow capabilities of a digital <br>
system in a simple manner. The registers of the system are the basic elements for storing <br>and holding the binary information. Digital logic circuits process the binary information <br>stored in the registers. Digital logic circuits and registers are covered in Chapters 2 <br>through 6. The memory unit is explained in  Chapter   7 . The description of register oper-<br>ations at the register transfer level and the design of digital systems are covered in <br> Chapter    8   .   <br>
<b> <br>1 . 9       B I N A R Y   L O G I C </b><br>
 <br>Binary logic deals with variables that take on two discrete values and with operations <br>that assume logical meaning. The two values the variables assume may be called by dif-<br>ferent names (<i>true</i> and <i>false,</i> <i>yes</i> and <i>no</i>, etc.), but for our purpose, it is convenient to <br>think in terms of bits and assign the values 1 and 0. The binary logic introduced in this <br>section is equivalent to an algebra called Boolean algebra. The formal presentation of <br>Boolean algebra is covered in more detail in  Chapter   2  . The purpose of this section is <br>to introduce Boolean algebra in a heuristic manner and relate it to digital logic circuits <br>and binary signals. <br>
<b> <br>Definition of Binary Logic </b><br>
 <br>Binary logic consists of binary variables and a set of logical operations. The variables are <br>designated by letters of the alphabet, such as <i>A</i>,<i> B</i>,<i> C</i>,<i> x</i>,<i> y</i>,<i> z</i>, etc., with each variable hav-<br>ing two and only two distinct possible values: 1 and 0. There are three basic logical oper-<br>ations: AND, OR, and NOT. Each operation produces a binary result, denoted by <i>z</i>. <br>
 <br><b> 1. </b><br>
 <br>AND: This operation is represented by a dot or by the absence of an operator. For <br>example,     <i>x </i># <i>y </i>= <i>z</i> or  <i>xy </i>= <i>z</i>     is  read  "<i>x</i> AND <i>y</i> is equal to <i>z</i>." The logical operation <br>AND is interpreted to mean that   <i>z </i>= 1  if and only if   <i>x </i>= 1     and     <i>y </i>= 1;     otherwise <br> <br><i>z </i>= 0.     (Remember  that  <i>x</i>, <i>y</i>, and <i>z</i> are binary variables and can be equal either to <br>1 or 0, and nothing else.) The result of the operation <i>x </i># <i>y</i> is <i>z</i>.  <br>
 <br><b> 2. </b><br>
 <br>OR: This operation is represented by a plus sign. For example,   <i>x </i>+ <i>y </i>= <i>z</i>     is  read <br>"<i>x</i> OR <i>y</i> is equal to <i>z</i>," meaning that   <i>z </i>= 1 if  <i>x </i>= 1 or if  <i>y </i>= 1     or  if  both     <i>x </i>= 1    <br>and     <i>y </i>= 1.     If  both     <i>x </i>= 0     and     <i>y </i>= 0,     then     <i>z </i>= 0. <br>
 <br><b> 3. </b><br>
 <br>NOT: This operation is represented by a prime (sometimes by an overbar). For <br>example,     <i>x </i>= <i>z</i>     (or     <i>x </i>= <i>z</i>   )  is  read  "not  <i>x</i> is equal to <i>z</i>," meaning that <i>z</i> is what <i>x</i> <br>is not. In other words, if   <i>x </i>= 1,     then     <i>z </i>= 0,     but  if     <i>x </i>= 0,     then     <i>z </i>= 1.     The  NOT <br>operation is also referred to as the complement operation, since it changes a 1 to <br>0 and a 0 to 1, i.e., the result of complementing 1 is 0, and vice versa. <br>
 <br>Binary logic resembles binary arithmetic, and the operations AND and OR have <br>
similarities to multiplication and addition, respectively. In fact, the symbols used for <br>
<hr>
<A name=49></a><b>Section 1.9  Binary Logic    31</b><br>
<b> <br>Table 1.8 <br><i> <br>Truth Tables of Logical Operations </b></i><br>
<i> <br></i><b>AND </b><br>
<i> <br></i><b>OR </b><br>
<i> <br></i><b>NOT </b><br>
<i> <br>x </i><br>
<i> <br>y   x </i># <i>y    </i><br>
<i>  x  </i><br>
<i>  y  </i><br>
<i>  x  +  y  </i><br>
<i>  x  </i><br>
<i> x  </i><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
  <br>
  <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
  <br>
  <br>
AND and OR are the same as those used for multiplication and addition. However, <br><b>binary logic should not be confused with binary arithmetic.</b> One should realize that an <br>arithmetic variable designates a number that may consist of many digits. A logic vari-<br>able is always either 1 or 0. For example, in binary arithmetic, we have   1 + 1 = 10     (read <br>"one plus one is equal to 2"), whereas in binary logic, we have   1 + 1 = 1     (read  "one <br>OR one is equal to one"). <br>
 <br>For each combination of the values of <i>x</i> and <i>y</i>, there is a value of <i>z</i> specified by the <br>
definition of the logical operation. Definitions of logical operations may be listed in a <br>compact form called <i>truth tables</i>. A truth table is a table of all possible combinations of <br>the variables, showing the relation between the values that the variables may take and <br>the result of the operation. The truth tables for the operations AND and OR with vari-<br>ables <i>x</i> and <i>y</i> are obtained by listing all possible values that the variables may have when <br>combined in pairs. For each combination, the result of the operation is then listed in a <br>separate row. The truth tables for AND, OR, and NOT are given in  Table   1.8  . These <br>tables clearly demonstrate the definition of the operations. <br>
<b> <br>Logic Gates </b><br>
 <br>Logic gates are electronic circuits that operate on one or more input signals to pro-<br>duce an output signal. Electrical signals such as voltages or currents exist as analog <br>signals having values over a given continuous range, say, 0 to 3 V, but in a digital <br>system these voltages are interpreted to be either of two recognizable values, 0 or 1. <br>Voltageoperated logic circuits respond to two separate voltage levels that represent a <br>binary variable equal to logic 1 or logic 0. For example, a particular digital system may <br>define logic 0 as a signal equal to 0 V and logic 1 as a signal equal to 3 V. In practice, <br>each voltage level has an acceptable range, as shown in  Fig.   1.3  . The input terminals of <br>digital circuits accept binary signals within the allowable range and respond at the <br>output terminals with binary signals that fall within the specified range. The intermedi-<br>ate region between the allowed regions is crossed only during a state transition. Any <br>desired information for computing or control can be operated on by passing binary <br>signals through various combinations of logic gates, with each signal representing a <br>particular binary variable. When the physical signal is in a particular range it is inter-<br>preted to be either a 0 or a 1. <br>
<hr>
<A name=50></a><b>32    Chapter 1  Digital Systems and Binary Numbers</b><br>
Volts<br>
3<br>
Signal<br>
range for<br>
logic 1<br>
2<br>
Transition occurs<br>
between these limits<br>
1<br>
Signal<br>
range for<br>
logic 0<br>
0<br>
<b> <br>FIGURE 1.3   <br> <br>Signal levels for binary logic values  </b><br>
<i>x</i><br>
<i>z</i><br>
<i> x  </i> <i>y</i><br>
<i>x</i><br>
<i>z</i><br>
<i> x  y</i><br>
<i>x</i><br>
<i>x</i><br>
<i>y</i><br>
<i>y</i><br>
(a) Two-input AND gate<br>
(b) Two-input OR gate<br>
(c) NOT gate or inverter<br>
<b> <br>FIGURE 1.4   <br> <br>Symbols for digital logic circuits  </b><br>
 <br>The graphic symbols used to designate the three types of gates are shown in  Fig.   1.4  . <br>
The gates are blocks of hardware that produce the equivalent of logic1 or logic0 output <br>signals if input logic requirements are satisfied. The input signals <i>x</i> and <i>y</i> in the AND and <br>OR gates may exist in one of four possible states: 00, 10, 11, or 01. These input signals <br>are shown in  Fig.   1.5   together with the corresponding output signal for each gate. The <br>timing diagrams illustrate the idealized response of each gate to the four input signal <br>combinations. The horizontal axis of the timing diagram represents the time, and the <br>vertical axis shows the signal as it changes between the two possible voltage levels. In <br>reality, the transitions between logic values occur quickly, but not instantaneously. The <br>low level represents logic 0, the high level logic 1. The AND gate responds with a logic <br>1 output signal when both input signals are logic 1. The OR gate responds with a logic <br>1 output signal if any input signal is logic 1. The NOT gate is commonly referred to as <br>an inverter. The reason for this name is apparent from the signal response in the timing <br>diagram, which shows that the output signal inverts the logic sense of the input signal. <br>
<hr>
<A name=51></a><b>Problems    33</b><br>
<i>x</i><br>
0<br>
1<br>
1<br>
0<br>
0<br>
<i>y</i><br>
0<br>
0<br>
1<br>
1<br>
0<br>
AND: <i>x </i> <i>y</i><br>
0<br>
0<br>
1<br>
0<br>
0<br>
OR: <i>x</i><br>
<i> y</i><br>
0<br>
1<br>
1<br>
1<br>
0<br>
NOT: <i>x</i><br>
1<br>
0<br>
0<br>
1<br>
1<br>
<b> <br>FIGURE 1.5   <br> <br>Input�output signals for gates  </b><br>
<i>A</i><br>
<i>A</i><br>
<i>F</i><br>
<i> ABC</i><br>
<i>G</i><br>
<i> A   B   C   D</i><br>
<i>B</i><br>
<i>B</i><br>
<i>C</i><br>
<i>C</i><br>
<i>D</i><br>
(a) Three-input AND gate<br>
(b) Four-input OR gate<br>
<b> <br>FIGURE 1.6   <br> <br>Gates with multiple inputs  </b><br>
 <br>AND and OR gates may have more than two inputs. An AND gate with three inputs <br>
and an OR gate with four inputs are shown in  Fig.   1.6  . The threeinput AND gate <br>responds with logic 1 output if all three inputs are logic 1. The output produces logic 0 <br>if any input is logic 0. The fourinput OR gate responds with logic 1 if any input is logic <br>1; its output becomes logic 0 only when all inputs are logic 0. <br>
<b> <br>P R O B L E M S </b><br>
 <br>
(Answers to problems marked with <b>*</b> appear at the end of the text.)  <br>
 <br><b> 1.1 </b><br>
 <br>List the octal and hexadecimal numbers from 16 to 32. Using A and B for the last two <br>digits, list the numbers from 8 to 28 in base 12. <br>
 <br><b> 1.2*  </b> What is the exact number of bytes in a system that contains (a) 32K bytes, (b) 64M bytes, <br>
and (c) 6.4G bytes?  <br>
 <br><b> 1.3 </b><br>
 <br>Convert the following numbers with the indicated bases to decimal: <br>
 <br>
(a)   <b>*</b>   (4310) 5    <br>
  (b)   *   (198) 12 <br>
   <br>
(c)    (435) 8    <br>
  (d)    (345) 6 <br>
 <br><b> 1.4 </b><br>
 <br>What is the largest binary number that can be expressed with 16 bits? What are the equiv-<br>alent decimal and hexadecimal numbers?  <br>
 <br><b> 1.5*  </b> Determine the base of the numbers in each case for the following operations to be correct: <br>
(a) 14/2 = 5 <br>
(b)  54/4 = 13 <br>
(c)  24 + 17 =  40.   <br>
 <br><b> 1.6*  </b> The solutions to the quadratic equation  <i>x</i> 2 - 11x + 22 = 0 are  <i>x</i> = 3 and  <i>x</i> = 6. What is the <br>
base of the numbers?  <br>
<hr>
<A name=52></a><b>34    Chapter 1  Digital Systems and Binary Numbers</b><br>
 <br><b> 1.7*  </b> Convert the hexadecimal number 64CD to binary, and then convert it from binary to octal. <br>
 <br><b> 1.8 </b><br>
 <br>Convert the decimal number 431 to binary in two ways: (a) convert directly to binary; <br>(b) convert first to hexadecimal and then from hexadecimal to binary. Which method is faster? <br>
 <br><b> 1.9 </b><br>
 <br>Express the following numbers in decimal: <br>
 <br>
(a)   *   (10110.0101) 2      <br>
(b)   *   (16.5) 16 <br>
   <br>
(c)  * (26.24) <br>
8        <br>
(d)    (DADA.B) 16 <br>
   <br>
(e)    (1010.1101) 2 <br>
 <br><b> 1.10 </b><br>
 <br>Convert the following binary numbers to hexadecimal and to decimal: (a) 1.10010, <br>(b) 110.010. Explain why the decimal answer in (b) is 4 times that in (a). <br>
 <br><b> 1.11 </b><br>
 <br>Perform the following division in binary: 111011 � 101. <br>
 <br><b> 1.12* </b> Add and multiply the following numbers without converting them to decimal. <br> <br>
(a)   Binary numbers 1011 and 101. <br>
   <br>
(b)    Hexadecimal  numbers  2E  and  34.     <br>
 <br><b> 1.13 </b><br>
 <br>Do the following conversion problems: <br>
 <br>
(a)   Convert decimal 27.315 to binary. <br>
 <br>
(b)   Calculate the binary equivalent of 2/3 out to eight places. Then convert from binary to <br>
decimal. How close is the result to 2/3?  <br>
 <br>
(c)   Convert the binary result in (b) into hexadecimal. Then convert the result to decimal. <br>
Is the answer the same?  <br>
 <br><b> 1.14 </b><br>
 <br>Obtain the 1's and 2's complements of the following binary numbers: <br>
  <br>
(a)  00010000 <br>
(b)  00000000<br>
 (c) <br>
11011010 <br>
(d) <br>
10101010<br>
 (e) <br>
10000101 <br>
(f)  11111111.   <br>
 <br><b> 1.15 </b><br>
 <br>Find the 9's and the 10's complement of the following decimal numbers: <br>
 <br>
(a)  25,478,036 <br>
(b)  63, 325, 600 <br>
 <br>
(c) 25,000,000 <br>
(d)  00,000,000.   <br>
 <br><b> 1.16 </b><br>
    (a)    Find  the  16's  complement  of  C3DF.  <br>
   <br>
(b)    Convert  C3DF  to  binary.  <br>
 <br>
(c)   Find the 2's complement of the result in (b). <br>
 <br>
(d)   Convert the answer in (c) to hexadecimal and compare with the answer in (a). <br>
 <br><b> 1.17 </b><br>
 <br>Perform subtraction on the given unsigned numbers using the 10's complement of the <br>subtrahend. Where the result should be negative, find its 10's complement and affix a minus <br>sign. Verify your answers. <br>
  <br>
(a)  4,637  - 2,579 <br>
(b)  125 - 1,800<br>
 (c) <br>
2,043 <br>
- 4,361 <br>
(d)  1,631 -  745   <br>
 <br><b> 1.18 </b><br>
 <br>Perform subtraction on the given unsigned binary numbers using the 2's complement of the <br>subtrahend. Where the result should be negative, find its 2's complement and affix a minus sign. <br>
  <br>
(a)  10011  - 10010 <br>
(b)  100010 - 100110<br>
 (c) <br>
1001 <br>
- 110101 <br>
(d)  101000 -  10101   <br>
 <br><b> 1.19* </b> The following decimal numbers are shown in signmagnitude form: +9,286 and +801. <br>
 <br>Convert them to signed-10'scomplement form and perform the following operations <br>(note that the sum is +10,627 and requires five digits and a sign). <br>
 <br>
(a)<b>  </b> (+9,286) + (+801)    <b> </b><br>
(b)<b>  </b> (+9,286) + (-801)  <br>
 <br>
(c)<b>  </b> (-9,286) + (+801)    <b> </b><br>
(d)<b>  </b> (-9,286) + (-801)     <br>
<hr>
<A name=53></a><b>Problems    35</b><br>
 <br><b> 1.20 </b><br>
  Convert  decimal  +49 and +29 to binary, using the signed2'scomplement representation <br>and enough digits to accommodate the numbers. Then perform the binary equivalent of <br>(+29) + (-49), (-29) + (+49), and (-29) + (-49). Convert the answers back to decimal and <br>verify that they are correct. <br>
 <br><b> 1.21 </b><br>
 <br>If the numbers (+9,742) 10  and (+641) 10  are in signed magnitude format, their sum is (+10,383) 10 <br>and requires five digits and a sign. Convert the numbers to signed-10'scomplement form and <br>find the following sums: <br>
 <br>
(a)<b>  </b> (+9,742) + (+641)    <b> </b><br>
(b)<b>  </b> (+9,742) + (-641)  <br>
 <br>
(c)<b>  </b> (-9,742) + (+641)    <b> </b><br>
(d)<b>  </b> (-9,742) + (-641)     <br>
 <br><b> 1.22 </b><br>
 <br>Convert decimal 6,514 to both BCD and ASCII codes. For ASCII, an even parity bit is to <br>be appended at the left. <br>
 <br><b> 1.23 </b><br>
 <br>Represent the unsigned decimal numbers 791 and 658 in BCD, and then show the steps <br>necessary to form their sum. <br>
 <br><b> 1.24 </b><br>
 <br>Formulate a weighted binary code for the decimal digits, using the following weights: <br>
 <br>
(a)   <b>*</b>  6, 3, 1, 1  <br>
 <br>
(b)<b>  </b>  6,  4,  2,  1     <br>
 <br><b> 1.25 </b><br>
 <br>Represent the decimal number 6,248 in (a) BCD, (b) excess3 code, (c) 2421 code, and <br>(d) a 6311 code. <br>
 <br><b> 1.26 </b><br>
 <br>Find the 9's complement of decimal 6,248 and express it in 2421 code. Show that the result <br>is the 1's complement of the answer to (c) in CR_PROBlem 1.25. This demonstrates that <br>the 2421 code is selfcomplementing. <br>
 <br><b> 1.27 </b><br>
 <br>Assign a binary code in some orderly manner to the 52 playing cards. Use the minimum <br>number of bits. <br>
 <br><b> 1.28 </b><br>
 <br>Write the expression "G. Boole" in ASCII, using an eightbit code. Include the period and <br>the space. Treat the leftmost bit of each character as a parity bit. Each eightbit code should <br>have odd parity. (George Boole was a 19thcentury mathematician. Boolean algebra, <br>introduced in the next chapter, bears his name.)  <br>
 <br><b> 1.29* </b> Decode the following ASCII code: <br> <br>
 <br>1010011 1110100 1100101 1110110 1100101 0100000 1001010 1101111 1100010  1110011.   <br>
 <br><b> 1.30 </b><br>
 <br>The following is a string of ASCII characters whose bit patterns have been converted into <br>hexadecimal for compactness: 73 F4 E5 76 E5 4A EF 62 73. Of the eight bits in each pair <br>of digits, the leftmost is a parity bit. The remaining bits are the ASCII code. <br>
 <br>
(a)<b>  </b> Convert the string to bit form and decode the ASCII. <br>
 <br>
(b)<b>  </b> Determine the parity used: odd or even?  <br>
 <br><b> 1.31* </b> How many printing characters are there in ASCII? How many of them are special char-<br>
acters (not letters or numerals)?  <br>
 <br><b> 1.32* </b> What bit must be complemented to change an ASCII letter from capital to lowercase and <br>
vice  versa?   <br>
 <br><b> 1.33* </b> The state of a 12bit register is 100010010111. What is its content if it represents <br> <br>
(a)<b>  </b> Three decimal digits in BCD?  <br>
 <br>
(b)<b>  </b> Three decimal digits in the excess3 code?  <br>
 <br>
(c)<b>  </b> Three decimal digits in the 8421 code?  <br>
 <br>
(d)<b>  </b>  A  binary  number?     <br>
<hr>
<A name=54></a><b>36    Chapter 1  Digital Systems and Binary Numbers</b><br>
 <br><b> 1.34 </b><br>
 <br>List the ASCII code for the 10 decimal digits with an even parity bit in the leftmost <br>position.   <br>
 <br><b> 1.35 </b><br>
 <br>By means of a timing diagram similar to  Fig.   1.5  , show the signals of the outputs f and g in <br> <br>Fig.   P1.35   as functions of the three inputs a, b, and c. Use all eight possible combinations <br>of a, b, and c. <br>
a b c<br>
f<br>
g<br>
<b> <br>FIGURE P1.35   </b><br>
 <br> <br><b> 1.36 </b><br>
 <br>By means of a timing diagram similar to  Fig.   1.5  , show the signals of the outputs f and g in <br> <br>Fig.   P1.36   as functions of the two inputs a and b. Use all four possible combinations of a <br>and b. <br>
a<br>
b<br>
f<br>
g<br>
<b> <br>FIGURE P1.36   </b><br>
<b> <br></b> <br><b>R E F E R E N C E S </b><br>
 <br><b> 1. </b><br>
<b> </b><br>
C avanagh,<b> </b> J. J. 1984.<i> Digital Computer Arithmetic.</i> New York: McGrawHill. <br>
 <br><b> 2. </b><br>
<b> </b><br>
M ano,  M. M. 1988. <i>Computer Engineering: Hardware Design</i>. Englewood Cliffs, NJ: <br> PrenticeHall. <br>
 <br>
 <br><b>3. </b><br>
 N elson,<b> </b>V. P., H. T. N agle,  J. D. I rwin,  and B. D. C arroll . 1997. <i>Digital Logic Circuit <br>Analysis and Design.</i> Upper Saddle River, NJ: Prentice Hall. <br>
 <br>
 <br><b>4. </b><br>
 S chmid,<b> </b> H. 1974. <i>Decimal Computation</i>. New York: John Wiley. <br>
 <br>
 <br><b>5.  </b><br>
Katz, R. H. and Borriello, G.  2004. <i>Contemporary Logic Design</i>,  2nd ed. Upper Saddle <br>River, NJ:  PrenticeHall. <br>
<hr>
<A name=55></a><b>Web Search Topics    37</b><br>
<b> <br>W E B   S E A R C H   T O P I C S </b><br>
  <br>
 <br>
  BCD  code  <br>
 <br>
 <br>
  ASCII  <br>
 <br>
 <br>
  Storage  register  <br>
 <br>
 <br>
  Binary  logic  <br>
 <br>
 <br>
  BCD  addition  <br>
 <br>
 <br>
  Binary  codes  <br>
 <br>
 <br>
  Binary  numbers  <br>
 <br>
 <br>
  Excess3  code      <br>
<hr>
<A name=56></a> <br>Chapter 2 <br>
<b> <br>Boolean Algebra and Logic Gates </b> <br>
<b> <br>2 . 1       IN T R O D U C T I O N </b><br>
 <br>Because binary logic is used in all of today's digital computers and devices, the cost of <br>the circuits that implement it is an important factor addressed by designers--be they <br>computer engineers, electrical engineers, or computer scientists. Finding simpler and <br>cheaper, but equivalent, realizations of a circuit can reap huge payoffs in reducing the <br>overall cost of the design. Mathematical methods that simplify circuits rely primarily on <br>Boolean algebra. Therefore, this chapter provides a basic vocabulary and a brief founda-<br>tion in Boolean algebra that will enable you to optimize simple circuits and to under-<br>stand the purpose of algorithms used by software tools to optimize complex circuits <br>involving millions of logic gates. <br>
<b> <br>2 . 2       B A S I C   D E F I N I T I O N S </b><br>
 <br>Boolean algebra, like any other deductive mathematical system, may be defined with a <br>set of elements, a set of operators, and a number of unproved axioms or postulates. A <i>set</i> <br>of elements is any collection of objects, usually having a common property. If <i>S</i> is a set, <br>and<i> x </i>and<i> y </i>are certain objects, then the notation   <i>x </i>H <i>S</i>     means  that<i> x </i>is a member of the <br>set <i>S</i> and   <i>y </i>x <i>S</i>     means  that  <i>y</i> is not an element of <i>S</i>. A set with a denumerable number <br>of elements is specified by braces:   <i>A </i>= {1, 2, 3, 4}  indicates that the elements of set <i>A</i> <br>are the numbers 1, 2, 3, and 4. A <i>binary operator</i> defined on a set <i>S</i> of elements is a rule <br>that assigns, to each pair of elements from <i>S</i>, a unique element from <i>S</i>. As an example, <br>consider the relation   <i>a </i>* <i>b </i>= <i>c</i>.      We  say  that     *  is a binary operator if it specifies a rule <br>for finding <i>c</i> from the pair (<i>a, b</i>) and also if   <i>a</i>, <i>b</i>, <i>c </i>H <i>S</i>.     However,     *   is not a binary  operator <br>if     <i>a</i>, <i>b </i>H <i>S</i>,     and  if     <i>c </i>x <i>S</i>.  <br>
<b>38</b><br>
<hr>
<A name=57></a><b>Section 2.2  Basic Definitions    39</b><br>
 <br>The postulates of a mathematical system form the basic assumptions from which it <br>
is possible to deduce the rules, theorems, and properties of the system. The most com-<br>mon postulates used to formulate various algebraic structures are as follows: <br>
 <br><b> 1. </b><br>
 <br><i>Closure.</i> A set <i>S</i> is closed with respect to a binary operator if, for every pair of <br>elements of <i>S</i>, the binary operator specifies a rule for obtaining a unique element <br>of <i>S</i>. For example, the set of natural numbers   <i>N </i>= {1, 2, 3, 4, c}     is  closed  with <br>respect to the binary operator   +  by the rules of arithmetic addition, since, for any <br> <br><i>a</i>, <i>b </i>H <i>N</i>,  there is a unique   <i>c </i>H <i>N</i>     such  that     <i>a </i>+ <i>b </i>= <i>c</i>. The set of natural numbers <br>is  <i>not</i> closed with respect to the binary operator   -   by the rules of arithmetic <br>subtraction, because   2 - 3 = -1     and  2,     3 H <i>N</i>,     but     (-1) x <i>N</i>.  <br>
 <br><b> 2. </b><br>
 <br><i>Associative law.</i> A binary operator   *     on  a  set  <i>S</i> is said to be associative whenever <br>
 <br>(<i>x </i>* <i>y</i>) * <i>z </i>= <i>x </i>* (<i>y </i>* <i>z</i>) for all <i>x</i>, <i>y</i>, <i>z</i>, H <i>S </i> <br>
 <br><b> 3. </b><br>
 <br><i>Commutative law.</i> A binary operator   *     on  a  set  <i>S</i> is said to be commutative when-<br>ever <br>
 <i>x </i>* <i>y </i>= <i>y </i>* <i>x</i> for all <i>x</i>, <i>y </i>H <i>S </i> <br>
 <br><b> 4. </b><br>
 <br><i>Identity element.</i> A set <i>S</i> is said to have an identity element with respect to a binary <br>operation      *      on  <i>S</i> if there exists an element   <i>e </i>H <i>S</i>  with the property that <br>
 <br><i>e </i>* <i>x </i>= <i>x </i>* <i>e </i>= <i>x</i> for every <i>x </i>H <i>S </i> <br>
 <br>
  <i> Example:  </i>The element 0 is an identity element with respect to the binary operator <br>
 +   on the set of integers   <i>I </i>= { c, -3, -2, -1, 0, 1, 2, 3, c},     since <br>
 <i>x </i>+ 0 = 0 + <i>x </i>= <i>x</i> for any <i>x </i>H <i>I </i> <br>
 <br>
   The set of natural numbers, <i>N</i>, has no identity element, since 0 is excluded from the set. <br>
 <br><b> 5. </b><br>
 <br><i>Inverse.</i> A set <i>S</i> having the identity element <i>e</i> with respect to a binary operator   * <br>is said to have an inverse whenever, for every   <i>x </i>H <i>S</i>,  there exists an element   <i>y </i>H <i>S</i> <br>such that <br>
 <br><i>x </i>* <i>y </i>= <i>e </i> <br>
 <br>
   <i>Example: </i>In the set of integers, <i>I</i>, and the operator   +,     with     <i>e </i>= 0,     the  inverse  of <br>
an element <i>a</i> is   ( -<i>a</i>),     since     <i>a </i>+ (-<i>a</i>) = 0. <br>
 <br><b> 6. </b><br>
 <br><i>Distributive law. </i>If     *     and      #   are two binary operators on a set <i>S</i>,     *  is said to be dis-<br>tributive over   #      whenever <br>
 <i>x </i>* (<i>y </i># <i>z</i>) = (<i>x </i>* <i>y</i>) # (<i>x </i>* <i>z</i>) <br>
 A  <i>field</i> is an example of an algebraic structure. A field is a set of elements, together with <br>two binary operators, each having properties 1 through 5 and both operators combining <br>to give property 6. The set of real numbers, together with the binary operators   +      and      # ,    <br>
<hr>
<A name=58></a><b>40    Chapter 2  Boolean Algebra and Logic Gates</b><br>
forms the field of real numbers. The field of real numbers is the basis for arithmetic and <br>ordinary algebra. The operators and postulates have the following meanings: <br>
 <br>
     The  binary  operator      +      defines  addition.  <br>
 <br>
   The additive identity is 0. <br>
 <br>
   The additive inverse defines subtraction. <br>
 <br>
    The  binary  operator      #      defines  multiplication.  <br>
 <br>
   The multiplicative identity is 1. <br>
 <br>
   For  <i>a</i><br>
0,  the multiplicative inverse of   <i>a </i>= 1&gt;<i>a</i>     defines  division  (i.e.,     <i>a </i># 1&gt;<i>a </i>= 1 ). <br>
 <br>
   The only distributive law applicable is that of   #      over      +: <br>
 <br>
 <br>
 <br><i>a </i># (<i>b </i>+ <i>c</i>) = (<i>a </i># <i>b</i>) + (<i>a </i># <i>c</i>) <br>
<b> <br>2 . 3       A X I O M AT I C   D E F I N I T I O N </b><br>
<b>O F   B O O L E A N   A L G E B R A </b><br>
 <br>In 1854, George Boole developed an algebraic system now called <i>Boolean algebra</i>. In <br>1938, Claude E. Shannon introduced a twovalued Boolean algebra called <i>switching <br>algebra</i> that represented the properties of bistable electrical switching circuits. For the <br>formal definition of Boolean algebra, we shall employ the postulates formulated by <br>E. V. Huntington in 1904. <br>
 <br>Boolean algebra is an algebraic structure defined by a set of elements, <i>B</i>, together <br>
with two binary operators,   +   and      # ,  provided that the following (Huntington) postulates <br>are satisfied: <br>
 <br><b> 1. </b><br>
 <br>(a)   The structure is closed with respect to the operator   +. <br>
 <br>
  (b)   The structure is closed with respect to the operator   # . <br>
 <br><b> 2. </b><br>
    (a)     The  element 0 is an identity element with respect to   +;     that  is,     <i>x </i>+ 0 = <br>
0 + <i>x </i>= <i>x </i>. <br>
   <br>
  (b)    The element 1 is an identity element with respect to   # ;     that  is,     <i>x </i># 1 = 1 # <i>x </i>= <i>x</i>. <br>
 <br><b> 3. </b><br>
    (a)    The  structure  is  commutative  with  respect  to      +;     that  is,     <i>x </i>+ <i>y </i>= <i>y </i>+ <i>x </i>. <br>
 <br>
  (b)   The structure is commutative with respect to   # ;     that  is,     <i>x </i># <i>y </i>= <i>y </i># <i>x</i>. <br>
 <br><b> 4. </b><br>
    (a)    The  operator      #      is  distributive  over      +;     that  is,     <i>x </i># (<i>y </i>+ <i>z</i>) = (<i>x </i># <i>y</i>) + (<i>x </i># <i>z</i>). <br>
   <br>
  (b)    The  operator      +      is  distributive  over      # ;     that  is,     <i>x </i>+ (<i>y </i># <i>z</i>) = (<i>x </i>+ <i>y</i>) # (<i>x </i>+ <i>z</i>). <br>
 <br><b> 5. </b><br>
  For  every  element     <i>x </i>H <i>B</i>,   there exists an element   <i>x </i>H <i>B </i>     (called  the   <i>complement</i> of <i>x</i>) <br>such that (a)   <i>x </i>+ <i>x </i>= 1    and  (b)     <i>x </i># <i>x </i>= 0. <br>
 <br><b> 6. </b><br>
 <br>There exist at least two elements   <i>x</i>, <i>y </i>H <i>B </i>     such  that     <i>x</i><br>
<i>y</i>.  <br>
 <br>Comparing Boolean algebra with arithmetic and ordinary algebra (the field of real <br>
numbers), we note the following differences: <br>
 <br><b> 1. </b><br>
 <br>Huntington postulates do not include the associative law. However, this law holds for <br>Boolean algebra and can be derived (for both operators) from the other postulates. <br>
 <br><b> 2. </b><br>
  The  distributive  law     of + over  #      (i.e.,     <i>x </i>+ (<i>y </i># <i>z</i>) = (<i>x </i>+ <i>y</i>) # (<i>x </i>+ <i>z</i>)   )  is  valid  for <br>Boolean algebra, but not for ordinary algebra. <br>
<hr>
<A name=59></a><b>Section 2.3    Axiomatic Definition of Boolean Algebra         41</b><br>
 <br><b> 3. </b><br>
 <br>Boolean algebra does not have additive or multiplicative inverses; therefore, there <br>are no subtraction or division operations. <br>
 <br><b> 4. </b><br>
 <br>Postulate 5 defines an operator called the <i>complement</i> that is not available in <br>ordinary algebra. <br>
 <br><b> 5. </b><br>
 <br>Ordinary algebra deals with the real numbers, which constitute an infinite set of <br>elements. Boolean algebra deals with the as yet undefined set of elements, <i>B</i>, but <br>in the twovalued Boolean algebra defined next (and of interest in our subse-<br>quent use of that algebra), <i>B</i> is defined as a set with only two elements, 0 and 1. <br>
 <br>Boolean algebra resembles ordinary algebra in some respects. The choice of the <br>
   <br>symbols + and #  is intentional, to facilitate Boolean algebraic manipulations by persons <br>already familiar with ordinary algebra. Although one can use some knowledge from <br>ordinary algebra to deal with Boolean algebra, the beginner must be careful not to <br>substitute the rules of ordinary algebra where they are not applicable. <br>
 <br>It is important to distinguish between the elements of the set of an algebraic structure <br>
and the variables of an algebraic system. For example, the elements of the field of real <br>numbers are numbers, whereas variables such as <i>a</i>, <i>b</i>, <i>c</i>, etc., used in ordinary algebra, <br>are symbols that <i>stand</i> <i>for</i> real numbers. Similarly, in Boolean algebra, one defines the <br>elements of the set <i>B</i>, and variables such as <i>x</i>, <i>y</i>, and <i>z</i> are merely symbols that <i>represent</i> <br>the elements. At this point, it is important to realize that, in order to have a Boolean <br>algebra, one must show that <br>
 <br><b> 1. </b><br>
 <br>the elements of the set <i>B</i>,  <br>
 <br><b> 2. </b><br>
 <br>the rules of operation for the two binary operators, and  <br>
 <br><b> 3. </b><br>
 <br>the set of elements, <i>B</i>, together with the two operators, satisfy the six Huntington <br>postulates.   <br>
 <br>One can formulate many Boolean algebras, depending on the choice of elements of <br>
<i>B</i> and the rules of operation. In our subsequent work,  <b>we deal only with a twovalued <br>Boolean</b>  <b>algebra</b>  (i.e., a Boolean algebra with only two elements). Twovalued Boolean <br>algebra has applications in set theory (the algebra of classes) and in propositional logic. <br>Our interest here is in the application of Boolean algebra to gatetype circuits commonly <br>used in digital devices and computers. <br>
<b> <br>TwoValued Boolean Algebra </b><br>
 <br>A twovalued Boolean algebra is defined on a set of two elements,   <i>B </i>= {0,  1},     with  rules <br>for the two binary   operators + and #  as shown in the following operator tables (the rule <br>for the complement operator is for verification of postulate 5): <br>
<b> <br><i>x</i> </b><br>
<i><b> <br>y </b></i><br>
<i><b> <br>x </b></i># <b><i>y </b></i><br>
<i><b> <br>x  </b></i><br>
<i><b>y </b></i><br>
<i><b> <br>x</b></i><br>
<i><b>y </b></i><br>
<i><b> <br>x  </b></i><br>
<i><b> <br>x  </b></i><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
  <br>
  <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
  <br>
  <br>
<hr>
<A name=60></a><b>42    Chapter 2  Boolean Algebra and Logic Gates</b><br>
 <br>These rules are exactly the same as the AND, OR, and NOT operations, respectively, <br>
defined in Table 1.8. We must now show that the Huntington postulates are valid for the <br>set     <i>B </i>= {0, 1}  and the two binary   operators + and # .    <br>
 <br><b> 1. </b><br>
 <br>That the structure is <i>closed</i> with respect to the two operators is obvious from the <br>tables, since the result of each operation is either 1 or 0 and   1, 0 H <i>B</i>. <br>
 <br><b> 2. </b><br>
 <br>From the tables, we see that <br>
    <br>
  (a)       0 + 0 = 0<br>
0 + 1 = 1 + 0 = 1; <br>
   <br>
  (b)       1 # 1 = 1<br>
 <br>
 <br>
1 # 0 = 0 # 1 = 0. <br>
 <br>
   This establishes the two <i>identity elements,</i> 0 for   +      and  1  for      # ,     as  defined  by <br>
postulate 2. <br>
 <br><b> 3. </b><br>
  The  <i>commutative</i> laws are obvious from the symmetry of the binary operator tables. <br>
 <br><b> 4. </b><br>
    (a)    The  <i>distributive</i> law   <i>x </i># (<i>y </i>+ <i>z</i>) = (<i>x </i># <i>y</i>) + (<i>x </i># <i>z</i>)  can be shown to hold from <br>the operator tables by forming a truth table of all possible values of <i>x</i>, <i>y</i>, and <i>z</i>. For <br>each combination, we derive   <i>x </i># (<i>y </i>+ <i>z</i>)  and show that the value is the same as the <br>value of   (<i>x </i># <i>y</i>) + (<i>x </i># <i>z</i>): <br>
<i><b> <br>x  </b></i><br>
<i><b>y  </b></i><br>
<i><b>z </b></i><br>
 <br><b><i>y </b></i><br>
<i><b> </b></i><br>
<i><b>z</b></i> <br>
 <br><b><i>x </b></i># <b>( <i>y</b></i><br>
<i><b>z</i>)</b> <br>
 <br><b><i>x </b></i># <b><i>y</b></i>   <b><i>x </b></i># <b><i>z</b></i>   <b>(<i>x </b></i># <b><i>y</i>) (<i>x </b></i># <b><i>z</i>)</b> <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
   <br>
  (b)    The  <i>distributive</i> law   of + over # can  be shown to hold by means of a truth table <br>
similar to the one in part (a). <br>
 <br><b> 5. </b><br>
 <br>From the complement table, it is easily shown that <br>
    <br>
  (a)       <i>x </i>+ <i>x </i>= 1,     since     0 + 0 = 0 + 1 = 1     and     1 + 1 = 1 + 0 = 1. <br>
   <br>
  (b)       <i>x </i># <i>x </i>= 0,     since     0 # 0 = 0 # 1 = 0     and     1 # 1 = 1 # 0 = 0. <br>
 <br>
   Thus, postulate 1 is verified. <br>
 <br><b> 6. </b><br>
 <br>Postulate 6 is satisfied because the twovalued Boolean algebra has two elements, <br>1 and 0, with   1<br>
0. <br>
 <br>We have just established a twovalued Boolean algebra having a set of two elements, <br>
1 and 0, two binary operators with rules equivalent to the AND and OR operations, and <br>a complement operator equivalent to the NOT operator. Thus, Boolean algebra has been <br>defined in a formal mathematical manner and has been shown to be equivalent to the <br>binary logic presented heuristically in Section 1.9. The heuristic presentation is helpful <br>in understanding the application of Boolean algebra to gatetype circuits. The formal <br>
<hr>
<A name=61></a><b>Section 2.4    Basic Theorems and Properties of Boolean Algebra        43</b><br>
presentation is necessary for developing the theorems and properties of the algebraic <br>system. The twovalued Boolean algebra defined in this section is also called "switching <br>algebra" by engineers. To emphasize the similarities between twovalued Boolean alge-<br>bra and other binary systems, that algebra was called "binary logic" in Section 1.9. From <br>here on, we shall drop the adjective "twovalued" from Boolean algebra in subsequent <br>discussions.   <br>
<b> <br>2 . 4       B A S I C   T H E O R E M S   A N D   P R O P E R T I E S </b><br>
<b>O F   B O O L E A N   A L G E B R A </b><br>
<b> <br>Duality </b><br>
 <br>In Section 2.3, the Huntington postulates were listed in pairs and designated by part <br>(a) and part (b). One part may be obtained from the other if the binary operators and <br>the identity elements are interchanged. This important property of Boolean algebra is <br>called the <i>duality principle </i>and states that every algebraic expression deducible from <br>the postulates of Boolean algebra remains valid if the operators and identity elements <br>are interchanged. In a twovalued Boolean algebra, the identity elements and the ele-<br>ments of the set <i>B</i> are the same: 1 and 0. The duality principle has many applications. If <br>the <i>dual</i> of an algebraic expression is desired, we simply interchange OR and AND <br>operators and replace 1's by 0's and 0's by 1's. <br>
<b> <br>Basic Theorems </b><br>
 <br>Table   2.1   lists six theorems of Boolean algebra and four of its postulates. The notation <br>is simplified by omitting the binary operator whenever doing so does not lead to <br>confusion. The theorems and postulates listed are the most basic relationships in Boolean <br>
<b> <br>Table 2.1 <br><i> <br>Postulates and Theorems of Boolean Algebra </b></i><br>
 Postulate  2 <br>
 (a) <br>
 <br><i>x </i>+ 0 = <i>x </i> <br>
 (b) <br>
 <i>x </i># 1 = <i>x</i> <br>
 Postulate  5 <br>
 (a) <br>
 <br><i>x </i>+ <i>x </i>= 1    <br>
 (b) <br>
 <i>x </i># <i>x </i>= 0    <br>
 Theorem  1 <br>
 (a) <br>
    <br><i>x </i>+ <i>x </i>= <i>x </i>    <br>
 (b) <br>
    <br><i>x </i># <i>x </i>= <i>x </i> <br>
 Theorem  2 <br>
 (a) <br>
 <br><i>x </i>+ 1 = 1    <br>
 (b) <br>
 <br><i>x </i># 0 = 0    <br>
 <br>Theorem 3, involution <br>
 <br>
 <br>(<i>x </i>) = <i>x </i> <br>
 <br>
 <br>
 Postulate  3,  commutative <br>
 (a) <br>
    <br><i>x </i>+ <i>y </i>= <i>y </i>+ <i>x </i>    <br>
 (b) <br>
    <br><i>x y </i>= <i>yx </i> <br>
 <br>Theorem 4, associative <br>
 <br>(a)   <i>x </i>+ (<i>y </i>+ <i>z</i>) = (<i>x </i>+ <i>y</i>) + <i>z</i> <br>
 (b) <br>
 <br><i>x </i>(<i>yz</i>) = (<i>xy</i>)<i>z</i> <br>
 <br>Postulate 4, distributive <br>
 <br>(a) <br>
 <br><i>x </i>(<i>y </i>+ <i>z</i>) = <i>xy </i>+ <i>xz</i> <br>
 (b) <br>
 <br><i>x </i>+ <i>yz </i>= (<i>x </i>+ <i>y</i>)(<i>x </i>+ <i>z</i>)    <br>
 <br>Theorem 5, DeMorgan <br>
 <br>(a) <br>
 <br>(<i>x </i>+ <i>y</i>) = <i>x y </i> <br>
 (b) <br>
 <br>(<i>x y</i>) = <i>x </i>+ <i>y </i> <br>
 Theorem  6,  absorption <br>
 (a) <br>
    <br><i>x </i>+ <i>xy </i>= <i>x </i>    <br>
 (b) <br>
 <br><i>x </i>(<i>x </i>+ <i>y</i>) = <i>x </i> <br>
<hr>
<A name=62></a><b>44    Chapter 2  Boolean Algebra and Logic Gates</b><br>
algebra. The theorems, like the postulates, are listed in pairs; each relation is the dual of <br>the one paired with it. The postulates are basic axioms of the algebraic structure and <br>need no proof. The theorems must be proven from the postulates. Proofs of the theorems <br>with one variable are presented next. At the right is listed the number of the postulate <br>which justifies that particular step of the proof. <br>
<b> <br>THEOREM 1(a):  <i> </b>x </i>+ <i>x </i>= <i>x</i>.<b><i> </b></i><br>
<b> Statement </b><br>
<b> Justification </b><br>
 <i>x </i>+ <i>x </i>= (<i>x </i>+ <i>x</i>) # 1 <br>
 postulate  2(b) <br>
               = (<i>x </i>+ <i>x</i>)(<i>x </i>+ <i>x </i>) <br>
 5(a) <br>
 <br>             = <i>x </i>+ <i>xx </i> <br>
 4(b) <br>
               = <i>x </i>+ 0 <br>
 5(b) <br>
               = <i>x</i>    <br>
 2(a) <br>
<b> <br>THEOREM 1(b):<i>  </i> </b><i>x </i># <i>x </i>= <i>x</i>.<b> </b><br>
<b> Statement </b><br>
<b> Justification </b><br>
 <i>x </i># <i>x </i>= <i>xx </i>+ 0 <br>
 postulate  2(a) <br>
 <br>
  = <i>xx </i>+ <i>xx </i> <br>
 5(b) <br>
 <br>
  = <i>x</i>(<i>x </i>+ <i>x </i>) <br>
 4(a) <br>
 <br>
  = <i>x </i># 1 <br>
 5(a) <br>
 <br>
  = <i>x</i>    <br>
 2(b) <br>
 <br>Note that theorem 1(b) is the dual of theorem 1(a) and that each step of the proof <br>
in part (b) is the dual of its counterpart in part (a). Any dual theorem can be similarly <br>derived from the proof of its corresponding theorem. <br>
<i><b> <br></i>THEOREM 2(a):<i>   </b>x </i>+ 1 = 1.<b> </b><br>
<b> Statement </b><br>
<b> Justifi cation </b><br>
 <i>x </i>+ 1 = 1 # (<i>x </i>+ 1) <br>
 postulate  2(b) <br>
             = (<i>x </i>+ <i>x </i>)(<i>x </i>+ 1) <br>
 5(a) <br>
             = <i>x </i>+ <i>x </i># 1    <br>
 4(b) <br>
             = <i>x </i>+ <i>x </i> <br>
 2(b) <br>
             = 1    <br>
 5(a) <br>
<b> <br>THEOREM 2(b):   </b><i>x </i># 0 = 0<b> </b>by duality. <br>
 <br><b>THEOREM 3:  </b> (<i>x </i>) = <i>x</i>.  From postulate 5, we have   <i>x </i>+ <i>x </i>= 1     and     <i>x </i># <i>x </i>= 0,     which <br>together define the complement of <i>x</i>. The complement of   <i>x </i>  is<i> x </i>and is also   (<i>x </i>) .    <br>
<hr>
<A name=63></a><b>Section 2.4    Basic Theorems and Properties of Boolean Algebra        45</b><br>
Therefore, since the complement is unique, we have   (<i>x </i>) = <i>x</i>.     The  theorems  involv-<br>ing two or three variables may be proven algebraically from the postulates and the <br>theorems that have already been proven. Take, for example, the absorption theorem: <br>
<b> <br>THEOREM 6(a):   </b><i>x </i>+ <i>xy </i>= <i>x</i>.<b> </b><br>
<b> Statement </b><br>
<b> Justifi cation </b><br>
 <i>x </i>+ <i>xy </i>= <i>x </i># 1 + <i>xy</i> <br>
 postulate  2(b) <br>
  = <i>x</i>(1 + <i>y</i>)    <br>
 4(a) <br>
  = <i>x</i>(<i>y </i>+ 1) <br>
 3(a) <br>
  = <i>x </i># 1    <br>
 2(a) <br>
  = <i>x</i> <br>
 2(b) <br>
<b> <br>THEOREM 6(b):   </b> <i>x</i>(<i>x </i>+ <i>y</i>) = <i>x</i>     by  duality. <br>
 <br>The theorems of Boolean algebra can be proven by means of truth tables. In truth <br>
tables, both sides of the relation are checked to see whether they yield identical results <br>for all possible combinations of the variables involved. The following truth table verifies <br>the first absorption theorem: <br>
<i><b> <br>x  </b></i><br>
<i><b>y  </b></i><br>
<i><b>xy  </b></i><br>
<i><b> <br>x</b></i><br>
<i><b>xy </b></i><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 <br>The algebraic proofs of the associative law and DeMorgan's theorem are long and will <br>
not be shown here. However, their validity is easily shown with truth tables. For example, <br>the truth table for the first DeMorgan's theorem,   (<i>x </i>+ <i>y</i>) = <i>x y </i>,     is  as  follows: <br>
<i><b> <br>x  </b></i><br>
<i><b>y  </b></i><br>
<i><b> <br>x</b></i><br>
<i><b>y    </i>(<i>x</b></i><br>
<i><b>y</i>) <i> </b></i><br>
<i><b> <br>x  </b></i><br>
<i><b> <br>y  </b></i><br>
<i><b> <br>x y  </b></i><br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
<b> <br>Operator Precedence </b><br>
 <br>The operator precedence for evaluating Boolean expressions is (1) parentheses, <br>(2) NOT, (3) AND, and (4) OR. In other words, expressions inside parentheses must be <br>evaluated before all other operations. The next operation that holds precedence is the <br>complement, and then follows the AND and, finally, the OR. As an example, consider <br>the truth table for one of DeMorgan's theorems. The left side of the expression is <br> <br>(<i>x </i>+ <i>y</i>) . Therefore, the expression inside the parentheses is evaluated first and the <br>
<hr>
<A name=64></a><b>46    Chapter 2  Boolean Algebra and Logic Gates</b><br>
result then complemented. The right side of the expression is   <i>x y </i>,     so  the  complement <br>of<i> x </i>and the complement of<i> y </i>are both evaluated first and the result is then ANDed. <br>Note that in ordinary arithmetic, the same precedence holds (except for the comple-<br>ment) when multiplication and addition are replaced by AND and OR, respectively. <br>
<b> <br>2 . 5       B O O L E A N   F U N C T I O N S </b><br>
 <br>Boolean algebra is an algebra that deals with binary variables and logic operations. A <br>Boolean function described by an algebraic expression consists of binary variables, the <br>constants 0 and 1, and the logic operation symbols. For a given value of the binary variables, <br>the function can be equal to either 1 or 0. As an example, consider the Boolean function <br>
 <br><i>F</i>1 = <i>x </i>+ <i>y z</i> <br>
 The  function     <i>F</i>1  is equal to 1 if<i> x </i>is equal to 1 or if both   <i>y </i>     and  <i>z</i> are equal to 1.   <i>F</i>1     is  equal <br>to 0 otherwise. The complement operation dictates that when   <i>y </i>= 1, <i>y </i>= 0.     Therefore, <br> <br><i>F</i>1 = 1 if  <i>x </i>= 1     or  if     <i>y </i>= 0     and     <i>z </i>= 1. A Boolean function expresses the logical rela-<br>tionship between binary variables and is evaluated by determining the binary value of <br>the expression for all possible values of the variables. <br>
 <br>A Boolean function can be represented in a truth table. The number of rows in the <br>
truth table is   2<i>n</i>,     where  <i>n</i> is the number of variables in the function. The binary combina-<br>tions for the truth table are obtained from the binary numbers by counting from 0 <br>through     2<i>n </i>- 1.      Table    2.2     shows  the  truth  table  for  the  function     <i>F</i>1.     There  are  eight  pos-<br>sible binary combinations for assigning bits to the three variables <i>x</i>, <i>y</i>, and <i>z</i>. The column <br>labeled     <i>F</i>1  contains either 0 or 1 for each of these combinations. The table shows that <br>the function is equal to 1 when   <i>x </i>= 1     or  when     <i>yz </i>= 01  and is equal to 0 otherwise. <br>
 <br>A Boolean function can be transformed from an algebraic expression into a circuit <br>
diagram composed of logic gates connected in a particular structure. The logiccircuit <br>diagram (also called a schematic) for   <i>F</i>1     is  shown  in   Fig.    2.1   . There  is  an  inverter  for  input<i> <br>y </i>to generate its complement. There is an AND gate for the term   <i>y z</i>  and an OR gate <br>
<b> <br>Table 2.2 <br><i> <br>Truth Tables for   F1  and   F2 </b></i><br>
<i><b> <br>x  </b></i><br>
<i><b>y  </b></i><br>
<i><b>z  </b></i><br>
<i><b> <br>F1 </b></i><br>
<i><b> <br>F2 </b></i><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
<hr>
<A name=65></a><b>Section 2.5  Boolean Functions    47</b><br>
<i>x</i><br>
<i>F</i>1<br>
<i>y<br>z</i><br>
<b> <br>FIGURE 2.1   <br> <br>Gate implementation of   <i>F</i>1</b><br>
<i><b>x</b></i><br>
<i><b>y z</i> </b><br>
that combines<i> x </i>with     <i>y z</i>.  In logiccircuit diagrams, the variables of the function are taken <br>as the inputs of the circuit and the binary variable   <i>F</i>1  is taken as the output of the circuit. <br>The schematic expresses the relationship between the output of the circuit and its inputs. <br>Rather than listing each combination of inputs and outputs, it indicates how to compute <br>the logic value of each output from the logic values of the inputs.  <br>
 <br>There is only one way that a Boolean function can be represented in a truth table. <br>
However, when the function is in algebraic form, it can be expressed in a variety of ways, <br>all of which have equivalent logic. The particular expression used to represent the function <br>will dictate the interconnection of gates in the logiccircuit diagram. Conversely, the inter-<br>connection of gates will dictate the logic expression. Here is a key fact that motivates our <br>use of Boolean algebra: By manipulating a Boolean expression according to the rules of <br>Boolean algebra, it is sometimes possible to obtain a simpler expression for the same <br>function and thus reduce the number of gates in the circuit and the number of inputs to <br>the gate. Designers are motivated to reduce the complexity and number of gates because <br>their effort can significantly reduce the cost of a circuit. Consider, for example, the fol-<br>lowing Boolean function: <br>
 <br><i>F</i>2 = <i>x y z </i>+ <i>x yz </i>+ <i>xy </i> <br>
 <br>A schematic of an implementation of this function with logic gates is shown in <br> Fig.   2.2   (a).  Input  variables<i> x </i>and<i> y </i>are complemented with inverters to obtain   <i>x </i> and <br> <i>y </i>. The three terms in the expression are implemented with three AND gates. The <br>OR gate forms the logical OR of the three terms. The truth table for   <i>F</i>2     is  listed  in <br> <br>Table   2.2  . The function is equal to 1 when   <i>xyz </i>= 001  or 011 or when   <i>xy </i>= 10     (irre-<br>spective of the value of <i>z</i>) and is equal to 0 otherwise. This set of conditions produces <br>four 1's and four 0's for   <i>F</i>2.     <br>
 <br>Now consider the possible simplification of the function by applying some of the <br>
identities of Boolean algebra: <br>
 <br><i>F</i>2 = <i>x y z </i>+ <i>x yz </i>+ <i>xy </i>= <i>x z</i>(<i>y </i>+ <i>y</i>) + <i>xy </i>= <i>x z </i>+ <i>xy </i> <br>
 <br>The function is reduced to only two terms and can be implemented with gates as shown <br>in  Fig.   2.2  (b). It is obvious that the circuit in (b) is simpler than the one in (a), yet both <br>implement the same function. By means of a truth table, it is possible to verify that the <br>two expressions are equivalent. The simplified expression is equal to 1 when   <i>xz </i>= 01 or <br>when     <i>xy </i>= 10. This produces the same four 1's in the truth table. Since both expressions <br>
<hr>
<A name=66></a><b>48    Chapter 2  Boolean Algebra and Logic Gates</b><br>
<i>x</i><br>
<i>y</i><br>
<i>F</i><br>
<i>z</i><br>
2<br>
(a) <i>F</i>2<br>
<i>x y z</i><br>
 <i>x yz </i> <i>xy</i><br>
<i>x</i><br>
<i>y</i><br>
<i>F</i>2<br>
<i>z</i><br>
(b) <i>F</i>2<br>
<i>xy</i><br>
 <i>x z</i><br>
<b> <br>FIGURE 2.2   <br> <br>Implementation of Boolean function   <i>F2</i>  with gates  </b><br>
produce the same truth table, they are equivalent. Therefore, the two circuits have the <br>same outputs for all possible binary combinations of inputs of the three variables. Each <br>circuit implements the same identical function, but the one with fewer gates and fewer <br>inputs to gates is preferable because it requires fewer wires and components. In general, <br>there are many equivalent representations of a logic function. Finding the most eco-<br>nomic representation of the logic is an important design task. <br>
<b> <br>Algebraic Manipulation </b><br>
 <br>When a Boolean expression is implemented with logic gates, each term requires a gate <br>and each variable within the term designates an input to the gate. We define a <i>literal</i> to <br>be a single variable within a term, in complemented or uncomplemented form. The <br>function of  Fig.   2.2  (a) has three terms and eight literals, and the one in  Fig.   2.2  (b) has <br>two terms and four literals. By reducing the number of terms, the number of literals, or <br>both in a Boolean expression, it is often possible to obtain a simpler circuit. The manip-<br>ulation of Boolean algebra consists mostly of reducing an expression for the purpose of <br>obtaining a simpler circuit. Functions of up to five variables can be simplified by the <br>map method described in the next chapter. For complex Boolean functions and many <br>
<hr>
<A name=67></a><b>Section 2.5  Boolean Functions    49</b><br>
different outputs, designers of digital circuits use computer minimization programs that <br>are capable of producing optimal circuits with millions of logic gates. The concepts intro-<br>duced in this chapter provide the framework for those tools. The only manual method <br>available is a cutandtry procedure employing the basic relations and other manipulation <br>techniques that become familiar with use, but remain, nevertheless, subject to human <br>error. The examples that follow illustrate the algebraic manipulation of Boolean algebra <br>to acquaint the reader with this important design task. <br>
<b> <br>EXAMPLE 2.1  </b><br>
 <br>Simplify the following Boolean functions to a minimum number of literals. <br>
 <br><b> 1. </b> <i>x</i>(<i>x </i>+ <i>y</i>) = <i>xx </i>+ <i>xy </i>= 0 + <i>xy </i>= <i>xy</i>. <br><b>  2.  </b><i>x </i>+ <i>x y </i>= (<i>x </i>+ <i>x </i>)(<i>x </i>+ <i>y</i>) = 1(<i>x </i>+ <i>y</i>) = <i>x </i>+ <i>y</i>.<br><b>  3.  </b>(<i>x </i>+ <i>y</i>)(<i>x </i>+ <i>y </i>) = <i>x </i>+ <i>xy </i>+ <i>xy </i>+ <i>yy </i>= <i>x</i>(1 + <i>y </i>+ <i>y </i>) = <i>x</i>.<br><b>  4.  </b><i>xy </i>+ <i>x z </i>+ <i>yz </i>= <i>xy </i>+ <i>x z </i>+ <i>yz</i>(<i>x </i>+ <i>x </i>)<br> <br>
  = <i>xy </i>+ <i>x z </i>+ <i>xyz </i>+ <i>x yz</i> <br>
 <br>
  = <i>xy</i>(1 + <i>z</i>) + <i>x z</i>(1 + <i>y</i>)    <br>
 <br>
  = <i>xy </i>+ <i>x z</i>. <br>
 <br><b> 5. </b> (<i>x </i>+ <i>y</i>)(<i>x </i>+ <i>z</i>)(<i>y </i>+ <i>z</i>) = (<i>x </i>+ <i>y</i>)(<i>x </i>+ <i>z</i>),     by  duality  from  function  4.    <br>
<br>
 <br>Functions 1 and 2 are the dual of each other and use dual expressions in correspond-<br>ing steps. An easier way to simplify function 3 is by means of postulate 4(b) from <br> Table    2.1   :     (<i>x </i>+ <i>y</i>)(<i>x </i>+ <i>y </i>) = <i>x </i>+ <i>yy </i>= <i>x</i>. The fourth function illustrates the fact that <br>an increase in the number of literals sometimes leads to a simpler final expression. <br>Function 5 is not minimized directly, but can be derived from the dual of the steps used <br>to derive function 4. Functions 4 and 5 are together known as the <i>consensus theorem</i>.  <br>
<b> <br>Complement of a Function </b><br>
 <br>The complement of a function <i>F</i> is   <i>F </i> and is obtained from an interchange of 0's for 1's <br>and 1's for 0's in the value of <i>F</i>. The complement of a function may be derived algebraically <br>through DeMorgan's theorems, listed in  Table   2.1   for two variables. DeMorgan's theo-<br>rems can be extended to three or more variables. The threevariable form of the first <br>DeMorgan's theorem is derived as follows, from postulates and theorems listed in  Table   2.1  : <br>
 (<i>A </i>+ <i>B </i>+ <i>C</i>) = (<i>A </i>+ <i>x</i>)<br>
let <i>B </i>+ <i>C </i>= <i>x</i><br>
 <br>
  = <i>A x</i><br>
        by theorem 5(a) (DeMorgan)<br>
 <br>
  = <i>A </i>(<i>B </i>+ <i>C</i>)    substitute <i>B </i>+ <i>C </i>= <i>x</i><br>
 <br>
  = <i>A </i>(<i>B C </i>)    by theorem 5(a) (DeMorgan)<br>
 <br>
  = <i>A B C</i><br>
   by theorem 4(b) (associative) <br>
<hr>
<A name=68></a><b>50    Chapter 2  Boolean Algebra and Logic Gates</b><br>
 <br>DeMorgan's theorems for any number of variables resemble the twovariable case in <br>form and can be derived by successive substitutions similar to the method used in the <br>preceding derivation. These theorems can be generalized as follows: <br>
 (<i>A </i>+ <i>B </i>+ <i>C </i>+ <i>D </i>+ g + <i>F</i>) = <i>A B C D </i>c <i>F<br></i> (<i>ABCD </i>c <i>F</i>) = <i>A </i>+ <i>B </i>+ <i>C </i>+ <i>D </i>+ g + <i>F </i> <br>
 <br>The generalized form of DeMorgan's theorems states that the complement of a func-<br>tion is obtained by interchanging AND and OR operators and complementing each <br>literal. <br>
<b> <br>EXAMPLE 2.2  </b> <br>
 <br>Find the complement of the functions   <i>F</i>1 = <i>x yz </i>+ <i>x y z</i>     and     <i>F</i>2 = <i>x</i>(<i>y z </i>+ <i>yz</i>). By <br>applying DeMorgan's theorems as many times as necessary, the complements are <br>obtained as follows: <br>
 <i>F </i>=1 = (<i>x yz </i>+ <i>x y z</i>) = (<i>x yz </i>) (<i>x y z</i>) = (<i>x </i>+ <i>y </i>+ <i>z</i>)(<i>x </i>+ <i>y </i>+ <i>z </i>)<br>
 <br>
 <i>F </i>=2 = [<i>x</i>(<i>y z </i>+ <i>yz</i>)]    = <i>x </i>+ (<i>y z </i>+ <i>yz</i>) = <i>x </i>+ (<i>y z </i>) (<i>yz</i>)<br>
 <br>
  = <i>x </i>+ (<i>y </i>+ <i>z</i>)(<i>y </i>+ <i>z </i>)<br>
 <br>
  = <i>x </i>+ <i>yz </i>+ <i>y z</i> <br>
<br>
 <br>A simpler procedure for deriving the complement of a function is to take the dual of <br>
the function and complement each literal. This method follows from the generalized <br>forms of DeMorgan's theorems. Remember that the dual of a function is obtained from <br>the interchange of AND and OR operators and 1's and 0's. <br>
<b> <br>EXAMPLE 2.3 </b><br>
 <br>Find the complement of the functions   <i>F</i>1     and     <i>F</i>2  of Example 2.2 by taking their duals <br>and complementing each literal. <br>
 <br><b> 1. </b> <i>F</i>1 = <i>x yz </i>+ <i>x y z</i>.    <br>   <br>
 <br>The dual of   <i>F</i>1 is  (<i>x </i>+ <i>y </i>+ <i>z </i>)(<i>x </i>+ <i>y </i>+ <i>z</i>). <br>
   <br>
 <br>Complement each literal:   (<i>x </i>+ <i>y </i>+ <i>z</i>)(<i>x </i>+ <i>y </i>+ <i>z </i>) = <i>F </i>=1. <br>
 <br><b> 2. </b> <i>F</i>2 = <i>x</i>(<i>y z </i>+ <i>yz</i>). <br>   <br>
 <br>The dual of   <i>F</i>2 is  <i>x </i>+ (<i>y </i>+ <i>z </i>)(<i>y </i>+ <i>z</i>). <br>
   <br>
 <br>Complement each literal:   <i>x </i>+ (<i>y </i>+ <i>z</i>)(<i>y </i>+ <i>z </i>) = <i>F </i>=2. <br>
<br>
<hr>
<A name=69></a><b>Section 2.6  Canonical and Standard Forms    51</b><br>
<b> <br>2 . 6       C A N O N I C A L   A N D   S TA N D A R D   F O R M S </b><br>
<b> <br>Minterms and Maxterms </b><br>
 <br>A binary variable may appear either in its normal form (<i>x</i>) or in its complement form   (<i>x </i>). <br>Now consider two binary variables<i> x </i>and<i> y </i>combined with an AND operation. Since each <br>variable may appear in either form, there are four possible combinations:   <i>x y </i>, <i>x y</i>, <i>xy </i>,    <br>and <i>xy</i>. Each of these four AND terms is called a <i>minterm</i>, or a <i>standard product</i>. In a <br>similar manner, <i>n</i> variables can be combined to form   2<i>n</i>     minterms.  The     2<i>n</i>     different  min-<br>terms may be determined by a method similar to the one shown in  Table   2.3   for three <br>variables. The binary numbers from 0 to   2<i>n </i>- 1  are listed under the <i>n</i> variables. Each <br>minterm is obtained from an AND term of the <i>n</i> variables, with each variable being <br>primed if the corresponding bit of the binary number is a 0 and unprimed if a 1. A symbol <br>for each minterm is also shown in the table and is of the form   <i>mj</i>,     where  the  subscript  <i>j</i> <br>denotes the decimal equivalent of the binary number of the minterm designated. <br>
 <br>In a similar fashion, <i>n</i> variables forming an OR term, with each variable being primed <br>
or unprimed, provide   2<i>n</i>     possible  combinations,  called  <i>maxterms</i>, or <i>standard sums.</i> The <br>eight maxterms for three variables, together with their symbolic designations, are listed <br>in   Table    2.3   .  Any     2<i>n</i>     maxterms  for  <i>n</i> variables may be determined similarly. It is impor-<br>tant to note that (1) each maxterm is obtained from an OR term of the <i>n</i> variables, with <br>each variable being unprimed if the corresponding bit is a 0 and primed if a 1, and (2) <br>each maxterm is the complement of its corresponding minterm and vice versa. <br>
 <br><b>A Boolean function can be expressed algebraically from a given truth table by form-</b><br>
<b>ing a minterm for each combination of the variables that produces a 1 in the function <br>and then taking the OR of all those terms.</b>  For example, the function   <i>f</i>1     in   Table    2.4     is <br>determined by expressing the combinations 001, 100, and 111 as   <i>x y z</i>, <i>xy z</i>,      and  <i>xyz</i>, <br>respectively. Since each one of these minterms results in   <i>f</i>1 = 1,     we  have <br>
 <i>f</i>1 = <i>x y z </i>+ <i>xy z </i>+ <i>xyz </i>= <i>m</i>1 + <i>m</i>4 + <i>m</i>7 <br>
<b>Table 2.3<br><i>Minterms and Maxterms for Three Binary Variables</b></i><br>
<b>Minterms</b><br>
<b>Maxterms</b><br>
<i><b>x</b></i><br>
<i><b>y</b></i><br>
<i><b>z</b></i><br>
<b>Term</b><br>
<b>Designation</b><br>
<b>Term</b><br>
<b>Designation</b><br>
0<br>
0<br>
0<br>
<i>x y z</i><br>
<i>m</i>0<br>
<i>x </i>+ <i>y </i>+ <i>z</i><br>
<i>M</i>0<br>
0<br>
0<br>
1<br>
<i>x y z</i><br>
<i>m</i>1<br>
<i>x </i>+ <i>y </i>+ <i>z</i><br>
<i>M</i>1<br>
0<br>
1<br>
0<br>
<i>x yz</i><br>
<i>m</i>2<br>
<i>x </i>+ <i>y </i>+ <i>z</i><br>
<i>M</i>2<br>
0<br>
1<br>
1<br>
<i>x yz</i><br>
<i>m</i>3<br>
<i>x </i>+ <i>y </i>+ <i>z</i><br>
<i>M</i>3<br>
1<br>
0<br>
0<br>
<i>xy z</i><br>
<i>m</i>4<br>
<i>x </i>+ <i>y </i>+ <i>z</i><br>
<i>M</i>4<br>
1<br>
0<br>
1<br>
<i>xy z</i><br>
<i>m</i>5<br>
<i>x </i>+ <i>y </i>+ <i>z</i><br>
<i>M</i>5<br>
1<br>
1<br>
0<br>
<i>xyz</i><br>
<i>m</i>6<br>
<i>x </i>+ <i>y </i>+ <i>z</i><br>
<i>M</i>6<br>
1<br>
1<br>
1<br>
<i>xyz</i><br>
<i>m</i>7<br>
<i>x </i>+ <i>y </i>+ <i>z</i><br>
<i>M</i>7<br>
<hr>
<A name=70></a><b>52    Chapter 2  Boolean Algebra and Logic Gates</b><br>
<b>Table 2.4<br><i>Functions of Three Variables</b></i><br>
<i><b>x</b></i><br>
<i><b>y</b></i><br>
<i><b>z</b></i><br>
<b>Function <i>f</i>1</b><br>
<b>Function <i>f</i>2</b><br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
1<br>
1<br>
0<br>
0<br>
1<br>
0<br>
0<br>
0<br>
0<br>
1<br>
1<br>
0<br>
1<br>
1<br>
0<br>
0<br>
1<br>
0<br>
1<br>
0<br>
1<br>
0<br>
1<br>
1<br>
1<br>
0<br>
0<br>
1<br>
1<br>
1<br>
1<br>
1<br>
1<br>
 <br>Similarly, it may be easily verified that <br>
 <i>f</i>2 = <i>x yz </i>+ <i>xy z </i>+ <i>xyz </i>+ <i>xyz </i>= <i>m</i>3 + <i>m</i>5 + <i>m</i>6 + <i>m</i>7 <br>
 <br>These examples demonstrate an important property of Boolean algebra: Any Boolean <br>function can be expressed as a sum of minterms (with "sum" meaning the ORing of terms). <br>
 <br>Now consider the complement of a Boolean function. It may be read from the truth <br>
table by forming a minterm for each combination that produces a 0 in the function and <br>then ORing those terms. The complement of   <i>f</i>1     is  read  as <br>
 <i>f </i>=1 = <i>x y z </i>+ <i>x yz </i>+ <i>x yz </i>+ <i>xy z </i>+ <i>xyz </i> <br>
 <br>If we take the complement of   <i>f </i>=1,  we obtain the function   <i>f</i>1:    <br>
 <i>f</i>1 = (<i>x </i>+ <i>y </i>+ <i>z</i>)(<i>x </i>+ <i>y </i>+ <i>z</i>)(<i>x </i>+ <i>y </i>+ <i>z </i>)(<i>x </i>+ <i>y </i>+ <i>z</i>)<br>
  = <i>M </i>#<br>
#<br>
#<br>
#<br>
0 <i>M</i>2 <i>M</i>3 <i>M</i>5 <i>M</i>6 <br>
 <br>Similarly, it is possible to read the expression for   <i>f</i>2     from  the  table: <br>
 <i>f</i>2 = (<i>x </i>+ <i>y </i>+ <i>z</i>)(<i>x </i>+ <i>y </i>+ <i>z </i>)(<i>x </i>+ <i>y </i>+ <i>z</i>)(<i>x </i>+ <i>y </i>+ <i>z</i>)<br>
  = <i>M</i>0<i>M</i>1<i>M</i>2<i>M</i>4 <br>
 <br>These examples demonstrate a second property of Boolean algebra: Any Boolean func-<br>tion can be expressed as a product of maxterms (with "product" meaning the ANDing <br>of terms). The procedure for obtaining the product of maxterms directly from the truth <br>table is as follows: Form a maxterm for each combination of the variables that produces <br>a 0 in the function, and then form the AND of all those maxterms.  <b>Boolean functions <br>expressed as a sum of minterms or product of maxterms are said to be in  <i>canonical form</i> .</b> <br>
<b> <br>Sum of Minterms </b><br>
 <br>Previously, we stated that, for <i>n</i> binary variables, one can obtain   2<i>n</i>     distinct  minterms  and <br>that any Boolean function can be expressed as a sum of minterms.  <b>The minterms whose <br>sum defines the Boolean function are those which give the 1's of the function in a </b><br>
<hr>
<A name=71></a><b>Section 2.6  Canonical and Standard Forms    53</b><br>
<b>truth table</b>.  Since the function can be either 1 or 0 for each minterm, and since there are <br> <br>2<i>n</i>  minterms, one can calculate all the functions that can be formed with <i>n</i> variables to <br>be     22<i>n</i>.  It is sometimes convenient to express a Boolean function in its sumofminterms <br>form. If the function is not in this form, it can be made so by first expanding the expres-<br>sion into a sum of AND terms. Each term is then inspected to see if it contains all the <br>variables. If it misses one or more variables, it is ANDed with an expression such as <br> <i>x </i>+ <i>x </i>,     where<i> x </i>is one of the missing variables. The next example clarifies this procedure. <br>
<b> <br>EXAMPLE 2.4 </b><br>
 <br>Express the Boolean function   <i>F </i>= <i>A </i>+ <i>B C</i>  as a sum of minterms. The function has <br>three variables: <i>A</i>, <i>B</i>, and <i>C</i>. The first term <i>A</i> is missing two variables; therefore, <br>
 <i>A </i>= <i>A</i>(<i>B </i>+ <i>B </i>) = <i>AB </i>+ <i>AB </i> <br>
 <br>This function is still missing one variable, so <br>
 <i>A </i>= <i>AB</i>(<i>C </i>+ <i>C </i>) + <i>AB </i>(<i>C </i>+ <i>C </i>)<br>
  = <i>ABC </i>+ <i>ABC </i>+ <i>AB C </i>+ <i>AB C </i> <br>
 <br>The second term   <i>B C</i>  is missing one variable; hence, <br>
 <br><i>B C </i>= <i>B C</i>(<i>A </i>+ <i>A </i>) = <i>AB C </i>+ <i>A B C</i> <br>
 <br>Combining all terms, we have <br>
 <i>F </i>= <i>A </i>+ <i>B C</i><br>
  = <i>ABC </i>+ <i>ABC </i>+ <i>AB C </i>+ <i>AB C </i>+ <i>A B C</i> <br>
 But     <i>AB C</i>  appears twice, and according to theorem   1 (<i>x </i>+ <i>x </i>= <i>x</i>),  it is possible to <br>remove one of those occurrences. Rearranging the minterms in ascending order, we <br>finally obtain <br>
 <i>F </i>= <i>A B C </i>+ <i>AB C </i>+ <i>AB C </i>+ <i>ABC </i>+ <i>ABC</i><br>
= <i>m</i>1 + <i>m</i>4 + <i>m</i>5 + <i>m</i>6 + <i>m</i>7 <br>
<br>
 <br>When a Boolean function is in its sumofminterms form, it is sometimes convenient to <br>express the function in the following brief notation: <br>
 <br><i>F</i>(<i>A</i>, <i>B</i>, <i>C</i>) =<br>
(1, 4, 5, 6, 7) <br>
 <br>The summation symbol   g   stands for the ORing of terms; the numbers following it are <br>the indices of the minterms of the function. The letters in parentheses following <i>F</i> form <br>a list of the variables in the order taken when the minterm is converted to an AND term. <br>
 <br><b>An alternative procedure for deriving the minterms of a Boolean function is to obtain </b><br>
<b>the truth table of the function directly from the algebraic expression and then read the <br>minterms from the truth table.</b>  Consider the Boolean function given in Example 2.4: <br>
 <br><i>F </i>= <i>A </i>+ <i>B C</i> <br>
 <br>The truth table shown in  Table   2.5   can be derived directly from the algebraic expres-<br>sion by listing the eight binary combinations under variables <i>A</i>, <i>B</i>, and <i>C</i> and inserting <br>
<hr>
<A name=72></a><b>54    Chapter 2  Boolean Algebra and Logic Gates</b><br>
<b>Table 2.5<br><i>Truth Table for F</b></i><br>
<i><b>A</b></i><br>
<i><b>B C</b></i><br>
<i><b>A</b></i><br>
<i><b>B</b></i><br>
<i><b>C</b></i><br>
<i><b>F</b></i><br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
1<br>
1<br>
0<br>
1<br>
0<br>
0<br>
0<br>
1<br>
1<br>
0<br>
1<br>
0<br>
0<br>
1<br>
1<br>
0<br>
1<br>
1<br>
1<br>
1<br>
0<br>
1<br>
1<br>
1<br>
1<br>
1<br>
1's under <i>F</i> for those combinations for which   <i>A </i>= 1     and     <i>BC </i>= 01.  From the truth table, <br>we can then read the five minterms of the function to be 1, 4, 5, 6, and 7. <br>
<b> <br>Product of Maxterms </b><br>
 <br><b>Each of the   22<i>n</i>     functions  of  <i>n</i> binary variables can be also expressed as a product of <br>maxterms.</b> To express a Boolean function as a product of maxterms, it must first be <br>brought into a form of OR terms. This may be done by using the distributive law, <br> <i>x </i>+ <i>yz </i>= (<i>x </i>+ <i>y</i>)(<i>x </i>+ <i>z</i>).     Then  any  missing  variable<i> x </i>in each OR term is ORed with <br> <i>xx </i>. The procedure is clarified in the following example. <br>
<b> <br>EXAMPLE 2.5 </b><br>
 <br>Express the Boolean function   <i>F </i>= <i>xy </i>+ <i>x z</i>  as a product of maxterms. First, convert <br>the function into OR terms by using the distributive law: <br>
 <i>F </i>= <i>xy </i>+ <i>x z </i>= (<i>xy </i>+ <i>x </i>)(<i>xy </i>+ <i>z</i>)<br>
  = (<i>x </i>+ <i>x </i>)(<i>y </i>+ <i>x </i>)(<i>x </i>+ <i>z</i>)(<i>y </i>+ <i>z</i>)<br>  = (<i>x </i>+ <i>y</i>)(<i>x </i>+ <i>z</i>)(<i>y </i>+ <i>z</i>)   <br>
 <br>The function has three variables: <i>x</i>, <i>y</i>, and <i>z</i>. Each OR term is missing one variable; <br>therefore, <br>
 <i>x </i>+ <i>y </i>= <i>x </i>+ <i>y </i>+ <i>zz </i>= (<i>x </i>+ <i>y </i>+ <i>z</i>)(<i>x </i>+ <i>y </i>+ <i>z </i>)<br>
 <i>x </i>+ <i>z </i>= <i>x </i>+ <i>z </i>+ <i>yy </i>= (<i>x </i>+ <i>y </i>+ <i>z</i>)(<i>x </i>+ <i>y </i>+ <i>z</i>)<br> <i>y </i>+ <i>z </i>= <i>y </i>+ <i>z </i>+ <i>xx </i>= (<i>x </i>+ <i>y </i>+ <i>z</i>)(<i>x </i>+ <i>y </i>+ <i>z</i>)   <br>
 <br>Combining all the terms and removing those which appear more than once, we finally <br>obtain <br>
 <i>F </i>= (<i>x </i>+ <i>y </i>+ <i>z</i>)(<i>x </i>+ <i>y </i>+ <i>z</i>)(<i>x </i>+ <i>y </i>+ <i>z</i>)(<i>x </i>+ <i>y </i>+ <i>z </i>)<br>
  = <i>M</i>0<i>M</i>2<i>M</i>4<i>M</i>5 <br>
<hr>
<A name=73></a><b>Section 2.6  Canonical and Standard Forms    55</b><br>
 <br>A convenient way to express this function is as follows: <br>
 <br><i>F</i>(<i>x</i>, <i>y</i>, <i>z</i>) =<br>
(0, 2, 4, 5) <br>
 <br>The product symbol,    ,  denotes the ANDing of maxterms; the numbers are the indices <br>of the maxterms of the function. <br>
<br>
<b> <br>Conversion between Canonical Forms </b><br>
 <br>The complement of a function expressed as the sum of minterms equals the sum of min-<br>terms missing from the original function. This is because the original function is expressed <br>by those minterms which make the function equal to 1, whereas its complement is a 1 for <br>those minterms for which the function is a 0. As an example, consider the function <br>
 <br><i>F</i>(<i>A</i>, <i>B</i>, <i>C</i>) =<br>
(1, 4, 5, 6, 7) <br>
 <br>This function has a complement that can be expressed as <br>
 <br><i>F </i>(<i>A</i>, <i>B</i>, <i>C</i>) =<br>
(0, 2, 3) = <i>m</i>0 + <i>m</i>2 + <i>m</i>3 <br>
 <br>Now, if we take the complement of   <i>F </i>     by  DeMorgan's  theorem,  we  obtain  <i>F</i> in a differ-<br>ent form: <br>
 <br><i>F </i>= (<i>m</i><br>
#<br>
#<br>
0 + <i>m</i>2 + <i>m</i>3)<br>
= <i>m</i>=0 <i>m</i>=2 <i>m</i>=3 = <i>M</i>0<i>M</i>2<i>M</i>3 =<br>
(0, 2, 3) <br>
 <br>The last conversion follows from the definition of minterms and maxterms as shown in <br> <br>Table   2.3  . From the table, it is clear that the following relation holds: <br>
 <br><i>m</i>=<i>j </i>= <i>Mj</i> <br>
  That  is,  the  <b>maxterm with subscript <i>j</i> is a complement of the minterm with the same <br>subscript <i>j</i> and vice versa.</b> <br>
 <br>The last example demonstrates the conversion between a function expressed in sum<br>
ofminterms form and its equivalent in productofmaxterms form. A similar argument <br>will show that the conversion between the product of maxterms and the sum of minterms <br>is similar. We now state a general conversion procedure: To convert from one canonical <br>form to another, interchange the symbols         and        and list those numbers missing from <br>the original form. In order to find the missing terms, one must realize that the total number <br>of minterms or maxterms is   2<i>n</i>,     where  <i>n</i> is the number of binary variables in the function. <br>
 <br>A Boolean function can be converted from an algebraic expression to a product of <br>
maxterms by means of a truth table and the canonical conversion procedure. Consider, <br>for example, the Boolean expression <br>
 <br><i>F </i>= <i>xy </i>+ <i>x z</i> <br>
 <br>First, we derive the truth table of the function, as shown in  Table   2.6  . The 1's under <i>F</i> in <br>the table are determined from the combination of the variables for which   <i>xy </i>= 11 or <br> <i>xz </i>= 01. The minterms of the function are read from the truth table to be 1, 3, 6, and 7. <br>The function expressed as a sum of minterms is <br>
 <br><i>F</i>(<i>x</i>, <i>y</i>, <i>z</i>) =<br>
(1, 3, 6, 7) <br>
<hr>
<A name=74></a><b>56    Chapter 2  Boolean Algebra and Logic Gates</b><br>
<b>Table 2.6<br><i>Truth Table for F</b></i><br>
<i><b>xy</b></i><br>
<i><b>x z</b></i><br>
<i><b>x</b></i><br>
<i><b>y</b></i><br>
<i><b>z</b></i><br>
<i><b>F</b></i><br>
0<br>
0<br>
0<br>
0<br>
Minterms<br>
0<br>
0<br>
1<br>
1<br>
0<br>
1<br>
0<br>
0<br>
0<br>
1<br>
1<br>
1<br>
1<br>
0<br>
0<br>
0<br>
1<br>
0<br>
1<br>
0<br>
1<br>
1<br>
0<br>
1<br>
Maxterms<br>
1<br>
1<br>
1<br>
1<br>
 <br>Since there is a total of eight minterms or maxterms in a function of three variables, we <br>determine the missing terms to be 0, 2, 4, and 5. The function expressed as a product of <br>maxterms is <br>
 <br><i>F</i>(<i>x</i>, <i>y</i>, <i>z</i>) =<br>
(0, 2, 4, 5) <br>
 <br>the same answer as obtained in Example 2.5. <br>
<b> <br>Standard Forms </b><br>
 <br>The two canonical forms of Boolean algebra are basic forms that one obtains from read-<br>ing a given function from the truth table. These forms are very seldom the ones with the <br>least number of literals, because each minterm or maxterm must contain, by definition, <br><i>all</i> the variables, either complemented or uncomplemented. <br>
 <br>Another way to express Boolean functions is in <i>standard</i> form. In this configuration, <br>
the terms that form the function may contain one, two, or any number of literals. There <br>are two types of standard forms: the sum of products and products of sums. <br>
 The  <i>sum of products</i> is a Boolean expression containing AND terms, called <i>product </i><br>
<i>terms,</i> with one or more literals each. The <i>sum</i> denotes the ORing of these terms. An <br>example of a function expressed as a sum of products is <br>
 <br><i>F</i>1 = <i>y </i>+ <i>xy </i>+ <i>x yz </i> <br>
 <br>The expression has three product terms, with one, two, and three literals. Their sum is, <br>in effect, an OR operation. <br>
 <br>The logic diagram of a sumofproducts expression consists of a group of AND gates <br>
followed by a single OR gate. This configuration pattern is shown in  Fig.   2.3  (a). Each <br>product term requires an AND gate, except for a term with a single literal. The logic sum <br>is formed with an OR gate whose inputs are the outputs of the AND gates and the <br>single literal. It is assumed that the input variables are directly available in their comple-<br>ments, so inverters are not included in the diagram. This circuit configuration is referred <br>to as a <i>twolevel implementation</i>. <br>
<hr>
<A name=75></a><b>Section 2.6  Canonical and Standard Forms    57</b><br>
<i>y</i><br>
<i>x</i><br>
<i>x</i><br>
<i>y</i><br>
<i>y</i><br>
<i>F</i>1<br>
<i>F</i>2<br>
<i>z</i><br>
<i>z</i><br>
<i>x</i><br>
<i>x</i><br>
<i>y</i><br>
<i>y</i><br>
<i>z</i><br>
(a) Sum of Products<br>
(b) Product of Sums <br>
<b>FIGURE 2.3<br>Twolevel implementation</b><br>
<i>A</i><br>
<i>A</i><br>
<i>B</i><br>
<i>B</i><br>
<i>C</i><br>
<i>F</i><br>
<i>C</i><br>
3<br>
<i>F</i>3<br>
<i>D</i><br>
<i>D</i><br>
<i>E</i><br>
<i>C</i><br>
<i>E</i><br>
(a)<i> AB   C</i>(<i>D</i><br>
<i> E</i>)<br>
(b)<i> AB   CD   CE</i><br>
<b>FIGURE 2.4<br>Three and twolevel implementation</b><br>
 A  <i>product of sums</i> is a Boolean expression containing OR terms, called <i>sum terms</i>. <br>
Each term may have any number of literals. The <i>product</i> denotes the ANDing of these <br>terms. An example of a function expressed as a product of sums is <br>
 <br><i>F</i>2 = <i>x</i>(<i>y </i>+ <i>z</i>)(<i>x </i>+ <i>y </i>+ <i>z </i>)   <br>
 <br>This expression has three sum terms, with one, two, and three literals. The product is an <br>AND operation. The use of the words <i>product</i> and <i>sum</i> stems from the similarity of the <br>AND operation to the arithmetic product (multiplication) and the similarity of the OR <br>operation to the arithmetic sum (addition). The gate structure of the productofsums <br>expression consists of a group of OR gates for the sum terms (except for a single literal), <br>followed by an AND gate, as shown in  Fig.   2.3  (b).  <b>This standard type of expression <br>results in a twolevel structure of gates.</b> <br>
 <br>A Boolean function may be expressed in a nonstandard form. For example, the function <br>
 <br><i>F</i>3 = <i>AB </i>+ <i>C</i>(<i>D </i>+ <i>E</i>)   <br>
 <br>is neither in sumofproducts nor in productofsums form. The implementation of this <br>expression is shown in  Fig.   2.4  (a) and requires two AND gates and two OR gates. There <br>are three levels of gating in this circuit. It can be changed to a standard form by using <br>the distributive law to remove the parentheses: <br>
 <br><i>F</i>3 = <i>AB </i>+ <i>C</i>(<i>D </i>+ <i>E</i>) = <i>AB </i>+ <i>CD </i>+ <i>CE</i> <br>
<hr>
<A name=76></a><b>58    Chapter 2  Boolean Algebra and Logic Gates</b><br>
 <br>The sumofproducts expression is implemented in  Fig.   2.4  (b). In general, a twolevel <br>implementation is preferred because it produces the least amount of delay through the <br>gates when the signal propagates from the inputs to the output. However, the number <br>of inputs to a given gate might not be practical. <br>
<b> <br>2 . 7       O T H E R   L O G I C   O P E R AT I O N S </b><br>
 <br>When the binary operators AND and OR are placed between two variables,<i> x </i>and <i>y</i>, <br>they form two Boolean functions,   <i>x </i># <i>y</i>     and     <i>x </i>+ <i>y</i>,  respectively. Previously we stated that <br>there are   22<i>n</i>     functions  for  <i>n</i> binary variables. Thus, for two variables,   <i>n </i>= 2,     and  the <br>number of possible Boolean functions is 16. Therefore, the AND and OR functions <br>are only 2 of a total of 16 possible functions formed with two binary variables. It would <br>be instructive to find the other 14 functions and investigate their properties. <br>
 <br>The truth tables for the 16 functions formed with two binary variables are listed in <br>
 Table    2.7   .  Each  of  the  16  columns,     <i>F</i>0 to  <i>F</i>15,  represents a truth table of one possible func-<br>tion for the two variables, <i>x</i> and <i>y.</i> Note that the functions are determined from the <br>16 binary combinations that can be assigned to <i>F</i>. The 16 functions can be expressed <br>algebraically by means of Boolean functions, as is shown in the first column of  Table   2.8  . <br>The Boolean expressions listed are simplified to their minimum number of literals. <br>
 <br>Although each function can be expressed in terms of the Boolean operators AND, <br>
OR, and NOT, there is no reason one cannot assign special operator symbols for express-<br>ing the other functions. Such operator symbols are listed in the second column of <br> <br>Table   2.8  . However, of all the new symbols shown, only the exclusiveOR symbol,   <br>
,    <br>
is in common use by digital designers. <br>
 <br>Each of the functions in  Table   2.8   is listed with an accompanying name and a com-<br>
ment that explains the function in some way.1 The 16 functions listed can be subdivided <br>into three categories: <br>
 <br><b> 1. </b><br>
 <br>Two functions that produce a constant 0 or 1. <br>
 <br><b> 2. </b><br>
 <br>Four functions with unary operations: complement and transfer. <br>
 <br><b> 3. </b><br>
 <br>Ten functions with binary operators that define eight different operations: AND, <br>OR, NAND, NOR, exclusiveOR, equivalence, inhibition, and implication. <br>
<b>Table 2.7<br><i>Truth Tables for the 16 Functions of Two Binary Variables</b></i><br>
<i><b>x</b></i><br>
<i><b>y</b></i><br>
<i><b>F0</b></i><br>
<i><b>F1</b></i><br>
<i><b>F2</b></i><br>
<i><b>F3</b></i><br>
<i><b>F4</b></i><br>
<i><b>F5</b></i><br>
<i><b>F6</b></i><br>
<i><b>F7</b></i><br>
<i><b>F8</b></i><br>
<i><b>F9</b></i><br>
<i><b>F10 F11 F12 F13 F14 F15</b></i><br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
1<br>
1<br>
1<br>
1<br>
1<br>
1<br>
1<br>
1<br>
0<br>
1<br>
0<br>
0<br>
0<br>
0<br>
1<br>
1<br>
1<br>
1<br>
0<br>
0<br>
0<br>
0<br>
1<br>
1<br>
1<br>
1<br>
1<br>
0<br>
0<br>
0<br>
1<br>
1<br>
0<br>
0<br>
1<br>
1<br>
0<br>
0<br>
1<br>
1<br>
0<br>
0<br>
1<br>
1<br>
1<br>
1<br>
0<br>
1<br>
0<br>
1<br>
0<br>
1<br>
0<br>
1<br>
0<br>
1<br>
0<br>
1<br>
0<br>
1<br>
0<br>
1<br>
1 The symbol ^ is also used to indicate the exclusive or operator, e.g., <i>x</i>^<i>y</i>. The symbol for the AND function is <br>sometimes omitted from the product of two variables, e.g., <i>xy</i>. <br>
<hr>
<A name=77></a><b>Section 2.7  Other Logic Operations    59</b><br>
<b>Table 2.8<br><i>Boolean Expressions for the 16 Functions of Two Variables</b></i><br>
<b>Operator </b><br>
<b>Boolean Functions</b><br>
<b> Symbol</b><br>
<b>Name</b><br>
<b>Comments</b><br>
<i>F</i>0 = 0<br>
Null<br>
Binary constant 0<br>
<i>F</i>1 = <i>xy</i><br>
<i>x </i># <i>y</i><br>
AND<br>
<i>x</i> and <i>y</i><br>
<i>F</i>2 = <i>xy</i><br>
<i>x/y</i><br>
Inhibition<br>
<i>x,</i> but not <i>y</i><br>
<i>F</i>3 = <i>x</i><br>
Transfer<br>
<i>x</i><br>
<i>F</i>4 = <i>x y</i><br>
<i>y/x</i><br>
Inhibition<br>
<i>y,</i> but not <i>x</i><br>
<i>F</i>5 = <i>y</i><br>
Transfer<br>
<i>y</i><br>
<i>F</i>6 = <i>xy </i>+ <i>x y</i><br>
<i>x</i><br>
<i>y</i><br>
ExclusiveOR<br>
<i>x</i> or <i>y,</i> but not both<br>
<i>F</i>7 = <i>x </i>+ <i>y</i><br>
<i>x </i>+ <i>y</i><br>
OR<br>
<i>x</i> or <i>y</i><br>
<i>F</i>8 = (<i>x </i>+ <i>y</i>)<br>
<i>x</i>  T <i>y</i><br>
NOR<br>
NotOR<br>
<i>F</i>9 = <i>xy </i>+ <i>x y</i><br>
(<i>x</i><br>
<i>y</i>)<br>
Equivalence<br>
x equals <i>y</i><br>
<i>F</i>10 = <i>y</i><br>
<i>y</i><br>
Complement<br>
Not <i>y</i><br>
<i>F</i>11 = <i>x </i>+ <i>y</i><br>
<i>x</i><br>
<i>y</i><br>
Implication<br>
If <i>y,</i> then <i>x</i><br>
<i>F</i>12 = <i>x</i><br>
<i>x</i><br>
Complement<br>
Not <i>x</i><br>
<i>F</i>13 = <i>x </i>+ <i>y</i><br>
<i>x</i><br>
<i>y</i><br>
Implication<br>
If <i>x,</i> then <i>y</i><br>
<i>F</i>14 = (<i>xy</i>)<br>
<i>x</i>  c <i>y</i><br>
NAND<br>
NotAND<br>
<i>F</i>15 = 1<br>
Identity<br>
Binary constant 1<br>
 <br>Constants for binary functions can be equal to only 1 or 0. The complement function <br>
produces the complement of each of the binary variables. A function that is equal to an <br>input variable has been given the name <i>transfer</i>, because the variable<i> x </i>or<i> y </i>is transferred <br>through the gate that forms the function without changing its value. Of the eight binary <br>operators, two (inhibition and implication) are used by logicians, but are seldom used <br>in computer logic. The AND and OR operators have been mentioned in conjunction <br>with Boolean algebra. The other four functions are used extensively in the design of <br>digital systems. <br>
 <br>The NOR function is the complement of the OR function, and its name is an <br>
abbreviation of <i>not</i><i>OR</i>. Similarly, NAND is the complement of AND and is an <br>abbreviation of <i>not</i><i>AND</i>. The exclusiveOR, abbreviated XOR, is similar to OR, but <br>excludes the combination of <i>both</i> <i>x</i> and<i> y </i>being equal to 1; it holds only when <i>x</i> and<i> y <br></i>differ in value. (It is sometimes referred to as the binary difference operator.) Equiv-<br>alence is a function that is 1 when the two binary variables are equal (i.e., when both <br>are 0 or both are 1). The exclusiveOR and equivalence functions are the comple-<br>ments of each other. This can be easily verified by inspecting  Table   2.7  : The truth <br>table for exclusiveOR is   <i>F</i>6  and for equivalence is   <i>F</i>9,  and these two functions are <br>the complements of each other. For this reason, the equivalence function is called <br>exclusiveNOR, abbreviated XNOR. <br>
<hr>
<A name=78></a><b>60    Chapter 2  Boolean Algebra and Logic Gates</b><br>
 <br>Boolean algebra, as defined in Section 2.2, has two binary operators, which we have <br>
called AND and OR, and a unary operator, NOT (complement). From the definitions, <br>we have deduced a number of properties of these operators and now have defined other <br>binary operators in terms of them. There is nothing unique about this procedure. We <br>could have just as well started with the operator NOR   ( T),  for example, and later <br>defined AND, OR, and NOT in terms of it. There are, nevertheless, good reasons for <br>introducing Boolean algebra in the way it has been introduced. The concepts of "and," <br>"or," and "not" are familiar and are used by people to express everyday logical ideas. <br>Moreover, the Huntington postulates reflect the dual nature of the algebra, emphasizing <br>the symmetry of    +      and      #   with respect to each other. <br>
<b> <br>2 . 8       D I G I TA L   L O G I C   G AT E S </b><br>
 <br>Since Boolean functions are expressed in terms of AND, OR, and NOT operations, it is <br>easier to implement a Boolean function with these type of gates. Still, the possibility of <br>constructing gates for the other logic operations is of practical interest. Factors to be <br>weighed in considering the construction of other types of logic gates are (1) the feasibil-<br>ity and economy of producing the gate with physical components, (2) the possibility of <br>extending the gate to more than two inputs, (3) the basic properties of the binary oper-<br>ator, such as commutativity and associativity, and (4) the ability of the gate to implement <br>Boolean functions alone or in conjunction with other gates. <br>
 <br>Of the 16 functions defined in  Table   2.8  , two are equal to a constant and four are <br>
repeated. There are only 10 functions left to be considered as candidates for logic gates. <br>Two--inhibition and implication--are not commutative or associative and thus are <br>impractical to use as standard logic gates. The other eight--complement, transfer, AND, <br>OR, NAND, NOR, exclusiveOR, and equivalence--are used as standard gates in <br> digital  design. <br>
 <br>The graphic symbols and truth tables of the eight gates are shown in  Fig.   2.5  . Each <br>
gate has one or two binary input variables, designated by <i>x</i> and <i>y</i>, and one binary output <br>variable, designated by <i>F</i>. The AND, OR, and inverter circuits were defined in Fig. 1.6. <br>The inverter circuit inverts the logic sense of a binary variable, producing the NOT, or <br>complement, function. The small circle in the output of the graphic symbol of an inverter <br>(referred to as a <i>bubble</i>) designates the logic complement. The triangle symbol by itself <br>designates a buffer circuit. A buffer produces the <i>transfer</i> function, but does not produce <br>a logic operation, since the binary value of the output is equal to the binary value of the <br>input. This circuit is used for power amplification of the signal and is equivalent to two <br>inverters connected in cascade. <br>
 <br>The NAND function is the complement of the AND function, as indicated by a <br>
graphic symbol that consists of an AND graphic symbol followed by a small circle. The <br>NOR function is the complement of the OR function and uses an OR graphic symbol <br>followed by a small circle. NAND and NOR gates are used extensively as standard logic <br>gates and are in fact far more popular than the AND and OR gates. This is because <br>NAND and NOR gates are easily constructed with transistor circuits and because  digital <br>circuits can be easily implemented with them. <br>
<hr>
<A name=79></a><b>Section 2.8  Digital Logic Gates    61</b><br>
Graphic<br>
Algebraic<br>
Truth<br>
Name<br>
symbol<br>
function<br>
table<br>
<i>x</i><br>
<i>y</i><br>
<i>F</i><br>
<i>x</i><br>
0<br>
0<br>
0<br>
AND<br>
<i>F</i><br>
<i>F</i><br>
<i>x </i>� <i>y</i><br>
<i>y</i><br>
0<br>
1<br>
0<br>
1<br>
0<br>
0<br>
1<br>
1<br>
1<br>
<i>x</i><br>
<i>y</i><br>
<i>F</i><br>
<i>x</i><br>
OR<br>
0<br>
0<br>
0<br>
<i>F</i><br>
<i>F</i><br>
<i>x</i><br>
<i>y</i><br>
<i>y</i><br>
0<br>
1<br>
1<br>
1<br>
0<br>
1<br>
1<br>
1<br>
1<br>
<i>x</i><br>
<i>F</i><br>
Inverter<br>
<i>x</i><br>
<i>F</i><br>
<i>F</i><br>
<i>x</i><br>
0<br>
1<br>
1<br>
0<br>
<i>x</i><br>
<i>F</i><br>
Buffer<br>
<i>x</i><br>
<i>F</i><br>
<i>F</i><br>
<i>x</i><br>
0<br>
0<br>
1<br>
1<br>
<i>x</i><br>
<i>y</i><br>
<i>F</i><br>
<i>x</i><br>
0<br>
0<br>
1<br>
NAND<br>
<i>F</i><br>
<i>F</i><br>
 (<i>xy</i>)<br>
<i>y</i><br>
0<br>
1<br>
1<br>
1<br>
0<br>
1<br>
1<br>
1<br>
0<br>
<i>x</i><br>
<i>y</i><br>
<i>F</i><br>
<i>x</i><br>
0<br>
0<br>
1<br>
NOR<br>
<i>F</i><br>
<i>F</i><br>
 (<i>x</i><br>
<i>y</i>)<br>
<i>y</i><br>
0<br>
1<br>
0<br>
1<br>
0<br>
0<br>
1<br>
1<br>
0<br>
<i>x</i><br>
<i>y</i><br>
<i>F</i><br>
Exclusive-OR<br>
<i>x</i><br>
<i>F</i><br>
 <i>xy</i><br>
<i>x </i>y<br>
0<br>
0<br>
0<br>
(XOR)<br>
<i>F</i><br>
<i>y</i><br>
<i>x </i> y<br>
0<br>
1<br>
1<br>
1<br>
0<br>
1<br>
1<br>
1<br>
0<br>
<i>x</i><br>
<i>y</i><br>
<i>F</i><br>
Exclusive-NOR<br>
<i>x</i><br>
<i>F</i><br>
 <i>xy</i><br>
<i>x </i>y<br>
0<br>
0<br>
1<br>
or<br>
<i>F</i><br>
<i>y</i><br>
 (<i>x </i> y)<br>
0<br>
1<br>
0<br>
equivalence<br>
1<br>
0<br>
0<br>
1<br>
1<br>
1<br>
<b>FIGURE 2.5<br>Digital logic gates</b><br>
<hr>
<A name=80></a><b>62    Chapter 2  Boolean Algebra and Logic Gates</b><br>
 <br>The exclusiveOR gate has a graphic symbol similar to that of the OR gate, except <br>
for the additional curved line on the input side. The equivalence, or exclusiveNOR, gate <br>is the complement of the exclusiveOR, as indicated by the small circle on the output <br>side of the graphic symbol. <br>
<b> <br>Extension to Multiple Inputs </b><br>
 <br>The gates shown in  Fig.   2.5  --except for the inverter and buffer--can be extended to <br>have more than two inputs. A gate can be extended to have multiple inputs if the binary <br>operation it represents is commutative and associative. The AND and OR operations, <br>defined in Boolean algebra, possess these two properties. For the OR function, we have <br>
 <i>x </i>+ <i>y </i>= <i>y </i>+ <i>x </i>(commutative)   <br>
 and <br>
 <br>(<i>x </i>+ <i>y</i>) + <i>z </i>= <i>x </i>+ (<i>y </i>+ <i>z</i>) = <i>x </i>+ <i>y </i>+ <i>z </i>(associative)   <br>
 <br>which indicates that the gate inputs can be interchanged and that the OR function can <br>be extended to three or more variables. <br>
 <br>The NAND and NOR functions are commutative, and their gates can be extended <br>
to have more than two inputs, provided that the definition of the operation is modified <br>slightly. The difficulty is that the NAND and NOR operators are not associative <br>(i.e.,    (<i>x</i>   <i>y</i>)   <i>z</i><br>
<i>x</i>   (<i>y</i>   <i>z</i>)   ),  as  shown  in   Fig.    2.6     and  the  following  equations: <br>
T<br>
T<br>
T<br>
T<br>
 (<i>x</i>   <i>y</i>)   <i>z</i><br>
T<br>
T<br>
= [(<i>x </i>+ <i>y</i>)<br>
+ <i>z</i>]<br>
= (<i>x </i>+ <i>y</i>)<i>z </i>= <i>xz </i>+ <i>yz</i><br>
 <i>x</i>   (<i>y</i>   <i>z</i>)<br>
T<br>
T<br>
= [<i>x </i>+ (<i>y </i>+ <i>z</i>) ] = <i>x </i>(<i>y </i>+ <i>z</i>) = <i>x y </i>+ <i>x z</i> <br>
 <br>To overcome this difficulty, we define the multiple NOR (or NAND) gate as a <br> <br>complemented OR (or AND) gate. Thus, by definition, we have <br>
 <i>x</i>   <i>y</i>   <i>z</i><br>
T<br>
T<br>
= (<i>x </i>+ <i>y </i>+ <i>z</i>)<br>
 <i>x</i>  c <i>y</i> c <i>z </i>= (<i>xyz</i>)  <br>
 <br>The graphic symbols for the threeinput gates are shown in  Fig.   2.7 . In writing cascaded <br>NOR and NAND operations, one must use the correct parentheses to signify the proper <br>sequence of the gates. To demonstrate this principle, consider the circuit of  Fig.  2.7  (c). <br>The Boolean function for the circuit must be written as <br>
 <br><i>F </i>= [(<i>ABC</i>) (<i>DE</i>) ] = <i>ABC </i>+ <i>DE</i> <br>
 <br>The second expression is obtained from one of DeMorgan's theorems. It also shows that <br>an expression in sumofproducts form can be implemented with NAND gates. (NAND <br>and NOR gates are discussed further in Section 3.7.) <br>
 <br>The exclusiveOR and equivalence gates are both commutative and associative and <br>
can be extended to more than two inputs. However, multipleinput exclusiveOR gates <br>are uncommon from the hardware standpoint. In fact, even a twoinput function is usu-<br>ally constructed with other types of gates. Moreover, the definition of the function must <br>be modified when extended to more than two variables. ExclusiveOR is an <i>odd</i>  function <br>(i.e., it is equal to 1 if the input variables have an odd number of 1's). The construction <br>
<hr>
<A name=81></a><b>Section 2.8  Digital Logic Gates    63</b><br>
<i>x</i><br>
<i>y</i><br>
(<i>x</i><br>
<i>y</i>) <i> z  </i> (<i>x</i><br>
<i>y</i>)<i>z</i><br>
<i>y</i><br>
<i>x</i><br>
<i>x</i><br>
(<i>y    z</i>)<br>
 <i>x </i>(<i>y</i><br>
<i>z</i>)<br>
<i>y</i><br>
<i>z</i><br>
<b>FIGURE 2.6<br>Demonstrating the nonassociativity of the NOR operator: </b>(<b><i>x </b></i>T<b><i> y</b></i>) T <b><i>z</b></i><br>
<i><b>x</b></i> T (<b><i>y </b></i>T<b><i> z</b></i>)<br>
<i>x</i><br>
<i>x</i><br>
<i>y</i><br>
(<i>x</i><br>
<i> y   z</i>)<br>
<i>y</i><br>
(<i>xyz</i>)<br>
<i>z</i><br>
<i>z</i><br>
(a) 3-input NOR gate<br>
(b) 3-input NAND gate<br>
<i>A</i><br>
<i>B</i><br>
<i>C</i><br>
<i>F</i><br>
[(<i>ABC</i>)    (<i>DE</i>) ]    <i>ABC</i><br>
 <i>DE</i> <br>
<i>D</i><br>
<i>E</i><br>
(c) Cascaded NAND gates<br>
<b>FIGURE 2.7<br>Multipleinput and cascaded NOR and NAND gates</b><br>
of a threeinput exclusiveOR function is shown in  Fig.   2.8  . This function is normally <br>implemented by cascading twoinput gates, as shown in (a). Graphically, it can be <br> <br>represented with a single threeinput gate, as shown in (b). The truth table in (c) clearly <br>indicates that the output <i>F</i> is equal to 1 if only one input is equal to 1 or if all three inputs <br>are equal to 1 (i.e., when the total number of 1's in the input variables is <i>odd</i>).  (Exclusive<br>OR gates are discussed further in Section 3.9.) <br>
<b> <br>Positive and Negative Logic </b><br>
 <br>The binary signal at the inputs and outputs of any gate has one of two values, except <br>during transition. One signal value represents logic 1 and the other logic 0. Since two <br>signal values are assigned to two logic values, there exist two different assignments of <br>
<hr>
<A name=82></a><b>64    Chapter 2  Boolean Algebra and Logic Gates</b><br>
<i>x</i><br>
<i>x</i><br>
<i>y</i><br>
<i>z</i><br>
<i>F</i><br>
<i>y</i><br>
0<br>
0<br>
0<br>
0<br>
<i>F</i><br>
<i> x </i><i> y </i><i> z</i><br>
<i>z</i><br>
0<br>
0<br>
1<br>
1<br>
0<br>
1<br>
0<br>
1<br>
(a) Using 2-input gates<br>
0<br>
1<br>
1<br>
0<br>
1<br>
0<br>
0<br>
1<br>
1<br>
0<br>
1<br>
0<br>
1<br>
1<br>
0<br>
0<br>
<i>x</i><br>
<i>y</i><br>
<i>F</i><br>
<i> x </i><i> y </i><i> z</i><br>
1<br>
1<br>
1<br>
1<br>
<i>z</i><br>
(c) Truth table<br>
(b) 3-input gate<br>
<b>FIGURE 2.8<br>Threeinput exclusiveOR gate</b><br>
Logic<br>
Signal<br>
Logic<br>
Signal<br>
value<br>
value<br>
value<br>
value<br>
1<br>
<i>H</i><br>
0<br>
<i>H</i><br>
0<br>
<i>L</i><br>
1<br>
<i>L</i><br>
(a) Positive logic<br>
(b) Negative logic<br>
<b>FIGURE 2.9<br>Signal assignment and logic polarity</b><br>
signal level to logic value, as shown in  Fig.   2.9  . The higher signal level is designated by <br><i>H</i> and the lower signal level by <i>L</i>.  <b>Choosing the highlevel <i>H</i> to represent logic 1 defines <br>a positive logic system. Choosing the lowlevel <i>L</i> to represent logic 1 defines a negative <br>logic system.</b>   The  terms  <i>positive</i> and <i>negative</i> are somewhat misleading, since both sig-<br>nals may be positive or both may be negative. It is not the actual values of the signals <br>that determine the type of logic, but rather the assignment of logic values to the relative <br>amplitudes of the two signal levels. <br>
 <br>Hardware digital gates are defined in terms of signal values such as <i>H</i> and <i>L</i>. It is up <br>
to the user to decide on a positive or negative logic polarity. Consider, for example, the <br>electronic gate shown in  Fig.   2.10  (b). The truth table for this gate is listed in  Fig.   2.10  (a). <br>It specifies the physical behavior of the gate when <i>H</i> is 3 V and <i>L</i> is 0 V. The truth table <br>of  Fig.   2.10  (c) assumes a positive logic assignment, with   <i>H </i>= 1     and     <i>L </i>= 0.     This  truth <br>table is the same as the one for the AND operation. The graphic symbol for a positive <br>logic AND gate is shown in  Fig.   2.10  (d). <br>
 <br>Now consider the negative logic assignment for the same physical gate with   <i>L </i>= 1    <br>
and     <i>H </i>= 0. The result is the truth table of  Fig.   2.10  (e). This table represents the OR <br>operation, even though the entries are reversed. The graphic symbol for the negative<br>logic OR gate is shown in  Fig.   2.10  (f). The small triangles in the inputs and output <br>
<hr>
<A name=83></a><b>Section 2.8  Digital Logic Gates    65</b><br>
<i>x</i><br>
<i>y</i><br>
<i>z</i><br>
<i>x</i><br>
<i>L</i><br>
<i>L</i><br>
<i>L</i><br>
Digital<br>
<i>L</i><br>
<i>H</i><br>
<i>L</i><br>
<i>z</i><br>
gate<br>
<i>H</i><br>
<i>L</i><br>
<i>L</i><br>
<i>y</i><br>
<i>H</i><br>
<i>H</i><br>
<i>H</i><br>
(b) Gate block diagram<br>
(a) Truth table<br> with <br>
<i>H</i> and <i>L</i><br>
<i>x</i><br>
<i>y</i><br>
<i>z</i><br>
0<br>
0<br>
0<br>
0<br>
1<br>
0<br>
<i>x</i><br>
1<br>
0<br>
0<br>
<i>z</i><br>
1<br>
1<br>
1<br>
<i>y</i><br>
(c) Truth table for<br>
(d) Positive logic AND gate<br>
 positive <br>
logic<br>
<i>x</i><br>
<i>y</i><br>
<i>z</i><br>
1<br>
1<br>
1<br>
1<br>
0<br>
1<br>
<i>x</i><br>
0<br>
1<br>
1<br>
<i>z</i><br>
0<br>
0<br>
0<br>
<i>y</i><br>
(e) Truth table for<br>
(f) Negative logic OR gate<br>
 negative <br>
logic<br>
<b>FIGURE 2.10<br>Demonstration of positive and negative logic</b><br>
 designate  a  <i>polarity indicator</i>, the presence of which along a terminal signifies that <br>negative logic is assumed for the signal. Thus, the same physical gate can operate either <br>as a positivelogic AND gate or as a negativelogic OR gate. <br>
 <br>The conversion from positive logic to negative logic and vice versa is essentially <br>
an operation that changes 1's to 0's and 0's to 1's in both the inputs and the output <br>of a gate. Since this operation produces the dual of a function, the change of all ter-<br>minals from one polarity to the other results in taking the dual of the function. The <br>upshot is that all AND operations are converted to OR operations (or graphic sym-<br>bols) and vice versa. In addition, one must not forget to include the polarityindicator <br>triangle in the graphic symbols when negative logic is assumed. In this book, we will <br>not use negative logic gates and will assume that all gates operate with a positive logic <br>assignment.   <br>
<hr>
<A name=84></a><b>66    Chapter 2  Boolean Algebra and Logic Gates</b><br>
<b> <br>2 . 9       IN T E G R AT E D   C I R C U I T S </b><br>
 <br>An integrated circuit (IC) is fabricated on a die of a silicon semiconductor crystal, called <br>a <i>chip,</i> containing the electronic components for constructing digital gates. The complex <br>chemical and physical processes used to form a semiconductor circuit are not a subject <br>of this book. The various gates are interconnected inside the chip to form the required <br>circuit. The chip is mounted in a ceramic or plastic container, and connections are welded <br>to external pins to form the integrated circuit. The number of pins may range from 14 <br>on a small IC package to several thousand on a larger package. Each IC has a numeric <br>designation printed on the surface of the package for identification. Vendors provide <br>data books, catalogs, and Internet websites that contain descriptions and information <br>about the ICs that they manufacture. <br>
<b> <br>Levels of Integration </b><br>
 <br>Digital ICs are often categorized according to the complexity of their circuits, as mea-<br>sured by the number of logic gates in a single package. The differentiation between those <br>chips which have a few internal gates and those having hundreds of thousands of gates <br>is made by customary reference to a package as being either a small, medium, large, <br>or very largescale integration device. <br>
 <br><i>Smallscale integration</i> (SSI) devices contain several independent gates in a single <br>
package. The inputs and outputs of the gates are connected directly to the pins in the <br>package. The number of gates is usually fewer than 10 and is limited by the number of <br>pins available in the IC. <br>
 <br><i>Mediumscale integration</i> (MSI) devices have a complexity of approximately 10 to <br>
1,000 gates in a single package. They usually perform specific elementary digital opera-<br>tions. MSI digital functions are introduced in  Chapter   4   as decoders, adders, and multi-<br>plexers and in  Chapter   6   as registers and counters. <br>
 <br><i>Largescale integration</i> (LSI) devices contain thousands of gates in a single package. <br>
They include digital systems such as processors, memory chips, and programmable logic <br>devices. Some LSI components are presented in  Chapter   7 . <br>
<i> <br>Very largescale integration</i> (VLSI) devices now contain millions of gates within a <br>
single package. Examples are large memory arrays and complex microcomputer chips. <br>Because of their small size and low cost, VLSI devices have revolutionized the computer <br>system design technology, giving the designer the capability to create structures that <br>were previously uneconomical to build. <br>
<b> <br>Digital Logic Families </b><br>
 <br>Digital integrated circuits are classified not only by their complexity or logical operation, <br>but also by the specific circuit technology to which they belong. The circuit technology <br>is referred to as a <i>digital logic family</i>. Each logic family has its own basic electronic <br>circuit upon which more complex digital circuits and components are developed. The <br>basic circuit in each technology is a NAND, NOR, or inverter gate. The electronic <br>
<hr>
<A name=85></a><b>Section 2.9  Integrated Circuits    67</b><br>
 <br>components employed in the construction of the basic circuit are usually used to name <br>the technology. Many different logic families of digital integrated circuits have been <br>introduced commercially. The following are the most popular: <br>
 TTL <br>
 transistor�transistor  logic; <br>
 ECL <br>
 emittercoupled  logic; <br>
 MOS <br>
 metaloxide  semiconductor; <br>
 CMOS <br>
 complementary  metaloxide  semiconductor. <br>
 <br>TTL is a logic family that has been in use for 50 years and is considered to be stan-<br>
dard. ECL has an advantage in systems requiring highspeed operation. MOS is suitable <br>for circuits that need high component density, and CMOS is preferable in systems <br>requiring low power consumption, such as digital cameras, personal media players, and <br>other handheld portable devices. Low power consumption is essential for VLSI design; <br>therefore, CMOS has become the dominant logic family, while TTL and ECL continue <br>to decline in use. The most important parameters distinguishing logic families are listed <br>below; CMOS integrated circuits are discussed briefly in the appendix. <br>
 <br><i>Fanout</i> specifies the number of standard loads that the output of a typical gate can <br>
drive without impairing its normal operation. A standard load is usually defined as the <br>amount of current needed by an input of another similar gate in the same family. <br>
<i> Fanin</i> is the number of inputs available in a gate. <br><i> Power  dissipation</i> is the power consumed by the gate that must be available from the <br>
power supply. <br>
<i> Propagation  delay</i> is the average transition delay time for a signal to propagate from <br>
input to output. For example, if the input of an inverter switches from 0 to 1, the output <br>will switch from 1 to 0, but after a time determined by the propagation delay of the <br>device. The operating speed is inversely proportional to the propagation delay. <br>
<i> Noise  margin</i> is the maximum external noise voltage added to an input signal that <br>
does not cause an undesirable change in the circuit output. <br>
<b> <br>ComputerAided Design of VLSI Circuits </b><br>
 <br>Integrated circuits having submicron geometric features are manufactured by optically <br>projecting patterns of light onto silicon wafers. Prior to exposure, the wafers are coated <br>with a photoresistive material that either hardens or softens when exposed to light. <br>Removing extraneous photoresist leaves patterns of exposed silicon. The exposed <br>regions are then implanted with dopant atoms to create a semiconductor material hav-<br>ing the electrical properties of transistors and the logical properties of gates. The design <br>process translates a functional specification or description of the circuit (i.e., what it must <br>do) into a physical specification or description (how it must be implemented in silicon). <br>
 <br>The design of digital systems with VLSI circuits containing millions of transistors and <br>
gates is an enormous and formidable task. Systems of this complexity are usually impos-<br>sible to develop and verify without the assistance of computeraided design (CAD) <br>
<hr>
<A name=86></a><b>68    Chapter 2  Boolean Algebra and Logic Gates</b><br>
tools, which consist of software programs that support computerbased representations <br>of circuits and aid in the development of digital hardware by automating the design <br>process. Electronic design automation (EDA) covers all phases of the design of inte-<br>grated circuits. A typical design flow for creating VLSI circuits consists of a sequence of <br>steps beginning with design entry (e.g., entering a schematic) and culminating with the <br>generation of the database that contains the photomask used to fabricate the IC. There <br>are a variety of options available for creating the physical realization of a digital circuit <br>in silicon. The designer can choose between an applicationspecific integrated circuit <br>(ASIC), a fieldprogrammable gate array (FPGA), a programmable logic device (PLD), <br>and a fullcustom IC. With each of these devices comes a set of CAD tools that provide <br>the necessary software to facilitate the hardware fabrication of the unit. Each of these <br>technologies has a market niche determined by the size of the market and the unit cost <br>of the devices that are required to implement a design. <br>
 <br>Some CAD systems include an editing program for creating and modifying schematic <br>
diagrams on a computer screen. This process is called <i>schematic capture </i>or<i> schematic</i> <br><i>entry</i>. With the aid of menus, keyboard commands, and a mouse, a schematic editor can <br>draw circuit diagrams of digital circuits on the computer screen. Components can be <br>placed on the screen from a list in an internal library and can then be connected with <br>lines that represent wires. The schematic entry software creates and manages a database <br>containing the information produced with the schematic. Primitive gates and functional <br>blocks have associated models that allow the functionality (i.e., logical behavior) and <br>timing of the circuit to be verified. Verification is performed by applying inputs to the <br>circuit and using a logic simulator to determine and display the outputs in text or wave-<br>form format. <br>
 <br>An important development in the design of digital systems is the use of a hardware <br>
description language (HDL). Such a language resembles a computer programming <br>language, but is specifically oriented to describing digital hardware. It represents logic <br>diagrams and other digital information in textual form to describe the functionality <br>and structure of a circuit. Moreover, the HDL description of a circuit's functionality <br>can be abstract, without reference to specific hardware, thereby freeing a designer to <br>devote attention to higher level functional detail (e.g., under certain conditions the <br>circuit must detect a particular pattern of 1's and 0's in a serial bit stream of data) rather <br>than transistorlevel detail. HDLbased models of a circuit or system are simulated to <br>check and verify its functionality before it is submitted to fabrication, thereby reducing <br>the risk and waste of manufacturing a circuit that fails to operate correctly. In tandem <br>with the emergence of HDLbased design languages, tools have been developed to <br>automatically and optimally synthesize the logic described by an HDL model of a <br>circuit. These two advances in technology have led to an  <b>almost total reliance by indus-<br>try on HDLbased synthesis tools and methodologies for the design of the circuits of <br>complex digital systems.</b> Two HDLs--Verilog and VHDL--have been approved as <br>standards by the Institute of Electronics and Electrical Engineers (IEEE) and are in <br>use by design teams worldwide. The Verilog HDL is introduced in Section 3.10, and <br>because of its importance, we include several exercises and design problems based on <br>Verilog throughout the book. <br>
<hr>
<A name=87></a><b>Problems    69</b><br>
<b> <br>P R O B L E M S </b><br>
 <br>
 <br>(Answers to problems marked with <b>*</b> appear at the end of the text.)  <br>
 <br><b> 2.1 </b><br>
 <br>Demonstrate the validity of the following identities by means of truth tables: <br>
    <br>
(a)    DeMorgan's theorem for three variables:   (<i>x</i>  +  <i>y</i>  +  <i>z</i>) = <i>x y z </i>     and     (<i>xyz</i>) =<br>
<i>x </i>+ <i>y </i>+ <i>z </i> <br>
   <br>
(b)    The  distributive  law:   <i>x</i> +  <i>yz</i> = ( <i>x</i> +  <i>y</i> )( <i>x</i> +  <i>z</i> )  <br>
   <br>
(c)    The  distributive  law:   <i>x</i>(<i>y </i>+<i> z</i>) = <i>xy </i>+<i> xz</i> <br>
   <br>
(d)    The  associative  law:   <i>x </i>+<i> </i>(<i>y </i>+<i> z) </i>=<i> </i>(<i>x </i>+<i> y</i>)<i> </i>+<i> z</i> <br>
   <br>
(e)    The  associative  law  and   <i>x</i>(<i>yz</i>)<i> </i>=<i> </i>(<i>xy</i>)<i>z</i> <br>
 <br><b> 2.2 </b><br>
 <br>Simplify the following Boolean expressions to a minimum number of literals: <br>
    <br>
(a)  <b>*</b>   <i>xy </i>+<i> xy</i>    <br>
  (b)  <b>*</b>   (<i>x </i>+ <i>y</i>) (<i>x </i>+ <i>y </i>) <br>
   <br>
(c)  <b>*</b>   <i>xyz </i>+<i> x</i>  <i>y </i>+<i> xyz</i>    <br>
  (d)  <b>*</b>   (<i>A </i>+ <i>B</i>) (<i>A </i>+ <i>B </i>)  <br>
   <br>
(e)  <b>  </b> (<i>a </i>+<i> b </i>+<i> c </i>)(<i>a  b  </i>+<i> c</i>)    <br>
  (f)<b> </b><br>
 <br><i>a bc </i>+<i> abc  </i>+<i> abc </i>+<i> a bc </i> <br>
 <br><b> 2.3 </b><br>
 <br>Simplify the following Boolean expressions to a minimum number of literals: <br>
    <br>
(a)  <b>*</b>   <i>ABC </i>+ <i>A B </i>+ <i>ABC </i> <br>
 <br>(b)<b>*</b>   <i>x</i>  <i>yz </i>+<i> xz</i> <br>
   <br>
(c)  <b>*</b>   (<i>x </i>+ <i>y</i>) (<i>x </i>+ <i>y </i>)      <br>
  (d)  <b>*</b>   <i>xy </i>+<i> x(wz </i>+<i> wz )</i> <br>
   <br>
(e)  <b>*</b>   (<i>BC </i>+ <i>A D</i>) (<i>AB </i>+ <i>CD </i>)      <br>
  (f)         (<i>a  </i>+<i> c </i>)<i> </i>(<i>a </i>+<i> b  </i>+<i> c </i>) <br>
 <br><b> 2.4 </b><br>
 <br>Reduce the following Boolean expressions to the indicated number of literals: <br>
    <br>
(a)  <b>*</b>   <i>A C </i>+ <i>ABC </i>+ <i>AC </i>    <br>
to  three  literals  <br>
   <br>
(b)  <b>*</b>   (<i>x y </i>+ <i>z</i>) + <i>z </i>+ <i>xy </i>+ <i>wz</i>    <br>
to  three  literals  <br>
   <br>
(c)  <b>*</b>  <i>A B</i>(<i>D </i>+ <i>C D</i>) + <i>B</i>(<i>A </i>+ <i>A CD</i>)    <br>
to  one  literal  <br>
   <br>
(d)  <b>*</b>  (<i>A </i>+ <i>C</i>) (<i>A </i>+ <i>C </i>) (<i>A </i>+ <i>B </i>+ <i>C D</i>)    <br>
to  four  literals  <br>
   <br>
(e)<b>    </b> <i>ABC'D </i>+<i> A'BD </i>+<i> ABCD</i>  <br>
to  two  literals     <br>
 <br><b> 2.5 </b><br>
 <br>Draw logic diagrams of the circuits that implement the original and simplified expressions <br>in Problem 2.2. <br>
 <br><b> 2.6 </b><br>
 <br>Draw logic diagrams of the circuits that implement the original and simplified expressions <br>in Problem 2.3. <br>
 <br><b> 2.7 </b><br>
 <br>Draw logic diagrams of the circuits that implement the original and simplified expressions <br>in Problem 2.4. <br>
 <br><b> 2.8 </b><br>
 <br>Find the complement of  <i>F </i>=<i> wx </i>+<i> yz;</i>  then show that   <i>FF </i>= 0     and     <i>F </i>+ <i>F </i>= 1. <br>
 <br><b> 2.9 </b><br>
 <br>Find the complement of the following expressions: <br>
    <br>
(a)  <b>*</b>   <i>xy  </i>+<i> x y</i> <br>
 <br>(b)<b>  </b> (<i>a </i>+<i> c</i>)<i> </i>(<i>a </i>+<i> b </i>)<i> </i>(<i>a  </i>+<i> b </i>+<i> c </i>)   <br>
   <br>
(c)  <b>  </b> <i>z </i>+<i> z </i>(<i>v w </i>+<i> xy</i>) <br>
 <br><b> 2.10 </b><br>
 <br>Given the Boolean functions   <i>F</i>1     and   <i>F </i>2 <i> ,</i>  show that <br>
 <br>
(a)<b>  </b>  The  Boolean  function     <i>E </i>= <i>F</i>1 + <i>F</i>2  contains the sum of the minterms of   <i>F</i>1     and     <i>F</i>2. <br>
   <br>
(b)<b>  </b>  The  Boolean  function     <i>G </i>= <i>F</i>1<i>F</i>2  contains only the minterms that are common to   <i>F</i>1 <br>
and     <i>F</i>2. <br>
 <br><b> 2.11 </b><br>
 <br>List the truth table of the function: <br>
    <br>
(a)  <b>*</b>   <i>F </i>=<i> xy </i>+<i> xy  </i>+<i> y z</i> <br>
 <br>(b)<b>  </b> <i>F </i>=    <i>bc </i>+<i> a c </i> <br>
 <br><b> 2.12 </b><br>
 <br>We can perform logical operations on strings of bits by considering each pair of correspond-<br>ing bits separately (called bitwise operation). Given two eightbit strings   <i>A</i> = 10110001 <br>and  <i>B</i> = 10101100, evaluate the eightbit result after the following logical operations: <br>
  <br>
(a)<b>*</b> <br>
AND  (b) <br>
OR  (c)<b>*</b> <br>
XOR  (d)<b>*</b> NOT  <br>
<i>A</i> <br>
  (e) <br>
NOT <br>
 <br>
<i>B</i> <br>
<hr>
<A name=88></a><b>70    Chapter 2  Boolean Algebra and Logic Gates</b><br>
 <br><b> 2.13 </b><br>
 <br>Draw logic diagrams to implement the following Boolean expressions: <br>
    <br>
(a)     <i>y </i>=<i> </i>[(<i>u </i>+<i> x </i>) (<i>y  </i>+<i> z</i>)]   <br>
   <br>
(b)<b>  </b> <i>y </i>=<i> </i>(<i>u </i><br>
<i> y</i>) <i> </i>+<i> x</i> <br>
   <br>
(c)     <i>y </i>=<i> </i>(<i>u  </i>+<i> x </i>) (<i>y </i>+<i> z </i>)   <br>
   <br>
(d)     <i>y </i>=<i> u</i>(<i>x </i><br>
<i> z</i>)<i> </i>+<i> y </i> <br>
   <br>
(e)<b>  </b> <i>y </i>=<i> u </i>+<i> yz </i>+<i> uxy</i> <br>
   <br>
(f)     <i>y </i>=<i> u </i>+<i> x </i>+<i> x </i>(<i>u </i>+<i> y </i>) <br>
 <br><b> 2.14 </b><br>
 <br>Implement the Boolean function <br>
 <br><i>F </i>= <i>xy</i>  +  <i>x y </i>  +  <i>y z</i> <br>
    <br>
(a)      With  AND,  OR,  and  inverter  gates  <br>
   <br>
(b)  <b>*</b>  With OR and inverter gates  <br>
   <br>
(c)  <b>  </b> With AND and inverter gates  <br>
   <br>
(d)  <b>  </b> With NAND and inverter gates  <br>
   <br>
(e)  <b>  </b>  With  NOR  and  inverter  gates     <br>
 <br><b> 2.15* </b> Simplify the following Boolean functions   <i>T</i>1     and     <i>T</i>2  to a minimum number of literals: <br>
<i><b> <br>A  </b></i><br>
<i><b> <br>B  </b></i><br>
<i><b> <br>C  </b></i><br>
<i><b> <br>T  </i>1 </b><br>
<i><b> <br>T  </i>2<i> </b></i><br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 <br><b> 2.16 </b><br>
 <br>The logical sum of all minterms of a Boolean function of  <i>n</i>  variables is 1. <br>
 <br>
(a)<b>  </b> Prove the previous statement for  <i>n</i> = 3. <br>
   <br>
(b)<b>  </b> Suggest a procedure for a general proof. <br>
 <br><b> 2.17 </b><br>
 <br>Obtain the truth table of the following functions, and express each function in sumofmin-<br>terms and productofmaxterms form: <br>
    <br>
(a)  <b>*</b>   (<i>b </i>+<i> cd</i>)(<i>c </i>+<i> bd</i>)    <br>
  (b)<b>  </b> (<i>cd </i>+<i> b c </i>+<i> bd </i>)(<i>b </i>+<i> d</i>)   <br>
   <br>
(c)  <b>  </b> (<i>c  </i>+<i> d</i>)(<i>b </i>+<i> c </i>)    <br>
  (d)<b>  </b> <i>bd  </i>+<i> acd  </i>+<i> ab c </i>+<i> a c </i> <br>
 <br><b> 2.18 </b><br>
 <br>For the Boolean function <br>
 <br>
 <br><i>F </i>= <i>xy z</i>  +  <i>x y z</i>  +  <i>w xy</i>  +  <i>wx y</i>  +  <i>wxy</i> <br>
    <br>
(a)      Obtain  the  truth  table  of   <i>F.</i> <br>
   <br>
(b)  <b>  </b> Draw the logic diagram, using the original Boolean expression. <br>
   <br>
(c)  <b>*</b>  Use Boolean algebra to simplify the function to a minimum number of literals. <br>
 <br>
(d)     Obtain the truth table of the function from the simplified expression and show that <br>
it is the same as the one in part (a). <br>
   <br>
(e)  <b>   </b>Draw the logic diagram from the simplified expression, and compare the total number <br>
of gates with the diagram of part (b). <br>
<hr>
<A name=89></a><b>Problems    71</b><br>
 <br><b> 2.19* </b> Express the following function as a sum of minterms and as a product of maxterms: <br>
 <br><i>F</i>(<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>) = <i>B D </i>+ <i>A D </i>+ <i>BD</i> <br>
 <br><b> 2.20 </b><br>
 <br>Express the complement of the following functions in sumofminterms form: <br>
 <br>
(a)<b>  </b> <i>F</i>(<i>A,B ,C, D</i>)<i> </i>=<i>  </i>g (2, 4, 7, 10, 12, 14)  <br>
 <br>
  (b)<b>  </b> <i>F</i> ( <i>x, y, z</i> )  =  w (3,  5,  7)      <br>
 <br><b> 2.21 </b><br>
 <br>Convert each of the following to the other canonical form: <br>
 <br>
(a)<b>  </b> <i>F</i>(<i>x, y, z</i>)<i> </i>=<i>  </i>g (1, 3, 5)  <br>
 <br>
  (b)<b>  </b> <i>F</i>(<i>A, B, C, D</i>)    =<i>  </i>w (3,  5,  8,  11)      <br>
 <br><b> 2.22* </b> Convert each of the following expressions into sum of products and product of sums: <br> <br>
(a)<b>  </b> ( <i>u </i>+<i> xw</i> )( <i>x </i>+<i> u v</i> )  <br>
 <br>
  (b)       <i>x </i>  +  <i>x</i>(<i>x</i>  +  <i>y </i>)(<i>y</i>  +  <i>z </i>) <br>
 <br><b> 2.23 </b><br>
 <br>Draw the logic diagram corresponding to the following Boolean expressions without sim-<br>plifying them: <br>
 <br>
(a)<b>  </b> <i>BC </i> +  <i>AB</i>  +  <i>ACD</i> <br>
 <br>
  (b)<b>  </b> (<i>A</i>  +  <i>B</i>)(<i>C</i>  +  <i>D</i>)(<i>A </i>  +  <i>B</i>  +  <i>D</i>) <br>
   <br>
(c)<b>  </b> (<i>AB</i>  +  <i>A B </i>)(<i>CD </i>  +  <i>C D</i>) <br>
 <br>
  (d)<b>  </b> <i>A </i>+<i> CD </i>+<i> </i>(<i>A </i>+<i> D'</i>)(<i>C' </i>+<i> D</i>) <br>
 <br><b> 2.24 </b><br>
 <br>Show that the dual of the exclusiveOR is equal to its complement. <br>
 <br><b> 2.25 </b><br>
 <br>By substituting the Boolean expression equivalent of the binary operations as defined in <br> Table    2.8   ,  show  the  following: <br>
 <br>
(a)<b>  </b> The inhibition operation is neither commutative nor associative. <br>
   <br>
(b)<b>  </b> The exclusiveOR operation is commutative and associative. <br>
 <br><b> 2.26 </b><br>
 <br>Show that a positive logic NAND gate is a negative logic NOR gate and vice versa. <br>
 <br><b> 2.27 </b><br>
 <br>Write the Boolean equations and draw the logic diagram of the circuit whose outputs are <br>defined by the following truth table: <br>
<b> <br>Table P2.27</b><br>
<b> <br><i>f</i> 1 </b><br>
<b> <br><i>f</i> 2 </b><br>
<b> <br><i>a</i> </b><br>
<b> <br><i>b</i> </b><br>
<b> <br><i>c </b></i><br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 <br><b> 2.28 </b><br>
 <br>Write Boolean expressions and construct the truth tables describing the outputs of the <br>circuits described by the logic diagrams in Fig. P2.28. <br>
 <br><b> 2.29 </b><br>
 <br>Determine whether the following Boolean equation is true or false. <br>
 <br>
 <i>x y </i>+ <i>x z </i>+ <i>x z </i>= <i>x z </i>+ <i>y z </i>+ <i>x z</i> <br>
<hr>
<A name=90></a><b>72    Chapter 2  Boolean Algebra and Logic Gates</b><br>
<i>a</i><br>
<i>y</i>1<br>
<i>a</i><br>
<i>b</i><br>
<i>b</i><br>
<i>c</i><br>
<i>c</i><br>
<i>y</i><br>
<i>d</i><br>
<i>y</i>2<br>
<i>d</i><br>
<i>e</i><br>
<i>e</i><br>
<i>f</i><br>
(a)<br>
(b)<br>
<b> <br>FIGURE P2.28 </b><br>
 <br><b> 2.30 </b><br>
 <br>Write the following Boolean expressions in sum of products form: <br>
 <br>
 <br>(<i>b </i>+ <i>d</i>)(<i>a </i>+ <i>b </i>+ <i>c</i>) <br>
 <br><b> 2.31 </b><br>
 <br>Write the following Boolean expression in product of sums form: <br>
 <br>
 <br><i>a b </i>+ <i>a c </i>+ <i>abc</i> <br>
<b> <br>R E F E R E N C E S </b><br>
<b> </b><br>
<b> <br>1. </b> <br>
B oole,   G.  1854.  <i>An Investigation of the Laws of Thought</i>. New York: Dover. <br>
<b> </b><br>
<b> <br>2. </b> <br>
D ietmeyer,  D. L. 1988. <i>Logic Design of Digital Systems</i>, 3rd ed. Boston: Allyn and Bacon. <br>
<b> </b><br>
<b> <br>3. </b> <br>
H untington,  E. V. Sets of independent postulates for the algebra of logic. <i>Trans. Am. Math. <br>Soc.</i>, 5 (1904): 288�309. <br>
<b> </b><br>
<b> <br>4. </b> <br>
<i>IEEE Standard Hardware Description Language Based on the Verilog Hardware Descrip-<br>tion Language</i>, Language Reference Manual (LRM), IEEE Std.13641995, 1996, 2001, <br>2005, The Institute of Electrical and Electronics Engineers, Piscataway, NJ. <br>
<b> </b><br>
<b> <br>5. </b> <br>
<i>IEEE Standard VHDL Language Reference Manual</i> (LRM), IEEE Std. 10761987, 1988, <br>The Institute of Electrical and Electronics Engineers, Piscataway, NJ. <br>
<b> </b><br>
<b> <br>6. </b> <br>
M ano,  M. M. and C. R. K ime . 2000. <i>Logic and Computer Design Fundamentals</i>, 2nd ed. <br>Upper Saddle River, NJ: Prentice Hall. <br>
<b> </b><br>
<b> <br>7. </b> <br>
S hannon,  C. E. A symbolic analysis of relay and switching circuits. <i>Trans.</i> <i>AIEE</i>, 57 (1938): <br>713�723.    <br>
<b>W E B   S E A R C H   T O P I C S</b><br>
  <br>
Algebraic <br>
field<br>
  <br>
Boolean <br>
logic<br>
  <br>
Boolean <br>
gates<br>
  <br>
Bipolar <br>
transistor<br>
  <br>
Field-effect <br>
transistor<br>
  <br>
Emitter-coupled <br>
logic<br>
  <br>
TTL <br>
logic<br>
  <br>
CMOS <br>
logic<br>
  <br>
CMOS <br>
process<br>
<hr>
<A name=91></a> <br>Chapter 3 <br>
<b> <br>Gate-Level Minimization  </b><br>
<b> <br>3 . 1       IN T R O D U C T I O N </b><br>
 <br><i>Gate-level minimization</i>  is the design task of finding an optimal gate-level implementa-<br>tion of the Boolean functions describing a digital circuit. This task is well understood, <br>but is difficult to execute by manual methods when the logic has more than a few inputs. <br>Fortunately, computer-based logic synthesis tools can minimize a large set of Boolean <br>equations efficiently and quickly. Nevertheless, it is important that a designer understand <br>the underlying mathematical description and solution of the problem. This chapter serves <br>as a foundation for your understanding of that important topic and will enable you to <br>execute a manual design of simple circuits, preparing you for skilled use of modern <br>design tools. The chapter will also introduce a hardware description language that is used <br>by modern design tools. <br>
<b> <br>3 . 2       T H E   M A P   M E T H O D </b><br>
 <br>The complexity of the digital logic gates that implement a Boolean function is directly <br>related to the complexity of the algebraic expression from which the function is imple-<br>mented. Although the truth table representation of a function is unique, when it is expressed <br>algebraically it can appear in many different, but equivalent, forms. Boolean expressions may <br>be simplified by algebraic means as discussed in Section 2.4. However, this procedure of <br>minimization is awkward because it lacks specific rules to predict each succeeding step in <br>the manipulative process. The map method presented here provides a simple, straightforward <br>procedure for minimizing Boolean functions. This method may be regarded as a pictorial <br>form of a truth table. The map method is also known as the  <i>Karnaugh map</i>  or  <i>K-map</i> . <br>
<b>73</b><br>
<hr>
<A name=92></a><b>74    Chapter 3  Gate-Level Minimization</b><br>
 <br>A K-map is a diagram made up of squares, with each square representing one minterm <br>
of the function that is to be minimized. Since any Boolean function can be expressed as a <br>sum of minterms, it follows that a Boolean function is recognized graphically in the map <br>from the area enclosed by those squares whose minterms are included in the function. In <br>fact, the map presents a visual diagram of all possible ways a function may be expressed <br>in standard form. By recognizing various patterns, the user can derive alternative algebraic <br>expressions for the same function, from which the simplest can be selected. <br>
 <br>The simplified expressions produced by the map are always in one of the two standard <br>
forms: sum of products or product of sums. It will be assumed that the simplest algebraic <br>expression is an algebraic expression with a minimum number of terms and with the <br>smallest possible number of literals in each term. This expression produces a circuit <br>diagram with a minimum number of gates and the minimum number of inputs to each <br>gate. We will see subsequently that the simplest expression is not unique: It is sometimes <br>possible to find two or more expressions that satisfy the minimization criteria. In that <br>case, either solution is satisfactory. <br>
<b> <br>Two-Variable K-Map </b><br>
 <br>The two-variable map is shown in  Fig.   3.1  (a). There are four minterms for two variables; <br>hence, the map consists of four squares, one for each minterm. The map is redrawn in <br>(b) to show the relationship between the squares and the two variables  <i>x</i>  and  <i>y</i> .  The  0 <br>and 1 marked in each row and column designate the values of variables. Variable  <i>x</i> <br>appears primed in row 0 and unprimed in row 1. Similarly,  <i>y</i>  appears primed in column <br>0 and unprimed in column 1. <br>
 <br>If we mark the squares whose minterms belong to a given function, the two-variable <br>
map becomes another useful way to represent any one of the 16 Boolean functions of <br>two variables. As an example, the function  <i>xy</i>   is  shown  in   Fig.    3.2   (a).  Since   <i>xy</i>  is equal to <br> <br><i>m</i>3,  a 1 is placed inside the square that belongs to   <i>m</i>3.     Similarly,  the  function     <i>x </i>+ <i>y</i> is <br>represented in the map of  Fig.   3.2  (b) by three squares marked with 1's. These squares <br>are found from the minterms of the function: <br>
 <br><i>m</i>1 + <i>m</i>2 + <i>m</i>3 = <i>x y </i>+ <i>xy </i>+ <i>xy </i>= <i>x </i>+ <i>y</i> <br>
<i>y</i><br>
<i>y</i><br>
<i>x</i><br>
0<br>
1<br>
<i>m</i><br>
<i>m</i><br>
0<br>
1<br>
<i>m</i>0<br>
<i>m</i>1<br>
0<br>
<i>x y</i><br>
<i>x y</i><br>
<i>m</i><br>
<i>m</i><br>
2<br>
3<br>
<i>m</i>2<br>
<i>m</i>3<br>
<i>x</i><br>
1<br>
<i>xy</i><br>
<i>xy</i><br>
(a)<br>
(b)<br>
<b> <br>FIGURE 3.1 <br> <br>Two-variable K-map  </b><br>
<hr>
<A name=93></a><b>Section 3.2  The Map Method    75</b><br>
<i>y</i><br>
<i>y</i><br>
<i>y</i><br>
<i>y</i><br>
<i>x</i><br>
0<br>
1<br>
<i>x</i><br>
0<br>
1<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>y</i><br>
0<br>
1<br>
0<br>
1<br>
0<br>
0<br>
1<br>
<i>m</i><br>
<i>m</i><br>
2<br>
3<br>
<i>m</i><br>
<i>m</i><br>
2<br>
3<br>
<i>x</i><br>
1<br>
1<br>
<i>x</i><br>
1<br>
1<br>
1<br>
<i>x</i><br>
(a) <i>xy</i><br>
(b) <i>x</i><br>
<i> y</i><br>
<b> <br>FIGURE 3.2 <br> <br>Representation of functions in the map  </b><br>
 <br>The three squares could also have been determined from the intersection of variable <br> <br><i>x</i>  in the second row and variable  <i>y</i>  in the second column, which encloses the area <br>belonging to  <i>x</i>  or  <i>y</i> . In each example, the minterms at which the function is asserted are <br>marked with a 1. <br>
<b> <br>Three-Variable K-Map </b><br>
 <br>A three-variable K-map is shown in  Fig.   3.3  . There are eight minterms for three binary <br>variables; therefore, the map consists of eight squares. Note that the minterms are <br>arranged, not in a binary sequence, but in a sequence similar to the Gray code ( Table   1.6  ). <br>The characteristic of this sequence is that  <b>only one bit changes in value from one adjacent <br>column to the next.</b> The map drawn in part (b) is marked with numbers in each row and <br>each column to show the relationship between the squares and the three variables. For <br>example, the square assigned to   <i>m</i>5  corresponds to row 1 and column 01. When these two <br>numbers are concatenated, they give the binary number 101, whose decimal equivalent <br>is 5. Each cell of the map corresponds to a unique minterm, so another way of looking at <br>square     <i>m</i>5 = <i>xy z</i>  is to consider it to be in the row marked  <i>x</i>  and the column belonging <br>to     <i>y z</i>  (column 01). Note that there are four squares in which each variable is equal to 1 <br>and four in which each is equal to 0. The variable appears unprimed in the former four <br>
<i>y</i><br>
<i>yz</i><br>
<i>x</i><br>
00<br>
01<br>
11<br>
10<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
0<br>
1<br>
3<br>
2<br>
<i>m</i>0<br>
<i>m</i>1<br>
<i>m</i>3<br>
<i>m</i>2<br>
0 <i>x y z</i><br>
<i>x y z</i><br>
<i>x yz</i><br>
<i>x yz</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
7<br>
6<br>
<i>m</i>4<br>
<i>m</i>5<br>
<i>m</i>7<br>
<i>m</i>6<br>
<i>x</i><br>
1<br>
<i>xy z</i><br>
<i>xy z</i><br>
<i>xyz</i><br>
<i>xyz</i><br>
<i>z</i><br>
(a)<br>
(b)<br>
<b> <br>FIGURE 3.3 <br> <br>Three-variable K-map  </b><br>
<hr>
<A name=94></a><b>76    Chapter 3  Gate-Level Minimization</b><br>
squares and primed in the latter. For convenience, we write the variable with its letter <br>symbol under the four squares in which it is unprimed.  <br>
 <br>To understand the usefulness of the map in simplifying Boolean functions, we must <br>
recognize the basic property possessed by adjacent squares:  <b>Any two adjacent squares <br>in the map differ by only one variable,</b>  which is primed in one square and unprimed in <br>the other. For example,   <i>m</i>5     and     <i>m</i>7  lie in two adjacent squares. Variable  <i>y</i>  is primed in <br> <br><i>m</i>5     and  unprimed  in     <i>m</i>7,  whereas the other two variables are the same in both squares. <br>From the postulates of Boolean algebra, it follows that the sum of two minterms in <br>adjacent squares can be simplified to a single product term consisting of only two liter-<br>als. To clarify this concept, consider the sum of two adjacent squares such as   <i>m</i>5     and     <i>m</i>7:    <br>
 <br><i>m</i>5 + <i>m</i>7 = <i>xy z </i>+ <i>xyz </i>= <i>xz</i>(<i>y </i>+ <i>y</i>) = <i>xz</i> <br>
 <br>Here, the two squares differ by the variable  <i>y</i> , which can be removed when the sum of <br>the two minterms is formed. Thus, any two minterms in adjacent squares (vertically or <br>horizontally, but not diagonally, adjacent) that are ORed together will cause a removal <br>of the dissimilar variable. The next four examples explain the procedure for minimizing <br>a Boolean function with a K-map. <br>
<b> <br>EXAMPLE 3.1 </b><br>
 <br>Simplify the Boolean function <br>
 <br><i>F</i> (<i>x</i>, <i>y</i>, <i>z</i>) =<br>
(2, 3, 4, 5)   <br>
 <br>First, a 1 is marked in each minterm square that represents the function. This is shown <br>in  Fig.   3.4  , in which the squares for minterms 010, 011, 100, and 101 are marked with 1's. <br>The next step is to find possible adjacent squares. These are indicated in the map by two <br>shaded rectangles, each enclosing two 1's. The upper right rectangle represents the area <br>enclosed by   <i>x y</i>. This area is determined by observing that the two-square area is in row <br>0, corresponding to   <i>x </i>,  and the last two columns, corresponding to  <i>y</i> . Similarly, the lower <br>left rectangle represents the product term   <i>xy </i>.  (The second row represents  <i>x</i>  and the <br>two left columns represent   <i>y </i>. ) The sum of four minterms can be replaced by a sum of <br>
<i>y</i><br>
<i>yz</i><br>
<i>x y</i><br>
<i>x</i><br>
00<br>
01<br>
11<br>
10<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
0<br>
1<br>
3<br>
2<br>
0<br>
1<br>
1<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
7<br>
6<br>
<i>x</i><br>
1<br>
1<br>
1<br>
<i>z</i><br>
<i>xy</i><br>
<b> <br>FIGURE 3.4 <br> <br>Map for  Example   3.1  ,   <i>F </i>(<i>x, y, z</i>) </b>=<br>
<b>(2, 3, 4, 5) </b>= <b><i>x y </b></i>+ <b><i>xy </i> </b><br>
<hr>
<A name=95></a><b>Section 3.2  The Map Method    77</b><br>
only two product terms. The logical sum of these two product terms gives the simplified <br>expression <br>
 <br><i>F </i>= <i>x y </i>+ <i>xy </i> <br>
<br>
 <br>In certain cases, two squares in the map are considered to be adjacent even though <br>
they  do  not  touch  each  other.  In   Fig.    3.3   (b),     <i>m</i>0     is  adjacent  to     <i>m</i>2     and     <i>m</i>4     is  adjacent  to <br> <br><i>m</i>6  because their minterms differ by one variable. This difference can be readily verified <br>algebraically: <br>
 <br><i>m</i>0 + <i>m</i>2 = <i>x y z </i>+ <i>x yz </i>= <i>x z </i>(<i>y </i>+ <i>y</i>) = <i>x z </i> <br> <br><i>m</i>4 + <i>m</i>6 = <i>xy z </i>+  <i>xyz </i>   =     <br>
<i>xz </i>  + (<i>y </i>+ <i>y</i>) = <i>xz </i> <br>
 <br>Consequently, we must modify the definition of adjacent squares to include this and <br>other similar cases. We do so by considering the map as being drawn on a surface in <br>which the right and left edges touch each other to form adjacent squares. <br>
<b> <br>EXAMPLE 3.2 </b><br>
 <br>Simplify the Boolean function <br>
 <br><i>F </i>(<i>x</i>, <i>y</i>, <i>z</i>) =<br>
(3, 4, 6, 7)   <br>
 <br>The map for this function is shown in  Fig.   3.5  . There are four squares marked with 1's, <br>one for each minterm of the function. Two adjacent squares are combined in the third <br>column to give a two-literal term  <i>yz</i> . The remaining two squares with 1's are also adja-<br>cent by the new definition. These two squares, when combined, give the two-literal term <br> <i>xz </i>. The simplified function then becomes <br>
 <br><i>F </i>= <i>yz </i>+ <i>xz </i> <br>
<i>y</i><br>
<i>yz</i><br>
<i>x</i><br>
00<br>
01<br>
11<br>
10<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>yz</i><br>
0<br>
1<br>
3<br>
2<br>
0<br>
1<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
7<br>
6<br>
<i>x</i><br>
1<br>
1<br>
1<br>
1<br>
<i>z</i><br>
<i>xy z</i><br>
<i>xyz</i><br>
<i>Note: xy z</i><br>
<i> xyz</i><br>
<i> xz</i><br>
<b> <br>FIGURE 3.5 <br> <br>Map for  Example   3.2  ,   <i>F </i>(<i>x, y, z</i>) </b>=<br>
<b>(3, 4, 6, 7) </b>= <b><i>yz </b></i>+ <b><i>xz </i> </b><br>
<br>
<hr>
<A name=96></a><b>78    Chapter 3  Gate-Level Minimization</b><br>
 <br>Consider now any combination of four adjacent squares in the three-variable map. <br>
Any such combination represents the logical sum of four minterms and results in an <br>expression with only one literal. As an example, the logical sum of the four adjacent <br>minterms 0, 2, 4, and 6 reduces to the single literal term   <i>z </i>:    <br>
 <br><i>m</i>0 + <i>m</i>2 + <i>m</i>4 + <i>m</i>6 = <i>x y z </i>+ <i>x yz </i>+ <i>xy z </i>+ <i>xyz</i><br>
= <i>x z </i>(<i>y </i>+ <i>y</i>) + <i>xz </i>(<i>y </i>+ <i>y</i>)<br>
= <i>x z </i>+ <i>xz </i>= <i>z </i>(<i>x </i>+ <i>x</i>) = <i>z </i> <br>
 <br>The number of adjacent squares that may be combined must always represent a <br>
number that is a power of two, such as 1, 2, 4, and 8. As more adjacent squares are com-<br>bined, we obtain a product term with fewer literals. <br>
 <br>One square represents one minterm, giving a term with three literals. <br> <br>Two adjacent squares represent a term with two literals. <br> <br>Four adjacent squares represent a term with one literal. <br> <br>Eight adjacent squares encompass the entire map and produce a function that is <br>always equal to 1. <br>
<b> <br>EXAMPLE 3.3 </b><br>
 <br>Simplify the Boolean function <br>
 <br><i>F</i> (<i>x</i>, <i>y</i>, <i>z</i>) =<br>
(0, 2, 4, 5, 6) <br>
 <br>The map for  <i>F</i>  is shown in  Fig.   3.6  . First, we combine the four adjacent squares in the <br>first and last columns to give the single literal term   <i>z </i>.     The  remaining  single  square, <br>representing minterm 5, is combined with an adjacent square that has already been used <br>once. This is not only permissible, but rather desirable, because the two adjacent squares <br>give the two-literal term   <i>xy </i>  and the single square represents the three-literal minterm <br> <i>xy z</i>.     The  simplified  function  is <br>
 <br><i>F </i>= <i>z </i>+ <i>xy </i> <br>
<i>y</i><br>
<i>yz</i><br>
<i>x</i><br>
00<br>
01<br>
11<br>
10<br>
<i>y z</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>yz</i><br>
0<br>
1<br>
3<br>
2<br>
0<br>
1<br>
1<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
7<br>
6<br>
<i>x</i><br>
1<br>
1<br>
1<br>
1<br>
<i>z</i><br>
<i>xy</i><br>
<i>Note: y z</i><br>
<i> yz</i><br>
<i> z</i><br>
<b> <br>FIGURE 3.6 <br> <br>Map for  Example   3.3  ,   <i>F (x, y, z) </b></i>=<br>
<b>(0, 2, 4, 5, 6) </b>= <b><i>z </b></i>+ <b><i>xy </i> </b><br>
<br>
<hr>
<A name=97></a><b>Section 3.2  The Map Method    79</b><br>
 <br>If a function is not expressed in sum-of-minterms form, it is possible to use the map to <br>
obtain the minterms of the function and then simplify the function to an expression with a <br>minimum number of terms. It is necessary, however, to make sure that the algebraic expres-<br>sion is in sum-of-products form. Each product term can be plotted in the map in one, two, <br>or more squares. The minterms of the function are then read directly from the map. <br>
<b> <br>EXAMPLE 3.4 </b><br>
 <br>For the Boolean function <br>
 <br><i>F </i>= <i>A C </i>+ <i>A B </i>+ <i>AB C </i>+ <i>BC</i> <br>
 <br>
(a)  Express this function as a sum of minterms. <br>
   <br>
(b)    Find  the  minimal  sum-of-products  expression.   <br>
 Note  that  <i>F</i> is a sum of products. Three product terms in the expression have two literals <br>and are represented in a three-variable map by two squares each. The two squares cor-<br>responding to the first term,   <i>A C</i>,     are  found  in   Fig.    3.7     from  the  coincidence  of     <i>A </i>     (first <br>row) and  <i>C</i>  (two middle columns) to give squares 001 and 011. Note that, in marking <br>1's in the squares, it is possible to find a 1 already placed there from a preceding term. <br>This happens with the second term,   <i>A B</i>,  which has 1's in squares 011 and 010. Square <br>011 is common with the first term,   <i>A C</i>,  though, so only one 1 is marked in it. Continu-<br>ing in this fashion, we determine that the term   <i>AB C</i>  belongs in square 101, correspond-<br>ing to minterm 5, and the term  <i>BC</i>  has two 1's in squares 011 and 111. The function has <br>a total of five minterms, as indicated by the five 1's in the map of  Fig.   3.7 .  The minterms <br>are read directly from the map to be 1, 2, 3, 5, and 7. The function can be expressed in <br>sum-of-minterms form as  <br>
 <br><i>F</i> (<i>A</i>,<i> B</i>,<i> C </i>) =<br>
(1, 2, 3, 5, 7) <br>
 <br>The sum-of-products expression, as originally given, has too many terms. It can be <br>simplified, as shown in the map, to an expression with only two terms: <br>
 <br><i>F </i>= <i>C </i>+ <i>A B</i> <br>
<i>B</i><br>
<i>BC</i><br>
<i>A</i><br>
<i>A B</i><br>
00<br>
01<br>
11<br>
10<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
0<br>
1<br>
3<br>
2<br>
0<br>
1<br>
1<br>
1<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
7<br>
6<br>
<i>A </i>1<br>
1<br>
1<br>
<i>C</i><br>
<i>C</i><br>
<b> <br>FIGURE 3.7 <br> <br>Map of  Example   3.4  ,   <i>A C</b></i><br>
<i><b>A B</b></i><br>
<i><b>AB C</b></i><br>
<i><b>BC</b></i><br>
<i><b>C</b></i><br>
<i><b>A B</i> </b><br>
<br>
<hr>
<A name=98></a><b>80    Chapter 3  Gate-Level Minimization</b><br>
<b> <br>3 . 3     F O U R - VA R I A B L E  K - M A P </b><br>
 <br>The map for Boolean functions of four binary variables (<i>w</i>, <i>x</i>, <i>y</i>, <i>z</i>)  is  shown  in   Fig.    3.8   . <br>In Fig. 3.8(a) are listed the 16 minterms and the squares assigned to each. In Fig. 3.8(b), <br>the map is redrawn to show the relationship between the squares and the four variables. <br>The rows and columns are numbered in a Gray code sequence, with only one digit <br>changing value between two adjacent rows or columns. The minterm corresponding to <br>each square can be obtained from the concatenation of the row number with the column <br>number. For example, the numbers of the third row (11) and the second column (01), <br>when concatenated, give the binary number 1101, the binary equivalent of decimal 13. <br>Thus, the square in the third row and second column represents minterm   <i>m</i>13. <br>
 <br>The map minimization of four-variable Boolean functions is similar to the method <br>
used to minimize three-variable functions. Adjacent squares are defined to be squares <br>next to each other. In addition, the map is considered to lie on a surface with the top <br>and bottom edges, as well as the right and left edges, touching each other to form adja-<br>cent squares. For example,   <i>m</i>0     and     <i>m</i>2  form adjacent squares, as do   <i>m</i>3     and     <i>m</i>11.     The <br>combination of adjacent squares that is useful during the simplification process is easily <br>determined from inspection of the four-variable map: <br>
 <br>One square represents one minterm, giving a term with four literals. <br> <br>Two adjacent squares represent a term with three literals. <br> <br>Four adjacent squares represent a term with two literals. <br> <br>Eight adjacent squares represent a term with one literal. <br>
 <br>Sixteen adjacent squares produce a function that is always equal to 1. <br>
 <br>No other combination of squares can simplify the function. The next two examples <br>
show the procedure used to simplify four-variable Boolean functions. <br>
<i>y</i><br>
<i>yz</i><br>
<i>wx</i><br>
00<br>
01<br>
11<br>
10<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
0<br>
1<br>
3<br>
2<br>
<i>m</i>0<br>
<i>m</i>1<br>
<i>m</i>3<br>
<i>m</i>2<br>
00 <i>w x y z w x y z w x yz w x yz</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
7<br>
6<br>
<i>m</i>4<br>
<i>m</i>5<br>
<i>m</i>7<br>
<i>m</i>6<br>
01 <i>w xy z</i><br>
<i>w xy z</i><br>
<i>w xyz</i><br>
<i>w xyz</i><br>
<i>x</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
12<br>
13<br>
15<br>
14<br>
<i>m</i>12<br>
<i>m</i>13<br>
<i>m</i>15<br>
<i>m</i>14<br>
11 <i>wxy z</i><br>
<i>wxy z</i><br>
<i>wxyz</i><br>
<i>wxyz</i><br>
<i>w</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
8<br>
9<br>
11<br>
10<br>
<i>m</i>8<br>
<i>m</i>9<br>
<i>m</i>11<br>
<i>m</i>10<br>
10 <i>wx y z</i><br>
<i>wx y z</i><br>
<i>wx yz</i><br>
<i>wx yz</i><br>
<i>z</i><br>
(a)<br>
(b)<br>
<b> <br>FIGURE 3.8 <br> <br>Four-variable map  </b><br>
<hr>
<A name=99></a><b>Section 3.3  Four-Variable K-Map    81</b><br>
<b> <br>EXAMPLE 3.5 </b><br>
 <br>Simplify the Boolean function <br>
 <br><i>F</i> (<i>w</i>, <i>x</i>, <i>y</i>, <i>z</i>) =<br>
(0, 1, 2, 4, 5, 6, 8, 9, 12, 13, 14) <br>
 <br>Since the function has four variables, a four-variable map must be used. The minterms <br>listed in the sum are marked by 1's in the map of  Fig.   3.9  . Eight adjacent squares marked <br>with 1's can be combined to form the one literal term   <i>y </i>. The remaining three 1's on the <br>right cannot be combined to give a simplified term; they must be combined as two or <br>four adjacent squares. The larger the number of squares combined, the smaller is the <br>number of literals in the term. In this example, the top two 1's on the right are combined <br>with the top two 1's on the left to give the term   <i>w z </i> . Note that it is permissible to use <br>the same square more than once. We are now left with a square marked by 1 in the third <br>row and fourth column (square 1110). Instead of taking this square alone (which will <br>give a term with four literals), we combine it with squares already used to form an area <br>of four adjacent squares. These squares make up the two middle rows and the two end <br>columns, giving the term   <i>xz </i>.     The  simplified  function  is  <br>
 <br><i>F </i>= <i>y </i>+ <i>w z </i>+ <i>xz </i> <br>
<i>y</i><br>
<i>yz</i><br>
<i>wx</i><br>
00<br>
01<br>
11<br>
10<br>
<i>w y z</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
0<br>
1<br>
3<br>
2<br>
00<br>
1<br>
1<br>
1<br>
<i>w yz</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
7<br>
6<br>
01<br>
1<br>
1<br>
1<br>
<i>x</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
12<br>
13<br>
15<br>
14<br>
11<br>
1<br>
1<br>
1<br>
<i>xyz</i><br>
<i>xy z w</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
8<br>
9<br>
11<br>
10<br>
10<br>
1<br>
1<br>
<i>z</i><br>
<i>y</i><br>
<i>Note: w y z</i><br>
 <i>w yz</i><br>
<i> w z</i><br>
<i>          xy z</i><br>
 <i>xyz</i><br>
<i> xz</i><br>
<b> <br>FIGURE 3.9 <br> <br>Map for  Example   3.5  ,   <i>F(w, x, y, z)</b></i><br>
<b>(0,1, 2, 4, 5, 6, 8, 9, 12, 13, 14)</b><br>
 <br><b><i>y</b></i><br>
<i><b>w z</b></i><br>
<i><b>xz </i> </b><br>
<br>
<b> <br>EXAMPLE 3.6 </b><br>
 <br>Simplify the Boolean function <br>
 <br><i>F </i>= <i>A B C </i>+ <i>B CD </i>+ <i>A BCD </i>+ <i>AB C </i> <br>
 <br>The area in the map covered by this function consists of the squares marked with 1's in <br> <br>Fig.   3.10  . The function has four variables and, as expressed, consists of three terms with <br>
<hr>
<A name=100></a><b>82    Chapter 3  Gate-Level Minimization</b><br>
<i>A B C</i><br>
<i>C</i><br>
<i>CD</i><br>
<i>AB</i><br>
00<br>
01<br>
11<br>
10<br>
<i>A B C D</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
0<br>
1<br>
3<br>
2<br>
<i>A B CD</i><br>
00<br>
1<br>
1<br>
1<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
7<br>
6<br>
01<br>
1<br>
<i>A CD</i><br>
<i>B</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
12<br>
13<br>
15<br>
14<br>
11<br>
<i>A</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
8<br>
9<br>
11<br>
10<br>
10<br>
1<br>
1<br>
1<br>
<i>AB CD</i><br>
<i>AB C D</i><br>
<i>D</i><br>
<i>AB C</i><br>
<i>Note: A B C D</i><br>
 <i>A B CD</i><br>
<i> A B D</i><br>
<i> AB C D</i><br>
<i> AB CD</i><br>
<i> AB D</i><br>
<i> </i><br>
<i>A B D</i><br>
<i> AB D</i><br>
<i> B D</i><br>
<i> </i><br>
<i>A B C</i><br>
<i> AB C</i><br>
<i> B C</i><br>
<b> <br>FIGURE 3.10 <br> <br>Map for  Example   3.6  ,   <i>A B C</b></i><br>
<i><b>B CD</b></i><br>
<i><b>A BCD</b></i><br>
<i><b>AB C</b></i><br>
<i><b>B D</b></i><br>
<i><b>B C</b></i><br>
<i><b>A CD </i> </b><br>
three literals each and one term with four literals. Each term with three literals is repre-<br>sented in the map by two squares. For example,   <i>A B C </i>  is represented in squares 0000 <br>and 0001. The  function can be simplified in the map by taking the 1's in the four corners <br>to give the term   <i>B D </i>. This is possible because these four squares are adjacent when the <br>map is drawn in a surface with top and bottom edges, as well as left and right edges, <br>touching one another. The two left-hand 1's in the top row are combined with the two <br>1's in the bottom row to give the term   <i>B C </i>. The remaining 1 may be combined in a two-<br>square area to give the term   <i>A CD </i>.     The  simplified  function  is <br>
 <br><i>F </i>= <i>B D </i>+ <i>B C </i>+ <i>A CD </i> <br>
<br>
<b> <br>Prime Implicants </b><br>
 <br>In choosing adjacent squares in a map, we must ensure that (1) all the minterms of the <br>function are covered when we combine the squares, (2) the number of terms in the <br>expression is minimized, and (3) there are no redundant terms (i.e., minterms already <br>covered by other terms). Sometimes there may be two or more expressions that satisfy <br>the simplification criteria. The procedure for combining squares in the map may be made <br>more systematic if we understand the meaning of two special types of terms.  <b>A</b>  <b><i>prime <br>implicant</b></i>  <b>is a product term</b> <b>obtained by combining the maximum possible number of <br>adjacent squares in the map.</b> If a minterm in a square is covered by only one prime <br>implicant, that prime implicant is said to be  <i>essential.</i> <br>
<hr>
<A name=101></a><b>Section 3.3  Four-Variable K-Map    83</b><br>
 <br><b>The prime implicants of a function can be obtained from the map by combining all </b><br>
<b>possible maximum numbers of squares.</b> This means that a single 1 on a map represents <br>a prime implicant if it is not adjacent to any other 1's. Two adjacent 1's form a prime <br>implicant, provided that they are not within a group of four adjacent squares. Four <br>adjacent 1's form a prime implicant if they are not within a group of eight adjacent <br>squares, and so on. The essential prime implicants are found by looking at each square <br>marked with a 1 and checking the number of prime implicants that cover it. The prime <br>implicant is essential if it is the only prime implicant that covers the minterm. <br>
 <br>Consider the following four-variable Boolean function: <br>
 <br><i>F</i>( <i>A</i>,<i> B</i>,<i> C</i>,<i> D</i>) =<br>
(0, 2, 3, 5, 7, 8, 9, 10, 11, 13, 15) <br>
 <br>The minterms of the function are marked with 1's in the maps of  Fig.   3.11 . The partial <br>map (Fig. 3.11(a)) shows two essential prime implicants, each formed by collapsing four <br>cells into a term having only two literals. One term is essential because there is only one <br>way to include minterm   <i>m</i>0  within four adjacent squares. These four squares define the <br>term     <i>B D </i>.  Similarly, there is only one way that minterm   <i>m</i>5  can be combined with four <br>adjacent squares, and this gives the second term  <i>BD</i> . The two essential prime implicants <br>cover eight minterms. The three minterms that were omitted from the partial map <br>(   <i>m</i>3, <i>m</i>9,     and     <i>m</i>11 ) must be considered next.  <br>
 <br>Figure   3.11  (b) shows all possible ways that the three minterms can be covered with <br>
prime implicants. Minterm   <i>m</i>3  can be covered with either prime implicant  <i>CD</i>  or prime <br>implicant     <i>B C.</i>     Minterm     <i>m</i>9  can be covered with either  <i>AD</i>   or     <i>AB </i>.     Minterm     <i>m</i>11 is <br>covered with any one of the four prime implicants. The simplified expression is obtained <br>from the logical sum of the two essential prime implicants and any two prime implicants <br>
<i>C</i><br>
<i>C</i><br>
<i>CD</i><br>
<i>CD</i><br>
<i>AB</i><br>
<i>AB</i><br>
00<br>
01<br>
11<br>
10<br>
00<br>
01<br>
11<br>
10<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>A B CD</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
0<br>
1<br>
3<br>
2<br>
0<br>
1<br>
3<br>
2<br>
00<br>
1<br>
1<br>
00<br>
1<br>
1<br>
1<br>
<i>CD</i><br>
<i>A B C D</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
7<br>
6<br>
4<br>
5<br>
7<br>
6<br>
01<br>
1<br>
1<br>
<i>AD</i><br>
01<br>
1<br>
1<br>
<i>BD</i><br>
<i>B</i><br>
<i>B</i><br>
<i>B C</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
12<br>
13<br>
15<br>
14<br>
12<br>
13<br>
15<br>
14<br>
11<br>
1<br>
1<br>
11<br>
1<br>
1<br>
<i>A</i><br>
<i>A</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
8<br>
9<br>
11<br>
10<br>
8<br>
9<br>
11<br>
10<br>
10<br>
1<br>
1<br>
10<br>
1<br>
1<br>
1<br>
1<br>
<i>AB CD</i><br>
<i>AB C D</i><br>
<i>D</i><br>
<i>D</i><br>
<i>AB</i><br>
<i>Note: A B C D </i>  <i> A B CD</i><br>
<i> A B D</i><br>
<i> AB C D</i><br>
<i> AB CD</i><br>
<i> AB D</i><br>
<i> </i><br>
<i>A B D</i><br>
<i> AB D</i><br>
<i> B D</i><br>
(a) Essential prime implicants<br>
(b) Prime implicants <i>CD</i>, <i>B C</i>,<br>
<i>BD</i> and <i>B D</i><br>
<i>AD</i>, and <i>AB</i><br>
<b> <br>FIGURE 3.11 <br> <br>Simplification using prime implicants  </b><br>
<hr>
<A name=102></a><b>84    Chapter 3  Gate-Level Minimization</b><br>
that cover minterms   <i>m</i>3, <i>m</i>9,     and     <i>m</i>11. There are four possible ways that the function can <br>be expressed with four product terms of two literals each: <br>
  <i>F </i>= <i>BD </i>+ <i>B D </i>+ <i>CD </i>+ <i>AD</i> <br>
      = <i>BD </i>+ <i>B D </i>+ <i>CD </i>+ <i>AB </i> <br>
  = <i>BD </i>+ <i>B D </i>+ <i>B C </i>+ <i>AD </i> <br>
  = <i>BD </i>+ <i>B D </i>+ <i>B C </i>+ <i>AB </i> <br>
 <br>The previous example has demonstrated that the identification of the prime implicants in <br>the map helps in determining the alternatives that are available for obtaining a simplified <br>expression. <br>
 <br>The procedure for finding the simplified expression from the map requires that we <br>
first determine all the essential prime implicants. The simplified expression is obtained <br>from the logical sum of all the essential prime implicants, plus other prime implicants <br>that may be needed to cover any remaining minterms not covered by the essential prime <br>implicants. Occasionally, there may be more than one way of combining squares, and <br>each combination may produce an equally simplified expression. <br>
<b> <br>Five-Variable Map </b><br>
 <br>Maps for more than four variables are not as simple to use as maps for four or fewer <br>variables. A five-variable map needs 32 squares and a six-variable map needs 64 squares. <br>When the number of variables becomes large, the number of squares becomes excessive <br>and the geometry for combining adjacent squares becomes more involved. <br>
 <br>Maps for more than four variables are difficult to use and will not be considered here. <br>
<b> <br>3 . 4       P R O D U C T- O F - S U M S   S I M P L I F I C AT I O N </b><br>
 <br>The minimized Boolean functions derived from the map in all previous examples were <br>expressed in sum-of-products form. With a minor modification, the product-of-sums <br>form can be obtained. <br>
 <br>The procedure for obtaining a minimized function in product-of-sums form follows <br>
from the basic properties of Boolean functions. The 1's placed in the squares of the <br>map represent the minterms of the function. The minterms not included in the standard <br>sum-of-products form of a function denote the complement of the function. From this <br>observation, we see that the complement of a function is represented in the map by <br>the squares not marked by 1's. If we mark the empty squares by 0's and combine them <br>into valid adjacent squares, we obtain a simplified sum-of-products expression of the <br>complement of the function (i.e., of   <i>F </i>   ).  The  complement  of     <i>F </i>  gives us back the func-<br>tion  <i>F</i>  in product-of-sums form (a consequence of DeMorgan's theorem). Because of <br>the generalized DeMorgan's theorem, the function so obtained is automatically in <br>product-of-sums form. The best way to show this is by example. <br>
<hr>
<A name=103></a><b>Section 3.4  Product-of-Sums Simplification    85</b><br>
<b> <br>EXAMPLE 3.7 </b><br>
 <br>Simplify the following Boolean function into (a) sum-of-products form and <br>(b) product-of-sums form: <br>
 <br><i>F</i> (<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>) =<br>
(0, 1, 2, 5, 8, 9, 10) <br>
 <br>The 1's marked in the map of  Fig.   3.12   represent all the minterms of the function. The <br>squares marked with 0's represent the minterms not included in  <i>F</i>  and therefore denote <br>the complement of  <i>F</i> . Combining the squares with 1's gives the simplified function in <br>sum-of-products form: <br>
 <br>
   (a)       <i>F </i>= <i>B D </i>+ <i>B C </i>+ <i>A C D</i> <br>
 <br>If the squares marked with 0's are combined, as shown in the diagram, we obtain <br>the simplified complemented function: <br>
 <br>
 <br>
 <br><i>F </i>= <i>AB </i>+ <i>CD </i>+ <i>BD </i> <br>
 <br>Applying DeMorgan's theorem (by taking the dual and complementing each <br>literal as described in Section 2.4), we obtain the simplified function in product-<br>of-sums form: <br>
 <br>
  (b)       <i>F </i>= (<i>A </i>+ <i>B </i>) (<i>C </i>+ <i>D </i>) (<i>B </i>+ <i>D</i>) <br>
<br>
 <br>The gate-level implementation of the simplified expressions obtained in  Example   3.7   is <br>
shown in  Fig.   3.13  . The sum-of-products expression is implemented in (a) with a group of <br>AND gates, one for each AND term. The outputs of the AND gates are connected to the <br>inputs of a single OR gate. The same function is implemented in (b) in its product-of-sums <br>
<i>C</i><br>
<i>CD</i><br>
<i>AB</i><br>
00<br>
01<br>
11<br>
10<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>CD</i><br>
0<br>
1<br>
3<br>
2<br>
00<br>
1<br>
1<br>
0<br>
1<br>
<i>BCD</i><br>
<i>BC D</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
7<br>
6<br>
01<br>
0<br>
1<br>
0<br>
0<br>
<i>B</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
12<br>
13<br>
15<br>
14<br>
11<br>
0<br>
0<br>
0<br>
0<br>
<i>A</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
8<br>
9<br>
11<br>
10<br>
10<br>
1<br>
1<br>
0<br>
1<br>
<i>AB</i><br>
<i>D</i><br>
<i>Note: BC D</i><br>
<i> BCD</i><br>
<i> BD</i><br>
<b> <br>FIGURE 3.12 <br> <br>Map for  Example   3.7  ,   <i>F </i>(<i>A, B, C, D) </b></i>=<br>
<b>(<i>0,1, 2, 5, 8, 9,10) </b></i>= <b><i>B D </b></i>+ <b><i>B C </b></i>+ <b><i>A C D </b></i>= <b> </b><br>
<b> <br>(<i>A </b></i>+ <b><i>B </i>)(<i>C </b></i>+ <b><i>D </i>)(<i>B </b></i>+ <b><i>D</i>)  </b><br>
<hr>
<A name=104></a><b>86    Chapter 3  Gate-Level Minimization</b><br>
<i>B</i><br>
<i>A</i><br>
<i>D</i><br>
<i>B</i><br>
<i>C</i><br>
<i>F</i><br>
<i>F</i><br>
<i>C</i><br>
<i>D</i><br>
<i>A</i><br>
<i>D</i><br>
<i>D</i><br>
(a)<i> F   B D </i>  <i> B C </i>  <i> A C D</i><br>
(b)<i> F </i><br>
(<i>A </i>   <i>B </i>) (<i>C</i><br>
<i> D </i>) (<i>B </i>  <i> D</i>)<br>
<b> <br>FIGURE 3.13 <br> <br>Gate implementations of the function of  Example   3.7  </b><br>
<b> <br>Table 3.1 <br><i> <br>Truth Table of Function F </b></i><br>
<i><b> <br>x </b></i><br>
<i><b> <br>y </b></i><br>
<i><b> <br>z </b></i><br>
<i><b> <br>F </b></i><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
form with a group of OR gates, one for each OR term. The outputs of the OR gates are <br>connected to the inputs of a single AND gate. In each case, it is assumed that the input <br>variables are directly available in their complement, so inverters are not needed. The con-<br>figuration pattern established in  Fig.   3.13   is the general form by which any Boolean function <br>is implemented when expressed in one of the standard forms. AND gates are connected <br>to a single OR gate when in sum-of-products form; OR gates are connected to a single <br>AND gate when in product-of-sums form. Either configuration forms two levels of gates. <br>Thus, the implementation of a function in a standard form is said to be a two-level imple-<br>mentation. The two-level implementation may not be practical, depending on the number <br>of inputs to the gates. <br>
 <br>Example   3.7   showed the procedure for obtaining the product-of-sums simplifica-<br>
tion when the function is originally expressed in the sum-of-minterms canonical form. <br>The procedure is also valid when the function is originally expressed in the product-<br>of-maxterms canonical form. Consider, for example, the truth table that defines the <br> function   <i>F</i>  in  Table   3.1 . In sum-of-minterms form, this function is expressed as <br>
<b> <br></b><i>F</i> (<i>x</i>, <i>y</i>, <i>z</i>) =<br>
(1, 3, 4, 6) <br>
<hr>
<A name=105></a><b>Section 3.4  Product-of-Sums Simplification    87</b><br>
<i>y</i><br>
<i>yz</i><br>
<i>x</i><br>
00<br>
01<br>
11<br>
10<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
0<br>
1<br>
3<br>
2<br>
<i>x z</i><br>
0<br>
0<br>
1<br>
1<br>
0<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
7<br>
6<br>
<i>x</i><br>
1<br>
1<br>
0<br>
0<br>
1<br>
<i>z</i><br>
<i>xz</i><br>
<b> <br>FIGURE 3.14 <br> <br>Map for the function of  Table   3.1  </b><br>
 <br>In product-of-maxterms form, it is expressed as <br>
 <br><i>F</i> (<i>x</i>, <i>y</i>, <i>z</i>) =<br>
(0, 2, 5, 7) <br>
 <br>In other words, the 1's of the function represent the minterms and the 0's represent <br>the maxterms. The map for this function is shown in  Fig.   3.14  . One can start simplify-<br>ing the function by first marking the 1's for each minterm that the function is a 1. The <br>remaining squares are marked by 0's. If, instead, the product of maxterms is initially <br>given, one can start marking 0's in those squares listed in the function; the remaining <br>squares are then marked by 1's. Once the 1's and 0's are marked, the function can be <br>simplified in either one of the standard forms. For the sum of products, we combine <br>the 1's to obtain <br>
 <br><i>F </i>= <i>x z </i>+ <i>xz </i> <br>
 <br>For the product of sums, we combine the 0's to obtain the simplified complemented <br>function <br>
 <br><i>F </i>= <i>xz </i>+ <i>x z</i><br>
 <br>which shows that the exclusive-OR function is the complement of the equivalence func-<br>tion (Section 2.6). Taking the complement of   <i>F </i>,  we obtain the simplified function in <br>product-of-sums form: <br>
 <br><i>F </i>= (<i>x </i>+ <i>z </i>)(<i>x </i>+ <i>z</i>)   <br>
 <br>To enter a function expressed in product-of-sums form into the map, use the comple-<br>ment of the function to find the squares that are to be marked by 0's. For example, the <br>function <br>
 <br><i>F </i>= (<i>A </i>+ <i>B </i>+ <i>C </i>)(<i>B </i>+ <i>D</i>)   <br>
 <br>can be entered into the map by first taking its complement, namely, <br>
 <br><i>F </i>= <i>ABC </i>+ <i>B D </i> <br>
<hr>
<A name=106></a><b>88    Chapter 3  Gate-Level Minimization</b><br>
 <br>and then marking 0's in the squares representing the minterms of   <i>F </i>.     The  remaining <br>squares are marked with 1's. <br>
<b> <br>3 . 5       D O N ' T- C A R E   C O N D I T I O N S </b><br>
 <br>The logical sum of the minterms associated with a Boolean function specifies the con-<br>ditions under which the function is equal to 1. The function is equal to 0 for the rest of <br>the minterms. This pair of conditions assumes that all the combinations of the values <br>for the variables of the function are valid. In practice, in some applications the function <br>is not specified for certain combinations of the variables. As an example, the four-bit <br>binary code for the decimal digits has six combinations that are not used and conse-<br>quently are considered to be unspecified. Functions that have unspecified outputs for <br>some input combinations are called  <i>incompletely specified functions</i> . In most applica-<br>tions, we simply don't care what value is assumed by the function for the unspecified <br>minterms. For this reason, it is customary to call the unspecified minterms of a function <br> <br><i>don't-care conditions</i> . These don't-care conditions can be used on a map to provide <br>further simplification of the Boolean expression. <br>
 <br>A don't-care minterm is a combination of variables whose logical value is not speci-<br>
fied. Such a minterm cannot be marked with a 1 in the map, because it would require <br>that the function always be a 1 for such a combination. Likewise, putting a 0 on the <br>square requires the function to be 0. To distinguish the don't-care condition from 1's and <br>0's, an  X  is used. Thus, an  X  inside a square in the map indicates that we don't care <br>whether the value of 0 or 1 is assigned to  <i>F</i>  for the particular minterm. <br>
 <br>In choosing adjacent squares to simplify the function in a map, the don't-care min-<br>
terms may be assumed to be either 0 or 1. When simplifying the function, we can choose <br>to include each don't-care minterm with either the 1's or the 0's, depending on which <br>combination gives the simplest expression. <br>
<b> <br>EXAMPLE 3.8 </b><br>
 <br>Simplify the Boolean function <br>
 <br><i>F</i> (<i>w</i>, <i>x</i>, <i>y</i>, <i>z</i>) =<br>
(1, 3, 7, 11, 15) <br>
 <br>which has the don't-care conditions <br>
 <br><i>d</i> (<i>w</i>, <i>x</i>, <i>y</i>, <i>z</i>) =<br>
(0, 2, 5) <br>
 <br>The minterms of  <i>F</i>  are the variable combinations that make the function equal to 1. The <br>minterms of  <i>d</i>  are the don't-care minterms that may be assigned either 0 or 1. The map <br>simplification is shown in  Fig.   3.15  . The minterms of  <i>F</i>  are marked by 1's, those of  <i>d</i>   are <br>marked by X's, and the remaining squares are filled with 0's. To get the simplified expres-<br>sion in sum-of-products form, we must include all five 1's in the map, but we may or may <br>not include any of the X's, depending on the way the function is simplified. The term  <i>yz</i> <br>covers the four minterms in the third column. The remaining minterm,   <i>m</i>1,     can  be  combined <br>
<hr>
<A name=107></a><b>Section 3.5  Don't-Care Conditions    89</b><br>
<i>y</i><br>
<i>y</i><br>
<i>yz</i><br>
<i>yz</i><br>
<i>wx</i><br>
<i>wx</i><br>
00<br>
01<br>
11<br>
10<br>
00<br>
01<br>
11<br>
10<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
0<br>
1<br>
3<br>
2<br>
0<br>
1<br>
3<br>
2<br>
00<br>
X<br>
1<br>
1<br>
X<br>
00<br>
X<br>
1<br>
1<br>
X<br>
<i>w x</i><br>
<i>w z</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
7<br>
6<br>
4<br>
5<br>
7<br>
6<br>
01<br>
0<br>
X<br>
1<br>
0<br>
01<br>
0<br>
X<br>
1<br>
0<br>
<i>x</i><br>
<i>x</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
12<br>
13<br>
15<br>
14<br>
12<br>
13<br>
15<br>
14<br>
11<br>
0<br>
0<br>
1<br>
0<br>
11<br>
0<br>
0<br>
1<br>
0<br>
<i>w</i><br>
<i>w</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
8<br>
9<br>
11<br>
10<br>
8<br>
9<br>
11<br>
10<br>
10<br>
0<br>
0<br>
1<br>
0<br>
10<br>
0<br>
0<br>
1<br>
0<br>
<i>z</i><br>
<i>z</i><br>
<i>yz</i><br>
<i>yz</i><br>
(a) <i>F</i><br>
 <i>yz </i> <i>w x</i><br>
(b) <i>F</i><br>
 <i>yz </i> <i>w z</i><br>
<b> <br>FIGURE 3.15 <br> <br>Example with don't-care conditions  </b><br>
with minterm   <i>m</i>3  to give the three-literal term   <i>w x z</i>.  However, by including one or <br>two adjacent X's we can combine four adjacent squares to give a two-literal term. In <br>Fig. 3.15(a), don't-care minterms 0 and 2 are included with the 1's, resulting in the simpli-<br>fied function <br>
 <br><i>F </i>= <i>yz </i>+ <i>w x </i> <br>
 <br>In Fig. 3.15(b), don't-care minterm 5 is included with the 1's, and the simplified func-<br>tion is now <br>
 <br><i>F </i>= <i>yz </i>+ <i>w z</i> <br>
 <br>Either one of the preceding two expressions satisfies the conditions stated for this <br> example.  <br>
<br>
 <br>The previous example has shown that the don't-care minterms in the map are ini-<br>
tially marked with X's and are considered as being either 0 or 1. The choice between 0 <br>and 1 is made depending on the way the incompletely specified function is simplified. <br>Once the choice is made, the simplified function obtained will consist of a sum of min-<br>terms that includes those minterms which were initially unspecified and have been <br>chosen to be included with the 1's. Consider the two simplified expressions obtained <br>in  Example   3.8  : <br>
 <br><i>F</i> (<i>w</i>, <i>x</i>, <i>y</i>, <i>z</i>) = <i>yz </i>+ <i>w x </i>=<br>
(0, 1, 2, 3, 7, 11, 15)<br>
<i>F</i> (<i>w</i>, <i>x</i>, <i>y</i>, <i>z</i>) = <i>yz </i>+ <i>w z</i>  =<br>
(1, 3, 5, 7, 11, 15) <br>
 <br>Both expressions include minterms 1, 3, 7, 11, and 15 that make the function  <i>F</i>   equal <br>to 1. The don't-care minterms 0, 2, and 5 are treated differently in each expression. <br>
<hr>
<A name=108></a><b>90    Chapter 3  Gate-Level Minimization</b><br>
The first expression includes minterms 0 and 2 with the 1's and leaves minterm 5 with <br>the 0's. The second expression includes minterm 5 with the 1's and leaves minterms 0 <br>and 2 with the 0's. The two expressions represent two functions that are not algebra-<br>ically equal. Both cover the specified minterms of the function, but each covers dif-<br>ferent don't-care minterms. As far as the incompletely specified function is concerned, <br>either expression is acceptable because the only difference is in the value of  <i>F</i>  for the <br>don't-care minterms. <br>
 <br>It is also possible to obtain a simplified product-of-sums expression for the function <br>
of  Fig.   3.15  . In this case, the only way to combine the 0's is to include don't-care minterms <br>0 and 2 with the 0's to give a simplified complemented function: <br>
 <br><i>F </i>= <i>z </i>+ <i>wy </i> <br>
 <br>Taking the complement of   <i>F </i>  gives the simplified expression in product-of-sums form: <br>
 <br><i>F</i> (<i>w</i>, <i>x</i>, <i>y</i>, <i>z</i>) = <i>z</i>(<i>w </i>+ <i>y</i>) =<br>
(1, 3, 5, 7, 11, 15) <br>
 <br>In this case, we include minterms 0 and 2 with the 0's and minterm 5 with the 1's. <br>
<b> <br>3 . 6       N A N D   A N D   N O R   I M P L E M E N TAT I O N </b><br>
 <br>Digital circuits are frequently constructed with NAND or NOR gates rather than with <br>AND and OR gates. NAND and NOR gates are easier to fabricate with electronic <br>components and are the basic gates used in all IC digital logic families. Because of the <br>prominence of NAND and NOR gates in the design of digital circuits, rules and proce-<br>dures have been developed for the conversion from Boolean functions given in terms <br>of AND, OR, and NOT into equivalent NAND and NOR logic diagrams. <br>
<b> <br>NAND Circuits </b><br>
 <br>The NAND gate is said to be a  <i>universal</i>  gate because any logic circuit can be imple-<br>mented with it. To show that any Boolean function can be implemented with NAND <br>gates, we need only show that the logical operations of AND, OR, and complement can <br>be obtained with NAND  gates alone. This is indeed shown in  Fig.   3.16  . The complement <br>operation is obtained from a one-input NAND gate that behaves exactly like an inverter. <br>The AND operation requires two NAND gates. The first produces the NAND operation <br>and the second inverts the logical sense of the signal. The OR operation is achieved <br>through a NAND gate with additional inverters in each input. <br>
 <br><b>A convenient way to implement a Boolean function with NAND gates is to obtain </b><br>
<b>the simplified Boolean function in terms of Boolean operators and then convert the <br>function to NAND logic.</b> The conversion of an algebraic expression from AND, OR, and <br>complement to NAND can be done by simple circuit manipulation techniques that <br>change AND�OR diagrams to NAND diagrams. <br>
 <br>To facilitate the conversion to NAND logic, it is convenient to define an alternative <br>
graphic symbol for the gate. Two equivalent graphic symbols for the NAND gate are <br>shown in  Fig.   3.17 . The AND-invert symbol has been defined previously and consists <br>
<hr>
<A name=109></a><b>Section 3.6  NAND and NOR Implementation    91</b><br>
Inverter <i>x</i><br>
<i>x</i><br>
<i>x</i><br>
<i>xy</i><br>
AND <i>y</i><br>
<i>x</i><br>
(<i>x y </i>)    <i>x</i><br>
 <i>y</i><br>
OR<br>
<i>y</i><br>
<b> <br>FIGURE 3.16 <br> <br>Logic operations with NAND gates  </b><br>
<i>x</i><br>
<i>x</i><br>
<i>y</i><br>
(<i>xyz</i>)<br>
<i>y</i><br>
<i>x </i>   <i>y </i>   <i>z </i>   (<i>xyz</i>)<br>
<i>z</i><br>
<i>z</i><br>
(a) AND-invert <br>
(b) Invert-OR<br>
<b> <br>FIGURE 3.17 <br> <br>Two graphic symbols for a three-input NAND gate  </b><br>
of an AND graphic symbol followed by a small circle negation indicator referred to as <br>a bubble. Alternatively, it is possible to represent a NAND gate by an OR graphic <br>symbol that is preceded by a bubble in each input. The invert-OR symbol for the <br>NAND gate follows DeMorgan's theorem and the convention that the negation indica-<br>tor (bubble) denotes complementation. The two graphic symbols' representations are <br>useful in the analysis and design of NAND circuits. When both symbols are mixed in <br>the same diagram, the circuit is said to be in mixed notation. <br>
<b> <br>Two-Level Implementation </b><br>
 <br><b>The implementation of Boolean functions with NAND gates requires that the functions <br>be in sum-of-products form.</b> To see the relationship between a sum-of-products expres-<br>sion and its equivalent NAND implementation, consider the logic diagrams drawn in <br> <br>Fig.   3.18  . All three diagrams are equivalent and implement the function <br>
 <br><i>F </i>= <i>AB </i>+ <i>CD</i> <br>
 <br>The function is implemented in Fig. 3.18(a) with AND and OR gates. In Fig. 3.18(b), the <br>AND gates are replaced by NAND gates and the OR gate is replaced by a NAND gate <br>with an OR-invert graphic symbol. Remember that a bubble denotes complementation <br>and two bubbles along the same line represent double complementation, so both can be <br>removed. Removing the bubbles on the gates of (b) produces the circuit of (a). Therefore, <br>the two diagrams implement the same function and are equivalent. <br>
<hr>
<A name=110></a><b>92    Chapter 3  Gate-Level Minimization</b><br>
<i>A</i><br>
<i>B</i><br>
<i>F</i><br>
<i>C</i><br>
<i>D</i><br>
(a)<br>
<i>A</i><br>
<i>A</i><br>
<i>B</i><br>
<i>B</i><br>
<i>F</i><br>
<i>F</i><br>
<i>C</i><br>
<i>C</i><br>
<i>D</i><br>
<i>D</i><br>
(b)<br>
(c)<br>
<b> <br>FIGURE 3.18 <br> <br>Three ways to implement  <i>F </b></i>=<b><i> AB </b></i>+<b><i> CD</i> </b><br>
 <br>In  Fig.   3.18  (c), the output NAND gate is redrawn with the AND-invert graphic symbol. <br>
In drawing NAND logic diagrams, the circuit shown in either Fig. 3.18(b) or (c) is accept-<br>able. The one in Fig. 3.18(b) is in mixed notation and represents a more direct relationship <br>to the Boolean expression it implements. The NAND implementation in  Fig.   3.18  (c) can <br>be verified algebraically. The function it implements can easily be converted to sum- of-<br>products form by DeMorgan's theorem: <br>
 <br><i>F </i>= ((<i>AB</i>) (<i>CD</i>) ) = <i>AB </i>+ <i>CD</i> <br>
<b> <br>EXAMPLE 3.9 </b><br>
 <br>Implement the following Boolean function with NAND gates: <br>
 <br><i>F</i> (<i>x</i>, <i>y</i>, <i>z</i>) = (1, 2, 3, 4, 5, 7) <br>
 <br>The first step is to simplify the function into sum-of-products form. This is done by <br>means of the map of  Fig.   3.19  (a), from which the simplified function is obtained: <br>
 <br><i>F </i>= <i>xy </i>+ <i>x y </i>+ <i>z</i> <br>
 <br>The two-level NAND implementation is shown in  Fig.   3.19  (b) in mixed notation. Note <br>that input  <i>z</i>  must have a one-input NAND gate (an inverter) to compensate for the <br>bubble in the second-level gate. An alternative way of drawing the logic diagram is given <br>in  Fig.   3.19  (c). Here, all the NAND gates are drawn with the same graphic symbol. The <br>inverter with input  <i>z</i>  has been removed, but the input variable is complemented and <br>denoted by   <i>z </i>. <br>
<br>
<hr>
<A name=111></a><b>Section 3.6  NAND and NOR Implementation    93</b><br>
<i>y</i><br>
<i>yz</i><br>
<i>x</i><br>
00<br>
01<br>
11<br>
10<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
0<br>
1<br>
3<br>
2<br>
0<br>
0<br>
1<br>
<i>x y</i><br>
1<br>
1<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
7<br>
6<br>
<i>x </i>1<br>
1<br>
1<br>
1<br>
<i>F</i><br>
<i> xy</i><br>
<i> x y</i><br>
<i> z</i><br>
<i>z</i><br>
<i>xy</i><br>
<i>z</i><br>
(a)<br>
<i>x</i><br>
<i>x</i><br>
<i>y</i><br>
<i>y</i><br>
<i>x</i><br>
<i>x</i><br>
<i>F</i><br>
<i>F</i><br>
<i>y</i><br>
<i>y</i><br>
<i>z</i><br>
<i>z</i><br>
(b)<br>
(c)<br>
<b> <br>FIGURE 3.19 <br> <br>Solution to  Example   3.9  </b><br>
 <br>The procedure described in the previous example indicates that a Boolean function <br>
can be implemented with two levels of NAND gates. The procedure for obtaining the <br>logic diagram from a Boolean function is as follows: <br>
 <br><b> 1. </b><br>
 <br>Simplify the function and express it in sum-of-products form. <br>
 <br><b> 2. </b><br>
 <br>Draw a NAND gate for each product term of the expression that has at least two <br>literals. The inputs to each NAND gate are the literals of the term. This procedure <br>produces a group of first-level gates. <br>
 <br><b> 3. </b><br>
 <br>Draw a single gate using the AND-invert or the invert-OR graphic symbol in the <br>second level, with inputs coming from outputs of first-level gates. <br>
 <br><b> 4. </b><br>
 <br>A term with a single literal requires an inverter in the first level. However, if the <br>single literal is complemented, it can be connected directly to an input of the second-<br>level NAND gate. <br>
<b> <br>Multilevel NAND Circuits </b><br>
 <br>The standard form of expressing Boolean functions results in a two-level implementation. <br>There are occasions, however, when the design of digital systems results in gating structures <br>with three or more levels. The most common procedure in the design of multilevel circuits <br>is to express the Boolean function in terms of AND, OR, and complement operations. The <br>function can then be implemented with AND and OR gates. After that, if necessary, it can <br>be converted into an all-NAND circuit. Consider, for example, the Boolean function <br>
 <br><i>F </i>= <i>A </i>(<i>CD </i>+ <i>B</i>) + <i>BC </i> <br>
<hr>
<A name=112></a><b>94    Chapter 3  Gate-Level Minimization</b><br>
<i>C</i><br>
<i>D</i><br>
<i>B</i><br>
<i>A</i><br>
<i>F</i><br>
<i>B</i><br>
<i>C</i><br>
(a) AND�OR gates <br>
<i>C</i><br>
<i>D</i><br>
<i>B</i><br>
<i>A</i><br>
<i>F</i><br>
<i>B</i><br>
<i>C</i><br>
(b) NAND gates<br>
<b> <br>FIGURE 3.20 <br> <br>Implementing   <i>F </b></i>= <b><i>A</i>(<i>CD </b></i>+ <b><i>B</i>) </b>+ <b><i>BC </i> </b><br>
 <br>Although it is possible to remove the parentheses and reduce the expression into a standard <br>sum-of-products form, we choose to implement it as a multilevel circuit for illustration. The <br>AND�OR implementation is shown in  Fig.   3.20  (a). There are four levels of gating in the <br>circuit. The first level has two AND gates. The second level has an OR gate followed by an <br>AND gate in the third level and an OR gate in the fourth level. A logic diagram with a pat-<br>tern of alternating levels of AND and OR gates can easily be converted into a NAND circuit <br>with the use of mixed notation, shown in  Fig.   3.20  (b). The procedure is to change every AND <br>gate to an AND-invert graphic symbol and every OR gate to an invert-OR graphic symbol. <br>The NAND circuit performs the same logic as the AND�OR diagram as long as there are <br>two bubbles along the same line. The bubble associated with input  <i>B</i>  causes an extra comple-<br>mentation, which must be compensated for by changing the input literal to   <i>B </i>.  <br>
 <br>The general procedure for converting a multilevel AND�OR diagram into an all-NAND <br>
diagram using mixed notation is as follows: <br>
 <br><b> 1. </b><br>
 <br>Convert all AND gates to NAND gates with AND-invert graphic symbols. <br>
 <br><b> 2. </b><br>
 <br>Convert all OR gates to NAND gates with invert-OR graphic symbols. <br>
 <br><b> 3. </b><br>
 <br>Check all the bubbles in the diagram. For every bubble that is not compensated <br>by another small circle along the same line, insert an inverter (a one-input NAND <br>gate) or complement the input literal. <br>
 <br>As another example, consider the multilevel Boolean function <br>
 <br><i>F </i>= (<i>AB </i>+ <i>A B</i>)(<i>C </i>+ <i>D </i>)   <br>
<hr>
<A name=113></a><b>Section 3.6  NAND and NOR Implementation    95</b><br>
<i>A</i><br>
<i>B</i><br>
<i>A</i><br>
<i>B</i><br>
<i>F</i><br>
<i>C</i><br>
<i>D</i><br>
(a) AND�OR gates<br>
<i>A</i><br>
<i>B</i><br>
<i>A</i><br>
<i>B</i><br>
<i>F</i><br>
<i>C</i><br>
<i>D</i><br>
(b) NAND gates<br>
<b> <br>FIGURE 3.21 <br> <br>Implementing   <i>F </b></i>= <b>(<i>AB </b></i>+ <b><i>A B</i>)</b>  <b>(<i>C </b></i>+ <b><i>D </i>)  </b><br>
 <br>The AND�OR implementation of this function is shown in  Fig.   3.21  (a) with three levels <br>of gating. The conversion to NAND with mixed notation is presented in Fig. 3.21(b) of <br>the diagram. The two additional bubbles associated with inputs  <i>C</i>   and     <i>D </i>     cause  these <br>two literals to be complemented to   <i>C </i>     and   <i>D</i> . The bubble in the output NAND gate <br>complements the output value, so we need to insert an inverter gate at the output in <br>order to complement the signal again and get the original value back. <b> </b><br>
<b> <br>NOR Implementation </b><br>
 <br>The NOR operation is the dual of the NAND operation. Therefore, all procedures and <br>rules for NOR logic are the duals of the corresponding procedures and rules developed <br>for NAND logic. The NOR gate is another universal gate that can be used to implement <br>any Boolean function. The implementation of the complement, OR, and AND operations <br>with NOR gates is shown in  Fig.   3.22  . The complement operation is obtained from a one-<br>input NOR gate that behaves exactly like an inverter. The OR operation requires two NOR <br>gates, and the AND operation is obtained with a NOR gate that has inverters in each input. <br>
 <br>The two graphic symbols for the mixed notation are shown in  Fig.   3.23  .The OR-invert <br>
symbol defines the NOR operation as an OR followed by a complement. The invert-AND <br>symbol complements each input and then performs an AND operation. The two symbols <br>designate the same NOR operation and are logically identical because of  DeMorgan's <br>theorem. <br>
<hr>
<A name=114></a><b>96    Chapter 3  Gate-Level Minimization</b><br>
Inverter <i>x</i><br>
<i>x</i><br>
<i>x</i><br>
OR<br>
<i>x</i><br>
<i> y</i><br>
<i>y</i><br>
<i>x</i><br>
AND<br>
(<i>x </i>  <i> y </i>)    <i>xy</i><br>
<i>y</i><br>
<b> <br>FIGURE 3.22 <br> <br>Logic operations with NOR gates  </b><br>
<i>x</i><br>
<i>x</i><br>
<i>y</i><br>
(<i>x</i><br>
 <i>y </i> <i>z</i>)<br>
<i>y</i><br>
<i>x y z </i>   (<i>x</i><br>
 <i>y </i> <i>z</i>)<br>
<i>z</i><br>
<i>z</i><br>
(a) OR-invert<br>
(b) Invert-AND<br>
<b> <br>FIGURE 3.23 <br> <br>Two graphic symbols for the NOR gate  </b><br>
 <br>A two-level implementation with NOR gates requires that the function be simplified <br>
into product-of-sums form. Remember that the simplified product-of-sums expression <br>is obtained from the map by combining the 0's and complementing. A product-of-sums <br>expression is implemented with a first level of OR gates that produce the sum terms <br>followed by a second-level AND gate to produce the product. The transformation from <br>the OR�AND diagram to a NOR diagram is achieved by changing the OR gates to <br>NOR gates with OR-invert graphic symbols and the AND gate to a NOR gate with an <br>invert-AND graphic symbol. A single literal term going into the second-level gate must <br>be complemented.  Figure   3.24   shows the NOR implementation of a function expressed <br>as a product of sums: <br>
 <br><i>F </i>= (<i>A </i>+ <i>B</i>)(<i>C </i>+ <i>D</i>)<i>E</i> <br>
 <br>The OR�AND pattern can easily be detected by the removal of the bubbles along the <br>same line. Variable  <i>E</i>  is complemented to compensate for the third bubble at the input <br>of the second-level gate. <br>
 <br>The procedure for converting a multilevel AND�OR diagram to an all-NOR diagram <br>
is similar to the one presented for NAND gates. For the NOR case, we must convert <br>each OR gate to an OR-invert symbol and each AND gate to an invert-AND symbol. <br>Any bubble that is not compensated by another bubble along the same line needs an <br>inverter, or the complementation of the input literal. <br>
 <br>The transformation of the AND�OR diagram of  Fig.   3.21  (a) into a NOR diagram is <br>
shown in  Fig.   3.25  . The Boolean function for this circuit is <br>
 <br><i>F </i>= (<i>AB </i>+ <i>A B</i>)(<i>C </i>+ <i>D </i>)   <br>
<hr>
<A name=115></a><b>Section 3.7  Other Two-Level Implementations    97</b><br>
<i>A</i><br>
<i>B</i><br>
<i>C</i><br>
<i>F</i><br>
<i>D</i><br>
<i>E</i><br>
<b> <br>FIGURE 3.24 <br> <br>Implementing   <i>F </b></i>= <b>(<i>A </b></i>+ <b><i>B</i>)(<i>C </b></i>+ <b><i>D</i>)<i>E</i> </b><br>
<i>A</i><br>
<i>B</i><br>
<i>F</i><br>
<i>A</i><br>
<i>B</i><br>
<i>C</i><br>
<i>D</i><br>
<b> <br>FIGURE 3.25 <br> <br>Implementing   <i>F </b></i>= <b>(<i>AB </b></i>+ <b><i>A B</i>)(<i>C </b></i>+ <b><i>D </i>)   with NOR gates  </b><br>
 <br>The equivalent AND�OR diagram can be recognized from the NOR diagram by remov-<br>ing all the bubbles. To compensate for the bubbles in four inputs, it is necessary to <br>complement the corresponding input literals. <br>
<b> <br>3 . 7       O T H E R   T W O - L E V E L   I M P L E M E N TAT I O N S </b><br>
 <br>The types of gates most often found in integrated circuits are NAND and NOR gates. <br>For this reason, NAND and NOR logic implementations are the most important from <br>a practical point of view. Some (but not all) NAND or NOR gates allow the possibility <br>of a wire connection between the outputs of two gates to provide a specific logic func-<br>tion. This type of logic is called  <i>wired logic.</i>  For example, open-collector TTL NAND <br>gates, when tied together, perform wired-AND logic. The wired-AND logic performed <br>with two NAND gates is depicted in  Fig.   3.26  (a). The AND gate is drawn with the lines <br>going through the center of the gate to distinguish it from a conventional gate. The <br>wired-AND gate is not a physical gate, but only a symbol to designate the function <br>obtained from the indicated wired connection. The logic function implemented by the <br>circuit  of   Fig.    3.26   (a)  is <br>
 <br><i>F </i>= (<i>AB</i>) c (<i>CD</i>) = (<i>AB </i>+ <i>CD</i>) = (<i>A </i>+ <i>B </i>)(<i>C </i>+ <i>D </i>)   <br>
 <br>and is called an AND�OR�INVERT function. <br>
<hr>
<A name=116></a><b>98    Chapter 3  Gate-Level Minimization</b><br>
<i>A</i><br>
<i>A</i><br>
<i>B</i><br>
<i>B</i><br>
<i>F</i><br>
(<i>AB</i><br>
<i> CD</i>)  <br>
<i>F</i><br>
[(<i>A</i><br>
<i> B</i>) (<i>C</i><br>
<i> D</i>)]<br>
<i>C</i><br>
<i>C</i><br>
<i>D</i><br>
<i>D</i><br>
(a) Wired-AND in open-collector<br>
(b) Wired-OR in ECL gates<br>
TTL NAND gates.<br>
(AND�OR�INVERT)<br>
(OR�AND�INVERT)<br>
<b> <br>FIGURE 3.26 <br> <br>Wired logic  <br> <br>(a)   Wired-AND logic with two NAND gates  <br> <br>(b)   Wired-OR in emitter-coupled logic (ECL) gates  </b><br>
 <br>Similarly, the NOR outputs of ECL gates can be tied together to perform a wired-OR <br>
function. The logic function implemented by the circuit of  Fig.   3.26  (b) is <br>
 <br><i>F </i>= (<i>A </i>+ <i>B</i>) + (<i>C </i>+ <i>D</i>) = 3(<i>A </i>+ <i>B</i>)(<i>C </i>+ <i>D</i>)4  <br>
 <br>and is called an OR�AND�INVERT function. <br>
 <br>A wired-logic gate does not produce a physical second-level gate, since it is just a wire <br>
connection. Nevertheless, for discussion purposes, we will consider the circuits of  Fig.   3.26 <br>as two-level implementations. The first level consists of NAND (or NOR) gates and the <br>second level has a single AND (or OR) gate. The wired connection in the graphic symbol <br>will be omitted in subsequent discussions. <br>
<b> <br>Nondegenerate Forms </b><br>
 <br>It will be instructive from a theoretical point of view to find out how many two-level com-<br>binations of gates are possible. We consider four types of gates: AND, OR, NAND, and <br>NOR. If we assign one type of gate for the first level and one type for the second level, we <br>find that there are 16 possible combinations of two-level forms. (The same type of gate can <br>be in the first and second levels, as in a NAND�NAND implementation.) Eight of these <br>combinations are said to be  <i>degenerate</i>  forms because they degenerate to a single opera-<br>tion. This can be seen from a circuit with AND gates in the first level and an AND gate in <br>the second level. The output of the circuit is merely the AND function of all input variables. <br>The remaining eight  <i>nondegenerate</i>  forms produce an implementation in sum-of-products <br>form or product-of-sums form. The eight  <i>nondegenerate</i>  forms are as follows: <br>
 AND�OR <br>
 OR�AND <br>
 NAND�NAND <br>
 NOR�NOR <br>
 NOR�OR <br>
 NAND�AND <br>
 OR�NAND <br>
 AND�NOR <br>
<hr>
<A name=117></a><b>Section 3.7  Other Two-Level Implementations    99</b><br>
 <br>The first gate listed in each of the forms constitutes a first level in the implementation. <br>The second gate listed is a single gate placed in the second level. Note that any two forms <br>listed on the same line are duals of each other. <br>
 <br>The AND�OR and OR�AND forms are the basic two-level forms discussed in <br>
Section 3.4. The NAND�NAND and NOR�NOR forms were presented in Section 3.5. <br>The remaining four forms are investigated in this section. <br>
<b> <br>AND�OR�INVERT Implementation </b><br>
 <br>The two forms, NAND�AND and AND�NOR, are equivalent and can be treated <br>together. Both perform the AND�OR�INVERT function, as shown in  Fig.   3.27  . The <br>AND�NOR form resembles the AND�OR form, but with an inversion done by the <br>bubble in the output of the NOR gate. It implements the function <br>
 <br><i>F </i>= (<i>AB </i>+ <i>CD </i>+ <i>E</i>)  <br>
 <br>By using the alternative graphic symbol for the NOR gate, we obtain the diagram of <br>
 <br>Fig.   3.27  (b). Note that the single variable  <i>E</i>  is  <i>not</i>  complemented, because the only <br>change made is in the graphic symbol of the NOR gate. Now we move the bubble from <br>the input terminal of the second-level gate to the output terminals of the first-level gates. <br>An inverter is needed for the single variable in order to compensate for the bubble. <br>Alternatively, the inverter can be removed, provided that input  <i>E</i>  is complemented. The <br>circuit of  Fig.   3.27  (c) is a NAND�AND form and was shown in  Fig.   3.26   to implement <br>the AND�OR�INVERT function. <br>
 <br>An AND�OR implementation requires an expression in sum-of-products form. The <br>
AND�OR�INVERT implementation is similar, except for the inversion. Therefore, if the <br> <br><i>complement</i>  of the function is simplified into sum-of-products form (by combining the 0's <br>in the map), it will be possible to implement   <i>F </i>  with the AND�OR part of the function. <br>When     <i>F </i>  passes through the always present output inversion (the INVERT part), it will <br>
<i>A</i><br>
<i>A</i><br>
<i>A</i><br>
<i>B</i><br>
<i>B</i><br>
<i>B</i><br>
<i>C</i><br>
<i>C</i><br>
<i>C</i><br>
<i>F</i><br>
<i>F</i><br>
<i>F</i><br>
<i>D</i><br>
<i>D</i><br>
<i>D</i><br>
<i>E</i><br>
<i>E</i><br>
<i>E</i><br>
(a) AND�NOR<br>
(b) AND�NOR<br>
(c) NAND�AND<br>
<b> <br>FIGURE 3.27 <br> <br>AND�OR�INVERT circuits,   <i>F </b></i>= <b>(<i>AB </b></i>+ <b><i>CD </b></i>+ <b><i>E </i>)  </b><br>
<hr>
<A name=118></a><b>100    Chapter 3  Gate-Level Minimization</b><br>
generate the output  <i>F</i>  of the function. An example for the AND�OR�INVERT imple-<br>mentation will be shown subsequently. <br>
<b> <br>OR�AND�INVERT Implementation </b><br>
 <br>The OR�NAND and NOR�OR forms perform the OR�AND�INVERT function, as <br>shown in  Fig.   3.28  . The OR�NAND form resembles the OR�AND form, except for the <br>inversion done by the bubble in the NAND gate. It implements the function <br>
 <br><i>F </i>= 3(<i>A </i>+ <i>B</i>)(<i>C </i>+ <i>D</i>)<i>E</i>4  <br>
 <br>By using the alternative graphic symbol for the NAND gate, we obtain the diagram <br>
of  Fig.   3.28  (b). The circuit in Fig. 3.28(c) is obtained by moving the small circles from the <br>inputs of the second-level gate to the outputs of the first-level gates. The circuit of  Fig. <br> <br>3.28  (c) is a NOR�OR form and was shown in  Fig.   3.26   to implement the OR�AND�<br>INVERT function. <br>
 <br>The OR�AND�INVERT implementation requires an expression in product-of-sums <br>
form. If the complement of the function is simplified into that form, we can implement <br> <br><i>F </i>  with the OR�AND part of the function. When   <i>F </i>  passes through the INVERT part, <br>we obtain the complement of   <i>F </i>,     or   <i>F</i> , in the output. <br>
<b> <br>Tabular Summary and Example </b><br>
 <br>Table   3.2   summarizes the procedures for implementing a Boolean function in any one <br>of the four 2-level forms. Because of the INVERT part in each case, it is convenient to <br>use the simplification of   <i>F </i>  (the complement) of the function. When   <i>F </i>     is  implemented <br>in one of these forms, we obtain the complement of the function in the AND�OR or <br>OR�AND form. The four 2-level forms invert this function, giving an output that is the <br>complement of   <i>F </i>. This is the normal output  <i>F</i> . <b> </b><br>
<i>A</i><br>
<i>A</i><br>
<i>A</i><br>
<i>B</i><br>
<i>B</i><br>
<i>B</i><br>
<i>C</i><br>
<i>C</i><br>
<i>C</i><br>
<i>F</i><br>
<i>F</i><br>
<i>F</i><br>
<i>D</i><br>
<i>D</i><br>
<i>D</i><br>
<i>E</i><br>
<i>E</i><br>
<i>E</i><br>
(a) OR�NAND<br>
(b) OR�NAND<br>
(c) NOR�OR<br>
<b> <br>FIGURE 3.28 <br> <br>OR�AND�INVERT circuits,   <i>F </b></i>= 3<b>(<i>A </b></i>+ <b><i>B </i>)(<i>C </b></i>+ <b><i>D </i>)<i>E</b></i>4 <b> </b><br>
<hr>
<A name=119></a><b>Section 3.7  Other Two-Level Implementations    101</b><br>
<b> <br>Table 3.2 <br><i> <br>Implementation with Other Two-Level Forms </b></i><br>
<b> <br>Equivalent </b><br>
<b>Nondegenerate Form </b><br>
<b> <br>Implements </b><br>
<b> <br>Simplify </b><br>
<b> <br>To Get </b><br>
<b>the </b><br>
<b> <br><i>F</i>'</b> <br>
<b>an Output </b><br>
<b> <br>(a)  </b><br>
<b>(b)* </b><br>
<b>Function </b><br>
<b>into </b><br>
<b>of </b><br>
 AND�NOR <br>
 NAND�AND <br>
 AND�OR�INVERT <br>
 Sum-of-products <br>form by combining <br>0's in the map. <br>
<i>  F  </i><br>
 OR�NAND <br>
 NOR�OR <br>
 OR�AND�INVERT <br>
 Product-of-sums <br>form by combining <br>1's in the map and <br>then complementing. <br>
<i>  F  </i><br>
 <br>* Form (b) requires an inverter for a single literal term. <br>
<b> <br>EXAMPLE 3.10 </b><br>
 <br>Implement the function of  Fig.   3.29  (a) with the four 2-level forms listed in  Table   3.2  . <br> <br>The complement of the function is simplified into sum-of-products form by  combining <br>the 0's in the map: <br>
 <br><i>F </i>= <i>x y </i>+ <i>xy </i>+ <i>z</i> <br>
 <br>The normal output for this function can be expressed as <br>
 <br><i>F </i>= (<i>x y </i>+ <i>xy </i>+ <i>z</i>)  <br>
 <br>which is in the AND�OR�INVERT form. The AND�NOR and NAND�AND imple-<br>mentations are shown in  Fig.   3.29  (b). Note that a one-input NAND, or inverter, gate is <br>needed in the NAND�AND implementation, but not in the AND�NOR case. The <br>inverter can be removed if we apply the input variable   <i>z </i>     instead  of   <i>z.</i> <br>
 <br>The OR�AND�INVERT forms require a simplified expression of the complement <br>
of the function in product-of-sums form. To obtain this expression, we first combine the <br>1's in the map: <br>
 <br><i>F </i>= <i>x y z </i>+ <i>xyz </i> <br>
 <br>Then we take the complement of the function: <br>
 <br><i>F </i>= (<i>x </i>+ <i>y </i>+ <i>z</i>)(<i>x </i>+ <i>y </i>+ <i>z</i>)   <br>
<hr>
<A name=120></a><b>102    Chapter 3  Gate-Level Minimization</b><br>
<i>y</i><br>
<i>yz</i><br>
<i>x</i><br>
00<br>
01<br>
11<br>
10<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
0<br>
1<br>
3<br>
2<br>
<i>F = x y z  + xyz</i><br>
0<br>
1<br>
0<br>
0<br>
0<br>
<i>F  = x y + xy  + z</i><br>
<i>x y z</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
7<br>
6<br>
<i>xyz</i><br>
<i>x</i><br>
1<br>
0<br>
0<br>
0<br>
1<br>
<i>z</i><br>
(a) Map simplification in sum of products<br>
<i>x</i><br>
<i>x</i><br>
<i>y</i><br>
<i>y</i><br>
<i>x</i><br>
<i>x</i><br>
<i>F</i><br>
<i>F</i><br>
<i>y</i><br>
<i>y</i><br>
<i>z</i><br>
<i>z</i><br>
 AND�NOR<br>
NAND�AND<br>
(b) <i>F</i><br>
 (<i>x y </i> <i>xy</i><br>
 <i>z</i>)<br>
<i>x</i><br>
<i>x</i><br>
<i>y</i><br>
<i>y</i><br>
<i>z</i><br>
<i>z</i><br>
<i>F</i><br>
<i>F</i><br>
<i>x</i><br>
<i>x</i><br>
<i>y</i><br>
<i>y</i><br>
<i>z</i><br>
<i>z</i><br>
 OR�NAND<br>
NOR�OR<br>
(c) <i>F</i><br>
 [(<i>x </i> <i>y </i> <i>z</i>) (<i>x</i><br>
 <i>y</i><br>
 <i>z</i>)]  <br>
<b> <br>FIGURE 3.29 <br> <br>Other two-level implementations  </b><br>
 <br>The normal output  <i>F</i>  can now be expressed in the form <br>
 <br><i>F </i>= 3(<i>x </i>+ <i>y </i>+ <i>z</i>)(<i>x </i>+ <i>y </i>+ <i>z</i>)4  <br>
 <br>which is the OR�AND�INVERT form. From this expression, we can implement the <br>function in the OR�NAND and NOR�OR forms, as shown in  Fig.   3.29  (c). <br>
<br>
<hr>
<A name=121></a><b>Section 3.8  Exclusive-OR Function    103</b><br>
<b> <br>3 . 8       E X C L U S I V E - O R   F U N C T I O N </b><br>
 <br>The exclusive-OR (XOR), denoted by the symbol   {,  is a logical operation that performs <br>the following Boolean operation: <br>
 <i>x </i>{ <i>y </i>= <i>xy </i>+ <i>x y </i> <br>
 <br>The exclusive-OR is equal to 1 if only  <i>x</i>  is equal to 1 or if only  <i>y</i>  is equal to 1 (i.e.,  <i>x</i>  and  <i>y</i> <br>differ in value), but not when both are equal to 1 or when both are equal to 0. The exclusive-<br>NOR, also known as equivalence, performs the following Boolean operation: <br>
 <br>(<i>x </i>{ <i>y</i>) = <i>xy </i>+ <i>x y </i> <br>
 <br>The exclusive-NOR is equal to 1 if both  <i>x</i>  and  <i>y</i>  are equal to 1 or if both are equal to 0. <br>The exclusive-NOR can be shown to be the complement of the exclusive-OR by means <br>of a truth table or by algebraic manipulation: <br>
 <br>(<i>x </i>{ <i>y</i>) = (<i>xy </i>+ <i>x y</i>) = (<i>x </i>+ <i>y</i>)(<i>x </i>+ <i>y </i>) = <i>xy </i>+ <i>x y </i> <br>
 <br>The following identities apply to the exclusive-OR operation: <br>
 <i>x </i>{ 0 = <i>x </i> <br> <i>x </i>{ 1 = <i>x </i> <br>
 <i>x </i>{ <i>x </i>= 0   <br>
 <i>x </i>{ <i>x </i>= 1   <br>
 <i>x </i>{ <i>y </i>= <i>x </i>{ <i>y </i>= (<i>x </i>{ <i>y</i>)<br>
 <br>
 <br>Any of these identities can be proven with a truth table or by replacing the   {      operation <br>by its equivalent Boolean expression. Also, it can be shown that the exclusive-OR oper-<br>ation is both commutative and associative; that is, <br>
 <i>A </i>{ <i>B </i>= <i>B </i>{ <i>A </i> <br>
 and <br>
 <br>(<i>A </i>{ <i>B</i>) { <i>C </i>= <i>A </i>{ (<i>B </i>{ <i>C</i>) = <i>A </i>{ <i>B </i>{ <i>C</i><br>
 <br>
 <br>This means that the two inputs to an exclusive-OR gate can be interchanged without <br>affecting the operation. It also means that we can evaluate a three-variable exclusive-OR <br>operation in any order, and for this reason, three or more variables can be expressed <br>without parentheses. This would imply the possibility of using exclusive-OR gates with <br>three or more inputs. However, multiple-input exclusive-OR gates are difficult to fabri-<br>cate with hardware. In fact, even a two-input function is usually constructed with other <br>types of gates. A two-input exclusive-OR function is constructed with conventional gates <br>using two inverters, two AND gates, and an OR gate, as shown in  Fig.   3.30  (a).   Figure  3.30  (b) <br>shows the implementation of the exclusive-OR with four NAND gates. The first NAND <br>gate performs the operation   (<i>xy</i>) = (<i>x </i>+ <i>y </i>). The other two-level NAND circuit <br> <br>produces the sum of products of its inputs: <br>
 <br>(<i>x </i>+ <i>y </i>)<i>x </i>+ (<i>x </i>+ <i>y </i>)<i>y </i>= <i>xy </i>+ <i>x y </i>= <i>x </i>{ <i>y </i> <br>
<hr>
<A name=122></a><b>104    Chapter 3  Gate-Level Minimization</b><br>
<i>x</i><br>
<i>x </i> <i>y</i><br>
<i>y</i><br>
(a) Exclusive-OR with AND�OR�NOT gates<br>
<i>x</i><br>
<i>x </i> <i>y</i><br>
<i>y</i><br>
(b) Exclusive-OR with NAND gates<br>
<b> <br>FIGURE 3.30 <br> <br>Exclusive-OR implementations  </b><br>
 <br>Only a limited number of Boolean functions can be expressed in terms of exclusive-OR <br>
operations. Nevertheless, this function emerges quite often during the design of digital <br>systems. It is particularly useful in arithmetic operations and error detection and correc-<br>tion circuits. <br>
<b> <br>Odd Function </b><br>
 <br>The exclusive-OR operation with three or more variables can be converted into an <br>ordinary Boolean function by replacing the  {  symbol with its equivalent Boolean <br>expression. In particular, the three-variable case can be converted to a Boolean expres-<br>sion as follows: <br>
 <i>A </i>{ <i>B </i>{ <i>C </i>= (<i>AB </i>+ <i>A B</i>)<i>C </i>+ (<i>AB </i>+ <i>A B </i>)<i>C</i><br>
= <i>AB C</i><br>
+ <i>A BC</i><br>
+ <i>ABC </i>+ <i>A B C</i><br>
=<br>
(1, 2, 4, 7) <br>
 <br>The Boolean expression clearly indicates that the three-variable exclusive-OR function is <br>equal to 1 if only one variable is equal to 1 or if all three variables are equal to 1. Contrary <br>to the two-variable case, in which only one variable must be equal to 1, in the case of three <br>or more variables the requirement is that an odd number of variables be equal to 1. As a <br>consequence, the multiple-variable exclusive-OR operation is defined as an  <i>odd function.</i> <br>
<hr>
<A name=123></a><b>Section 3.8  Exclusive-OR Function    105</b><br>
 <br>The Boolean function derived from the three-variable exclusive-OR operation is <br>
expressed as the logical sum of four minterms whose binary numerical values are 001, 010, <br>100, and 111. Each of these binary numbers has an odd number of 1's. The remaining four <br>minterms not included in the function are 000, 011, 101, and 110, and they have an even <br>number of 1's in their binary numerical values. In general, an  <i>n</i> -variable  exclusive-OR <br>function is an odd function defined as the logical sum of the   2<i>n</i>&gt;2     minterms  whose  binary <br>numerical values have an odd number of 1's. <br>
 <br>The definition of an odd function can be clarified by plotting it in a map.  Figure   3.31  (a) <br>
shows the map for the three-variable exclusive-OR function. The four minterms of the <br>function are a unit distance apart from each other. The odd function is identified from <br>the four minterms whose binary values have an odd number of 1's. The complement of <br>an odd function is an even function. As shown in  Fig.   3.31  (b), the three-variable even <br>function is equal to 1 when an even number of its variables is equal to 1 (including the <br>condition that none of the variables is equal to 1). <br>
 <br>The three-input odd function is implemented by means of two-input exclusive-OR <br>
gates, as shown in  Fig.   3.32  (a). The complement of an odd function is obtained by replac-<br>ing the output gate with an exclusive-NOR gate, as shown in  Fig.   3.32  (b). <br>
 <br>Consider now the four-variable exclusive-OR operation. By algebraic manipulation, <br>
we can obtain the sum of minterms for this function: <br>
 <i>A </i>{ <i>B </i>{ <i>C </i>{ <i>D </i>= (<i>AB </i>+ <i>A B</i>) { (<i>CD </i>+ <i>C D</i>)<br>
 <br>
= (<i>AB</i><br>
+ <i>A B</i>)(<i>CD </i>+ <i>C D </i>) + (<i>AB </i>+ <i>A B </i>)(<i>CD</i><br>
+ <i>C D</i>)<br>
 <br>
=<br>
(1, 2, 4, 7, 8, 11, 13, 14)  <br>
<i>B</i><br>
<i>B</i><br>
<i>BC</i><br>
<i>BC</i><br>
<i>A</i><br>
00<br>
01<br>
11<br>
10<br>
<i>A</i><br>
00<br>
01<br>
11<br>
10<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
0<br>
1<br>
3<br>
2<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
0<br>
1<br>
3<br>
2<br>
0<br>
1<br>
1<br>
0<br>
1<br>
1<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
7<br>
6<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
7<br>
6<br>
<i>A</i><br>
1<br>
1<br>
1<br>
<i>A </i>1<br>
1<br>
1<br>
<i>C</i><br>
<i>C</i><br>
(a) Odd function <i>F</i><br>
<i> A </i> <i>B </i><i> C</i><br>
(b) Even function <i>F</i><br>
 (<i>A </i> <i>B </i> <i>C</i>)<br>
<b> <br>FIGURE 3.31 <br> <br>Map for a three-variable exclusive-OR function  </b><br>
<i>A</i><br>
<i>A</i><br>
<i>B</i><br>
<i>B</i><br>
<i>C</i><br>
<i>C</i><br>
(a) 3-input odd function<br>
(b) 3-input even function<br>
<b> <br>FIGURE 3.32 <br> <br>Logic diagram of odd and even functions  </b><br>
<hr>
<A name=124></a><b>106    Chapter 3  Gate-Level Minimization</b><br>
<i>C</i><br>
<i>C</i><br>
<i>CD</i><br>
<i>CD</i><br>
<i>AB</i><br>
00<br>
01<br>
11<br>
10<br>
<i>AB</i><br>
00<br>
01<br>
11<br>
10<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
0<br>
1<br>
3<br>
2<br>
0<br>
1<br>
3<br>
2<br>
00<br>
1<br>
1<br>
00<br>
1<br>
1<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
7<br>
6<br>
4<br>
5<br>
7<br>
6<br>
01<br>
1<br>
1<br>
01<br>
1<br>
1<br>
<i>B</i><br>
<i>B</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
12<br>
13<br>
15<br>
14<br>
12<br>
13<br>
15<br>
14<br>
11<br>
1<br>
1<br>
11<br>
1<br>
1<br>
<i>A</i><br>
<i>A</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
8<br>
9<br>
11<br>
10<br>
8<br>
9<br>
11<br>
10<br>
10<br>
1<br>
1<br>
10<br>
1<br>
1<br>
<i>D</i><br>
<i>D</i><br>
(a) Odd function <i>F</i><br>
<i> A </i> <i>B </i><i> C </i><i> D</i><br>
(b) Even function <i>F</i><br>
<i> (A </i> <i>B </i><i> C </i><i> D)</i><br>
<b> <br>FIGURE 3.33 <br> <br>Map for a four-variable exclusive-OR function  </b><br>
 <br>There are 16 minterms for a four-variable Boolean function. Half of the minterms <br>
have binary numerical values with an odd number of 1's; the other half of the minterms <br>have binary numerical values with an even number of 1's. In plotting the function in the <br>map, the binary numerical value for a minterm is determined from the row and column <br>numbers of the square that represents the minterm. The map of  Fig.   3.33  (a) is a plot of <br>the four-variable exclusive-OR function. This is an odd function because the binary <br>values of all the minterms have an odd number of 1's. The complement of an odd func-<br>tion is an even function. As shown in  Fig.   3.33  (b), the four-variable even function is equal <br>to 1 when an even number of its variables is equal to 1. <br>
<b> <br>Parity Generation and Checking </b><br>
 <br>Exclusive-OR functions are very useful in systems requiring error detection and cor-<br>rection codes. As discussed in Section 1.6, a parity bit is used for the purpose of <br>detecting errors during the transmission of binary information. A parity bit is an extra <br>bit included with a binary message to make the number of 1's either odd or even. The <br>message, including the parity bit, is transmitted and then checked at the receiving end <br>for errors. An error is detected if the checked parity does not correspond with the <br>one transmitted. The circuit that generates the parity bit in the transmitter is called <br>a  <i>parity generator.</i> The circuit that checks the parity in the receiver is called a  <i>parity <br>checker.</i> <br>
 <br>As an example, consider a three-bit message to be transmitted together with an <br>
even-parity bit.  Table   3.3   shows the truth table for the parity generator. The three <br>bits-- <i>x</i>,<i> y</i>,  and  <i>z</i> --constitute the message and are the inputs to the circuit. The parity <br>bit  <i>P</i>  is the output. For even parity, the bit  <i>P</i>  must be generated to make the total <br>number of 1's (including  <i>P</i> ) even. From the truth table, we see that  <i>P</i>  constitutes an <br>
<hr>
<A name=125></a><b>Section 3.8  Exclusive-OR Function    107</b><br>
<b> <br>Table 3.3 <br><i> <br>Even-Parity-Generator Truth Table </b></i><br>
<b> <br>Three-Bit Message </b><br>
<b> <br>Parity Bit </b><br>
<i><b> <br>x  </b></i><br>
<i><b> <br>y  </b></i><br>
<i><b> <br>z  </b></i><br>
<i><b> <br>P  </b></i><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
<i>x</i><br>
<i>x</i><br>
<i>y</i><br>
<i>y</i><br>
<i>P</i><br>
<i>C</i><br>
<i>z</i><br>
<i>z</i><br>
<i>P</i><br>
(a) 3-bit even parity generator<br>
(b) 4-bit even parity checker<br>
<b> <br>FIGURE 3.34 <br> <br>Logic diagram of a parity generator and checker  </b><br>
odd function because it is equal to 1 for those minterms whose numerical values have <br>an odd number of 1's. Therefore,  <i>P</i>  can be expressed as a three-variable exclusive-OR <br>function: <br>
<b> <br></b><i>P </i>= <i>x </i>{ <i>y </i>{ <i>z </i> <br>
 <br>The logic diagram for the parity generator is shown in  Fig.   3.34  (a).  <br>
 <br>The three bits in the message, together with the parity bit, are transmitted to their <br>
destination, where they are applied to a parity-checker circuit to check for possible <br>errors in the transmission. Since the information was transmitted with even parity, the <br>four bits received must have an even number of 1's. An error occurs during the trans-<br>mission if the four bits received have an odd number of 1's, indicating that one bit has <br>changed in value during transmission. The output of the parity checker, denoted by <br> <br><i>C</i> , will be equal to 1 if an error occurs--that is, if the four bits received have an odd <br>number of 1's. Table   3.4   is the truth table for the even-parity checker. From it, we see <br>that the function  <i>C</i>  consists of the eight minterms with binary numerical values hav-<br>ing an odd number of 1's. The table corresponds to the map of  Fig.   3.33  (a), which <br>
<hr>
<A name=126></a><b>108    Chapter 3  Gate-Level Minimization</b><br>
<b> <br>Table 3.4 <br><i> <br>Even-Parity-Checker Truth Table </b></i><br>
<b> <br>Four Bits </b><br>
<b> <br>Parity Error </b><br>
<b>Received </b><br>
<b>Check </b><br>
<i><b> <br>x  </b></i><br>
<i><b> <br>y  </b></i><br>
<i><b> <br>z  </b></i><br>
<i><b> <br>P  </b></i><br>
<i><b> <br>C  </b></i><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
represents an odd function. The parity checker can be implemented with exclusive-<br>OR gates: <br>
 <br><i>C </i>= <i>x </i>{ <i>y </i>{ <i>z </i>{ <i>P </i> <br>
 <br>The logic diagram of the parity checker is shown in  Fig.   3.34  (b). <br>
 <br>It is worth noting that the parity generator can be implemented with the circuit of  <br>
Fig.    3.34   (b)  if  the  input   <i>P</i>  is connected to logic 0 and the output is marked with  <i>P</i> .  This is <br>because     <i>z </i>{ 0 = <i>z</i>,   causing the value of  <i>z</i>  to pass through the gate unchanged. The advan-<br>tage of this strategy is that the same circuit can be used for both parity generation and <br>checking. <br>
 <br>It is obvious from the foregoing example that parity generation and checking circuits <br>
always have an output function that includes half of the minterms whose numerical  values <br>have either an odd or even number of 1's. As a consequence, they can be  implemented <br>with exclusive-OR gates. A function with an even number of 1's is the complement of an <br>odd function. It is implemented with exclusive-OR gates, except that the gate associated <br>with the output must be an exclusive-NOR to provide the required complementation. <br>
<b> <br>3 . 9       H A R D W A R E   D E S C R I P T I O N   L A N G U A G E </b><br>
 <br>Manual methods for designing logic circuits are feasible only when the circuit is small. <br>For anything else (i.e., a practical circuit), designers use computer-based design tools. <br>Coupled with the correct-by-construction methodology, computer-based design tools <br>
<hr>
<A name=127></a><b>Section 3.9  Hardware Description Language    109</b><br>
leverage the creativity and the effort of a designer and reduce the risk of producing a <br>flawed design. Prototype integrated circuits are too expensive and time consuming to <br>build, so all modern design tools rely on a hardware description language to describe, <br>design, and test a circuit in software before it is ever manufactured. <br>
 A   <i>hardware description language</i>  (HDL) is a computer-based language that describes <br>
the hardware of digital systems in a textual form. It resembles an ordinary computer <br>programming language, such as C, but is specifically oriented to describing hardware <br>structures and the behavior of logic circuits. It can be used to represent logic diagrams, <br>truth tables, Boolean expressions, and complex abstractions of the behavior of a digital <br>system. One way to view an HDL is to observe that it describes a relationship between <br>signals that are the inputs to a circuit and the signals that are the outputs of the circuit. <br>For example, an HDL description of an AND gate describes how the logic value of the <br>gate's output is determined by the logic values of its inputs. <br>
 <br>As a  <i>documentation</i>  language, an HDL is used to represent and document digital <br>
systems in a form that can be read by both humans and computers and is suitable as <br>an exchange language between designers. The language content can be stored, <br>retrieved, edited, and transmitted easily and processed by computer software in <br>an  efficient  manner. <br>
 <br>HDLs are used in several major steps in the design flow of an integrated circuit: <br>
design entry, functional simulation or verification, logic synthesis, timing verification, <br>and fault simulation. <br>
 <br><i>Design entry</i>  creates an HDL-based description of the functionality that is to be <br>
implemented in hardware. Depending on the HDL, the description can be in a variety <br>of forms: Boolean logic equations, truth tables, a netlist of interconnected gates, or an <br>abstract behavioral model. The HDL model may also represent a partition of a larger <br>circuit into smaller interconnected and interacting functional units. <br>
 <br><i>Logic simulation</i>  displays the behavior of a digital system through the use of a com-<br>
puter. A simulator interprets the HDL description and either produces readable output, <br>such as a time-ordered sequence of input and output signal values, or displays wave-<br>forms of the signals. The simulation of a circuit predicts how the hardware will behave <br>before it is actually fabricated. Simulation detects functional errors in a design without <br>having to physically create and operate the circuit. Errors that are detected during a <br>simulation can be corrected by modifying the appropriate HDL statements. The stimu-<br>lus (i.e., the logic values of the inputs to a circuit) that tests the functionality of the design <br>is called a  <i>test bench.</i> Thus, to simulate a digital system, the design is first described in <br>an HDL and then verified by simulating the design and checking it with a test bench, <br>which is also written in the HDL. An alternative and more complex approach relies on <br>formal mathematical methods to prove that a circuit is functionally correct. We will focus <br>exclusively on simulation. <br>
 <br><i>Logic synthesis</i>  is the process of deriving a list of physical components and their <br>
interconnections (called a  <i>netlist</i> ) from the model of a digital system described in an <br>HDL. The netlist can be used to fabricate an integrated circuit or to lay out a printed <br>circuit board with the hardware counterparts of the gates in the list. Logic synthesis is <br>similar to compiling a program in a conventional high-level language. The difference is <br>
<hr>
<A name=128></a><b>110    Chapter 3  Gate-Level Minimization</b><br>
that, instead of producing an object code, logic synthesis produces a database describing <br>the elements and structure of a circuit. The database specifies how to fabricate a physi-<br>cal integrated circuit that implements in silicon the functionality described by statements <br>made in an HDL. Logic synthesis is based on formal exact procedures that implement <br>digital circuits and addresses that part of a digital design which can be automated with <br>computer software. The design of today's large, complex circuits is made possible by <br>logic synthesis software. <br>
 <br><i>Timing verification</i>  confirms that the fabricated, integrated circuit will operate at a <br>
specified speed. Because each logic gate in a circuit has a propagation delay, a signal <br>transition at the input of a circuit cannot immediately cause a change in the logic value <br>of the output of a circuit. Propagation delays ultimately limit the speed at which <br>a circuit can operate. Timing verification checks each signal path to verify that it is <br>not compromised by propagation delay. This step is done after logic synthesis specifies <br>the actual devices that will compose a circuit and before the circuit is released for <br>production. <br>
 <br>In VLSI circuit design,  <i>fault simulation</i>  compares the behavior of an ideal circuit with <br>
the behavior of a circuit that contains a process-induced flaw. Dust and other particu-<br>lates in the atmosphere of the clean room can cause a circuit to be fabricated with a <br>fault. A circuit with a fault will not exhibit the same functionality as a fault-free circuit. <br>Fault simulation is used to identify input stimuli that can be used to reveal the difference <br>between the faulty circuit and the fault-free circuit. These test patterns will be used to <br>test fabricated devices to ensure that only good devices are shipped to the customer. <br>Test generation and fault simulation may occur at different steps in the design process, <br>but they are always done before production in order to avoid the disaster of producing <br>a circuit whose internal logic cannot be tested. <br>
 <br>Companies that design integrated circuits use proprietary and public HDLs. In the <br>
public domain, there are two standard HDLs that are supported by the IEEE: VHDL <br>and Verilog. VHDL is a Department of Defense�mandated language. (The  <i>V</i>   in  VHDL <br>stands for the first letter in VHSIC, an acronym for very high-speed integrated circuit.) <br>Verilog began as a proprietary HDL of Cadence Design Systems, but Cadence trans-<br>ferred control of Verilog to a consortium of companies and universities known as Open <br>Verilog International (OVI) as a step leading to its adoption as an IEEE standard. <br>VHDL is more difficult to learn than Verilog. Because Verilog is an easier language than <br>VHDL to describe, learn, and use, we have chosen it for this book. However, the Verilog <br>HDL descriptions listed throughout the book are not just about Verilog, but also serve <br>to introduce a design methodology based on the concept of computer-aided modeling <br>of digital systems by means of a typical hardware description language. Our emphasis <br>will be on the modeling, verification, and synthesis (both manual and automated) of <br>Verilog models of circuits having specified behavior. The Verilog HDL was initially <br>approved as a standard HDL in 1995; revised and enhanced versions of the language <br>were approved in 2001 and 2005. We will address only those features of Verilog, includ-<br>ing the latest standard, that support our discussion of HDL-based design methodology <br>for integrated circuits. <br>
<hr>
<A name=129></a><b>Section 3.9  Hardware Description Language    111</b><br>
<b> <br>Module Declaration </b><br>
 <br>The language reference manual for the Verilog HDL presents a syntax that describes <br>precisely the constructs that can be used in the language. In particular, a Verilog <br>model is composed of text using keywords, of which there are about 100. Keywords <br>are predefined lowercase identifiers that define the language constructs. Examples of <br>keywords are  <b>module</b>,<b> endmodule</b>,<b> input</b>,<b> output</b>,<b> wire</b>,<b> and</b>,<b> or</b>,<b> </b> and  <b>not</b>.<b> </b> For clarity, <br>keywords will be displayed in boldface in the text in all examples of code and wher-<br>ever it is appropriate to call attention to their use. Any text between two forward <br>slashes ( <i>// </i> ) and the end of the line is interpreted as a comment and will have no effect <br>on a simulation using the model. Multiline comments begin with /  *     and  terminate <br>with     * /. Blank spaces are ignored, but they may not appear within the text of a key-<br>word, a user-specified identifier, an operator, or the representation of a number. Ver-<br>ilog is case sensitive, which means that uppercase and lowercase letters are <br>distinguishable (e.g.,  <b>not</b>  is not the same as NOT). The term  <i>module</i>  refers to the text <br>enclosed by the keyword pair  <b>module</b>  . . .   <b>endmodule</b>.<b> </b>A module is the fundamental <br>descriptive unit in the Verilog language. It is declared by the keyword  <b>module</b>   and <br>must always be terminated by the keyword  <b>endmodule</b>.  <br>
 <br>Combinational logic can be described by a schematic connection of gates, by a set of <br>
Boolean equations, or by a truth table. Each type of description can be developed in <br>Verilog. We will demonstrate each style, beginning with a simple example of a Verilog <br>gate-level description to illustrate some aspects of the language. <br>
 <br>The HDL description of the circuit of  Fig.   3.35   is shown in HDL  Example   3.1 . The <br>
first line of text is a comment (optional) providing useful information to the reader. The <br>second line begins with the keyword  <b>module</b>  and starts the declaration (description) of <br>the module; the last line completes the declaration with the keyword  <b>endmodule</b>.<b> </b> The <br>keyword  <b>module</b>  is followed by a name and a list of ports. The name ( <i>Simple_Circuit</i>   in <br>this example) is an identifier. Identifiers are names given to modules, variables (e.g., a <br>signal), and other elements of the language so that they can be referenced in the design. <br>In general, we choose meaningful names for modules. Identifiers are composed of alpha-<br>numeric characters and the underscore (_), and are case sensitive. Identifiers must start <br>with an alphabetic character or an underscore, but they cannot start with a number. <br>
<i>A</i><br>
<i>w1</i><br>
<i>G1</i><br>
<i>B</i><br>
<i>G3</i><br>
<i>D</i><br>
<i>C</i><br>
<i>G2</i><br>
<i>E</i><br>
<b> <br>FIGURE 3.35 <br> <br>Circuit to demonstrate an HDL  </b><br>
<hr>
<A name=130></a><b>112    Chapter 3  Gate-Level Minimization</b><br>
<b> <br>HDL Example 3.1 (Combinational Logic Modeled with Primitives) </b><br>
// Verilog model of  circuit of  Figure 3.35. IEEE 1364�1995 Syntax<br>
<b>module</b>  Simple_Circuit (A, B, C, D, E);<br>
<b>output</b> D, <br>
E;<br>
<b>input</b> <br>
A, B, C;<br>
<b>wire</b> w1;<br>
<b>and</b> <br>
G1 (w1, A, B); // Optional gate instance name<br>
<b>not</b> <br>
G2 (E, C);<br>
<b>or</b> <br>
G3 (D, w1, E);<br>
<b>endmodule</b><br>
  The   <i>port list</i>  of a module is the interface between the module and its environment. <br>
In this example, the ports are the inputs and outputs of the circuit. The logic values of <br>the inputs to a circuit are determined by the environment; the logic values of the outputs <br>are determined within the circuit and result from the action of the inputs on the circuit. <br>The port list is enclosed in parentheses, and commas are used to separate elements of <br>the list. The statement is terminated with a semicolon (;). In our examples, all keywords <br>(which must be in lowercase) are printed in bold for clarity, but that is not a requirement <br>of the language. Next, the keywords  <b>input</b>  and  <b>output</b>  specify which of the ports are <br>inputs and which are outputs. Internal connections are declared as wires. The circuit in <br>this example has one internal connection, at terminal  <i>w1</i> , and is declared with the key-<br>word  <b>wire.</b> The structure of the circuit is specified by a list of (predefined)  <i>primitive</i> <br>gates, each identified by a descriptive keyword ( <b>and, not, or</b> ). The elements of the list <br>are referred to as  <i>instantiations</i>  of a gate, each of which is referred to as a  <i>gate instance</i> . <br>Each  <i>gate instantiation</i>  consists of an optional name (such as  <i>G1, G2</i> , etc.) followed by <br>the gate output and inputs separated by commas and enclosed within parentheses. The <br>output of a primitive gate is always listed first, followed by the inputs. For example, the <br>OR gate of the schematic is represented by the  <b>or</b>  primitive, is named  <i>G3</i> , and has out-<br>put  <i>D</i>  and inputs  <i>w1</i>  and  <i>E</i> .  ( <i>Note</i> : The output of a primitive must be listed first, but the <br>inputs and outputs of a module may be listed in any order.) The module description ends <br>with the keyword  <b>endmodule. </b> Each statement must be terminated with a semicolon, but <br>there is no semicolon after  <b>endmodule.  </b><br>
 <br>It is important to understand the distinction between the terms  <i>declaration</i>  and  <i>instan-</i><br>
<i>tiation</i> .A Verilog module is declared. Its declaration specifies the input�output behavior <br>of the hardware that it represents. Predefined primitives are not declared, because their <br>definition is specified by the language and is not subject to change by the user. Primitives <br>are used (i.e., instantiated), just as gates are used to populate a printed circuit board. <br>We'll see that once a module has been declared, it may be used (instantiated) within a <br>design. Note that  <i>Simple_Circuit</i>  is not a computational model like those developed in <br>an ordinary programming language: The sequential ordering of the statements instanti-<br>ating gates in the model has no significance and does not specify a sequence of compu-<br>tations. A Verilog model is a  <i>descriptive</i>  model.  <i>Simple_Circuit</i>  describes what primitives <br>form a circuit and how they are connected. The input�output behavior of the circuit is <br>
<hr>
<A name=131></a><b>Section 3.9  Hardware Description Language    113</b><br>
<b> <br>Table 3.5 <br><i> <br>Output of Gates after Delay </b></i><br>
<b> </b><br>
<b> <br>Input </b><br>
<b> <br>Output </b><br>
<b> <br>Time Units </b><br>
<b> </b><br>
<b>(ns) </b><br>
<i><b> <br>ABC  </b></i><br>
<i><b> <br>E w1 D  </b></i><br>
 Initial <br>
 -- <br>
 0  0  0 <br>
 1 <br>
  0    1 <br>
 Change <br>
 -- <br>
 1  1  1 <br>
 1 <br>
  0    1 <br>
  <br>
 10 <br>
 1  1  1 <br>
 0 <br>
  0    1 <br>
  <br>
 20 <br>
 1  1  1 <br>
 0 <br>
  0    1 <br>
  <br>
 30 <br>
 1  1  1 <br>
 0 <br>
  1    0 <br>
  <br>
 40 <br>
 1  1  1 <br>
 0 <br>
  1    0 <br>
 <br>
 50 <br>
 1  1  1 <br>
 0 <br>
  1    1 <br>
implicitly specified by the description because the behavior of each logic gate is defined. <br>Thus, an HDL-based model can be used to simulate the circuit that it represents. <br>
<b> <br>Gate Delays </b><br>
 <br>All physical circuits exhibit a propagation delay between the transition of an input and a <br>resulting transition of an output. When an HDL model of a circuit is simulated, it is some-<br>times necessary to specify the amount of delay from the input to the output of its gates. <br>In Verilog, the propagation delay of a gate is specified in terms of  <i>time units</i>  and by the <br>symbol #. The numbers associated with time delays in Verilog are dimensionless. The <br>association of a time unit with physical time is made with the   <b>timescale</b>  compiler direc-<br>tive. (Compiler directives start with the ( )   back quote, or grave accent, symbol.) Such a <br>directive is specified before the declaration of a module and applies to all numerical <br>values of time in the code that follows. An example of a timescale directive is <br>
 <br><b>timescale </b>1ns/100ps <br>
 <br>The first number specifies the unit of measurement for time delays. The second number <br>specifies the precision for which the delays are rounded off, in this case to 0.1 ns. If no <br>timescale is specified, a simulator may display dimensionless values or default to a certain <br>time unit, usually   1 ns ( =10-9 s).  Our examples will use only the default time unit. <br>
 HDL   Example    3.2     repeats  the  description  of  the  simple  circuit  of   Example    3.1   ,  but <br>
with propagation delays specified for each gate. The  <b>and</b>,<b> or </b>, and  <b>not</b>  gates have a time <br>delay of 30, 20, and 10 ns, respectively. If the circuit is simulated and the inputs change <br>from  <i>A</i> ,   <i>B</i> ,  <i>C </i>= 0     to   <i>A</i> ,   <i>B</i> ,  <i>C </i>= 1,     the  outputs  change  as  shown  in   Table    3.5     (calculated <br>by hand or generated by a simulator). The output of the inverter at  <i>E</i>  changes from 1 to <br>0 after a 10-ns delay. The output of the AND gate at  <i>w1</i>  changes from 0 to 1 after a 30-ns <br>delay. The output of the OR gate at  <i>D</i>  changes from 1 to 0 at   <i>t </i>= 30  ns     and  then  changes <br>back to 1 at   <i>t </i>= 50 ns.  In both cases, the change in the output of the OR gate results <br>from a change in its inputs 20 ns earlier. It is clear from this result that although output <br> <br><i>D</i>  eventually returns to a final value of 1 after the input changes, the gate delays produce <br>a negative spike that lasts 20 ns before the final value is reached. <b> </b><br>
<hr>
<A name=132></a><b>114    Chapter 3  Gate-Level Minimization</b><br>
<b> <br>HDL Example 3.2 (Gate-Level Model with Propagation Delays) </b><br>
// Verilog model of  simple circuit with propagation delay<br>
<b>module</b>  Simple_Circuit_prop_delay (A, B, C, D, E);<br><b> output</b> D, E;<br>
<b>input</b>  A, B, C;<br><b>wire</b> w1;<br>
<b>and</b> <br>
#(30) G1 (w1, A, B);<br>
<b>not</b> <br>
#(10) G2 (E, C);<br>
<b>or</b> <br>
#(20) G3 (D, w1, E);<br>
<b>endmodule</b><br>
 <br>In order to simulate a circuit with an HDL, it is necessary to apply inputs to the circuit <br>
so that the simulator will generate an output response. An HDL description that provides <br>the stimulus to a design is called a  <i>test bench.</i> The writing of test benches is explained in <br>more detail at the end of Section 4.12. Here, we demonstrate the procedure with a simple <br>example without dwelling on too many details. HDL  Example   3.3   shows a test bench for <br>simulating the circuit with delay. (Note the distinguishing name  <i>Simple_Circuit_prop_<br>delay</i> .) In its simplest form, a test bench is a module containing a signal generator and <br>an instantiation of the model that is to be verified. Note that the test bench ( <i>t_Simple_<br>Circuit_prop_delay</i> ) has no input or output ports, because it does not interact with its <br>environment. In general, we prefer to name the test bench with the prefix  <i>t_</i>   concatenated <br>with the name of the module that is to be tested by the test bench, but that choice is left <br>to the designer. Within the test bench, the inputs to the circuit are declared with keyword <br> <br><b>reg</b>  and the outputs are declared with the keyword  <b>wire </b>. The module  <i>Simple_Circuit_<br>prop_delay</i>  is instantiated with the instance name M1. Every instantiation of a module <br>must include a unique instance name. Note that using a test bench is similar to testing <br>actual hardware by attaching signal generators to the inputs of a circuit and attaching <br>
<b> <br>HDL Example 3.3 (Test Bench) </b><br>
// Test bench for Simple_Circuit_prop_delay<br>
<b>module</b>  t_Simple_Circuit_prop_delay;<br>
<b>wire</b> D, <br>
E;<br>
<b>reg</b> <br>
A, B, C;<br>
Simple_Circuit_prop_delay M1 (A, B, C, D, E); // Instance name required<br>
<b>initial</b><br>
<b>begin</b><br>
A = 1'b0; B = 1'b0; C = 1'b0;<br>#100 A = 1'b1; B = 1'b1; C = 1'b1;<br>
<b>end</b><br>
<b>initial #200 $finish;</b><br>
<b>endmodule</b><br>
<hr>
<A name=133></a><b>Section 3.9  Hardware Description Language    115</b><br>
0.0 ns<br>
58.0 ns<br>
116.0 ns<br>
174.0 ns<br>
Name<br>
<i>A</i><br>
<i>B</i><br>
<i>C</i><br>
<i>D</i><br>
<i>E</i><br>
<b> <br>FIGURE 3.36 <br> <br>Simulation output of HDL  Example   3.3  </b><br>
probes (wires) to the outputs of the circuit. (The interaction between the signal genera-<br>tors of the stimulus module and the instantiated circuit module is illustrated in  Fig.   4.36  .) <br>
 <br>Hardware signal generators are not used to verify an HDL model:  The entire simula-<br>
tion exercise is done with software models executing on a digital computer under the <br>direction of an HDL simulator. The waveforms of the input signals are abstractly modeled <br>(generated) by Verilog statements specifying waveform values and transitions. The  <b>initial</b> <br> <br>keyword is used with a set of statements that begin executing when the simulation is ini-<br>tialized; the signal activity associated with  <b>initial</b>  terminates execution when the last state-<br>ment has finished executing. The  <b>initial</b>  statements are commonly used to describe <br>waveforms in a test bench. The set of statements to be executed is called a  <i>block statement</i> <br>and consists of several statements enclosed by the keywords  <b>begin</b>  and  <b>end</b>.<b> </b> The action <br>specified by the statements begins when the simulation is launched, and the statements <br>are executed in sequence, left to right, from top to bottom, by a simulator in order to <br>provide the input to the circuit. Initially,   <i>A</i>, <i>B</i>, <i>C </i>= 0. ( <i>A, B,</i>  and  <i>C</i>  are each set to   1 b0,    <br>which signifies one binary digit with a value of 0.) After 100 ns, the inputs change to <br> <i>A</i>, <i>B</i>, <i>C </i>= 1. After another 100 ns, the simulation terminates at time 200 ns. A second <br> <br><b>initial</b>  statement uses the  <b>$finish</b>  system task to specify termination of the simulation. If a <br>statement is preceded by a delay value (e.g., #100), the simulator postpones executing the <br>statement until the specified time delay has elapsed. The timing diagram of waveforms <br>that result from the simulation is shown in Figure 3.36. The total simulation generates <br>waveforms over an interval of 200 ns. The inputs  <i>A, B,</i>  and  <i>C</i>  change from 0 to 1 after 100 <br>ns. Output  <i>E</i>  is unknown for the first 10 ns (denoted by shading), and output  <i>D</i>  is unknown <br>for the first 30 ns. Output  <i>E</i>  goes from 1 to 0 at 110 ns. Output  <i>D</i>  goes from 1 to 0 at 130 <br>ns and back to 1 at 150 ns, just as we predicted in  Table   3.5  . <br>
<b> <br>Boolean Expressions </b><br>
 <br>Boolean equations describing combinational logic are specified in Verilog with a con-<br>tinuous assignment statement consisting of the keyword  <b>assign</b>  followed by a Boolean <br>expression. To distinguish arithmetic operators from logical operators, Verilog uses the <br>symbols (&amp;), (/), and (&amp;) for AND, OR, and NOT (complement), respectively. Thus, to <br>
<hr>
<A name=134></a><b>116    Chapter 3  Gate-Level Minimization</b><br>
describe the simple circuit of  Fig.   3.35   with a Boolean expression, we use the statement <br>
 <br><b>assign D </b>= (A &amp;&amp; B) (!C); <br>
 <br>HDL  Example   3.4   describes a circuit that is specified with the following two Boolean <br>expressions: <br>
 <i>E</i>  =  <i>A</i>  +  <i>BC </i>+  <i>B D</i> <br> <br><i>F</i>  =  <i>B C</i>  +  <i>BC D </i> <br>
 <br>The equations specify how the logic values  <i>E</i>  and  <i>F</i>  are determined by the values of <br> <br><i>A, B, C,</i>  and  <i>D</i> . <br>
<b> <br>HDL Example 3.4 (Combinational Logic Modeled with Boolean Equations) </b><br>
// Verilog model: Circuit with Boolean expressions<br>
<b>module</b>  Circuit_Boolean_CA (E, F, A, B, C, D);<br>
<b>output</b> E, <br>
F;<br>
<b>input</b> <br>
A, B, C, D;<br>
<b>assign</b> E   A || (B &amp;&amp; C) || ((!B) &amp;&amp; D);<br><b>assign</b> F   ((!B) &amp;&amp; C) || (B &amp;&amp; (!C) &amp;&amp; (!D));<br>
<b>endmodule</b><br>
 <br>The circuit has two outputs  <i>E</i>  and  <i>F</i>  and four inputs  <i>A, B, C,</i>  and  <i>D</i> . The two  <b>assign</b> <br>
statements describe the Boolean equations. The values of  <i>E</i>  and  <i>F</i>  during simulation are <br>determined dynamically by the values of  <i>A</i> ,   <i>B</i> ,   <i>C</i> , and  <i>D</i> . The simulator detects when the <br>test bench changes a value of one or more of the inputs. When this happens, the simula-<br>tor updates the values of  <i>E</i>  and  <i>F</i> . The continuous assignment mechanism is so named <br>because the relationship between the assigned value and the variables is permanent. The <br>mechanism acts just like combinational logic, has a gate-level equivalent circuit, and is <br>referred to as  <i>implicit combinational logic</i> . <br>
 <br>We have shown that a digital circuit can be described with HDL statements, just as <br>
it can be drawn in a circuit diagram or specified with a Boolean expression. A third <br>alternative is to describe combinational logic with a truth table. <br>
<b> <br>User-Defined Primitives </b><br>
 <br>The logic gates used in Verilog descriptions with keywords  <b>and, or,</b>  etc., are defined by <br>the system and are referred to as  <i>system primitives. (Caution: Other languages may use <br>these words differently</i> . <i>)</i> The user can create additional primitives by defining them in <br>tabular form. These types of circuits are referred to as  <i>user-defined primitives</i>   (UDPs). <br>One way of specifying a digital circuit in tabular form is by means of a truth table. UDP <br>descriptions do not use the keyword pair  <b>module</b>  . . .  <b>endmodule.</b>  Instead, they are <br>declared with the keyword pair  <b>primitive</b>  . . .  <b>endprimitive.</b> The best way to demonstrate <br>a UDP declaration is by means of an example. <br>
<hr>
<A name=135></a><b>Section 3.9  Hardware Description Language    117</b><br>
 <br>HDL  Example   3.5   defines a UDP with a truth table. It proceeds according to the <br>
following general rules: <br>
   �     It  is  declared  with  the  keyword   <b>primitive</b> , followed by a name and port list.  <br> <br>�   There can be only one output, and it must be listed fi rst in the port list and declared <br>
with keyword  <b>output</b> .  <br>
 <br>�   There can be any number of inputs. The order in which they are listed in the  <b>input</b><br>
declaration must conform to the order in which they are given values in the table that <br>follows.  <br>
 <br>�   The truth table is enclosed within the keywords  <b>table</b>  and  <b>endtable</b>.   <br> <br>�   The values of the inputs are listed in order, ending with a colon (:). The output is al-<br>
ways the last entry in a row and is followed by a semicolon (;).  <br>
 <br>�   The declaration of a UDP ends with the keyword  <b>endprimitive</b>.    <br>
<b> <br>HDL Example 3.5 (User-Defined Primitive) </b><br>
// Verilog model: User-defined Primitive<br>
<b>primitive</b>  UDP_02467 (D, A, B, C);<br>
<b>output</b> D;<br><b>input</b>   A, B, C;<br>
//Truth table for D 5 f  (A, B, C) 5  (0, 2, 4, 6, 7);<br><b> table <br></b>// <br>
A <br>
B <br>
C <br>
: <br>
D <br>
// Column header comment<br>
0 0 0 : 1;<br>0 0 1 : 0;<br>0 1 0 : 1;<br>0 1 1 : 0;<br>1 0 0 : 1;<br>1 0 1 : 0;<br>1 1 0 : 1;<br>1 1 1 : 1;<br>
<b> endtable <br>endprimitive </b><br>
// Instantiate primitive<br>
// Verilog model: Circuit instantiation of  Circuit_UDP_02467<br>
<b>module</b>  Circuit_with_UDP_02467 (e, f, a, b, c, d);<br>
<b>output</b> e, <br>
f;<br>
<b>input</b> <br>
a, b, c, d<br>
  UDP_02467 <br>
(e, a, b, c);<br>
<b>and</b> <br>
(f, e, d); <br>
// Option gate instance name omitted<br>
<b>endmodule</b><br>
<hr>
<A name=136></a><b>118    Chapter 3  Gate-Level Minimization</b><br>
<i>A</i><br>
<i>B</i><br>
UDP_02467<br>
<i>E</i><br>
<i>C</i><br>
<i>F</i><br>
<i>D</i><br>
<b> <br>FIGURE 3.37 <br> <br>Schematic for <i> Circuit with_UDP_02467  </b></i><br>
 <br>Note that the variables listed on top of the table are part of a comment and are shown <br>
only for clarity. The system recognizes the variables by the order in which they are listed <br>in the input declaration. A user-defined primitive can be instantiated in the construction <br>of other modules (digital circuits), just as the system primitives are used. For example, <br>the declaration <br>
 <br>Circuit _with _UDP_ 02467 (E, F, A, B, C, D); <br>
 <br>will produce a circuit that implements the hardware shown in  Figure   3.37 . <br>
 <br>Although Verilog HDL uses this kind of description for UDPs only, other HDLs and <br>
computer-aided design (CAD) systems use other procedures to specify digital circuits <br>in tabular form. The tables can be processed by CAD software to derive an efficient gate <br>structure of the design. None of Verilog's predefined primitives describes sequential <br>logic. The model of a sequential UDP requires that its output be declared as a  <b>reg</b>   data <br>type, and that a column be added to the truth table to describe the next state. So the <br>columns are organized as inputs : state : next state. <br>
 <br>In this section, we introduced the Verilog HDL and presented simple examples to <br>
illustrate alternatives for modeling combinational logic. A more detailed presentation <br>of Verilog HDL can be found in the next chapter. The reader familiar with combina-<br>tional circuits can go directly to Section 4.12 to continue with this subject. <br>
<b> <br>P R O B L E M S </b><br>
 <br>
 <br>(Answers to problems marked with * appear at the end of the text.) <br>
 <br><b> 3.1* </b><br>
 <br>Simplify the following Boolean functions, using three-variable maps: <br>
    <br>
(a)       <i>F </i>1<i>x</i>, <i>y</i>, <i>z</i>2 =<br>
10, 2, 4, 52      <br>
  (b)       <i>F </i>1<i>x</i>, <i>y</i>, <i>z</i>2 =<br>
10, 2, 4, 5, 62 <br>
   <br>
(c)       <i>F </i>1<i>x</i>, <i>y</i>, <i>z</i>2 =<br>
10, 1, 2, 3, 52      <br>
  (d)    <i>F </i>1<i>x, y, z</i>2 =<br>
11, 2, 3, 72 <br>
 <br><b> 3.2 </b><br>
 <br>Simplify the following Boolean functions, using three-variable maps: <br>
    <br>
(a)  * <i>F</i> (<i>x</i>, <i>y</i>, <i>z</i>) =<br>
(0,  1,  5,  7)      <br>
  (b)  * <i>F</i> (<i>x</i>, <i>y</i>, <i>z</i>) =<br>
(1, 2, 3, 6, 7) <br>
   <br>
(c)       <i>F </i>1<i>x</i>, <i>y</i>, <i>z</i>2 =<br>
12, 3, 4, 52      <br>
  (d)       <i>F </i>1<i>x</i>, <i>y</i>, <i>z</i>2 =<br>
11, 2, 3, 5, 6, 72 <br>
   <br>
(e)       <i>F </i>1<i>x</i>, <i>y</i>, <i>z</i>2 =<br>
10, 2, 4, 62      <br>
  (f)       <i>F </i>1<i>x</i>, <i>y</i>, <i>z</i>2 =<br>
13, 4, 5, 6, 72 <br>
 <br><b> 3.3* </b><br>
 <br>Simplify the following Boolean expressions, using three-variable maps: <br>
    <br>
(a)  *   <i>xy </i>+ <i>x y z </i>+ <i>x yz </i>      <br>
  (b)  *   <i>x y </i>+ <i>yz </i>+ <i>x yz </i> <br>
   <br>
(c)  *   <i>F </i>1<i>x</i>, <i>y</i>, <i>z</i>2 = <i>x y </i>+ <i>yz </i>+ <i>y z </i>      <br>
  (d)       <i>F </i>1<i>x</i>, <i>y</i>, <i>z</i>2 = <i>x yz </i>+ <i>xy z</i><br>
+ <i>xy z</i> <br>
<hr>
<A name=137></a><b>Problems    119</b><br>
 <br><b> 3.4 </b><br>
 <br>Simplify the following Boolean functions, using  <i>Karnaugh</i>   maps: <br>
    <br>
(a)  *   <i>F </i> (<i>x</i>, <i>y</i>, <i>z</i>) =<br>
(2, 3, 6, 7)      <br>
  (b)  *  <i>F </i> (<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>) =<br>
(4, 6, 7, 15) <br>
   <br>
(c)  *   <i>F </i> (<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>) =<br>
(3, 7, 11, 13, 14, 15)         (d)  *   <i>F</i> (<i>w</i>, <i>x</i>, <i>y</i>, <i>z</i>) = (2, 3, 12, 13, 14, 15) <br>
   <br>
(e)         <i>F </i>(<i>w</i>, <i>x</i>, <i>y</i>, <i>z</i>) =<br>
(<i>11, 12, 13, 14, 15</i>)      <br>
 <br>
    (f)         <i>F</i> (<i>w</i>, <i>x</i>, <i>y</i>, <i>z</i>) =<br>
(8, 10, 12, 13, 14) <br>
 <br><b> 3.5 </b><br>
 <br>Simplify the following Boolean functions, using four-variable maps: <br>
    <br>
(a)  *   <i>F </i> (<i>w</i>, <i>x</i>, <i>y</i>, <i>z</i>) =<br>
 (1, 4, 5, 6, 12, 14, 15) <br>
   <br>
(b)         <i>F </i>(<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>) =<br>
(<i>2, 3, 6, 7, 12, 13, 14</i>) <br>
   <br>
(c)         <i>F </i>(<i>w</i>, <i>x</i>, <i>y</i>, <i>z</i>) =<br>
(1, 3, 4, 5, 6, 7, 9, 11, 13, 15)     <br>
   <br>
(d)  *   <i>F </i> (<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>) =<br>
 (0, 2, 4, 5, 6, 7, 8, 10, 13, 15) <br>
 <br><b> 3.6 </b><br>
 <br>Simplify the following Boolean expressions, using four-variable maps: <br>
    <br>
(a)  *   <i>A B C D </i>+ <i>AC D </i>+ <i>B CD </i>+ <i>A BCD </i>+ <i>BC D</i> <br>
   <br>
(b)  *   <i>x z </i>+ <i>w xy </i>+ <i>w</i>(<i>x y </i>+ <i>xy </i>) <br>
   <br>
(c)         <i>A B C D </i>+ <i>AB D </i>+  <i>A BC </i>+ <i>ABCD </i>+  <i>AB C</i> <br>
   <br>
(d)         <i>A B C D </i>  +  <i>BC D</i>  +  <i>A C D</i>  +  <i>A BCD</i>  +  <i>ACD </i> <br>
 <br><b> 3.7 </b><br>
 <br>Simplify the following Boolean expressions, using four-variable maps: <br>
    <br>
(a)  *   <i>w z </i>+ <i>xz </i>+ <i>x y </i>+ <i>wx z</i> <br>
   <br>
(b)         <i>AD </i>+ <i>B C D </i>+ <i>BCD </i>+ <i>BC D</i> <br>
   <br>
(c)  *   <i>AB C </i>+ <i>B C D </i>+ <i>BCD </i>+ <i>ACD </i>+ <i>A B C </i>+ <i>A BC D</i> <br>
   <br>
(d)         <i>wxy</i>  +  <i>xz</i>  +  <i>wx z</i>  +  <i>w x</i> <br>
 <br><b> 3.8 </b><br>
 <br>Find the minterms of the following Boolean expressions by first plotting each function in <br>a map: <br>
    <br>
(a)  *   <i>xy </i>+ <i>yz </i>+ <i>xy z</i>      <br>
  (b)  *   <i>C D </i>+ <i>ABC </i>+ <i>ABD </i>+ <i>A B D</i> <br>
   <br>
(c)         <i>wyz </i>+ <i>w x </i>+ <i>wxz </i>      <br>
  (d)         <i>A B </i>+ <i>A CD </i>+ <i>B CD </i>+ <i>BC D </i> <br>
 <br><b> 3.9 </b><br>
 <br>Find all the prime implicants for the following Boolean functions, and determine which <br>are essential: <br>
    <br>
(a)  *   <i>F </i>(<i>w</i>, <i>x</i>, <i>y</i>, <i>z</i>) =<br>
(0, 2, 4, 5, 6, 7, 8, 10, 13, 15)     <br>
   <br>
(b)  *   <i>F </i> (<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>) =<br>
 (0, 2, 3, 5, 7, 8, 10, 11, 14, 15) <br>
   <br>
(c)         <i>F </i>1<i>A, B, C, D</i>2 =<br>
12, 3, 4, 5, 6, 7, 9, 11, 12, 132 <br>
   <br>
(d)         <i>F </i>1<i>w, x, y, z</i>2 =<br>
11, 3, 6, 7, 8, 9, 12, 13, 14, 152 <br>
   <br>
(e)         <i>F </i>1<i>A, B, C, D</i>2 =<br>
10, 1, 2, 5, 7, 8, 9, 10, 13, 152 <br>
   <br>
(f)         <i>F </i>1<i>w, x, y, z</i>2 =<br>
10, 1, 2, 5, 7, 8, 10, 152 <br>
 <br><b> 3.10 </b><br>
 <br>Simplify the following Boolean functions by first finding the essential prime implicants: <br>
    <br>
(a)         <i>F </i>1<i>w, x, y, z</i>2 =<br>
10, 2, 5, 7, 8, 10, 12, 13, 14, 152 <br>
   <br>
(b)         <i>F </i>(<i>A, B, C, D</i>) =<br>
(0, 2, 3, 5, 7, 8, 10, 11, 14, 15) <br>
   <br>
(c)  *   <i>F </i>(<i>A, B, C, D</i>) =<br>
(1, 3, 4, 5, 10, 11, 12, 13, 14, 15) <br>
   <br>
(d)         <i>F </i>1<i>w, x, y, z</i>2 =<br>
10, 1, 4, 5, 6, 7, 9, 11, 14, 152 <br>
   <br>
(e)         <i>F </i>1<i>A, B, C, D</i>2 =<br>
10, 1, 3, 7, 8, 9, 10, 13, 152 <br>
   <br>
(f)         <i>F </i>1<i>w, x, y, z</i>2 =<br>
10, 1, 2, 4, 5, 6, 7, 10, 152 <br>
 <br><b> 3.11 </b><br>
 <br>Convert the following Boolean function from a sum-of-products form to a simplified <br>product-of-sums form. <br>
 <br>
 <br><i>F </i>1<i>x, y, z</i>2 =<br>
10, 1, 2, 5, 8, 10, 132 <br>
<hr>
<A name=138></a><b>120    Chapter 3  Gate-Level Minimization</b><br>
 <br><b> 3.12 </b><br>
 <br>Simplify the following Boolean functions: <br>
    <br>
(a)  *   <i>F </i>1<i>A, B, C, D</i>2 =<br>
11, 3, 5, 7, 13, 152 <br>
   <br>
(b)         <i>F </i>1<i>A, B, C, D</i>2 =<br>
11, 3, 6, 9, 11, 12, 142 <br>
 <br><b> 3.13 </b><br>
 <br>Simplify the following expressions to (1) sum-of-products and (2) products-of-sums: <br>
    <br>
(a)  *   <i>x z </i>+ <i>y z </i>+ <i>yz </i>+ <i>xy</i> <br>
   <br>
(b)         <i>ACD </i>+ <i>C D </i>+ <i>AB </i>+ <i>ABCD</i> <br>
   <br>
(c)          1<i>A </i>+ <i>B </i>+ <i>D </i>2 1<i>A</i><br>
+ <i>B</i><br>
+ <i>C </i>2 1<i>A</i><br>
+ <i>B</i><br>
+ <i>C</i>2 1<i>B</i><br>
+ <i>C </i>+ <i>D </i>2 <br>
   <br>
(d)         <i>BCD </i>+ <i>ABC </i>+ <i>ACD</i> <br>
 <br><b> 3.14 </b><br>
 <br>Give three possible ways to express the following Boolean function with eight or fewer literals: <br>
 <br><i>F </i>= <i>A BC D </i>+ <i>AB CD </i>+ <i>A B C </i>+ <i>ACD </i> <br>
 <br><b> 3.15 </b><br>
 <br>Simplify the following Boolean function  <i>F</i> , together with the don't-care conditions  <i>d</i> ,  and <br>then express the simplified function in sum-of-minterms form: <br>
    <br>
(a)         <i>F </i>1<i>x, y, z</i>2 =<br>
10, 1, 4, 5, 62      <br>
  (b)  *   <i>F</i> (<i>A, B, C, D</i>) =<br>
 <br>(0, 6, 8, 13, 14)<br>
 <br>
         <i>d </i>1<i>x, y, z</i>2 =<br>
12, 3, 72 <br>
 <br>
<i>d </i>(<i>A, B, C, D</i>) =<br>
 <br>(2,  4,  10)     <br>
   <br>
(c)         <i>F </i>1<i>A, B, C, D</i>2 =<br>
15, 6, 7, 12, 14, 15, 2         (d)         <i>F</i>1<i>A, B, C, D</i>2 = 14, 12, 7, 2, 10,2<br>
 <br>
 <br>
   <i>d </i>1<i>A, B, C, D</i>2 =<br>
13, 9, 11, 152 <br>
 <br>
  <i>d </i>1<i>A, B, C, D</i>2 =<br>
10, 6, 82 <br>
 <br><b> 3.16 </b><br>
 <br>Simplify the following functions, and implement them with two-level NAND gate circuits: <br>
    <br>
(a)           <i>F </i>1<i>A, B, C, D</i>2 = <i>AC D </i>+ <i>A C </i>+ <i>ABC </i>+ <i>AB C </i>+ <i>A C D </i> <br>
   <br>
(b)           <i>F </i>1<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>2 = <i>A B C D </i>+ <i>CD </i>+ <i>AC D</i> <br>
   <br>
(c)           <i>F </i>1<i>A</i>, <i>B</i>, <i>C</i>2 = 1<i>A </i>+ <i>C </i>+ <i>D </i>2 1<i>A </i>+ <i>C </i>2 1<i>C </i>+ <i>D </i>2 <br>
   <br>
(d)           <i>F </i>1<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>2 = <i>A </i>+ <i>B </i>+ <i>D </i>+ <i>B C</i> <br>
 <br><b> 3.17* </b><br>
 <br>Draw a NAND logic diagram that implements the complement of the following function: <br>
 <br><i>F </i>1<i>A, B, C, D</i>2 =<br>
10, 1, 2, 3, 6, 10, 11, 142 <br>
 <br><b> 3.18 </b><br>
 <br>Draw a logic diagram using only two-input NOR gates to implement the following function: <br>
 <br><i>F </i>1<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>2 = (<i>A </i>{ <i>B</i>)'(<i>C </i>{ <i>D</i>)  <br>
 <br><b> 3.19 </b><br>
 <br>Simplify the following functions, and implement them with two-level NOR gate circuits: <br>
    <br>
(a)  *   <i>F </i>= <i>wx </i>+ <i>y z </i>+ <i>w yz </i> <br>
   <br>
(b)         <i>F </i>1<i>w, x, y, z</i>2 =<br>
10, 3, 12, 152 <br>
   <br>
(c)         <i>F</i> (<i>x</i>, <i>y</i>, <i>z</i>)  = [(<i>x </i>+ <i>y</i>)(<i>x </i>= <i>z</i>)]  <br>
 <br><b> 3.20 </b><br>
 <br>Draw the multiple-level NOR circuit for the following expression: <br>
 <br><i>CD </i>1<i>B </i>+ <i>C</i>2<i>A </i>+ 1<i>BC </i>+ <i>DE </i>2 <br>
 <br><b> 3.21 </b><br>
 <br>Draw the multiple-level NAND circuit for the following expression: <br>
 <br><i>w </i>1<i>x </i>+ <i>y </i>+ <i>z</i>2 + <i>xyz</i> <br>
 <br><b> 3.22 </b><br>
 <br>Convert the logic diagram of the circuit shown in  Fig.   4.4   into a multiple-level NAND circuit. <br>
 <br><b> 3.23 </b><br>
 <br>Implement the following Boolean function  <i>F</i> , together with the don't-care conditions  <i>d</i> , <br>using no more than two NOR gates: <br>
 <br><i>F </i>1<i>A, B, C, D</i>2 =<br>
12, 4, 10, 12, 14, 2<br>
<i>d </i>1<i>A, B, C, D</i>2 =<br>
10, 1, 5, 82 <br>
 <br>
 <br>Assume that both the normal and complement inputs are available. <br>
<hr>
<A name=139></a><b>Problems    121</b><br>
 <br><b> 3.24 </b><br>
 <br>Implement the following Boolean function  <i>F</i> , using the two-level forms of logic (a) NAND-<br>AND, (b) AND-NOR, (c) OR-NAND, and (d) NOR-OR: <br>
 <br><i>F </i>1<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>2 =<br>
10, 4, 8, 9, 10, 11, 12, 142 <br>
 <br><b> 3.25 </b><br>
 <br>List the eight degenerate two-level forms and show that they reduce to a single operation. <br>Explain how the degenerate two-level forms can be used to extend the number of inputs <br>to a gate. <br>
 <br><b> 3.26 </b><br>
 <br>With the use of maps, find the simplest sum-of-products form of the function  <i>F = fg</i> ,  where <br>
 <i>f </i>= <i>abc </i>+ <i>c d </i>+ <i>a cd </i>+ <i>b cz </i> <br>
  <br>
 <br>
and <br>
 <br><i>g </i>= 1<i>a </i>+ <i>b </i>+ <i>c </i>+ <i>d </i>2 1<i>b </i>+ <i>c </i>+ <i>d</i>2 1<i>a </i>+ <i>c </i>+ <i>d </i>2 <br>
 <br><b> 3.27 </b><br>
 <br>Show that the dual of the exclusive-OR is also its complement. <br>
 <br><b> 3.28 </b><br>
 <br>Derive the circuits for a three-bit parity generator and four-bit parity checker using an odd <br>parity  bit.   <br>
 <br><b> 3.29 </b><br>
 <br>Implement the following four Boolean expressions with three half adders: <br>
 <br><i>D </i>= <i>A </i>{ <i>B </i>{ <i>C</i><br>
<i>E </i>= <i>A BC </i>+ <i>AB C</i><br>
<i>F </i>= <i>ABC </i>+ (<i>A </i>+ <i>B </i>) <i>C</i><br>
<i>G </i>= <i>ABC</i> <br>
 <br><b> 3.30* </b><br>
 <br>Implement the following Boolean expression with exclusive-OR and AND gates: <br>
 <br><i>F </i>= <i>AB CD </i>+ <i>A BC D </i>+ <i>AB C D </i>+ <i>A BC D</i> <br>
 <br><b> 3.31 </b><br>
 <br>Write a Verilog gate-level description of the circuit shown in <br>
    <br>
(a)     Fig.    3.20   (a)   <br>
  (b)     Fig.    3.20   (b)   <br>
  (c)     Fig.    3.21   (a)  <br>
   <br>
(d)     Fig.    3.21   (b)   <br>
  (e)     Fig.    3.24      <br>
  (f)     Fig.    3.25        <br>
 <br><b> 3.32 </b><br>
 <br>Using continuous assignment statements, write a Verilog description of the circuit <br>shown in <br>
    <br>
(a)     Fig.    3.20   (a)   <br>
  (b)     Fig.    3.20   (b)   <br>
  (c)     Fig.    3.21   (a)  <br>
   <br>
(d)     Fig.    3.21   (b)     <br>
(e)     Fig.    3.24        <br>
(f)     Fig.    3.25        <br>
 <br><b> 3.33 </b><br>
 <br>The exclusive-OR circuit of  Fig.   3.30  (a) has gates with a delay of 3 ns for an inverter, a 6 ns <br>delay for an AND gate, and a 8 ns delay for an OR gate. The input of the circuit goes from <br> <br><i>xy =</i>  00 to  <i>xy =</i>   01. <br>
 <br>
(a)   Determine the signals at the output of each gate from  <i>t =</i>  0 to  <i>t =</i>  50 ns. <br>
 <br>
(b)   Write a Verilog gate-level description of the circuit, including the delays. <br>
 <br>
(c)   Write a stimulus module (i.e., a test bench similar to HDL  Example   3.3  ), and simulate <br>
the circuit to verify the answer in part (a). <br>
 <br><b> 3.34 </b><br>
 <br>Using continuous assignments, write a Verilog description of the circuit specified by the <br>following Boolean functions: <br>
 <br><i>Out_1 </i>= 1<i>A </i>+ <i>B </i>2<i>C </i>1<i>C </i>+ <i>D</i>2<br>
<i>Out</i>_2 = 1<i>C D </i>+ <i>BCD </i>+ <i>CD </i>2 1<i>A </i>+ <i>B</i>2<br>
<i>Out</i>_3 = 1<i>AB </i>+ <i>C</i>2<i>D </i>+ <i>B C</i> <br>
 <br>
 <br>Write a test bench and simulate the circuit's behavior. <br>
<hr>
<A name=140></a><b>122    Chapter 3  Gate-Level Minimization</b><br>
 <br><b> 3.35* </b><br>
 <br>Find the syntax errors in the following declarations (note that names for primitive gates <br>are optional): <br>
 <br>
 <br>
 <br><b>module</b> Exmpl-3(A, B, C, D, F) <br>
// Line 1 <br>
 <br>
 <br>
<b>inputs</b> <br>
A, B, C, Output D, F, <br>
// Line 2 <br>
 <br>
 <br>
  <b>output</b> <br>
B <br>
// Line 3 <br>
 <br>
 <br>
  <b>and</b> <br>
g1(A, B, D); <br>
// Line 4 <br>
 <br>
 <br>
 <br><b> not</b> <br>
(D, A, C), <br>
// Line 5 <br>
 <br>
 <br>
  <b>OR</b> <br>
(F, B; C); <br>
// Line 6 <br>
 <br>
 <br>
 <br><b>endmodule;</b> <br>
 <br>
// Line 7 <br>
 <br><b> 3.36 </b><br>
 <br>Draw the logic diagram of the digital circuit specified by the following Verilog description: <br>
 <br>
(a) <b>module</b> Circuit_A (A, B, C, D, F); <br>
 <br>
 <br>
 <br>
  <b>input</b> <br>
A, B, C, D; <br>
 <br>
 <br>
 <br>
  <b>output</b> F; <br>
 <br>
 <br>
 <br>
<b>wire</b> <br>
w, x, y, z, a, d; <br>
 <br>
 <br>
 <br>
  <b>or</b> <br>
(x, B, C, d); <br>
 <br>
 <br>
 <br>
 <br><b> and</b> <br>
(y, a ,C); <br>
 <br>
 <br>
 <br>
  <b>and</b> <br>
(w, z ,B); <br>
 <br>
 <br>
 <br>
  and <br>
(z, y, A); <br>
 <br>
 <br>
 <br>
  <b>or</b> <br>
(F, x, w); <br>
 <br>
 <br>
 <br>
  <b>not</b> (a, <br>
A); <br>
 <br>
 <br>
 <br>
  <b>not</b> (d, <br>
D); <br>
 <br>
 <br>
 <br><b>endmodule</b><br>
   <br>
(b)   <b> module</b> Circuit_B (F1, F2, F3, A0, A1, B0, B1); <br>
 <br>
 <br>
 <br>
  <b>output</b> <br>
F1, F2, F3; <br>
 <br>
 <br>
 <br>
  <b>input</b> <br>
A0, A1, B0, B1; <br>
 <br>
 <br>
 <br>
  <b>nor</b> <br>
(F1, F2, F3); <br>
 <br>
 <br>
 <br>
  <b>or</b> <br>
(F2, w1, w2, w3); <br>
 <br>
 <br>
 <br>
  <b>and</b> <br>
(F3, w4, w5); <br>
 <br>
 <br>
 <br>
  <b>and</b> <br>
(w1, w6, B1); <br>
 <br>
 <br>
 <br>
 <br><b> or</b> <br>
(w2, w6, w7, B0); <br>
 <br>
 <br>
 <br>
  <b>and</b> <br>
(w3, w7, B0, B1); <br>
 <br>
 <br>
 <br>
  <b>not</b> (w6, <br>
A1); <br>
 <br>
 <br>
 <br>
  <b>not</b> (w7, <br>
A0); <br>
 <br>
 <br>
 <br>
  <b>xor</b> <br>
(w4, A1, B1); <br>
 <br>
 <br>
 <br>
  <b>xnor</b> <br>
(w5, A0, B0); <br>
<b> </b><br>
<b> </b><br>
<b> <br>endmodule</b><br>
   <br>
(c)      <b>module</b> Circuit_C (y1, y2, y3, a, b); <br>
 <br>
 <br>
 <br>
  <b>output</b> y1, y2, y3; <br>
 <br>
 <br>
 <br>
  <b>input</b> a, b; <br>
 <br>
 <br>
 <br>
  <b>assign</b> y1 = a || b; <br>
 <br>
 <br>
 <br>
  <b>and</b> (y2, a, b); <br>
 <br>
 <br>
 <br>
  <b>assign</b> y3 = a &amp;&amp; b; <br>
 <br>
 <br>
 <br><b>endmodule</b><br>
<hr>
<A name=141></a><b>References    123</b><br>
 <br><b> 3.37 </b><br>
 <br>A majority logic function is a Boolean function that is equal to 1 if the majority of the <br>variables are equal to 1, equal to 0 otherwise. <br>
 <br>
(a)   Write a truth table for a four-bit majority function. <br>
 <br>
(b)   Write a Verilog user-defined primitive for a four-bit majority function. <br>
 <br><b> 3.38 </b><br>
 <br>Simulate the behavior of  <i>Circuit_with_UDP_02467</i> , using the stimulus waveforms shown <br>in   Fig.    P3.38   .           <br>
A<br>
t, ns<br>
10<br>
20<br>
30<br>
40<br>
50<br>
60<br>
70<br>
80<br>
B<br>
t, ns<br>
10<br>
20<br>
30<br>
40<br>
50<br>
60<br>
70<br>
80<br>
C<br>
t, ns<br>
10<br>
20<br>
30<br>
40<br>
50<br>
60<br>
70<br>
80<br>
D<br>
t, ns<br>
10<br>
20<br>
30<br>
40<br>
50<br>
60<br>
70<br>
80<br>
<b> <br>FIGURE P3.38 <br>Stimulus waveforms for Problem 3.38</b><br>
 <br><b> 3.39 </b><br>
 <br>Using primitive gates, write a Verilog model of a circuit that will produce two outputs, <br><i>s</i> and <i>c</i>, equal to the sum and carry produced by adding two binary input bits <i>a</i> and <i>b</i> (e.g., <br><i>s</i> = 1 and <i>c</i> = 0 if <i>a</i> = 0 and <i>b</i> = 1). ( <i>Hint:</i>  Begin by developing a truth table for <i>s</i> and <i>c</i>.)    <br>
<b> <br>R E F E R E N C E S </b><br>
 <br>
<b> <br>1.  </b><br>
B hasker ,  J.  1997.  <i>A Verilog HDL Primer</i>. Allentown, PA: Star Galaxy Press. <br>
 <br>
<b> <br>2.</b> <br>
 C iletti ,  M.  D.  1999.  <i>Modeling, Synthesis and Rapid Prototyping with the Verilog HDL</i>. <br>Upper Saddle River, NJ: Prentice Hall. <br>
 <br>
<b> <br>3.</b> <br>
 <br>H ill , F. J., and G. R. P eterson . 1981. <i>Introduction to Switching Theory and Logical Design</i>, <br>3rd ed. New York: John Wiley. <br>
 <br>
<b> <br>4. </b> <br>
<i>IEEE Standard Hardware Description Language Based on the Verilog Hardware Descrip-<br>tion Language</i> (IEEE Std. 1364-1995). 1995. New York: The Institute of Electrical and <br>Electronics Engineers. <br>
 <br>
<b> <br>5. </b> <br>
K arnaugh , M. A Map Method for Synthesis of Combinational Logic Circuits. <i>Transactions <br>of AIEE, Communication and Electronics</i>. 72, part I (Nov. 1953): 593�99. <br>
 <br>
<b> <br>6. </b> <br>
K ohavi ,  Z.  1978.  <i>Switching and Automata Theory</i>, 2nd ed. New York: McGraw-Hill. <br>
<hr>
<A name=142></a><b>124    Chapter 3  Gate-Level Minimization</b><br>
 <br>
<b> <br>7. </b> <br>
M ano , M. M. and C. R. K ime . 2004. <i>Logic and Computer Design Fundamentals</i>, 3rd ed. <br>Upper Saddle River, NJ: Prentice Hall. <br>
 <br>
<b> <br>8. </b> <br>
M c C luskey ,  E.  J.  1986.  <i>Logic Design Principles</i>. Englewood Cliffs, NJ: Prentice-Hall. <br>
 <br>
<b> <br>9. </b> <br>
P alnitkar ,  S.  1996.  <i>Verilog HDL: A Guide to Digital Design and Synthesis</i>. Mountain View, <br>CA: SunSoft Press (a Prentice Hall title). <br>
<b> <br>W E B   S E A R C H   T O P I C S </b><br>
 <br>
 <br>
   Boolean  minimization  <br>
 <br>
 <br>
  Karnaugh  map  <br>
 <br>
 <br>
  Wired  logic  <br>
 <br>
 <br>
  Emitter-coupled  logic  <br>
 <br>
 <br>
  Open-collector  logic  <br>
 <br>
 <br>
  Quine  McCluskey  method  <br>
 <br>
 <br>
  Expresso  software  <br>
 <br>
 <br>
  Consensus  theorem  <br>
 <br>
 <br>
  Don't-care  conditions        <br>
<hr>
<A name=143></a> <br>Chapter 4 <br>
<b> <br>Combinational Logic </b> <br>
<b> <br>4 . 1       IN T R O D U C T I O N </b><br>
 <br>Logic circuits for digital systems may be combinational or sequential. A combinational <br>circuit consists of logic gates whose outputs at any time are determined from only the <br>present combination of inputs. A combinational circuit performs an operation that can <br>be specified logically by a set of Boolean functions. In contrast, sequential circuits <br>employ storage elements in addition to logic gates. Their outputs are a function of the <br>inputs and the state of the storage elements. Because the state of the storage elements <br>is a function of previous inputs, the outputs of a sequential circuit depend not only on <br>present values of inputs, but also on past inputs, and the circuit behavior must be speci-<br>fied by a time sequence of inputs and internal states. Sequential circuits are the building <br>blocks  of  digital  systems  and  are  discussed  in   Chapters    5           and     8   .  <br>
<b> <br>4 . 2       C O M B I N AT I O N A L   C I R C U I T S </b><br>
 <br>A combinational circuit consists of an interconnection of logic gates. Combinational <br>logic gates react to the values of the signals at their inputs and produce the value of the <br>output signal, transforming binary information from the given input data to a required <br>output data. A block diagram of a combinational circuit is shown in  Fig.   4.1 . The  <i>n</i>   input <br>binary variables come from an external source; the  <i>m</i>  output variables are produced by <br>the internal combinational logic circuit and go to an external destination. Each input <br>and output variable exists physically as an analog signal whose values are interpreted <br>to be a binary signal that represents logic 1 and logic 0. ( <i>Note</i> : Logic simulators show <br>only 0's and 1's, not the actual analog signals.) In many applications, the source and <br>
<b>125</b><br>
<hr>
<A name=144></a><b>126    Chapter 4  Combinational Logic</b><br>
Combinational<br>
<i>n</i> inputs<br>
<i>m</i> outputs<br>
circuit<br>
<b> <br>FIGURE 4.1 <br> <br>Block diagram of combinational circuit  </b><br>
destination are storage registers. If the registers are included with the combinational <br>gates, then the total circuit must be considered to be a sequential circuit. <br>
 For   <i>n</i>  input variables, there are   2<i>n</i>  possible combinations of the binary inputs. For each <br>
possible input combination, there is one possible value for each output variable. Thus, a <br>combinational circuit can be specified with a truth table that lists the output values for <br>each combination of input variables. A combinational circuit also can be described by <br> <br><i>m</i>  Boolean functions, one for each output variable. Each output function is expressed <br>in terms of the  <i>n</i>  input variables. <br>
 <br>In  Chapter   1  , we learned about binary numbers and binary codes that represent discrete <br>
quantities of information. The binary variables are represented physically by electric volt-<br>ages or some other type of signal. The signals can be manipulated in digital logic gates to <br>perform required functions. In  Chapter   2  , we introduced Boolean algebra as a way to <br>express logic functions algebraically. In  Chapter   3  , we learned how to simplify Boolean <br>functions to achieve economical (simpler) gate implementations. The purpose of the cur-<br>rent chapter is to use the knowledge acquired in previous chapters to formulate systematic <br>analysis and design procedures for combinational circuits. The solution of some typical <br>examples will provide a useful catalog of elementary functions that are important for the <br>understanding of digital systems. We'll address three tasks: (1) Analyze the behavior of a <br>given logic circuit, (2) synthesize a circuit that will have a given behavior, and (3) write <br>hardware description language (HDL) models for some common circuits. <br>
 <br>There are several combinational circuits that are employed extensively in the design <br>
of digital systems. These circuits are available in integrated circuits and are classified as <br>standard components. They perform specific digital functions commonly needed in the <br>design of digital systems. In this chapter, we introduce the most important standard <br>combinational circuits, such as adders, subtractors, comparators, decoders, encoders, and <br>multiplexers. These components are available in integrated circuits as medium-scale <br>integration (MSI) circuits. They are also used as  <i>standard cells</i>  in complex very large-<br>scale integrated (VLSI) circuits such as application-specific integrated circuits (ASICs). <br>The standard cell functions are interconnected within the VLSI circuit in the same way <br>that they are used in multiple-IC MSI design. <br>
<b> <br>4 . 3       A N A L Y S I S   P R O C E D U R E </b><br>
 <br>The analysis of a combinational circuit requires that we determine the function that the <br>circuit implements. This task starts with a given logic diagram and culminates with a set <br>of Boolean functions, a truth table, or, possibly, an explanation of the circuit operation. <br>
<hr>
<A name=145></a><b>Section 4.3  Analysis Procedure    127</b><br>
If the logic diagram to be analyzed is accompanied by a function name or an explanation <br>of what it is assumed to accomplish, then the analysis problem reduces to a verification <br>of the stated function. The analysis can be performed manually by finding the Boolean <br>functions or truth table or by using a computer simulation program. <br>
 <br>The first step in the analysis is to make sure that the given circuit is combinational <br>
and not sequential.  <b>The diagram of a combinational circuit has logic gates with no <br> feedback  paths</b>  or  <b>memory elements .</b> A feedback path is a connection from the output <br>of one gate to the input of a second gate whose output forms part of the input to the <br>first gate. Feedback paths in a digital circuit define a sequential circuit and must be <br>analyzed by special methods and will not be considered here. <br>
 <br>Once the logic diagram is verified to be that of a combinational circuit, one can proceed <br>
to obtain the output Boolean functions or the truth table. If the function of the circuit is <br>under investigation, then it is necessary to interpret the operation of the circuit from the <br>derived Boolean functions or truth table. The success of such an investigation is enhanced <br>if one has previous experience and familiarity with a wide variety of digital circuits. <br>
 <br>To obtain the output Boolean functions from a logic diagram, we proceed as follows: <br>
 <br>
<b>1.  </b> Label all gate outputs that are a function of input variables with arbitrary symbols--<br>
but with meaningful names. Determine the Boolean functions for each gate output. <br>
 <br><b> 2. </b><br>
 <br>Label the gates that are a function of input variables and previously labeled gates <br>with other arbitrary symbols. Find the Boolean functions for these gates. <br>
 <br><b> 3. </b><br>
 <br>Repeat the process outlined in step 2 until the outputs of the circuit are obtained. <br>
 <br><b> 4. </b><br>
 <br>By repeated substitution of previously defined functions, obtain the output <br>Boolean  functions in terms of input variables. <br>
 <br>The analysis of the combinational circuit of  Fig.   4.2   illustrates the proposed proce-<br>
dure. We note that the circuit has three binary inputs-- <i>A</i> ,   <i>B</i> ,  and   <i>C</i> --and  two  binary <br>outputs--   <i>F</i>1     and     <i>F</i>2.    <b> </b> The outputs of various gates are labeled with intermediate symbols. <br>The outputs of gates that are a function only of input variables are   <i>T</i>1     and     <i>T</i>2.     Output <br> <br><i>F</i>2  can easily be derived from the input variables. The Boolean functions for these three <br>outputs are <br>
 <br><i>F</i>2 = <i>AB </i>+ <i>AC </i>+ <i>BC</i> <br>
 <br>
 <br><i>T</i>1 = <i>A </i>+ <i>B </i>+ <i>C</i><br>
 <br>
 <br><i>T</i>2 = <i>ABC</i> <br>
 <br>Next, we consider outputs of gates that are a function of already defined symbols: <br>
 <br>
 <br><i>T</i>3 = <i>F </i>2<i>T</i>1<br>
<i>F</i>1 = <i>T</i>3 + <i>T</i>2 <br>
 To  obtain     <i>F</i>1  as a function of  <i>A</i> ,   <i>B</i> , and  <i>C</i> , we form a series of substitutions as follows: <br>
<i>F</i>1 = <i>T</i>3 + <i>T</i>2 = <i>F </i>2<i>T</i>1 + <i>ABC </i>= 1<i>AB </i>+ <i>AC </i>+ <i>BC</i>2 1<i>A </i>+ <i>B </i>+ <i>C</i>2 + <i>ABC</i><br>
= 1<i>A </i>+ <i>B </i>2 1<i>A </i>+ <i>C </i>2 1<i>B</i><br>
+ <i>C </i>2 1<i>A </i>+ <i>B </i>+ <i>C</i>2 + <i>ABC</i><br>
= 1<i>A </i>+ <i>B C </i>2 1<i>AB</i><br>
+ <i>AC</i><br>
+ <i>BC</i><br>
+ <i>B C</i>2 + <i>ABC</i><br>
 <br>
= <i>A BC</i><br>
+ <i>A B C </i>+ <i>AB C</i><br>
+ <i>ABC</i> <br>
<hr>
<A name=146></a><b>128    Chapter 4  Combinational Logic</b><br>
<i>A</i><br>
<i>T</i>2<br>
<i>B</i><br>
<i>C</i><br>
<i>F</i>1<br>
<i>A</i><br>
<i>T</i>1<br>
<i>B</i><br>
<i>C</i><br>
<i>T</i>3<br>
<i>F </i>2<br>
<i>A</i><br>
<i>B</i><br>
<i>A</i><br>
<i>F</i>2<br>
<i>C</i><br>
<i>B</i><br>
<i>C</i><br>
<b> <br>FIGURE 4.2 <br> <br>Logic diagram for analysis example  </b><br>
 <br>If we want to pursue the investigation and determine the information transformation <br>
task achieved by this circuit, we can draw the circuit from the derived Boolean expres-<br>sions and try to recognize a familiar operation. The Boolean functions for   <i>F</i>1     and     <i>F</i>2 <br>implement a circuit discussed in Section 4.5. Merely finding a Boolean representation <br>of a circuit doesn't provide insight into its behavior, but in this example we will observe <br>that the Boolean equations and truth table for   <i>F</i>1     and     <i>F</i>2  match those describing the <br>functionality of what we call a full adder. <br>
 <br>The derivation of the truth table for a circuit is a straightforward process once the <br>
output Boolean functions are known. To obtain the truth table directly from the logic <br>diagram without going through the derivations of the Boolean functions, we proceed as <br>follows: <br>
 <br><b> 1. </b><br>
 <br>Determine the number of input variables in the circuit. For <i>n</i> inputs, form the   2<i>n</i> <br>possible input combinations and list the binary numbers from 0 to   (2<i>n </i>- 1)     in  a <br>table.  <br>
 <br><b> 2. </b><br>
 <br>Label the outputs of selected gates with arbitrary symbols. <br>
 <br><b> 3. </b><br>
 <br>Obtain the truth table for the outputs of those gates which are a function of the <br>input variables only. <br>
 <br><b> 4. </b><br>
 <br>Proceed to obtain the truth table for the outputs of those gates which are a func-<br>tion of previously defined values until the columns for all outputs are determined. <br>
<hr>
<A name=147></a><b>Section 4.4  Design Procedure    129</b><br>
<b> <br>Table 4.1 <br><i> <br>Truth Table for the Logic Diagram of  Fig.   4.2  </b></i><br>
<i> <br><b>A</b> </i><br>
<i> <br><b>B</b> </i><br>
<i> <br><b>C</b> </i><br>
<i> <br><b>F</b> </i><b>2</b><i> </i><br>
<i><b> <br>F2</b></i><br>
<i> <br><b>T</b> </i><b>1</b><i> </i><br>
<i> <br><b>T</b> </i><b>2</b><i> </i><br>
<i><b> <br>T</b> </i><b>3</b><i> </i><br>
<i> <br><b>F</b> </i><b>1</b><i> </i><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 This  process  is  illustrated  with  the  circuit  of   Fig.    4.2   .  In   Table    4.1   ,  we  form  the <br>
eight possible combinations for the three input variables. The truth table for   <i>F</i>2 is <br>determined directly from the values of  <i>A</i> ,   <i>B</i> , and  <i>C</i> ,  with     <i>F</i>2  equal to 1 for any com-<br>bination that has two or three inputs equal to 1. The truth table for   <i>F</i>2     is  the  comple-<br>ment of   <i>F</i>2.     The  truth  tables  for     <i>T</i>1     and     <i>T</i>2  are the OR and AND functions of the <br>input variables, respectively. The values for   <i>T</i>3     are  derived  from     <i>T</i>1     and     <i>F</i>2:<i>T</i>3     is  equal <br>to 1 when both   <i>T</i>1     and     <i>F</i>2  are equal to 1, and   <i>T</i>3  is equal to 0 otherwise. Finally,   <i>F</i>1 is <br>equal to 1 for those combinations in which either   <i>T</i>2 or  <i>T</i>3  or both are equal to 1. <br>Inspection of the truth table combinations for  <i>A, B, C,</i>  <i>F</i>1,     and     <i>F</i>2  shows that it is <br>identical to the truth table of the full adder given in Section 4.5 for  <i>x, y, z, S</i> , and  <i>C</i> , <br>respectively. <br>
 <br>Another way of analyzing a combinational circuit is by means of logic simulation. <br>
This is not practical, however, because the number of input patterns that might be <br>needed to generate meaningful outputs could be very large. But simulation has a very <br>practical application in verifying that the functionality of a circuit actually matches its <br>specification. In Section 4.12, we demonstrate the logic simulation and verification of <br>the  circuit  of   Fig.    4.2   ,  using  Verilog  HDL.  <br>
<b> <br>4 . 4       D E S I G N   P R O C E D U R E </b><br>
 <br>The design of combinational circuits starts from the specification of the design objective <br>and culminates in a logic circuit diagram or a set of Boolean functions from which the <br>logic diagram can be obtained. The procedure involves the following steps: <br>
 <br><b> 1. </b><br>
 <br>From the specifications of the circuit, determine the required number of inputs <br>and outputs and assign a symbol to each. <br>
 <br><b> 2. </b><br>
 <br>Derive the truth table that defines the required relationship between inputs and <br>outputs.  <br>
<hr>
<A name=148></a><b>130    Chapter 4  Combinational Logic</b><br>
 <br><b> 3. </b><br>
 <br>Obtain the simplified Boolean functions for each output as a function of the input <br>variables.  <br>
 <br><b> 4. </b><br>
 <br>Draw the logic diagram and verify the correctness of the design (manually or by <br>simulation).   <br>
 <br>A truth table for a combinational circuit consists of input columns and output <br>
columns. The input columns are obtained from the   2<i>n</i>  binary numbers for the  <i>n</i>   input <br>variables. The binary values for the outputs are determined from the stated specifica-<br>tions. The output functions specified in the truth table give the exact definition of the <br>combinational circuit. It is important that the verbal specifications be interpreted <br>correctly in the truth table, as they are often incomplete, and any wrong interpretation <br>may result in an incorrect truth table. <br>
 <br>The output binary functions listed in the truth table are simplified by any available <br>
method, such as algebraic manipulation, the map method, or a computer-based sim-<br>plification program. Frequently, there is a variety of simplified expressions from <br>which to choose. In a particular application, certain criteria will serve as a guide in <br>the process of choosing an implementation. A practical design must consider such <br>constraints as the number of gates, number of inputs to a gate, propagation time of <br>the signal through the gates, number of interconnections, limitations of the driving <br>capability of each gate (i.e., the number of gates to which the output of the circuit <br>may be connected), and various other criteria that must be taken into consideration <br>when designing integrated circuits. Since the importance of each constraint is dictated <br>by the particular application, it is difficult to make a general statement about what <br>constitutes an acceptable implementation. In most cases, the simplification begins by <br>satisfying an elementary objective, such as producing the simplified Boolean func-<br>tions in a standard form. Then the simplification proceeds with further steps to meet <br>other performance criteria. <br>
<b> <br>Code Conversion Example </b><br>
 <br>The availability of a large variety of codes for the same discrete elements of information <br>results in the use of different codes by different digital systems. It is sometimes necessary <br>to use the output of one system as the input to another. A conversion circuit must be <br>inserted between the two systems if each uses different codes for the same information. <br>Thus, a code converter is a circuit that makes the two systems compatible even though <br>each uses a different binary code. <br>
 <br>To convert from binary code A to binary code B, the input lines must supply the <br>
bit combination of elements as specified by code A and the output lines must gener-<br>ate the corresponding bit combination of code B. A combinational circuit performs <br>this transformation by means of logic gates. The design procedure will be illustrated <br>by an example that converts binary coded decimal (BCD) to the excess-3 code for the <br>decimal digits. <br>
 <br>The bit combinations assigned to the BCD and excess-3 codes are listed in Table 1.5 <br>
(Section 1.7). Since each code uses four bits to represent a decimal digit, there must <br>
<hr>
<A name=149></a><b>Section 4.4  Design Procedure    131</b><br>
<b> <br>Table 4.2 <br><i> <br>Truth Table for Code Conversion Example </b></i><br>
<b> <br>Input BCD </b><br>
<b> <br>Output Excess-3 Code </b><br>
<i><b> <br>A  </b></i><br>
<i><b>B  </b></i><br>
<i><b>C  </b></i><br>
<i><b>D  </b></i><br>
<i><b>w  </b></i><br>
<i><b>x  </b></i><br>
<i><b>y  </b></i><br>
<i><b>z </b></i><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
be four input variables and four output variables. We designate the four input binary <br> <br>variables by the symbols  <i>A, B, C,</i>  and  <i>D,</i>  and the four output variables by  <i>w, x, y</i> ,  and <br> <br><i>z</i> . The truth table relating the input and output variables is shown in  Table   4.2  . The bit <br>combinations for the inputs and their corresponding outputs are obtained directly <br>from Section 1.7. Note that four binary variables may have 16 bit combinations, but <br>only 10 are listed in the truth table. The six bit combinations not listed for the input <br>variables are don't-care combinations. These values have no meaning in BCD and we <br>assume that they will never occur in actual operation of the circuit. Therefore, we are <br>at liberty to assign to the output variables either a 1 or a 0, whichever gives a simpler <br>circuit. <br>
 <br>The maps in  Fig.   4.3   are plotted to obtain simplified Boolean functions for the <br>
outputs. Each one of the four maps represents one of the four outputs of the circuit <br>as a function of the four input variables. The 1's marked inside the squares are <br>obtained from the minterms that make the output equal to 1. The 1's are obtained <br>from the truth table by going over the output columns one at a time. For example, <br>the column under output  <i>z</i>  has five 1's; therefore, the map for  <i>z</i>  has five 1's, each <br>being in a square corresponding to the minterm that makes  <i>z</i>  equal to 1. The six <br>don't-care minterms 10 through 15 are marked with an  <i>X</i> . One possible way to sim-<br>plify the functions into sum-of-products form is listed under the map of each variable. <br>(See   Chapter    3   .) <br>
 <br>A two-level logic diagram for each output may be obtained directly from the Boolean <br>
expressions derived from the maps. There are various other possibilities for a logic diagram <br>that implements this circuit. The expressions obtained in  Fig.  4.3   may be manipulated <br>algebraically for the purpose of using common gates for two or more outputs. This manip-<br>ulation, shown next, illustrates the flexibility obtained with multiple-output systems when <br>
<hr>
<A name=150></a><b>132    Chapter 4  Combinational Logic</b><br>
<i>C</i><br>
<i>C</i><br>
<i>CD</i><br>
<i>CD</i><br>
<i>AB</i><br>
00<br>
01<br>
11<br>
10<br>
<i>AB</i><br>
00<br>
01<br>
11<br>
10<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
0<br>
1<br>
3<br>
2<br>
0<br>
1<br>
3<br>
2<br>
00<br>
1<br>
1<br>
00<br>
1<br>
1<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
7<br>
6<br>
4<br>
5<br>
7<br>
6<br>
01<br>
1<br>
1<br>
01<br>
1<br>
1<br>
<i>B</i><br>
<i>B</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
12<br>
13<br>
15<br>
14<br>
12<br>
13<br>
15<br>
14<br>
11<br>
X<br>
X<br>
X<br>
X<br>
11<br>
X<br>
X<br>
X<br>
X<br>
<i>A</i><br>
<i>A</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
8<br>
9<br>
11<br>
10<br>
8<br>
9<br>
11<br>
10<br>
10<br>
1<br>
X<br>
X<br>
10<br>
1<br>
X<br>
X<br>
<i>D</i><br>
<i>D</i><br>
<i>z</i><br>
<i>D</i><br>
<i>y</i><br>
<i>CD</i><br>
<i>C D</i><br>
<i>C</i><br>
<i>C</i><br>
<i>CD</i><br>
<i>CD</i><br>
00<br>
01<br>
11<br>
10<br>
<i>AB</i><br>
<i>AB</i><br>
00<br>
01<br>
11<br>
10<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
0<br>
1<br>
3<br>
2<br>
0<br>
1<br>
3<br>
2<br>
00<br>
1<br>
1<br>
1<br>
00<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
7<br>
6<br>
4<br>
5<br>
7<br>
6<br>
01<br>
1<br>
1<br>
01<br>
1<br>
1<br>
1<br>
<i>B</i><br>
<i>B</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
12<br>
13<br>
15<br>
14<br>
12<br>
13<br>
15<br>
14<br>
11<br>
X<br>
X<br>
X<br>
X<br>
11<br>
X<br>
X<br>
X<br>
X<br>
<i>A</i><br>
<i>A</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
8<br>
9<br>
11<br>
10<br>
8<br>
9<br>
11<br>
10<br>
10<br>
1<br>
X<br>
X<br>
10<br>
1<br>
1<br>
X<br>
X<br>
<i>D</i><br>
<i>D</i><br>
<i>x</i><br>
<i>B C</i><br>
<i>B D</i><br>
<i>BC D</i><br>
<i>w</i><br>
<i>A</i><br>
<i>BC</i><br>
<i>BD</i><br>
<b> <br>FIGURE 4.3 <br> <br>Maps for BCD-to-excess-3 code converter  </b><br>
implemented with three or more levels of gates: <br> <br>
 <br><i>z </i>= <i>D</i><br>
 <br>
<i>y </i>= <i>CD </i>+ <i>C D </i>= <i>CD </i>+ 1<i>C </i>+ <i>D</i>2<br>
<i>x </i>= <i>B C </i>+ <i>B D </i>+ <i>BC D </i>= <i>B </i>1<i>C </i>+ <i>D</i>2 + <i>BC D</i><br>
 <br>
= <i>B </i>1<i>C </i>+ <i>D</i>2 + <i>B </i>1<i>C </i>+ <i>D</i>2<br>
 <br>
<i>w </i>= <i>A </i>+ <i>BC </i>+ <i>BD </i>= <i>A </i>+ <i>B</i>1<i>C </i>+ <i>D</i>2 <br>
 <br>The logic diagram that implements these expressions is shown in  Fig.   4.4  . Note that the OR <br>gate whose output is   <i>C </i>+ <i>D</i>  has been used to implement partially each of three outputs. <br>
 <br>Not counting input inverters, the implementation in sum-of-products form requires <br>
seven AND gates and three OR gates. The implementation of  Fig.   4.4   requires four AND <br>gates, four OR gates, and one inverter. If only the normal inputs are available, the first <br>
<hr>
<A name=151></a><b>Section 4.5  Binary Adder�Subtractor    133</b><br>
<i>D</i><br>
<i>z</i><br>
<i>D</i><br>
<i>CD</i><br>
<i>C</i><br>
<i>y</i><br>
(<i>C</i><br>
<i>D</i>)<br>
<i>C</i><br>
<i>D</i><br>
<i>B</i><br>
<i>x</i><br>
<i>w</i><br>
<i>A</i><br>
<b> <br>FIGURE 4.4 <br> <br>Logic diagram for BCD-to-excess-3 code converter  </b><br>
implementation will require inverters for variables  <i>B, C</i> , and  <i>D</i> , and the second <br> <br>implementation will require inverters for variables  <i>B</i>  and  <i>D</i> . Thus, the three-level logic <br>circuit requires fewer gates, all of which in turn require no more than two inputs. <br>
<b> <br>4 . 5       B I N A R Y   A D D E R � S U B T R A C T O R </b><br>
 <br>Digital computers perform a variety of information-processing tasks. Among the func-<br>tions encountered are the various arithmetic operations. The most basic arithmetic <br>operation is the addition of two binary digits. This simple addition consists of four pos-<br>sible elementary operations:   0 + 0 = 0, 0 + 1 = 1, 1 + 0 = 1,       and     1 + 1 = 10.     The <br>first three operations produce a sum of one digit, but when both augend and addend <br>bits are equal to 1, the binary sum consists of two digits. The higher significant bit of this <br>result is called a  <i>carry</i> . When the augend and addend numbers contain more significant <br>digits, the carry obtained from the addition of two bits is added to the next higher order <br>pair of significant bits. A combinational circuit that performs the addition of two bits is <br>called a  <i>half adder</i> . One that performs the addition of three bits (two significant bits and <br>a previous carry) is a  <i>full adder</i> . The names of the circuits stem from the fact that two <br>half adders can be employed to implement a full adder. <br>
<hr>
<A name=152></a><b>134    Chapter 4  Combinational Logic</b><br>
 <br>A binary adder�subtractor is a combinational circuit that performs the arithmetic <br>
operations of addition and subtraction with binary numbers. We will develop this <br>circuit by means of a hierarchical design. The half adder design is carried out first, from <br>which we develop the full adder. Connecting  <i>n</i>  full adders in cascade produces a binary <br>adder for two  <i>n</i> -bit numbers. The subtraction circuit is included in a complementing <br>circuit. <br>
<b> <br>Half Adder </b><br>
 <br>From the verbal explanation of a half adder, we find that this circuit needs two binary <br>inputs and two binary outputs. The input variables designate the augend and addend <br>bits; the output variables produce the sum and carry. We assign symbols  <i>x</i>  and  <i>y</i>  to the <br>two inputs and  <i>S</i>  (for sum) and  <i>C</i>  (for carry) to the outputs. The truth table for the half <br>adder  is  listed  in   Table    4.3   .  The   <i>C</i>  output is 1 only when both inputs are 1. The  <i>S</i>   output <br>represents the least significant bit of the sum. <b> </b><br>
 <br>The simplified Boolean functions for the two outputs can be obtained directly from <br>
the truth table. The simplified sum-of-products expressions are <br>
 <br><i>S </i>= <i>x y </i>+ <i>xy</i><br>
 <br>
<i>C </i>= <i>xy</i> <br>
 <br>The logic diagram of the half adder implemented in sum of products is shown in <br>
 <br>Fig.   4.5(a)  . It can be also implemented with an exclusive-OR and an AND gate as shown <br>in  Fig.   4.5(b)  . This form is used to show that two half adders can be used to construct a <br>full adder. <b> </b><br>
<b> <br>Table 4.3 <br><i> <br>Half Adder </b></i><br>
<i> <br><b>x</b> </i><br>
<i> <br><b>y</b> </i><br>
<i> <br><b>C</b> </i><br>
<i> <br><b>S </b></i><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
<i>x<br>y</i><br>
<i>S</i><br>
<i>x</i><br>
<i>x</i><br>
<i>y</i><br>
<i>S</i><br>
<i>y</i><br>
<i>x</i><br>
<i>C</i><br>
<i>y</i><br>
<i>C</i><br>
(a)<i> S  </i> <i>xy </i>   <i>x y</i><br>
(b)<i> S  </i> <i>x</i>  <i>y</i><br>
<i> C </i> <i>xy</i><br>
<i> C </i><br>
 <i>xy</i><br>
<b> <br>FIGURE 4.5 <br> <br>Implementation of half adder  </b><br>
<hr>
<A name=153></a><b>Section 4.5  Binary Adder�Subtractor    135</b><br>
<b> <br>Full Adder </b><br>
 Addition  of  <i>n</i>-bit binary numbers requires the use of a full adder, and the process of addi-<br>tion proceeds on a bit-by-bit basis, right to left, beginning with the least significant bit. After <br>the least significant bit, addition at each position adds not only the respective bits of the <br>words, but must also consider a possible carry bit from addition at the previous position. <br>
 <br>A full adder is a combinational circuit that forms the arithmetic sum of three bits. It <br>
consists of three inputs and two outputs. Two of the input variables, denoted by  <i>x</i>  and  <i>y</i> , <br>represent the two significant bits to be added. The third input,  <i>z</i> , represents the carry from <br>the previous lower significant position. Two outputs are necessary because the arithmetic <br>sum of three binary digits ranges in value from 0 to 3, and binary representation of 2 or 3 <br>needs two bits. The two outputs are designated by the symbols  <i>S</i>  for sum and  <i>C</i>   for  carry. <br>The binary variable  <i>S</i>  gives the value of the least significant bit of the sum. The binary <br>variable  <i>C</i>  gives the output carry formed by adding the input carry and the bits of the <br>words. The truth table of the full adder is listed in  Table   4.4  .The eight rows under the input <br>variables designate all possible combinations of the three variables. The output variables <br>are determined from the arithmetic sum of the input bits. When all input bits are 0, the <br>output is 0. The  <i>S</i>  output is equal to 1 when only one input is equal to 1 or when all three <br>inputs are equal to 1. The  <i>C</i>  output has a carry of 1 if two or three inputs are equal to 1. <br>
 <br>The input and output bits of the combinational circuit have different interpretations <br>
at various stages of the problem. On the one hand, physically, the binary signals of the <br>inputs are considered binary digits to be added arithmetically to form a two-digit sum <br>at the output. On the other hand, the same binary values are considered as variables of <br>Boolean functions when expressed in the truth table or when the circuit is implemented <br>with logic gates. The maps for the outputs of the full adder are shown in  Fig.   4.6  . The <br>simplified expressions are <br>
 <br><i>S </i>= <i>x y z </i>+ <i>x yz </i>+ <i>xy z </i>+ <i>xyz</i><br>
 <br><i>C </i>= <i>xy </i>+ <i>xz </i>+ <i>yz</i><br>
 <br>The logic diagram for the full adder implemented in sum-of-products form is shown <br>
in  Fig.   4.7 . It can also be implemented with two half adders and one OR gate, as shown <br>
<b> <br>Table 4.4 <br><i> <br>Full Adder </b></i><br>
<i> <br><b>x</b> </i><br>
<i> <br><b>y</b> </i><br>
<i> <br><b>z</b> </i><br>
<i> <br><b>C  </b></i><br>
<i> <br><b>S</b> </i><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
<hr>
<A name=154></a><b>136    Chapter 4  Combinational Logic</b><br>
<i>y</i><br>
<i>y</i><br>
<i>yz</i><br>
<i>yz</i><br>
<i>x</i><br>
<i>x</i><br>
00<br>
01<br>
11<br>
10<br>
00<br>
01<br>
11<br>
10<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
0<br>
1<br>
3<br>
2<br>
0<br>
1<br>
3<br>
2<br>
0<br>
1<br>
1<br>
0<br>
1<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
7<br>
6<br>
4<br>
5<br>
7<br>
6<br>
<i>x</i><br>
1<br>
1<br>
1<br>
<i>x</i><br>
1<br>
1<br>
1<br>
1<br>
<i>z</i><br>
<i>z</i><br>
(a) <i>S</i><br>
 <i>x y z</i><br>
<i>x yz </i>   <i>xy z </i>   <i>xyz</i><br>
(b) <i>C</i><br>
 <i>xy</i><br>
<i>xz</i>   <i>yz</i><br>
<b> <br>FIGURE 4.6 <br> <br>K-Maps for full adder  </b><br>
<i>x</i><br>
<i>y<br>z</i><br>
<i>x</i><br>
<i>y</i><br>
<i>x</i><br>
<i>y<br>z</i><br>
<i>x</i><br>
<i>S</i><br>
<i>C</i><br>
<i>z</i><br>
<i>x</i><br>
<i>y<br>z</i><br>
<i>y</i><br>
<i>z</i><br>
<i>x</i><br>
<i>y<br>z</i><br>
<b> <br>FIGURE 4.7 <br> <br>Implementation of full adder in sum-of-products form  </b><br>
in   Fig.    4.8   .  The   <i>S</i>  output from the second half adder is the exclusive-OR of  <i>z</i>  and the <br>output of the first half adder, giving <br>
 <br>
 <br><i>S </i>= <i>z </i>{ 1<i>x </i>{ <i>y</i>2<br>
 <br>
= <i>z </i>1<i>xy </i>+ <i>x y</i>2 + <i>z </i>1<i>xy </i>+ <i>x y</i>2<br>
 <br>
= <i>z </i>1<i>xy </i>+ <i>x y</i>2 + <i>z </i>1<i>xy </i>+ <i>x y </i>2<br>
 <br>
= <i>xy z </i>+ <i>x yz </i>+ <i>xyz </i>+ <i>x y z</i> <br>
The carry output is<br>
 <br><i>C </i>= <i>z</i>1<i>xy </i>+ <i>x y</i>2 + <i>xy </i>= <i>xy z </i>+ <i>x yz </i>+ <i>xy</i> <br>
<b> <br>Binary Adder </b><br>
 <br>A binary adder is a digital circuit that produces the arithmetic sum of two binary num-<br>bers. It can be constructed with full adders connected in cascade, with the output carry <br>from each full adder connected to the input carry of the next full adder in the chain. <br>
<hr>
<A name=155></a><b>Section 4.5  Binary Adder�Subtractor    137</b><br>
<i>x</i><br>
<i>x </i><i> y</i><br>
(<i>x </i><i> y</i>)  <i>z</i><br>
<i>y</i><br>
<i>S</i><br>
<i>xy</i><br>
(<i>x </i><i> y</i>) <i>z</i><br>
(<i>x </i><i> y</i>) <i>z</i><br>
<i> xy</i><br>
<i>C</i><br>
<i>z</i><br>
<b> <br>FIGURE 4.8 <br> <br>Implementation of full adder with two half adders and an OR gate  </b><br>
Addition of <i>n</i>-bit numbers requires a chain of <i>n</i> full adders or a chain of one-half adder <br>and <i>n </i>9<i> </i>1 full adders. In the former case, the input carry to the least significant position <br>is fixed at 0.  Figure   4.9   shows the interconnection of four full-adder (FA) circuits to <br>provide a four-bit binary ripple carry adder. The augend bits of  <i>A</i>  and the addend bits <br>of  <i>B</i>  are designated by subscript numbers from right to left, with subscript 0 denoting <br>the least significant bit. The carries are connected in a chain through the full adders. The <br>input carry to the adder is   <i>C</i>0,  and it ripples through the full adders to the output carry <br> <br><i>C</i>4.     The   <i>S</i>  outputs generate the required sum bits. An  <i>n</i> -bit adder requires  <i>n</i>  full adders, <br>with each output carry connected to the input carry of the next higher order full adder. <br>
 <br>To demonstrate with a specific example, consider the two binary numbers   <i>A </i>= 1011    <br>
and     <i>B </i>= 0011.     Their  sum     <i>S </i>= 1110  is formed with the four-bit adder as follows: <br>
<b> <br>Subscript <i>i</i>:  </b><br>
<b>3  </b><br>
<b>2  </b><br>
<b>1  </b><br>
<b>0  </b><br>
<b> </b><br>
 Input  carry <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 <br><i>Ci</i> <br>
 Augend <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 <i>Ai</i> <br>
 Addend <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 <br><i>Bi</i> <br>
 Sum <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 <br><i>Si</i> <br>
 Output  carry <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 <br><i>Ci</i>+1 <br>
 <br>The bits are added with full adders, starting from the least significant position (subscript <br>0), to form the sum bit and carry bit. The input carry   <i>C</i>0  in the least significant position <br>must be 0. The value of   <i>Ci</i>+1  in a given significant position is the output carry of the full <br>adder. This value is transferred into the input carry of the full adder that adds the bits <br>one higher significant position to the left. The sum bits are thus generated starting from <br>the rightmost position and are available as soon as the corresponding previous carry <br>bit is generated. All the carries must be generated for the correct sum bits to appear at <br>the outputs. <br>
 <br>The four-bit adder is a typical example of a standard component. It can be used in <br>
many applications involving arithmetic operations. Observe that the design of this circuit <br>
<hr>
<A name=156></a><b>138    Chapter 4  Combinational Logic</b><br>
<i>B</i>3<br>
<i>A</i>3<br>
<i>B</i>2<br>
<i>A</i>2<br>
<i>B</i>1<br>
<i>A</i>1<br>
<i>B</i>0<br>
<i>A</i>0<br>
<i>C</i>3<br>
<i>C</i>2<br>
<i>C</i>1<br>
<i>FA</i><br>
<i>FA</i><br>
<i>FA</i><br>
<i>FA</i><br>
<i>C</i>0<br>
<i>C</i>4<br>
<i>S</i>3<br>
<i>S</i>2<br>
<i>S</i>1<br>
<i>S</i>0<br>
<b> <br>FIGURE 4.9 <br> <br>Four-bit adder  </b><br>
by the classical method would require a truth table with   29 = 512     entries,  since  there <br>are nine inputs to the circuit. By using an iterative method of cascading a standard func-<br>tion, it is possible to obtain a simple and straightforward implementation. <br>
<b> <br>Carry Propagation </b><br>
 <br>The addition of two binary numbers in parallel implies that all the bits of the augend <br>and addend are available for computation at the same time. As in any combinational <br>circuit, the signal must propagate through the gates before the correct output sum is <br>available in the output terminals. The total propagation time is equal to the propagation <br>delay of a typical gate, times the number of gate levels in the circuit. The longest propa-<br>gation delay time in an adder is the time it takes the carry to propagate through the full <br>adders. Since each bit of the sum output depends on the value of the input carry, the <br>value of   <i>Si</i>  at any given stage in the adder will be in its steady-state final value only after <br>the input carry to that stage has been propagated. In this regard, consider output   <i>S</i>3 in <br> Fig.    4.9   .  Inputs     <i>A</i>3     and     <i>B</i>3  are available as soon as input signals are applied to the adder. <br>However, input carry   <i>C</i>3  does not settle to its final value until   <i>C</i>2  is available from the <br>previous stage. Similarly,   <i>C</i>2  has to wait for   <i>C</i>1  and so on down to   <i>C</i>0.     Thus,  only  after <br>the carry propagates and ripples through all stages will the last output   <i>S</i>3     and  carry     <i>C</i>4 <br>settle to their final correct value. <br>
 <br>The number of gate levels for the carry propagation can be found from the circuit <br>
of the full adder. The circuit is redrawn with different labels in  Fig.   4.10   for convenience. <br>The input and output variables use the subscript  <i>i</i>  to denote a typical stage of the adder. <br>The signals at   <i>Pi</i>     and     <i>Gi</i>  settle to their steady-state values after they propagate through <br>their respective gates. These two signals are common to all half adders and depend on <br>only the input augend and addend bits. The signal from the input carry   <i>Ci</i>     to  the  output <br>carry     <i>Ci</i>+1  propagates through an AND gate and an OR gate, which constitute two gate <br>levels. If there are four full adders in the adder, the output carry   <i>C</i>4     would  have <br> <br>2 * 4 = 8     gate  levels  from     <i>C</i>0 to  <i>C</i>4.     For  an   <i>n</i> -bit adder, there are 2 <i>n</i>  gate levels for the <br>carry to propagate from input to output. <br>
<hr>
<A name=157></a><b>Section 4.5  Binary Adder�Subtractor    139</b><br>
Half adder<br>
Half adder<br>
<i>Ai</i><br>
<i>Pi</i><br>
<i>P </i> <br>
<i>i</i><br>
<i>Ci</i><br>
<i>Bi</i><br>
<i>Si</i><br>
<i>Gi</i><br>
<i>P</i><br>
   <br>
<i>i Ci</i><br>
<i>Gi Ci </i>1<br>
<i>Ci</i><br>
<b> <br>FIGURE 4.10 <br> <br>Full adder with <i> P</i>  and  <i>G</i>  shown  </b><br>
 <br>The carry propagation time is an important attribute of the adder because it limits <br>
the speed with which two numbers are added. Although the adder--or, for that matter, <br>any combinational circuit--will always have some value at its output terminals, the <br>outputs will not be correct unless the signals are given enough time to propagate through <br>the gates connected from the inputs to the outputs. Since all other arithmetic operations <br>are implemented by successive additions, the time consumed during the addition process <br>is critical. An obvious solution for reducing the carry propagation delay time is to <br>employ faster gates with reduced delays. However, physical circuits have a limit to their <br>capability. Another solution is to increase the complexity of the equipment in such a <br>way that the carry delay time is reduced. There are several techniques for reducing the <br>carry propagation time in a parallel adder. The most widely used technique employs the <br>principle of  <i>carry</i>    <i>lookahead logic</i> . <br>
 <br>Consider the circuit of the full adder shown in  Fig.   4.10  . If we define two new binary <br>
variables <br>
 <br><i>Pi </i>= <i>Ai </i>{ <i>Bi</i><br>
 <br>
<i>Gi </i>= <i>AiBi</i> <br>
 <br>the output sum and carry can respectively be expressed as <br>
 <br><i>Si </i>= <i>Pi </i>{ <i>Ci</i><br>
 <br>
<i>Ci</i>+1 = <i>Gi </i>+ <i>PiCi</i> <br>
 <br><i>Gi</i>  is called a  <i>carry generate</i> , and it produces a carry of 1 when both   <i>Ai</i>     and     <i>Bi</i>     are  1, <br>regardless of the input carry   <i>Ci</i>. <i>Pi</i>  is called a  <i>carry propagate</i> , because it determines <br>whether a carry into stage  <i>i</i>  will propagate into stage   <i>i </i>+ 1  (i.e., whether an assertion of <br> <br><i>Ci</i>  will propagate to an assertion of   <i>Ci</i>+1 ). <br>
 <br>We now write the Boolean functions for the carry outputs of each stage and substitute <br>
the value of each   <i>Ci</i>  from the previous equations: <br>
 <br><i>C</i>0 = input carry<br><i>C</i>1 = <i>G</i>0 + <i>P</i>0<i>C</i>0<br>
<hr>
<A name=158></a><b>140    Chapter 4  Combinational Logic</b><br>
<i>C</i>2 = <i>G</i>1 + <i>P</i>1<i>C</i>1 = <i>G</i>1 + <i>P</i>11<i>G</i>0 + <i>P</i>0<i>C</i>02 = <i>G</i>1 + <i>P</i>1<i>G</i>0 + <i>P</i>1<i>P</i>0<i>C</i>0<br>
 <br>
<i>C</i>3 = <i>G</i>2 + <i>P</i>2<i>C</i>2 = <i>G</i>2 + <i>P</i>2<i>G</i>1 + <i>P</i>2<i>P</i>1<i>G</i>0 = <i>P</i>2<i>P</i>1<i>P</i>0<i>C</i>0 <br>
 <br>Since the Boolean function for each output carry is expressed in sum-of-products form, <br>each function can be implemented with one level of AND gates followed by an OR gate <br>(or by a two-level NAND). The three Boolean functions for   <i>C</i>1, <i>C</i>2,     and     <i>C</i>3     are  imple-<br>mented in the carry lookahead generator shown in  Fig.   4.11 . Note that this circuit can <br>add in less time because   <i>C</i>3  does not have to wait for   <i>C</i>2     and     <i>C</i>1  to propagate; in fact,   <i>C</i>3<br> <br>is propagated at the same time as   <i>C</i>1     and     <i>C</i>2. This gain in speed of operation is achieved <br>at the expense of additional complexity (hardware). <br>
 <br>The construction of a four-bit adder with a carry lookahead scheme is shown in  Fig.  4.12  . <br>
Each sum output requires two exclusive-OR gates. The output of the first exclusive-OR <br>gate generates the   <i>Pi</i>  variable, and the AND gate generates the   <i>Gi</i>     variable.  The  carries <br>are propagated through the carry lookahead generator (similar to that in  Fig.   4.11  ) and <br>applied as inputs to the second exclusive-OR gate. All output carries are generated after <br>
<i>C</i>3<br>
<i>P</i>2<br>
<i>G</i>2<br>
<i>C</i>2<br>
<i>P</i>1<br>
<i>G</i>1<br>
<i>P</i><br>
<i>C</i><br>
0<br>
1<br>
<i>G</i>0<br>
<i>C</i>0<br>
<b> <br>FIGURE 4.11 <br> <br>Logic diagram of carry lookahead generator  </b><br>
<hr>
<A name=159></a><b>Section 4.5  Binary Adder�Subtractor    141</b><br>
<i>C</i>4<br>
<i>C</i>4<br>
<i>B</i>3<br>
<i>P</i>3<br>
<i>A</i><br>
<i>P</i>3<br>
3<br>
<i>S</i>3<br>
<i>C</i>3<br>
<i>G</i>3<br>
<i>B</i>2<br>
<i>P</i>2<br>
<i>P</i>2<br>
<i>A</i>2<br>
<i>S</i>2<br>
<i>C</i>2<br>
<i>G</i>2<br>
Carry<br>
Lookahead<br>
Generator<br>
<i>B</i>1<br>
<i>P</i>1<br>
<i>P</i>1<br>
<i>A</i>1<br>
<i>S</i>1<br>
<i>C</i>1<br>
<i>G</i>1<br>
<i>B</i>0<br>
<i>P</i>0<br>
<i>P</i>0<br>
<i>A</i>0<br>
<i>S</i>0<br>
<i>G</i>0<br>
<i>C</i><br>
<i>C</i><br>
0<br>
0<br>
<b> <br>FIGURE 4.12 <br> <br>Four-bit adder with carry lookahead  </b><br>
a delay through two levels of gates. Thus, outputs   <i>S</i>1     through     <i>S</i>3     have  equal  propagation <br>delay times. The two-level circuit for the output carry   <i>C</i>4  is not shown. This circuit can <br>easily be derived by the equation-substitution method. <br>
<b> <br>Binary Subtractor </b><br>
 <br>The subtraction of unsigned binary numbers can be done most conveniently by means <br>of complements, as discussed in Section 1.5. Remember that the subtraction   <i>A </i>- <i>B</i>     can <br>be done by taking the 2's complement of  <i>B</i>  and adding it to  <i>A</i> . The 2's complement can <br>be obtained by taking the 1's complement and adding 1 to the least significant pair of <br>bits. The 1's complement can be implemented with inverters, and a 1 can be added to <br>the sum through the input carry. <br>
<hr>
<A name=160></a><b>142    Chapter 4  Combinational Logic</b><br>
<i>B</i>3<br>
<i>A</i>3<br>
<i>B</i>2<br>
<i>A</i>2<br>
<i>B</i>1<br>
<i>A</i>1<br>
<i>B</i>0<br>
<i>A</i>0<br>
<i>M</i><br>
<i>C</i>4<br>
<i>C</i>3<br>
<i>C</i>2<br>
<i>C</i>1<br>
<i>C</i>0<br>
<i>C</i><br>
<i>FA</i><br>
<i>FA</i><br>
<i>FA</i><br>
<i>FA</i><br>
<i>S</i>3<br>
<i>S</i>2<br>
<i>S</i>1<br>
<i>S</i>0<br>
<i>V</i><br>
<b> <br>FIGURE 4.13 <br> <br>Four-bit adder�subtractor (with overflow detection)  </b><br>
 <br>The circuit for subtracting   <i>A </i>- <i>B</i>  consists of an adder with inverters placed between <br>
each data input  <i>B</i>  and the corresponding input of the full adder. The input carry   <i>C</i>0     must <br>be equal to 1 when subtraction is performed. The operation thus performed becomes  <i>A</i> , <br>plus the 1's complement of  <i>B</i> , plus 1. This is equal to  <i>A</i>  plus the 2's complement of  <i>B</i> . <br>For unsigned numbers, that gives   <i>A </i>- <i>B</i> if  <i>A </i>� <i>B</i>  or the 2's complement of   1<i>B </i>- <i>A</i>2 <br>if     <i>A </i>6 <i>B</i>.  For signed numbers, the result is   <i>A </i>- <i>B</i>,  provided that there is no overflow. <br>(See Section 1.6.) <br>
 <br>The addition and subtraction operations can be combined into one circuit with one <br>
common binary adder by including an exclusive-OR gate with each full adder. A four-bit <br>adder�subtractor circuit is shown in  Fig.   4.13  . The mode input  <i>M</i>  controls the operation. <br>When     <i>M </i>= 0,  the circuit is an adder, and when   <i>M </i>= 1,  the circuit becomes a subtractor. <br>Each exclusive-OR gate receives input  <i>M</i>  and one of the inputs of  <i>B</i> .  When     <i>M </i>= 0, we <br>have     <i>B </i>{ 0 = <i>B</i>. The full adders receive the value of  <i>B</i> , the input carry is 0, and the <br>circuit performs  <i>A</i>  plus  <i>B</i> .  When     <i>M </i>= 1,     we  have     <i>B </i>{ 1 = <i>B </i>     and     <i>C</i>0 = 1. The  <i>B</i>   inputs <br>are all complemented and a 1 is added through the input carry. The circuit performs the <br>operation  <i>A</i>  plus the 2's complement of  <i>B</i> . (The exclusive-OR with output  <i>V</i>  is for <br>detecting an overflow.) <br>
 <br>It is worth noting that binary numbers in the signed-complement system are added <br>
and subtracted by the same basic addition and subtraction rules as are unsigned num-<br>bers. Therefore, computers need only one common hardware circuit to handle both types <br>of arithmetic. The user or programmer must interpret the results of such addition or <br>subtraction differently, depending on whether it is assumed that the numbers are signed <br>or unsigned. <br>
<hr>
<A name=161></a><b>Section 4.5  Binary Adder�Subtractor    143</b><br>
<b> <br>Overflow </b><br>
 <br>When two numbers with  <i>n</i>  digits each are added and the sum is a number occupying <br> <br><i>n </i>+ 1  digits, we say that an overflow occurred. This is true for binary or decimal num-<br>bers, signed or unsigned. When the addition is performed with paper and pencil, an <br>overflow is not a problem, since there is no limit by the width of the page to write down <br>the sum. Overflow is a problem in digital computers because the number of bits that <br>hold the number is finite and a result that contains   <i>n </i>+ 1  bits cannot be accommodated <br>by an  <i>n</i> -bit word. For this reason, many computers detect the occurrence of an overflow, <br>and when it occurs, a corresponding flip-flop is set that can then be checked by the user. <br>
 <br>The detection of an overflow after the addition of two binary numbers depends on <br>
whether the numbers are considered to be signed or unsigned. When two unsigned <br>numbers are added, an overflow is detected from the end carry out of the most signifi-<br>cant position. In the case of signed numbers, two details are important: the leftmost bit <br>always represents the sign, and negative numbers are in 2's-complement form. When <br>two signed numbers are added, the sign bit is treated as part of the number and the end <br>carry does not indicate an overflow. <br>
 <br>An overflow cannot occur after an addition if one number is positive and the other <br>
is negative, since adding a positive number to a negative number produces a result <br>whose magnitude is smaller than the larger of the two original numbers. An overflow <br>may occur if the two numbers added are both positive or both negative. To see how this <br>can happen, consider the following example: Two signed binary numbers,   +70     and     +80,    <br>are stored in two eight-bit registers. The range of numbers that each register can accom-<br>modate is from binary   +127     to  binary     -128.  Since the sum of the two numbers is   +150,    <br>it exceeds the capacity of an eight-bit register. This is also true for   -70     and     -80.     The  two <br>additions in binary are shown next, together with the last two carries: <br>
carries:<br>
  0  1<br>
  <br>
carries:<br>
1  0<br>
+ 70<br>
 <br>
0  1000110<br>
- 70<br>
1  0111010<br>
 <br>
 <br>
+ 80<br>
 <br>
0  1010000<br>
- 80<br>
1  0110000<br>
   +150<br>
  <br>
1  0010110<br>
    <br>
- 150<br>
0  1101010<br>
 <br>Note that the eight-bit result that should have been positive has a negative sign bit (i.e., <br>the eighth bit) and the eight-bit result that should have been negative has a positive sign <br>bit. If, however, the carry out of the sign bit position is taken as the sign bit of the result, <br>then the nine-bit answer so obtained will be correct. But since the answer cannot be <br>accommodated within eight bits, we say that an overflow has occurred. <br>
 <br>An overflow condition can be detected by observing the carry into the sign bit position <br>
and the carry out of the sign bit position. If these two carries are not equal, an overflow <br>has occurred. This is indicated in the examples in which the two carries are explicitly <br>shown. If the two carries are applied to an exclusive-OR gate, an overflow is detected <br>when the output of the gate is equal to 1. For this method to work correctly, the 2's comple-<br>ment of a negative number must be computed by taking the 1's complement and adding 1. <br>This takes care of the condition when the maximum negative number is complemented. <br>
<hr>
<A name=162></a><b>144    Chapter 4  Combinational Logic</b><br>
 <br>The binary adder�subtractor circuit with outputs  <i>C</i>  and  <i>V</i>   is  shown  in   Fig.    4.13   .  If  the <br>
two binary numbers are considered to be unsigned, then the  <i>C</i>  bit detects a carry after <br>addition or a borrow after subtraction. If the numbers are considered to be signed, then <br>the  <i>V</i>  bit detects an overflow. If   <i>V </i>= 0  after an addition or subtraction, then no overflow <br>occurred and the  <i>n</i> -bit result is correct. If   <i>V </i>= 1,  then the result of the operation contains <br> <br><i>n </i>+ 1  bits, but only the rightmost  <i>n</i>  bits of the number fit in the space available, so an <br>overflow has occurred. The   1<i>n </i>+ 12  th bit is the actual sign and has been shifted out of <br>position.   <br>
<b> <br>4 . 6       D E C I M A L   A D D E R </b><br>
 <br>Computers or calculators that perform arithmetic operations directly in the decimal <br>number system represent decimal numbers in binary coded form. An adder for such <br>a computer must employ arithmetic circuits that accept coded decimal numbers and <br>present results in the same code. For binary addition, it is sufficient to consider a <br>pair of significant bits together with a previous carry. A decimal adder requires a <br>minimum of nine inputs and five outputs, since four bits are required to code each <br>decimal digit and the circuit must have an input and output carry. There is a wide <br>variety of possible decimal adder circuits, depending upon the code used to repre-<br>sent the decimal digits. Here we examine a decimal adder for the BCD code. (See <br>Section 1.7.) <br>
<b> <br>BCD Adder </b><br>
 <br>Consider the arithmetic addition of two decimal digits in BCD, together with an input <br>carry from a previous stage. Since each input digit does not exceed 9, the output sum <br>cannot be greater than   9 + 9 + 1 = 19,  the 1 in the sum being an input carry. Sup-<br>pose we apply two BCD digits to a four-bit binary adder. The adder will form the sum <br>in  <i>binary</i>  and produce a result that ranges from 0 through 19. These binary numbers <br>are listed in  Table   4.5   and are labeled by symbols   <i>K</i>, <i>Z</i>8, <i>Z</i>4, <i>Z</i>2,     and     <i>Z</i>1.      <i>K</i>  is the carry, <br>and the subscripts under the letter  <i>Z</i>  represent the weights 8, 4, 2, and 1 that can be <br>assigned to the four bits in the BCD code. The columns under the binary sum list the <br>binary value that appears in the outputs of the four-bit binary adder. The output sum <br>of two decimal digits must be represented in BCD and should appear in the form <br>listed in the columns under "BCD Sum." The problem is to find a rule by which the <br>binary sum is converted to the correct BCD digit representation of the number in the <br>BCD sum. <br>
 <br>In examining the contents of the table, it becomes apparent that when the binary sum <br>
is equal to or less than 1001, the corresponding BCD number is identical, and therefore <br>no conversion is needed. When the binary sum is greater than 1001, we obtain an invalid <br>BCD representation. The addition of binary 6 (0110) to the binary sum converts it to <br>the correct BCD representation and also produces an output carry as required. <b> </b><br>
<hr>
<A name=163></a><b>Section 4.6  Decimal Adder    145</b><br>
<b> <br>Table 4.5 <br><i> <br>Derivation of BCD Adder </b></i><br>
<b> <br>Binary Sum </b><br>
<b> <br>BCD Sum </b><br>
<b> <br>Decimal </b><br>
<i><b> <br>K  </b></i><br>
<i><b> <br>Z  </i>8<i> </b></i><br>
<i><b> <br>Z  </i>4<i> </b></i><br>
<i><b> <br>Z  </i>2<i> </b></i><br>
<i><b> <br>Z  </i>1<i> </b></i><br>
<i><b> <br>C  </b></i><br>
<i><b> <br>S  </i>8<i> </b></i><br>
<i><b> <br>S  </i>4<i> </b></i><br>
<i><b> <br>S  </i>2<i> </b></i><br>
<i><b> <br>S  </i>1<i> </b></i><br>
<i> </i><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 2 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 3 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 4 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 5 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 6 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 7 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 8 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 9 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 10 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 11 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 12 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 13 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 14 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 15 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 16 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 17 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 18 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 19 <br>
 <br>The logic circuit that detects the necessary correction can be derived from the <br>
entries in the table. It is obvious that a correction is needed when the binary sum has <br>an output carry   <i>K </i>= 1. The other six combinations from 1010 through 1111 that need <br>a correction have a 1 in position   <i>Z</i>8. To distinguish them from binary 1000 and 1001, <br>which also have a 1 in position   <i>Z</i>8,  we specify further that either   <i>Z</i>4 or  <i>Z</i>2     must  have <br>a 1. The condition for a correction and an output carry can be expressed by the Bool-<br>ean function <br>
 <br><i>C </i>= <i>K </i>+ <i>Z</i>8<i>Z</i>4 + <i>Z</i>8<i>Z</i>2 <br>
 When     <i>C </i>= 1,  it is necessary to add 0110 to the binary sum and provide an output carry <br>for the next stage. <br>
 <br>A BCD adder that adds two BCD digits and produces a sum digit in BCD is shown <br>
in  Fig.   4.14  . The two decimal digits, together with the input carry, are first added in the <br>top four-bit adder to produce the binary sum. When the output carry is equal to 0, noth-<br>ing is added to the binary sum. When it is equal to 1, binary 0110 is added to the binary <br>sum through the bottom four-bit adder. The output carry generated from the bottom <br>
<hr>
<A name=164></a><b>146    Chapter 4  Combinational Logic</b><br>
Addend<br>
Augend<br>
Carry<br>
Carry<br>
<i>K</i><br>
4-bit binary adder<br>
out<br>
in<br>
<i>Z</i>8<br>
<i>Z</i>4<br>
<i>Z</i>2<br>
<i>Z</i>1<br>
Output<br>
carry<br>
0<br>
4-bit binary adder<br>
<i>S</i>8<br>
<i>S</i>4<br>
<i>S</i>2<br>
<i>S</i>1<br>
<b> <br>FIGURE 4.14 <br> <br>Block diagram of a BCD adder  </b><br>
adder can be ignored, since it supplies information already available at the output carry <br>terminal. A decimal parallel adder that adds  <i>n</i>  decimal digits needs  <i>n</i>  BCD adder stages. <br>The output carry from one stage must be connected to the input carry of the next higher <br>order stage. <b> </b><br>
<b> <br>4 . 7       B I N A R Y   M U L T I P L I E R </b><br>
 <br>Multiplication of binary numbers is performed in the same way as multiplication of <br>decimal numbers. The multiplicand is multiplied by each bit of the multiplier, starting <br>from the least significant bit. Each such multiplication forms a partial product. Succes-<br>sive partial products are shifted one position to the left. The final product is obtained <br>from the sum of the partial products. <br>
 <br>To see how a binary multiplier can be implemented with a combinational circuit, <br>
consider the multiplication of two 2-bit numbers as shown in  Fig.   4.15  . The multiplicand <br>
<hr>
<A name=165></a><b>Section 4.7  Binary Multiplier    147</b><br>
<i>B</i><br>
<i>A</i>0<br>
1<br>
<i>B</i>0<br>
<i>B</i>1<br>
<i>B</i>0<br>
<i>A</i>1<br>
<i>A</i>0<br>
<i>A</i>0<i>B</i>1<br>
<i>A</i>0<i>B</i>0<br>
<i>A</i>1<i>B</i>1<br>
<i>A</i>1<i>B</i>0<br>
<i>C</i><br>
<i>A</i>1<br>
3<br>
<i>C</i>2<br>
<i>C</i>1<br>
<i>C</i>0<br>
<i>B</i>1<br>
<i>B</i>0<br>
HA<br>
HA<br>
<i>C</i>3 <i>C</i>2<br>
<i>C</i>1<br>
<i>C</i>0<br>
<b> <br>FIGURE 4.15 <br> <br>Two-bit by two-bit binary multiplier  </b><br>
bits are   <i>B</i>1     and     <i>B</i>0,  the multiplier bits are   <i>A</i>1     and     <i>A</i>0,  and the product is   <i>C</i>3<i>C</i>2<i>C</i>1<i>C</i>0.     The <br>first partial product is formed by multiplying   <i>B</i>1<i>B</i>0 by  <i>A</i>0. The multiplication of two bits <br>such as   <i>A</i>0     and     <i>B</i>0  produces a 1 if both bits are 1; otherwise, it produces a 0. This is iden-<br>tical to an AND operation. Therefore, the partial product can be implemented with <br>AND gates as shown in the diagram. The second partial product is formed by multiply-<br>ing     <i>B</i>1<i>B</i>0 by  <i>A</i>1  and shifting one position to the left. The two partial products are added <br>with two half-adder (HA) circuits. Usually, there are more bits in the partial products <br>and it is necessary to use full adders to produce the sum of the partial products. Note <br>that the least significant bit of the product does not have to go through an adder, since <br>it is formed by the output of the first AND gate. <br>
 <br>A combinational circuit binary multiplier with more bits can be constructed in a <br>
similar fashion. A bit of the multiplier is ANDed with each bit of the multiplicand in as <br>many levels as there are bits in the multiplier. The binary output in each level of AND <br>gates is added with the partial product of the previous level to form a new partial prod-<br>uct. The last level produces the product. For  <i>J</i>  multiplier bits and  <i>K</i>  multiplicand bits, we <br>need      1<i>J </i>* <i>K</i>2     AND  gates  and      1<i>J </i>- 12  <i>K</i> -bit adders to produce a product of   (<i>J </i>+ <i>K</i>)    <br>bits. <br>
 <br>As a second example, consider a multiplier circuit that multiplies a binary number <br>
represented by four bits by a number represented by three bits. Let the multiplicand be <br>represented by   <i>B</i>3<i>B</i>2<i>B</i>1<i>B</i>0  and the multiplier by   <i>A</i>2<i>A</i>1<i>A</i>0.     Since     <i>K </i>= 4     and     <i>J </i>= 3, we <br>need 12 AND gates and two 4-bit adders to produce a product of seven bits. The logic <br>diagram of the multiplier is shown in  Fig.   4.16  . <br>
<hr>
<A name=166></a><b>148    Chapter 4  Combinational Logic</b><br>
<i>A</i>0<br>
<i>B</i>3<br>
<i>B</i>2<br>
<i>B</i>1<br>
<i>B</i>0<br>
<i>A</i>1<br>
<i>B</i>3<br>
<i>B</i>2<br>
<i>B</i>1<br>
<i>B</i>0<br>
0<br>
Addend<br>
Augend<br>
4-bit adder<br>
Sum and output carry<br>
<i>A</i>2<br>
<i>B</i>3<br>
<i>B</i>2<br>
<i>B</i>1<br>
<i>B</i>0<br>
Addend<br>
Augend<br>
4-bit adder<br>
Sum and output carry<br>
<i>C</i><br>
<i>C</i><br>
<i>C</i><br>
<i>C</i><br>
<i>C</i><br>
6<br>
5<br>
4<br>
3<br>
2<br>
<i>C</i>1<br>
<i>C</i>0<br>
<b> <br>FIGURE 4.16 <br> <br>Four-bit by three-bit binary multiplier  </b><br>
<b> <br>4 . 8       M A G N I T U D E   C O M PA R AT O R </b><br>
 <br>The comparison of two numbers is an operation that determines whether one number <br>is greater than, less than, or equal to the other number. A  <i>magnitude comparator</i>  is a <br>combinational circuit that compares two numbers  <i>A</i>  and  <i>B</i>  and determines their relative <br>magnitudes. The outcome of the comparison is specified by three binary variables that <br>indicate whether   <i>A </i>7 <i>B</i>, <i>A </i>= <i>B</i>,     or     <i>A </i>6 <i>B</i>.    <br>
 <br>On the one hand, the circuit for comparing two  <i>n</i> -bit numbers has   22<i>n</i>     entries  in  the <br>
truth table and becomes too cumbersome, even with   <i>n </i>= 3.  On the other hand, as one <br>
<hr>
<A name=167></a><b>Section 4.8  Magnitude Comparator    149</b><br>
may suspect, a comparator circuit possesses a certain amount of regularity. Digital func-<br>tions that possess an inherent well-defined regularity can usually be designed by means <br>of an algorithm--a procedure which specifies a finite set of steps that, if followed, give <br>the solution to a problem. We illustrate this method here by deriving an algorithm for <br>the design of a four-bit magnitude comparator. <br>
 <br>The algorithm is a direct application of the procedure a person uses to compare the <br>
relative magnitudes of two numbers. Consider two numbers,  <i>A</i>  and  <i>B</i> , with four digits <br>each. Write the coefficients of the numbers in descending order of significance: <br>
 <i>A </i>= <i>A</i>3  <i>A</i>2  <i>A</i>1  <i>A</i>0<br>
<i>B </i>= <i>B</i>3 <i>B</i>2 <i>B</i>1 <i>B</i>0 <br>
 <br>Each subscripted letter represents one of the digits in the number. The two numbers are <br>equal if all pairs of significant digits are equal:   <i>A</i>3 = <i>B</i>3, <i>A</i>2 = <i>B</i>2, <i>A</i>1 = <i>B</i>1,     and <br> <i>A</i>0 = <i>B</i>0. When the numbers are binary, the digits are either 1 or 0, and the equality of <br>each pair of bits can be expressed logically with an exclusive-NOR function as <br>
 <i>xi </i>= <i>AiBi </i>+ <i>Ai</i> <i>Bi</i><br>
for <i>i </i>= 0, 1, 2, 3  <br>
 where     <i>xi </i>= 1  only if the pair of bits in position  <i>i</i>  are equal (i.e., if both are 1 or both <br>are 0). <br>
 <br>The equality of the two numbers  <i>A</i>  and  <i>B</i>  is displayed in a combinational circuit by <br>
an output binary variable that we designate by the symbol   1<i>A </i>= <i>B</i>2   .  This  binary  vari-<br>able is equal to 1 if the input numbers,  <i>A</i>  and  <i>B</i> , are equal, and is equal to 0 otherwise. <br>For equality to exist, all   <i>xi</i>  variables must be equal to 1, a condition that dictates an AND <br>operation of all variables: <br>
 1<i>A </i>= <i>B</i>2 = <i>x</i>3<i>x</i>2<i>x</i>1<i>x</i>0 <br>
 The   <i>binary</i>   variable      1<i>A </i>= <i>B</i>2  is equal to 1 only if all pairs of digits of the two numbers <br>are equal. <br>
 <br>To determine whether  <i>A</i>  is greater or less than  <i>B</i> , we inspect the relative magnitudes <br>
of pairs of significant digits, starting from the most significant position. If the two digits <br>of a pair are equal, we compare the next lower significant pair of digits. The comparison <br>continues until a pair of unequal digits is reached. If the corresponding digit of  <i>A</i>  is 1 <br>and that of  <i>B</i>  is 0, we conclude that   <i>A </i>7 <i>B</i>.  If the corresponding digit of  <i>A</i>  is 0 and that <br>of  <i>B</i>  is 1, we have   <i>A </i>6 <i>B</i>. The sequential comparison can be expressed logically by the <br>two Boolean functions <br>
 1<i>A </i>7 <i>B</i>2 = <i>A</i>3<i>B</i>3 + <i>x</i>3  <i>A</i>2<i>B</i>2 + <i>x</i>3<i>x</i>2<i>A</i>1<i>B</i>1 + <i>x</i>3<i>x</i>2<i>x</i>1<i>A</i>0<i>B</i>0<br>
1<i>A </i>6 <i>B</i>2 = <i>A</i>3<i>B</i>3 + <i>x</i>3<i>A</i>2<i>B</i>2 + <i>x</i>3<i>x</i>2<i>A</i>1<i>B</i>1 + <i>x</i>3<i>x</i>2<i>x</i>1<i>A n</i>0<i>B</i>0  <br>
 The  symbols      1<i>A </i>7 <i>B</i>2     and      1<i>A </i>6 <i>B</i>2     are   <i>binary</i>  output variables that are equal to 1 <br>when     <i>A </i>7 <i>B</i>     and     <i>A </i>6 <i>B</i>,     respectively. <br>
 <br>The gate implementation of the three output variables just derived is simpler than it <br>
seems because it involves a certain amount of repetition. The unequal outputs can use <br>the same gates that are needed to generate the equal output. The logic diagram of the <br>four-bit magnitude comparator is shown in  Fig.   4.17 . The four  <i>x</i>  outputs are generated <br>
<hr>
<A name=168></a><b>150    Chapter 4  Combinational Logic</b><br>
<i>A</i>3<br>
<i>x</i>3<br>
<i>B</i>3<br>
<i>A</i>2<br>
<i>x</i>2<br>
<i>B</i>2<br>
(<i>A</i><br>
<i>B</i>)<br>
<i>A</i>1<br>
<i>x</i>1<br>
<i>B</i>1<br>
<i>A</i>0<br>
<i>x</i>0<br>
(<i>A</i><br>
<i>B</i>)<br>
<i>B</i>0<br>
(<i>A</i><br>
<i>B</i>)<br>
<b> <br>FIGURE 4.17 <br> <br>Four-bit magnitude comparator  </b><br>
with exclusive-NOR circuits and are applied to an AND gate to give the output binary <br>variable      1<i>A </i>= <i>B</i>2 . The other two outputs use the  <i>x</i>  variables to generate the Boolean <br>functions listed previously. This is a multilevel implementation and has a regular pattern. <br>The procedure for obtaining magnitude comparator circuits for binary numbers with <br>more than four bits is obvious from this example. <b> </b><br>
<b> <br>4 . 9       D E C O D E R S </b><br>
 <br>Discrete quantities of information are represented in digital systems by binary codes. <br>A binary code of  <i>n</i>  bits is capable of representing up to   2<i>n</i>  distinct elements of coded <br>information. A  <i>decoder</i>  is a combinational circuit that converts binary information from <br>
<hr>
<A name=169></a><b>Section 4.9  Decoders    151</b><br>
 <br><i>n</i>  input lines to a maximum of   2<i>n</i>  unique output lines. If the  <i>n</i> -bit coded information has <br>unused combinations, the decoder may have fewer than   2<i>n</i>     outputs. <br>
 <br>The decoders presented here are called  <i>n</i> -to- <i>m</i> -line decoders, where   <i>m </i>... 2<i>n</i>.     Their <br>
purpose is to generate the   2<i>n</i>  (or fewer) minterms of  <i>n</i>  input variables. Each combination <br>of inputs will assert a unique output. The name  <i>decoder</i>  is also used in conjunction with <br>other code converters, such as a BCD-to-seven-segment decoder. <br>
 <br>As an example, consider the three-to-eight-line decoder circuit of  Fig.   4.18  . The three <br>
inputs are decoded into eight outputs, each representing one of the minterms of the <br>three input variables. The three inverters provide the complement of the inputs, and each <br>one of the eight AND gates generates one of the minterms. A particular application of <br>this decoder is binary-to-octal conversion. The input variables represent a binary num-<br>ber, and the outputs represent the eight digits of a number in the octal number system. <br>However, a three-to-eight-line decoder can be used for decoding  <i>any</i>  three-bit code to <br>provide eight outputs, one for each element of the code. <br>
<i>D</i><br>
 <br>
0<br>
<i>x y z </i> <br>
<i>D</i><br>
 <br>
1<br>
<i>x y z</i><br>
<i>z</i><br>
<i>D</i><br>
 <br>
2<br>
<i>x yz </i> <br>
<i>y</i><br>
<i>D</i><br>
 <br>
3<br>
<i>x yz</i> <br>
<i>D</i><br>
 <br>
4<br>
<i>xy z </i> <br>
<i>x</i><br>
<i>D</i><br>
 <br>
5<br>
<i>xy z</i> <br>
<i>D</i><br>
 <br>
6<br>
<i>xyz </i> <br>
<i>D</i><br>
 <br>
7<br>
<i>xyz</i> <br>
<b> <br>FIGURE 4.18 <br> <br>Three-to-eight-line decoder  </b><br>
<hr>
<A name=170></a><b>152    Chapter 4  Combinational Logic</b><br>
<b> <br>Table 4.6 <br><i> <br>Truth Table of a Three-to-Eight-Line Decoder </b></i><br>
<b> <br>Inputs  </b><br>
<b>Outputs </b><br>
<i> <br><b>x</b> </i><br>
<i> <br><b>y</b> </i><br>
<i> <br><b>z</b> </i><br>
<i> <br><b>D</b> </i><b>0</b><i> </i><br>
<i> <br><b>D</b> </i><b>1</b><i> </i><br>
<i> <br><b>D</b> </i><b>2</b><i> </i><br>
<i> <br><b>D</b> </i><b>3</b><i> </i><br>
<i> <br><b>D</b> </i><b>4</b><i> </i><br>
<i> <br><b>D</b> </i><b>5</b><i> </i><br>
<i> <br><b>D</b> </i><b>6</b><i> </i><br>
<i> <br><b>D</b> </i><b>7</b><i> </i><br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 <br>The operation of the decoder may be clarified by the truth table listed in  Table   4.6  . <br>
For each possible input combination, there are seven outputs that are equal to 0 and <br>only one that is equal to 1. The output whose value is equal to 1 represents the minterm <br>equivalent of the binary number currently available in the input lines. <b> </b><br>
 <br>Some decoders are constructed with NAND gates. Since a NAND gate produces the <br>
AND operation with an inverted output, it becomes more economical to generate the <br>decoder minterms in their complemented form. Furthermore, decoders include one or <br>more  <i>enable</i>  inputs to control the circuit operation. A two-to-four-line decoder with an <br>enable input constructed with NAND gates is shown in  Fig.   4.19  . The circuit operates <br>with complemented outputs and a complement enable input. The decoder is enabled <br>when  <i>E</i>  is equal to 0 (i.e., active-low enable). As indicated by the truth table, only one <br>
<i>D</i>0<br>
<i>E</i><br>
<i>A</i><br>
<i>B</i><br>
<i>D</i>0 <i>D</i>1 <i>D</i>2 <i>D</i>3<br>
<i>D</i>1<br>
1<br>
<i>X</i><br>
<i>X</i><br>
1<br>
1<br>
1<br>
1<br>
<i>A</i><br>
0<br>
0<br>
0<br>
0<br>
1<br>
1<br>
1<br>
0<br>
0<br>
1<br>
1<br>
0<br>
1<br>
1<br>
<i>D</i>2<br>
0<br>
1<br>
0<br>
1<br>
1<br>
0<br>
1<br>
<i>B</i><br>
0<br>
1<br>
1<br>
1<br>
1<br>
1<br>
1<br>
<i>D</i>3<br>
<i>E</i><br>
(a) Logic diagram<br>
(b) Truth table<br>
<b> <br>FIGURE 4.19 <br> <br>Two-to-four-line decoder with enable input  </b><br>
<hr>
<A name=171></a><b>Section 4.9  Decoders    153</b><br>
output can be equal to 0 at any given time; all other outputs are equal to 1. The output <br>whose value is equal to 0 represents the minterm selected by inputs  <i>A</i>  and  <i>B</i> .  The  circuit <br>is disabled when  <i>E</i>  is equal to 1, regardless of the values of the other two inputs. When <br>the circuit is disabled, none of the outputs are equal to 0 and none of the minterms are <br>selected. In general, a decoder may operate with complemented or uncomplemented <br>outputs. The enable input may be activated with a 0 or with a 1 signal. Some decoders <br>have two or more enable inputs that must satisfy a given logic condition in order to <br>enable the circuit. <br>
 <br>A decoder with enable input can function as a  <i>demultiplexer--</i> a circuit that receives <br>
information from a single line and directs it to one of   2<i>n</i>     possible  output  lines.  The <br>selection of a specific output is controlled by the bit combination of  <i>n</i>  selection lines. <br>The  decoder  of   Fig.    4.19     can  function  as  a  one-to-four-line  demultiplexer  when   <i>E</i>   is <br>taken as a data input line and  <i>A</i>  and  <i>B</i>  are taken as the selection inputs. The single <br>input variable  <i>E</i>  has a path to all four outputs, but the input information is directed to <br>only one of the output lines, as specified by the binary combination of the two selection <br>lines  <i>A</i>  and  <i>B</i> . This feature can be verified from the truth table of the circuit. For <br>example, if the selection lines   <i>AB </i>= 10,     output     <i>D</i>2  will be the same as the input value <br> <br><i>E</i> , while all other outputs are maintained at 1. Because decoder and demultiplexer <br>operations are obtained from the same circuit, a decoder with an enable input is <br>referred to as a  <i>decoder</i> �  <i>demultiplexer</i> . <br>
 <br>Decoders with enable inputs can be connected together to form a larger decoder <br>
circuit.  Figure   4.20   shows two 3-to-8-line decoders with enable inputs connected to form <br>a 4-to-16-line decoder. When  <i>w</i>   0, the top decoder is enabled and the other is disabled. <br>The bottom decoder outputs are all 0's, and the top eight outputs generate minterms <br>0000 to 0111. When  <i>w</i>   1, the enable conditions are reversed: The bottom decoder <br>outputs generate minterms 1000 to 1111, while the outputs of the top decoder are all <br>0's. This example demonstrates the usefulness of enable inputs in decoders and other <br>
<i>x</i><br>
<i>y</i><br>
3<br>
 8<br>
<i>D</i>0 to<i> D</i>7<br>
decoder<br>
<i>z</i><br>
<i>E</i><br>
<i>w</i><br>
3<br>
 8<br>
<i>D</i>8 to<i> D</i>15<br>
decoder<br>
<i>E</i><br>
 <br><b>FIGURE 4.20 <br> <br>4 </b>* <b>16   decoder constructed with two   3 </b>* <b>8   decoders  </b><br>
<hr>
<A name=172></a><b>154    Chapter 4  Combinational Logic</b><br>
combinational logic components. In general, enable inputs are a convenient feature for <br>interconnecting two or more standard components for the purpose of combining them <br>into a similar function with more inputs and outputs. <br>
<b> <br>Combinational Logic Implementation </b><br>
 <br>A decoder provides the   2<i>n</i>     minterms  of   <i>n</i>  input variables. Each asserted output of the <br>decoder is associated with a unique pattern of input bits. Since any Boolean function <br>can be expressed in sum-of-minterms form, a decoder that generates the minterms of <br>the function, together with an external OR gate that forms their logical sum, provides <br>a hardware implementation of the function. In this way, any combinational circuit with <br> <br><i>n</i>  inputs and  <i>m</i>  outputs can be implemented with an  <i>n</i> -to-2  <i>n</i>  -line decoder and  <i>m</i>   OR <br>gates. <br>
 <br>The procedure for implementing a combinational circuit by means of a decoder and <br>
OR gates requires that the Boolean function for the circuit be expressed as a sum of <br>minterms. A decoder is then chosen that generates all the minterms of the input vari-<br>ables. The inputs to each OR gate are selected from the decoder outputs according to <br>the list of minterms of each function. This procedure will be illustrated by an example <br>that implements a full-adder circuit. <br>
 <br>From the truth table of the full adder (see  Table   4.4  ), we obtain the functions for the <br>
combinational circuit in sum-of-minterms form: <br>
 <br><i>S</i>(<i>x</i>, <i>y</i>, <i>z</i>) =<br>
(1, 2, 4, 7)<br>
<i>C </i>(<i>x</i>, <i>y</i>, <i>z</i>) =<br>
(3, 5, 6, 7) <br>
 <br>Since there are three inputs and a total of eight minterms, we need a three-to-eight-line <br>decoder. The implementation is shown in  Fig.   4.21 . The decoder generates the eight <br>minterms for  <i>x</i> ,   <i>y</i> , and  <i>z</i> . The OR gate for output  <i>S</i>  forms the logical sum of minterms 1, <br>2, 4, and 7. The OR gate for output  <i>C</i>  forms the logical sum of minterms 3, 5, 6, and 7. <br>
0<br>
1<br>
<i>S</i><br>
<i>x</i><br>
22<br>
2<br>
3<br>
<i>y</i><br>
3<br>
 8<br>
21<br>
decoder<br>
4<br>
<i>z</i><br>
20<br>
5<br>
<i>C</i><br>
6<br>
7<br>
<b> <br>FIGURE 4.21 <br> <br>Implementation of a full adder with a decoder  </b><br>
<hr>
<A name=173></a><b>Section 4.10  Encoders    155</b><br>
 <br>A function with a long list of minterms requires an OR gate with a large number of <br>
inputs. A function having a list of  <i>k</i>  minterms can be expressed in its complemented form <br> <br><i>F </i>     with     2<i>n </i>- <i>k</i>  minterms. If the number of minterms in the function is greater than   2<i>n</i>&gt;2, <br>then     <i>F </i>  can be expressed with fewer minterms. In such a case, it is advantageous to use <br>a NOR gate to sum the minterms of   <i>F </i>. The output of the NOR gate complements this <br>sum and generates the normal output  <i>F</i> . If NAND gates are used for the decoder, as in <br> <br>Fig.   4.19  , then the external gates must be NAND gates instead of OR gates. This is <br>because a two-level NAND gate circuit implements a sum-of-minterms function and is <br>equivalent to a two-level AND�OR circuit. <br>
<b> <br>4 . 1 0       E N C O D E R S </b><br>
 <br>An encoder is a digital circuit that performs the inverse operation of a decoder. An <br>encoder  has     2<i>n</i>  (or fewer) input lines and  <i>n</i>  output lines. The output lines, as an aggregate, <br>generate the binary code corresponding to the input value. An example of an encoder <br>is the octal-to-binary encoder whose truth table is given in  Table   4.7 . It has eight inputs <br>(one for each of the octal digits) and three outputs that generate the corresponding <br>binary number. It is assumed that only one input has a value of 1 at any given time. <b> </b><br>
 <br>The encoder can be implemented with OR gates whose inputs are determined <br>
directly from the truth table. Output  <i>z</i>  is equal to 1 when the input octal digit is 1, 3, 5, <br>or 7. Output  <i>y</i>  is 1 for octal digits 2, 3, 6, or 7, and output  <i>x</i>  is 1 for digits 4, 5, 6, or 7. These <br>conditions can be expressed by the following Boolean output functions: <br>
 <br><i>z </i>= <i>D</i>1 + <i>D</i>3 + <i>D</i>5 + <i>D</i>7<br><i>y </i>= <i>D</i>2 + <i>D</i>3 + <i>D</i>6 + <i>D</i>7<br><i>x </i>= <i>D</i>4 + <i>D</i>5 + <i>D</i>6 + <i>D</i>7 <br>
 <br>The encoder can be implemented with three OR gates. <br>
<b> <br>Table 4.7 <br><i> <br>Truth Table of an Octal-to-Binary Encoder </b></i><br>
<b> <br>Inputs  </b><br>
<b>Outputs </b><br>
<i><b> <br>D  </i>0<i> </b></i><br>
<i><b> <br>D  </i>1 </b><br>
<i><b> <br>D  </i>2<i> </b></i><br>
<i><b> <br>D  </i>3<i> </b></i><br>
<i><b> <br>D  </i>4<i> </b></i><br>
<i><b> <br>D  </i>5<i> </b></i><br>
<i><b> <br>D  </i>6<i> </b></i><br>
<i><b> <br>D  </i>7<i> </b></i><br>
<i><b> <br>x  </b></i><br>
<i><b> <br>y  </b></i><br>
<i><b> <br>z  </b></i><br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
<hr>
<A name=174></a><b>156    Chapter 4  Combinational Logic</b><br>
 <br>The encoder defined in  Table   4.7   has the limitation that only one input can be active <br>
at any given time. If two inputs are active simultaneously, the output produces an unde-<br>fined combination. For example, if   <i>D</i>3     and     <i>D</i>6  are 1 simultaneously, the output of the <br>encoder will be 111 because all three outputs are equal to 1. The output 111 does not <br>represent either binary 3 or binary 6. To resolve this ambiguity, encoder circuits must <br>establish an input priority to ensure that only one input is encoded. If we establish a <br>higher priority for inputs with higher subscript numbers, and if both   <i>D</i>3     and     <i>D</i>6     are  1  at <br>the same time, the output will be 110 because   <i>D</i>6  has higher priority than   <i>D</i>3.    <br>
 <br>Another ambiguity in the octal-to-binary encoder is that an output with all 0's is <br>
generated when all the inputs are 0; but this output is the same as when   <i>D</i>0     is  equal  to 1. <br>The discrepancy can be resolved by providing one more output to indicate whether at <br>least one input is equal to 1. <br>
<b> <br>Priority Encoder </b><br>
 <br>A priority encoder is an encoder circuit that includes the priority function. The operation <br>of the priority encoder is such that if two or more inputs are equal to 1 at the same time, <br>the input having the highest priority will take precedence. The truth table of a four-input <br>priority encoder is given in  Table   4.8  . In addition to the two outputs  <i>x</i>  and  <i>y</i> ,  the  circuit <br>has a third output designated by  <i>V</i> ; this is a  <i>valid</i>  bit indicator that is set to 1 when one or <br>more inputs are equal to 1. If all inputs are 0, there is no valid input and  <i>V</i>  is equal to 0. <br>The other two outputs are not inspected when  V  equals 0 and are specified as don't-care <br>conditions. Note that whereas  X 's in output columns represent don't-care conditions, the <br> <br>X 's in the input columns are useful for representing a truth table in condensed form. <br>Instead of listing all 16 minterms of four variables, the truth table uses an  X  to represent <br>either 1 or 0. For example,  X 100 represents the two minterms 0100 and 1100. <br>
 <br>According to  Table   4.8  , the higher the subscript number, the higher the priority of <br>
the input. Input   <i>D</i>3  has the highest priority, so, regardless of the values of the other <br>inputs, when this input is 1, the output for  <i>xy</i>  is 11 (binary 3).   <i>D</i>2  has the next priority <br>level. The output is 10 if   <i>D</i>2 = 1,     provided  that     <i>D</i>3 = 0,  regardless of the values of the <br>other two lower priority inputs. The output for   <i>D</i>1  is generated only if higher priority <br>inputs are 0, and so on down the priority levels. <br>
<b> <br>Table 4.8 <br><i> <br>Truth Table of a Priority Encoder </b></i><br>
<b> <br>Inputs  </b><br>
<b>Outputs </b><br>
<i> <br><b>D</b> </i><b>0</b><i> </i><br>
<i> <br><b>D</b> </i><b>1</b><i> </i><br>
<i> <br><b>D</b> </i><b>2</b><i> </i><br>
<i> <br><b>D</b> </i><b>3</b><i> </i><br>
<i> <br><b>x</b> </i><br>
<i> <br><b>y</b> </i><br>
<i> <br><b>V</b> </i><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 X <br>
 X <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 X <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 X <br>
 X <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 X <br>
 X <br>
 X <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
<hr>
<A name=175></a><b>Section 4.10  Encoders    157</b><br>
<i>D</i>2<br>
<i>D</i>2<br>
<i>D</i>2<i>D</i>3<br>
<i>D</i>2<i>D</i>3<br>
<i>D</i><br>
<i>D</i><br>
0<i>D</i>1<br>
00<br>
01<br>
11<br>
10<br>
0<i>D</i>1<br>
00<br>
01<br>
11<br>
10<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
0<br>
1<br>
3<br>
2<br>
0<br>
1<br>
3<br>
2<br>
00<br>
X<br>
1<br>
1<br>
1<br>
00<br>
X<br>
1<br>
1<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
7<br>
6<br>
4<br>
5<br>
7<br>
6<br>
01<br>
1<br>
1<br>
1<br>
01<br>
1<br>
1<br>
1<br>
<i>D</i>1<br>
<i>D</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
1<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
12<br>
13<br>
15<br>
14<br>
12<br>
13<br>
15<br>
14<br>
11<br>
1<br>
1<br>
1<br>
11<br>
1<br>
1<br>
1<br>
<i>D</i>0<br>
<i>D</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
0<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
8<br>
9<br>
11<br>
10<br>
8<br>
9<br>
11<br>
10<br>
10<br>
1<br>
1<br>
X<br>
10<br>
1<br>
1<br>
<i>D</i>3<br>
<i>D</i>3<br>
<i>x</i><br>
<i>D</i>2<br>
<i>D</i>3<br>
<i>y</i><br>
<i>D</i>3<br>
<i>D</i>1<i>D </i>2<br>
<b> <br>FIGURE 4.22 <br> <br>Maps for a priority encoder  </b><br>
 <br>The maps for simplifying outputs  <i>x</i>  and  <i>y</i>  are shown in  Fig.   4.22  . The minterms for the <br>
two functions are derived from Table 4.8. Although the table has only five rows, when <br>each X in a row is replaced first by 0 and then by 1, we obtain all 16 possible input com-<br>binations. For example, the fourth row in the table, with inputs XX10, represents the four <br>minterms 0010, 0110, 1010, and 1110. The simplified Boolean expressions for the priority <br>encoder are obtained from the maps. The condition for output  <i>V</i>  is an OR function of <br>all the input variables. The priority encoder is implemented in  Fig.   4.23   according to the <br>following Boolean functions: <br>
 <br>
 <i>x </i>= <i>D</i>2 + <i>D</i>3<br>
 <br>
<i>y </i>= <i>D</i>3 + <i>D</i>1  <i>D</i>2<br>
<i>V </i>= <i>D</i>0 + <i>D</i>1 + <i>D</i>2 + <i>D</i>3 <br>
<i>D</i>3<br>
<i>y</i><br>
<i>D</i>2<br>
<i>D</i>1<br>
<i>x</i><br>
<i>V</i><br>
<i>D</i>0<br>
<b> <br>FIGURE 4.23 <br> <br>Four-input priority encoder  </b><br>
<hr>
<A name=176></a><b>158    Chapter 4  Combinational Logic</b><br>
<b> <br>4 . 1 1       M U L T I P L E X E R S </b><br>
 <br>A multiplexer is a combinational circuit that selects binary information from one of <br>many input lines and directs it to a single output line. The selection of a particular input <br>line is controlled by a set of selection lines. Normally, there are   2<i>n</i>  input lines and  <i>n</i>   selec-<br>tion lines whose bit combinations determine which input is selected. <br>
 <br>A two-to-one-line multiplexer connects one of two 1-bit sources to a common desti-<br>
nation, as shown in  Fig.   4.24  . The circuit has two data input lines, one output line, and <br>one selection line  <i>S</i> .  When     <i>S </i>= 0,  the upper AND gate is enabled and   <i>I</i>0  has a path to <br>the output. When   <i>S </i>= 1,  the lower AND gate is enabled and   <i>I</i>1  has a path to the output. <br>The multiplexer acts like an electronic switch that selects one of two sources. The block <br>diagram of a multiplexer is sometimes depicted by a wedge-shaped symbol, as shown in <br> <br>Fig.   4.24(b)  . It suggests visually how a selected one of multiple data sources is directed <br>into a single destination. The multiplexer is often labeled "MUX" in block diagrams. <br>
 <br>A four-to-one-line multiplexer is shown in  Fig.   4.25  . Each of the four inputs,   <i>I</i>0 <br>
through     <i>I</i>3,  is applied to one input of an AND gate. Selection lines   <i>S</i>1     and     <i>S</i>0     are  decoded <br>to select a particular AND gate. The outputs of the AND gates are applied to a single <br>OR gate that provides the one-line output. The function table lists the input that is <br>passed to the output for each combination of the binary selection values. To demonstrate <br>the operation of the circuit, consider the case when   <i>S</i>1<i>S</i>0 = 10.     The  AND  gate  associated <br>with  input     <i>I</i>2  has two of its inputs equal to 1 and the third input connected to   <i>I</i>2.     The <br>other three AND gates have at least one input equal to 0, which makes their outputs <br>equal to 0. The output of the OR gate is now equal to the value of   <i>I</i>2,     providing  a  path <br>from the selected input to the output. A multiplexer is also called a  <i>data selector</i> ,  since <br>it selects one of many inputs and steers the binary information to the output line. <br>
 <br>The AND gates and inverters in the multiplexer resemble a decoder circuit, and indeed, <br>
they decode the selection input lines. In general, a 2  <i>n</i>  -to-1-line multiplexer is constructed <br>from an  <i>n</i> -to-2  <i>n</i>   decoder by adding   2<i>n</i>  input lines to it, one to each AND gate. The outputs <br>of the AND gates are applied to a single OR gate. The size of a multiplexer is specified by <br>
<i>I</i>0<br>
<i>I</i>0<br>
0<br>
<i>Y</i><br>
MUX<br>
<i>Y</i><br>
<i>I</i>1<br>
1<br>
<i>I</i>1<br>
<i>S</i><br>
<i>S</i><br>
(a) Logic diagram<br>
(b) Block diagram<br>
<b> <br>FIGURE 4.24 <br> <br>Two-to-one-line multiplexer  </b><br>
<hr>
<A name=177></a><b>Section 4.11  Multiplexers    159</b><br>
<i>I</i>0<br>
<i>I</i>1<br>
<i>Y</i><br>
<i>I</i>2<br>
<i>I</i>3<br>
<i>S</i>1 <i>S</i>0<br>
<i>Y</i><br>
0<br>
0<br>
<i>I</i>0<br>
0<br>
1<br>
<i>I</i>1<br>
<i>S</i>1<br>
1<br>
0<br>
<i>I</i>2<br>
1<br>
1<br>
<i>I</i>3<br>
<i>S</i>0<br>
(a) Logic diagram<br>
(b) Function table<br>
<b> <br>FIGURE 4.25 <br> <br>Four-to-one-line multiplexer  </b><br>
the number   2<i>n</i>  of its data input lines and the single output line. The  <i>n</i>  selection lines are <br>implied from the   2<i>n</i>  data lines. As in decoders, multiplexers may have an enable input to <br>control the operation of the unit. When the enable input is in the inactive state, the outputs <br>are disabled, and when it is in the active state, the circuit functions as a normal multiplexer. <br>
 <br>Multiplexer circuits can be combined with common selection inputs to provide <br>
 <br>multiple-bit selection logic. As an illustration, a quadruple 2-to-1-line multiplexer is shown <br>in  Fig.   4.26  . The circuit has four multiplexers, each capable of selecting one of two input <br>lines. Output   <i>Y</i>0  can be selected to come from either input   <i>A</i>0     or  input     <i>B</i>0.     Similarly, <br>output     <i>Y</i>1  may have the value of   <i>A</i>1 or  <i>B</i>1,  and so on. Input selection line  <i>S</i>  selects one of <br>the lines in each of the four multiplexers. The enable input  <i>E</i>  must be active (i.e., asserted) <br>for normal operation. Although the circuit contains four 2-to-1-line multiplexers, we are <br>more likely to view it as a circuit that selects one of two 4-bit sets of data lines. As shown <br>in the function table, the unit is enabled when   <i>E </i>= 0.     Then,  if     <i>S </i>= 0,     the  four   <i>A</i>   inputs <br>have a path to the four outputs. If, by contrast,   <i>S </i>= 1,     the  four   <i>B</i>  inputs are applied to the <br>outputs. The outputs have all 0's when   <i>E </i>= 1,  regardless of the value of  <i>S</i> . <br>
<b> <br>Boolean Function Implementation </b><br>
 <br>In Section 4.9, it was shown that a decoder can be used to implement Boolean functions <br>by employing external OR gates. An examination of the logic diagram of a multiplexer <br>reveals that it is essentially a decoder that includes the OR gate within the unit. The <br>
<hr>
<A name=178></a><b>160    Chapter 4  Combinational Logic</b><br>
<i>A</i>0<br>
<i>Y</i>0<br>
<i>A</i>1<br>
<i>Y</i>1<br>
<i>A</i>2<br>
<i>Y</i>2<br>
<i>A</i>3<br>
<i>Y</i>3<br>
<i>B</i>0<br>
<i>E</i><br>
<i>S</i><br>
Output <i>Y</i><br>
<i>B</i>1<br>
1<br>
X<br>
all 0's<br>
0<br>
0<br>
select <i>A</i><br>
0<br>
1<br>
select <i>B</i><br>
<i>B</i>2<br>
Function table<br>
<i>B</i>3<br>
<i>S</i><br>
(select)<br>
<i>E</i><br>
(enable)<br>
<b> <br>FIGURE 4.26 <br> <br>Quadruple two-to-one-line multiplexer  </b><br>
minterms of a function are generated in a multiplexer by the circuit associated with the <br>selection inputs. The individual minterms can be selected by the data inputs, thereby <br>providing a method of implementing a Boolean function of  <i>n</i>  variables with a multi-<br>plexer that has  <i>n</i>  selection inputs and   2<i>n</i>  data inputs, one for each minterm. <br>
 <br>We will now show a more efficient method for implementing a Boolean function of <br>
 <br><i>n</i>  variables with a multiplexer that has   <i>n </i>- 1     selection  inputs.  The  first     <i>n </i>- 1     variables <br>of the function are connected to the selection inputs of the multiplexer. The remaining <br>single variable of the function is used for the data inputs. If the single variable is denoted <br>
<hr>
<A name=179></a><b>Section 4.11  Multiplexers    161</b><br>
by  <i>z</i> , each data input of the multiplexer will be  <i>z</i> ,  <i>z </i>,  1, or 0. To demonstrate this proce-<br>dure, consider the Boolean function <br>
 <br><i>F</i> (<i>x</i>, <i>y</i>, <i>z</i>) =<br>
(1, 2, 6, 7) <br>
 <br>This function of three variables can be implemented with a four-to-one-line multiplexer <br>as shown in  Fig.   4.27 . The two variables  <i>x</i>  and  <i>y</i>  are applied to the selection lines in that <br>order;  <i>x</i>  is connected to the   <i>S</i>1     input  and   <i>y</i>   to  the     <i>S</i>0  input. The values for the data input <br>lines are determined from the truth table of the function. When   <i>xy </i>= 00,     output   <i>F</i>   is <br>equal to  <i>z</i>   because     <i>F </i>= 0     when     <i>z </i>= 0     and     <i>F </i>= 1     when     <i>z </i>= 1.     This  requires  that  variable <br> <br><i>z</i>  be applied to data input 0. The operation of the multiplexer is such that when   <i>xy </i>= 00,    <br>data input 0 has a path to the output, and that makes  <i>F</i>  equal to  <i>z</i> . In a similar fashion, <br>we can determine the required input to data lines 1, 2, and 3 from the value of  <i>F</i>   when <br> <i>xy </i>= 01,  10, and 11, respectively. This particular example shows all four possibilities that <br>can be obtained for the data inputs. <br>
 <br>The general procedure for implementing any Boolean function of  <i>n</i>  variables with a <br>
multiplexer  with     <i>n </i>- 1     selection  inputs  and     2<i>n</i>-1  data inputs follows from the previous <br>example. To begin with, Boolean function is listed in a truth table. Then first   <i>n </i>- 1     vari-<br>ables in the table are applied to the selection inputs of the multiplexer. For each com-<br>bination of the selection variables, we evaluate the output as a function of the last <br>variable. This function can be 0, 1, the variable, or the complement of the variable. These <br>values are then applied to the data inputs in the proper order. <br>
 <br>As a second example, consider the implementation of the Boolean function <br>
 <br><i>F</i> (<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>) =<br>
(1, 3, 4, 11, 12, 13, 14, 15) <br>
 <br>This function is implemented with a multiplexer with three selection inputs as shown in <br> <br>Fig.   4.28  . Note that the first variable  <i>A</i>  must be connected to selection input   <i>S</i>2     so  that <br> <br><i>A</i> ,   <i>B,</i>  and  <i>C</i>  correspond to selection inputs   <i>S</i>2, <i>S</i>1,     and     <i>S</i>0,  respectively. The values for the <br>
4<br>
 1 MUX<br>
<i>y</i><br>
<i>S</i>0<br>
<i>x</i><br>
<i>y</i><br>
<i>z</i><br>
<i>F</i><br>
<i>x</i><br>
<i>S</i>1<br>
0<br>
0<br>
0<br>
0<br>
<i>F</i><br>
<i>z</i><br>
0<br>
0<br>
1<br>
1<br>
<i>z</i><br>
0<br>
<i>F</i><br>
0<br>
1<br>
0<br>
1<br>
<i>F</i><br>
<i>z</i><br>
0<br>
1<br>
1<br>
0<br>
<i>z</i><br>
1<br>
1<br>
0<br>
0<br>
0<br>
<i>F</i><br>
 0<br>
0<br>
2<br>
1<br>
0<br>
1<br>
0<br>
1<br>
3<br>
1<br>
1<br>
0<br>
1<br>
<i>F</i><br>
 1<br>
1<br>
1<br>
1<br>
1<br>
(a) Truth table<br>
(b) Multiplexer implementation<br>
<b> <br>FIGURE 4.27 <br> <br>Implementing a Boolean function with a multiplexer  </b><br>
<hr>
<A name=180></a><b>162    Chapter 4  Combinational Logic</b><br>
<i>A</i><br>
<i>B</i><br>
<i>C</i><br>
<i>D F</i><br>
0<br>
0<br>
0<br>
0<br>
0<br>
<i>F</i><br>
<i>D</i><br>
8<br>
 1 MUX<br>
0<br>
0<br>
0<br>
1<br>
1<br>
<i>C</i><br>
<i>S</i>0<br>
0<br>
0<br>
1<br>
0<br>
0<br>
<i>F</i><br>
<i>D</i><br>
0<br>
0<br>
1<br>
1<br>
1<br>
<i>B</i><br>
<i>S</i>1<br>
<i>A</i><br>
<i>S</i>2<br>
0<br>
1<br>
0<br>
0<br>
1<br>
<i>F</i><br>
<i>D</i><br>
0<br>
1<br>
0<br>
1<br>
0<br>
<i>D</i><br>
0<br>
0<br>
1<br>
1<br>
0<br>
0<br>
<i>F</i><br>
 0<br>
1<br>
0<br>
1<br>
1<br>
1<br>
0<br>
<i>F</i><br>
2<br>
1<br>
0<br>
0<br>
0<br>
0<br>
<i>F</i><br>
 0<br>
0<br>
3<br>
1<br>
0<br>
0<br>
1<br>
0<br>
4<br>
1<br>
0<br>
1<br>
0<br>
0<br>
5<br>
<i>F</i><br>
<i>D</i><br>
1<br>
0<br>
1<br>
1<br>
1<br>
1<br>
6<br>
1<br>
1<br>
0<br>
0<br>
1<br>
7<br>
<i>F</i><br>
 1<br>
1<br>
1<br>
0<br>
1<br>
1<br>
1<br>
1<br>
1<br>
0<br>
1<br>
<i>F</i><br>
 1<br>
1<br>
1<br>
1<br>
1<br>
1<br>
<b> <br>FIGURE 4.28 <br> <br>Implementing a four-input function with a multiplexer  </b><br>
data inputs are determined from the truth table listed in the figure. The corresponding <br>data line number is determined from the binary combination of  <i>ABC</i> . For example, the <br>table shows that when   <i>ABC </i>= 101, <i>F </i>= <i>D</i>,  so the input variable  <i>D</i>  is applied to data <br>input 5. The binary constants 0 and 1 correspond to two fixed signal values. When inte-<br>grated circuits are used, logic 0 corresponds to signal ground and logic 1 is equivalent to <br>the power signal, depending on the technology (e.g., 3 V). <b> </b><br>
<b> <br>Three-State Gates </b><br>
 <br>A multiplexer can be constructed with three-state gates--digital circuits that exhibit <br>three states. Two of the states are signals equivalent to logic 1 and logic 0 as in a conven-<br>tional gate. The third state is a  <i>high-impedance</i>  state in which (1) the logic behaves like <br>an open circuit, which means that the output appears to be disconnected, (2) the circuit <br>has no logic significance, and (3) the circuit connected to the output of the three-state <br>gate is not affected by the inputs to the gate. Three-state gates may perform any con-<br>ventional logic, such as AND or NAND. However, the one most commonly used is the <br>buffer gate. <br>
 <br>The graphic symbol for a three-state buffer gate is shown in  Fig.   4.29  . It is distinguished <br>
from a normal buffer by an input control line entering the bottom of the symbol. The <br>buffer has a normal input, an output, and a control input that determines the state of the <br>output. When the control input is equal to 1, the output is enabled and the gate behaves <br>like a conventional buffer, with the output equal to the normal input. When the control <br>
<hr>
<A name=181></a><b>Section 4.11  Multiplexers    163</b><br>
Normal input <i>A</i><br>
Output <i>Y</i><br>
<i>A</i> if <i>C</i><br>
 1<br>
High-impedance if <i>C</i><br>
 0<br>
Control input <i>C</i><br>
<b> <br>FIGURE 4.29 <br> <br>Graphic symbol for a three-state buffer  </b><br>
input is 0, the output is disabled and the gate goes to a high-impedance state, regardless <br>of the value in the normal input. The high-impedance state of a three-state gate provides <br>a special feature not available in other gates. Because of this feature, a large number of <br>three-state gate outputs can be connected with wires to form a common line without <br>endangering loading effects. <br>
 <br>The construction of multiplexers with three-state buffers is demonstrated in  Fig.   4.30  . <br>
Figure 4.30(a) shows the construction of a two-to-one-line multiplexer with 2 three-state <br>buffers and an inverter. The two outputs are connected together to form a single output <br>line. (Note that this type of connection cannot be made with gates that do not have <br>three-state outputs.) When the select input is 0, the upper buffer is enabled by its control <br>input and the lower buffer is disabled. Output  <i>Y</i>  is then equal to input  <i>A</i> .When the select <br>input is 1, the lower buffer is enabled and  <i>Y</i>  is equal to  <i>B</i> . <br>
 <br>The construction of a four-to-one-line multiplexer is shown in  Fig.   4.30(b)  . The out-<br>
puts of 4 three-state buffers are connected together to form a single output line. The <br>control inputs to the buffers determine which one of the four normal inputs   <i>I</i>0     through <br>
<i>I</i>0<br>
<i>Y</i><br>
<i>I</i>1<br>
<i>I</i>2<br>
<i>A</i><br>
<i>Y</i><br>
<i>I</i>3<br>
0<br>
<i>S</i>1<br>
Select<br>
1<br>
<i>B</i><br>
2<br>
 4<br>
<i>S</i>0<br>
decoder<br>
2<br>
Enable<br>
<i>EN</i><br>
Select<br>
3<br>
(a) 2-to-1-line mux<br>
(b) 4-to-1-line mux<br>
<b> <br>FIGURE 4.30 <br> <br>Multiplexers with three-state gates  </b><br>
<hr>
<A name=182></a><b>164    Chapter 4  Combinational Logic</b><br>
 <br><i>I</i>3  will be connected to the output line. No more than one buffer may be in the active <br>state at any given time. The connected buffers must be controlled so that only 1 three-<br>state buffer has access to the output while all other buffers are maintained in a high-<br>impedance state. One way to ensure that no more than one control input is active at any <br>given time is to use a decoder, as shown in the diagram. When the enable input of the <br>decoder is 0, all of its four outputs are 0 and the bus line is in a high-impedance state <br>because all four buffers are disabled. When the enable input is active, one of the three-<br>state buffers will be active, depending on the binary value in the select inputs of the <br>decoder. Careful investigation reveals that this circuit is another way of constructing a <br>four-to-one-line  multiplexer.   <br>
<b> <br>4 . 1 2       H D L   M O D E L S   O F   C O M B I N AT I O N A L </b><br>
<b>C I R C U I T S </b><br>
 <br>The Verilog HDL was introduced in Section 3.10. In the current section, we introduce <br>additional features of Verilog, present more elaborate examples, and compare alternative <br>descriptions of combinational circuits in Verilog. Sequential circuits are presented in <br>Chapter 5. As mentioned previously, the module is the basic building block for modeling <br>hardware with the Verilog HDL. The logic of a module can be described in any one (or a <br>combination) of the following modeling styles: <br>
 <br>
�   Gate-level modeling using instantiations of predefined and user-defined primitive <br>
gates.  <br>
 <br>
�   Dataflow modeling using continuous assignment statements with the keyword <br>
 <br><b>assign</b> .  <br>
 <br>
�   Behavioral modeling using procedural assignment statements with the keyword <br>
 <br><b>always </b>.<b> </b><br>
 <br>Gate-level (structural) modeling describes a circuit by specifying its gates and how they <br>are connected with each other. Dataflow modeling is used mostly for describing the <br>Boolean equations of combinational logic. We'll also consider here behavioral modeling <br>that is used to describe combinational and sequential circuits at a higher level of abstrac-<br>tion. Combinational logic can be designed with truth tables, Boolean equations, and <br>schematics; Verilog has a construct corresponding to each of these "classical" approaches <br>to design: user-defined primitives, continuous assignments, and primitives, as shown in <br> <br>Fig.   4.31 . There is one other modeling style, called switch-level modeling. It is sometimes <br>used in the simulation of MOS transistor circuit models, but not in logic synthesis. We <br>will not consider switch-level modeling. <br>
<b> <br>Gate-Level Modeling </b><br>
 <br>Gate-level modeling was introduced in Section 3.10 with a simple example. In this type <br>of representation, a circuit is specified by its logic gates and their interconnections. Gate-<br>level modeling provides a textual description of a schematic diagram. The Verilog HDL <br>
<hr>
<A name=183></a><b>Section 4.12  HDL Models of Combinational Circuits    165</b><br>
Verilog model<br>
(combinational logic)<br>
Primitive (gate)<br>
Continuous assignment<br>
-defined primitive<br>
Boolean equation<br>
User<br>
Truth table<br>
Schematic<br>
<b> <br>FIGURE 4.31 <br> <br>Relationship of Verilog constructs to truth tables, Boolean equations, and schematics  </b><br>
includes 12 basic gates as predefined primitives. Four of these primitive gates are of the <br>three-state type. The other eight are the same as the ones listed in Section 2.8. They are <br>all declared with the lowercase keywords  <b>and</b>,<b> nand</b>,<b> or</b>,<b> nor</b>,<b> xor</b>,<b> xnor</b>,<b> not</b>,  and  <b>buf </b>.<b> <br></b>Primitives such as  <b>and</b>  are  <i>n</i> -input primitives. They can have any number of scalar inputs <br>(e.g., a three-input  <b>and</b>  primitive). The  <b>buf</b>  and  <b>not</b>  primitives are  <i>n</i> -output  primitives. <br>A single input can drive multiple output lines distinguished by their identifiers. <br>
 <br>The Verilog language includes a functional description of each type of gate, too. The <br>
logic of each gate is based on a four-valued system. When the gates are simulated, <br>the simulator assigns one value to the output of each gate at any instant. In addition to <br>the two logic values of 0 and 1, there are two other values:  <i>unknown</i>  and  <i>high impedance</i> . <br>An unknown value is denoted by  <b>x</b>  and a high impedance by  <b>z </b>. An unknown value is <br>assigned during simulation when the logic value of a signal is ambiguous--for instance, <br>if it cannot be determined whether its value is 0 or 1 (e.g., a flip-flop without a reset <br>condition). A high-impedance condition occurs at the output of three-state gates that <br>are not enabled or if a wire is inadvertently left unconnected. The four-valued logic truth <br>tables for the  <b>and</b>,<b> or</b>,<b> xor</b>,  and  <b>not</b>  primitives are shown in  Table   4.9  . The truth table for <br>the other four gates is the same, except that the outputs are complemented. Note that <br>for the  <b>and</b>  gate, the output is 1 only when both inputs are 1 and the output is 0 if any <br>input is 0. Otherwise, if one input is  <b>x</b>  or  <b>z </b>,<b> </b>the output is  <b>x </b>. The output of the  <b>or</b>  gate is 0 <br>if both inputs are 0, is 1 if any input is 1, and is  <b>x</b>   otherwise. <b> </b><br>
 <br>When a primitive gate is listed in a module, we say that it is  <i>instantiated</i>  in the module. <br>
In general, component instantiations are statements that reference lower level compo-<br>nents in the design, essentially creating unique copies (or  <i>instances</i> ) of those components <br>in the higher level module. Thus, a module that uses a gate in its description is said to <br>
<hr>
<A name=184></a><b>166    Chapter 4  Combinational Logic</b><br>
<b> <br>Table 4.9 <br><i> <br>Truth Table for Predefined Primitive Gates </b></i><br>
<b> and </b><br>
 0 <br>
 1 <br>
<b> x </b><br>
<b> z </b><br>
<b> or </b><br>
 0 <br>
 1 <br>
<b> x </b><br>
<b> z </b><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
<b> x </b><br>
<b> x </b><br>
 1 <br>
 0 <br>
 1 <br>
<b> x </b><br>
<b> x </b><br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
<b> x </b><br>
 0 <br>
<b> x </b><br>
<b> x </b><br>
<b> x </b><br>
<b> x </b><br>
<b> x </b><br>
 1 <br>
<b> x </b><br>
<b> x </b><br>
<b> z </b><br>
 0 <br>
<b> x </b><br>
<b> x </b><br>
<b> x </b><br>
<b> z </b><br>
<b> x </b><br>
 1 <br>
<b> x </b><br>
<b> x </b><br>
<b> xor </b><br>
 0 <br>
 1 <br>
<b> x </b><br>
<b> z </b><br>
<b> not </b><br>
 input <br>
 output     <br>
 0 <br>
 0 <br>
 1 <br>
<b> x </b><br>
<b> x </b><br>
 <br>
 <br>0 <br>
 <br>1 <br>
 1 <br>
 1 <br>
 0 <br>
<b> x </b><br>
<b> x </b><br>
 <br>
 <br>1 <br>
 <br>0 <br>
<b> x </b><br>
<b> x </b><br>
<b> x </b><br>
<b> x </b><br>
<b> x </b><br>
 <br>
<b> <br>x </b><br>
<b> <br>x </b><br>
<b> z </b><br>
<b> x </b><br>
<b> x </b><br>
<b> x </b><br>
<b> x </b><br>
 <br>
<b> <br>z </b><br>
<b> <br>x </b><br>
 <br><i>instantiate</i>  the gate. Think of instantiation as the HDL counterpart of placing and <br> <br>connecting parts on a circuit board. <br>
 <br>We now present two examples of gate-level modeling. Both examples use identifiers <br>
having multiple bit widths, called  <i>vectors</i> . The syntax specifying a vector includes within <br>square brackets two numbers separated with a colon. The following Verilog statements <br>
specify two vectors: <br>
 <br><b>output</b>  [0: 3] D;<br>
 <br><b>wire</b> <br>
[7: 0] SUM;  <br>
 <br>The first statement declares an output vector  <i>D</i>  with four bits, 0 through 3. The second <br>declares a wire vector  <i>SUM</i>  with eight bits numbered 7 through 0. ( <i>Note</i> : The first (left-<br>most) number (array index) listed is always the most significant bit of the vector.) The <br>individual bits are specified within square brackets, so  <i>D[2]</i>  specifies bit 2 of  <i>D</i> . It is also <br>possible to address parts (contiguous bits) of vectors. For example,  <i>SUM[2: 0]</i>   specifies <br>the three least significant bits of vector  <i>SUM</i> . <br>
 <br>HDL Example 4.1 shows the gate-level description of a two-to-four-line decoder. <br>
(See  Fig.   4.19  .) This decoder has two data inputs  <i>A</i>  and  <i>B</i>  and an enable input  <i>E</i> .  The <br>four outputs are specified with the vector  <i>D</i> .  The   <b>wire</b>  declaration is for internal connec-<br>tions. Three  <b>not</b>  gates produce the complement of the inputs, and four  <b>nand</b>  gates provide <br>the outputs for  <i>D</i> . Remember that  <i>the output is always listed first in the port list of a <br>primitive</i> , followed by the inputs. This example describes the decoder of  Fig.  4.19   and <br>follows the procedures established in Section 3.10. Note that the keywords  <b>not</b>  and  <b>nand</b> <br>are written only once and do not have to be repeated for each gate, but commas must <br>be inserted at the end of each of the gates in the series, except for the last statement, <br>which must be terminated with a semicolon. <br>
<hr>
<A name=185></a><b>Section 4.12  HDL Models of Combinational Circuits    167</b><br>
<b> <br>HDL Example 4.1 (Two-to-Four-Line Decoder) </b><br>
 <br>// Gate-level description of two-to-four-line decoder<br> <br>// Refer to  Fig.   4.19   with symbol  <i>E</i>  replaced by  <i>enable</i> , for clarity.<br>
 <br><b>module</b>  decoder_2x4_gates (D, A, B, enable);<br>  <b>output</b>  [0: <br>
3] <br>
D;<br>
  <b>input</b>   <br>
A, <br>
B;<br>
  <b>input</b>   <br>
enable;<br>
  <b>wire</b>   <br>
A_not,B_not, <br>
enable_not;<br>
  <b>not</b><br>
  G1  (A_not, A),<br>  G2  (B_not, B),<br>  G3  (enable_not, enable);<br>
  <b>nand</b><br>
   G4  (D[0], A_not, B_not, enable_not),<br>  G5  (D[1], A_not, B, enable_not),<br>  G6  (D[2], A, B_not, enable_not),<br>  G7  (D[3], A, B, enable_not);<br>
 <br><b>endmodule</b> <br>
 <br>Two or more modules can be combined to build a hierarchical description of a design. <br>
There are two basic types of design methodologies: top down and bottom up. In a <br> <br><i>top-down</i>  design, the top-level block is defined and then the subblocks necessary to <br>build the top-level block are identified. In a  <i>bottom-up</i>  design, the building blocks are <br>first identified and then combined to build the top-level block. Take, for example, the <br>binary adder of  Fig.   4.9  . It can be considered as a top-block component built with four <br>full-adder blocks, while each full adder is built with two half-adder blocks. In a top-down <br>design, the four-bit adder is defined first, and then the two adders are described. In a <br>bottom-up design, the half adder is defined, then each full adder is constructed, and then <br>the four-bit adder is built from the full adders. <br>
 <br>A bottom-up hierarchical description of a four-bit adder is shown in HDL <br>
 <br>Example 4.2. The half adder is defined by instantiating primitive gates. The next mod-<br>ule describes the full adder by instantiating and connecting two half adders. The third <br>module describes the four-bit adder by instantiating and connecting four full adders. <br>Note that the first character of an identifier cannot be a number, but can be an under-<br>score, so the module name  <i>_4bitadder</i>  is valid. An alternative name that is meaningful, <br>but does not require a leading underscore, is  <i>adder_4_bit</i> . The instantiation is done by <br>using the name of the module that is instantiated together with a new (or the same) <br>set of port names. For example, the half adder  <i>HA1</i>  inside the full adder module is <br>instantiated with ports  <i>S1</i> ,   <i>C1</i> ,   <i>x,</i>  and  <i>y</i> . This produces a half adder with outputs  <i>S1</i>   and <br> <br><i>C1</i>  and inputs  <i>x</i>  and  <i>y</i> . <br>
<hr>
<A name=186></a><b>168    Chapter 4  Combinational Logic</b><br>
<b> <br>HDL Example 4.2 (Ripple-Carry Adder) </b><br>
 <br>// Gate-level description of four-bit ripple carry adder<br> <br>// Description of half adder ( Fig.   4.5b  )<br>
 <br>//  <b>module</b>  half_adder (S, C, x, y); <br>
// Verilog 1995 syntax<br>
 <br>//  <b>output</b>  S, <br>
C;<br>
 <br>//  <b>input</b>  x, <br>
y;<br>
 <br><b>module</b>  half_adder ( <b>output</b>  S, C,  <b>input</b>  x, y); <br>
 // Verilog 2001, 2005 syntax<br>
 <br>// Instantiate primitive gates<br>
 <br><b>xor</b>  (S, x, y);<br> <br><b>and</b>  (C, x, y);<br>
 <br><b>endmodule</b> <br>
 <br>// Description of full adder ( Fig.   4.8  ) <br>
 // Verilog 1995 syntax<br>
 <br>//  <b>module</b>  full_adder (S, C, x, y, z);<br> <br>//  <b>output</b>  S, <br>
C;<br>
 <br>//  <b>input</b> <br>
x, y, z;<br>
 <br><b>module</b>  full_adder ( <b>output</b>  S, C,  <b>input</b>  x, y, z); <br>
// Verilog 2001, 2005 syntax<br>
 <br><b>wire</b> S1, C1, C2;<br>
 <br>// Instantiate half adders<br>
 <br>half_adder HA1 (S1, C1, x, y);<br> <br>half_adder HA2 (S, C2, S1, z);<br><b> <br>or</b> G1 (C, C2, C1);<br>
 <br><b>endmodule</b> <br>
 <br>// Description of four-bit adder ( Fig.   4.9  ) <br>
// Verilog 1995 syntax<br>
 <br>//  <b>module</b>  ripple_carry_4_bit_adder (Sum, C4, A, B, C0);<br> <br>//  <b>output</b>  [3: 0] <br>
Sum;<br>
 <br>//  <b>output</b>   <br>
C4;<br>
 <br>// <b>input</b>   [3: 0] <br>
A, B;<br>
 <br>//  <b>input</b>   <br>
C0;<br>
 <br>// Alternative Verilog 2001, 2005 syntax:<br>
 <br><b>module</b>  ripple_carry_4_bit_adder (  <b>output</b>  [3: 0] Sum,  <b>output</b>  C4,  <br>
<b>input</b>  [3: 0] A, B,  <b>input</b>  C0);<br> <br><b>wire</b> <br>
C1, C2, C3; <br>
// Intermediate carries<br>
 <br>// Instantiate chain of full adders<br> <br>full_adder <br>
FA0 (Sum[0], C1, A[0], B[0], C0),<br>
 <br>
FA1 (Sum[1], C2, A[1], B[1], C1),<br>
 <br>
FA2 (Sum[2], C3, A[2], B[2], C2),<br>
 <br>
FA3 (Sum[3], C4, A[3], B[3], C3);<br>
<b> <br>endmodule </b> <br>
 <br>HDL Example 4.2 illustrates Verilog 2001, 2005 syntax, which eliminates extra typing <br>
of identifiers declaring the mode (e.g.,  <b>output</b> ), type ( <b>reg</b> ), and declaration of a vector range <br>(e.g., [3: 0]) of a port. The first version of the standard (1995) uses separate statements for <br>these declarations. <br>
<hr>
<A name=187></a><b>Section 4.12  HDL Models of Combinational Circuits    169</b><br>
 <br>Note that modules can be instantiated (nested) within other modules, but module <br>
declarations cannot be nested; that is, a module definition (declaration) cannot be placed <br>within another module declaration. In other words, a module definition cannot be <br>inserted into the text between the  <b>module</b>  and  <b>endmodule</b>  keywords of another module. <br>The only way one module definition can be incorporated into another module is by <br>instantiating it. Instantiating modules within other modules creates a hierarchical <br>decomposition of a design. A description of a module is said to be a  <i>structural</i>   descrip-<br>tion if it is composed of instantiations of other modules. Note also that<i> instance names <br></i>must be specified when defined modules are instantiated (such as  <i>FA0</i>  for the first full <br>adder in the third module), but using a name is optional when instantiating primitive <br>gates. Module  <i>ripple_carry_4_bit_adder</i>  is composed of instantiated and interconnected <br>full adders, each of which is itself composed of half adders and some  <i>glue logic</i> .  The  top <br>level, or parent module, of the design hierarchy is the module  <i>ripple_carry_4_</i> <i>bit_adder</i>. <br>Four copies of  <i>full_adder</i>  are its child modules, etc.  <i>C0</i>  is an input of the cell forming the <br>least significant bit of the chain, and  <i>C4</i>  is the output of the cell forming the most <br> significant  bit.  <br>
<b> <br>Three-State Gates </b><br>
 <br>As mentioned in Section 4.11, a three-state gate has a control input that can place the <br>gate into a high-impedance state. The high-impedance state is symbolized by  <b>z</b>   in  Verilog. <br>There are four types of three-state gates, as shown in  Fig.   4.32  . The  <b>bufif1</b>  gate behaves <br>like a normal buffer if   <i>control </i>= 1. The output goes to a high-impedance state  <b>z</b>   when <br> <br><i>control </i>= 0. The  <b>bufif0</b>  gate behaves in a similar fashion, except that the high-impedance <br>state occurs when   <i>control </i>= 1.     The  two   <b>notif</b>  gates operate in a similar manner, except <br>that the output is the complement of the input when the gate is not in a high-impedance <br>state. The gates are instantiated with the statement <br>
 <br><i>gate name </i>1<i>output</i>, <i>input</i>, <i>control</i>2;   <br>
in<br>
out<br>
in<br>
out<br>
control<br>
control<br>
bufif1<br>
bufif0<br>
in<br>
out<br>
in<br>
out<br>
control<br>
control<br>
notif1<br>
notif0<br>
<b> <br>FIGURE 4.32 <br> <br>Three-state gates  </b><br>
<hr>
<A name=188></a><b>170    Chapter 4  Combinational Logic</b><br>
 <br>The gate name can be that of any 1 of the 4 three-state gates. In simulation, the output <br>can result in 0, 1,  <b>x ,</b> or  <b>z .</b> Two examples of gate instantiation are <br>
 <br><b>bufif1</b> <br>
(OUT, A, control);<br>
 <br><b>notif0</b> <br>
(Y, B, enable);  <br>
 <br>In the first example, input  <i>A</i>  is transferred to  <i>OUT</i>   when     <i>control </i>= 1.  <i>OUT</i>  goes to  <b>z</b> <br>when     <i>control </i>= 0.  In the second example, output   <i>Y </i>= <b>z</b>     when     <i>enable </i>= 1     and  output <br> <br><i>Y </i>= <i>B </i>     when     <i>enable </i>= 0. <br>
 <br>The outputs of three-state gates can be connected together to form a common output <br>
line. To identify such a connection, Verilog HDL uses the keyword  <b>tri</b>  (for tristate) to <br>indicate that the output has multiple drivers. As an example, consider the two-to-one-<br>line multiplexer with three-state gates shown in  Fig.   4.33  . <br>
 <br>The HDL description must use a  <b>tri</b>  data type for the output:<br>
 <br>//  Mux  with three-state output<br>
 <br><b>module</b>  mux_tri (m_out, A, B, select);<br>
 <br><b>output</b>  m_out;<br> <br><b>input</b>  A, B, select;<br> <br><b>tri</b>  m_out;<br>
 <br><b>bufif1</b>  (m_out, A, select);<br> <br><b>bufif0</b>  (m_out, B, select);<br>
 <br><b>endmodule</b> <br>
 <br>The 2 three-state buffers have the same output. In order to show that they have a com-<br>mon connection, it is necessary to declare  <i>m_out</i>  with the keyword  <b>tri.</b> <br>
 Keywords   <b>wire</b>  and  <b>tri</b>  are examples of a set of data types called  <i>nets</i> ,  which  represent <br>
connections between hardware elements. In simulation, their value is determined by a <br>continuous assignment statement or by the device whose output they represent. The word <br> <br><i>net</i>  is not a keyword, but represents a class of data types, such as  <b>wir</b> e <b>, wor, wand, tri, <br> supply1,  </b>and<b> supply0.</b>   The   <b>wire</b>  declaration is used most frequently. In fact, if an identifier <br>is used, but not declared, the language specifies that it will be interpreted (by default) as <br>a  <b>wire</b> .The net  <b>wor</b>  models the hardware implementation of the wired-OR configuration <br>(emitter-coupled logic). The  <b>wand</b>  models the wired-AND configuration (open-collector <br>technology;  see   Fig.    3.26   ).  The  nets   <b>supply1</b>  and  <b>supply0</b>  represent power supply and <br>ground, respectively. They are used to hardwire an input of a device to either 1 or 0. <br>
<i>A</i><br>
m_out<br>
<i>B</i><br>
select<br>
<b> <br>FIGURE 4.33 <br> <br>Two-to-one-line multiplexer with three-state buffers  </b><br>
<hr>
<A name=189></a><b>Section 4.12  HDL Models of Combinational Circuits    171</b><br>
<b> <br>Dataflow Modeling </b><br>
 <br>Dataflow modeling of combinational logic uses a number of operators that act on binary <br>operands to produce a binary result. Verilog HDL provides about 30 different operators. <br> <br>Table   4.10   lists some of these operators, their symbols, and the operation that they per-<br>form. (A complete list of operators supported by Verilog 2001, 2005 can be found in <br> <br>Table   8.1   in Section 8.2.) It is necessary to distinguish between arithmetic and logic <br>operations, so different symbols are used for each. The plus symbol   1+2     indicates  the <br>arithmetic operation of addition; the bitwise logic AND operation (conjunction) uses <br>the symbol &amp;. There are special symbols for bitwise logical OR (disjunction), NOT, and <br>XOR. The equality symbol uses two equals signs (without spaces between them) to <br>distinguish it from the equals sign used with the  <b>assign</b>  statement. The bitwise operators <br>operate bit by bit on a pair of vector operands to produce a vector result. The concat-<br>enation operator provides a mechanism for appending multiple operands. For example, <br>two operands with two bits each can be concatenated to form an operand with four bits. <br>The conditional operator acts like a multiplexer and is explained later, in conjunction <br>with HDL Example 4.6. <b> </b><br>
 <br>It should be noted that a bitwise operator (e.g., &amp;) and its corresponding logical <br>
operator (e.g., ! ) may produce different results, depending on their operand. If the <br>operands are scalar the results will be identical; if the operands are vectors the result <br>will not necessarily match. For example, &amp; (1010) is (0101), and !(1010) is 0. A binary <br>value is considered to be logically true if it is not 0. In general, use the bitwise opera-<br>tors to describe arithmetic operations and the logical operators to describe logical <br>operations. <br>
 <br>Dataflow modeling uses continuous assignments and the keyword <b>assign.</b> A continu-<br>
ous assignment is a statement that assigns a value to a net. The data type family  <i>net</i>   is <br>used in Verilog HDL to represent a physical connection between circuit elements. A net <br>
<b> <br>Table 4.10 <br><i> <br>Some Verilog HDL Operators </b></i><br>
<b> <br>Symbol  </b><br>
<b>Operation Symbol</b><br>
<b> </b><br>
<b>Operation </b><br>
   <br>
 binary  addition <br>
  <br>
   <br>
 binary  subtraction <br>
  <br>
 &amp; <br>
 bitwise  AND <br>
&amp;&amp;<br>
 logical  AND <br>
  <br>
 bitwise  OR <br>
||<br>
 logical  OR <br>
 <br>^ <br>
 bitwise  XOR <br>
  <br>
 <br> <br>
 bitwise  NOT <br>
!<br>
 logical  NOT <br>
     <br>
 equality <br>
  <br>
   <br>
 greater  than <br>
  <br>
   <br>
 less  than <br>
  <br>
 {} <br>
 concatenation <br>
  <br>
 ?: <br>
 conditional <br>
  <br>
<hr>
<A name=190></a><b>172    Chapter 4  Combinational Logic</b><br>
is declared explicitly by a net keyword (e.g.,  <b>wire</b> ) or by declaring an identifier to be an <br>input port. The logic value associated with a net is determined by what the net is con-<br>nected to. If the net is connected to an output of a gate, the net is said to be  <i>driven</i>   by <br>the gate, and the logic value of the net is determined by the logic values of the inputs to <br>the gate and the truth table of the gate. If the identifier of a net is the left-hand side of <br>a continuous assignment statement or a procedural assignment statement, the value <br>assigned to the net is specified by a Boolean expression that uses operands and opera-<br>tors. As an example, assuming that the variables were declared, a two-to-one-line mul-<br>tiplexer with scalar data inputs  <i>A</i>  and  <i>B</i> , select input  <i>S</i> , and output  <i>Y</i>  is described with <br>the continuous assignment <br>
 <br><b>assign</b> Y   (A &amp;&amp; S) || (B &amp;&amp; S) <br>
 <br>The relationship between  <i>Y</i> ,   <i>A</i> ,   <i>B</i> , and  <i>S</i>  is declared by the keyword  <b>assign ,</b> followed by <br>the target output  <i>Y</i>  and an equals sign. Following the equals sign is a Boolean expres-<br>sion. In hardware terms, this assignment would be equivalent to connecting the output <br>of the OR gate to wire  <i>Y</i> . <br>
 <br>The next two examples show the dataflow models of the two previous gate-level <br>
examples. The dataflow description of a two-to-four-line decoder with active-low output <br>enable and inverted output is shown in HDL Example 4.3. The circuit is defined with <br>four continuous assignment statements using Boolean expressions, one for each output. <br>The dataflow description of the four-bit adder is shown in HDL Example 4.4. The addi-<br>tion logic is described by a single statement using the operators of addition and concat-<br>enation. The plus symbol ( ) specifies the binary addition of the four bits of  <i>A</i>  with the <br>four bits of  <i>B</i>  and the one bit of  <i>C</i> _ <i>in</i> . The target output is the  <i>concatenation</i>  of the <br>output carry  <i>C</i> _ <i>out</i>  and the four bits of  <i>Sum</i> . Concatenation of operands is expressed <br>within braces and a comma separating the operands. Thus,  <i>{C_out, Sum}</i>  represents the <br>five-bit result of the addition operation.  <br>
<b> <br>HDL Example 4.3 (Dataflow: Two-to-Four Line Decoder) </b><br>
 <br>// Dataflow description of two-to-four-line decoder<br>
 <br>// See  Fig.   4.19  . Note: The figure uses symbol E, but the<br> <br>// Verilog model uses enable to clearly indicate functionality.<br>
 <br><b>module</b> decoder_2x4_df ( <br>
// Verilog 2001, 2005 syntax<br>
<b>   output</b> <br>
[0: 3] <br>
  D,<br>
   <b>input</b>  <br>
 <br>
  A, B,<br>
 <br> <br>
 <br>
  enable<br>
 <br>);<br>   <b>assign</b>  D[0] <br>
 !((!A) &amp;&amp; (!B) &amp;&amp; (!enable)), <br>
 <br>
 <br>D[1]   !(*!A) &amp;&amp; B &amp;&amp; (!enable)),  <br>
 <br>
 <br>D[2]   !(A &amp;&amp; B &amp;&amp; (!enable)  <br>
 <br>
 <br>D[3]   !(A &amp;&amp; B &amp;&amp; (!enable))  <br>
 <br><b>endmodule</b> <br>
<hr>
<A name=191></a><b>Section 4.12  HDL Models of Combinational Circuits    173</b><br>
<b> <br>HDL Example 4.4 (Dataflow: Four-Bit Adder) </b><br>
 <br>// Dataflow description of four-bit adder<br>
 <br>// Verilog 2001, 2005 module port syntax<br>
 <br><b>module</b>  binary_adder (<br>   <b>output</b>  [3: 0] <br>
Sum,<br>
   <b>output</b>  C_out,<br>   <b>input</b>  [3: 0] <br>
A, B,<br>
   <b>input</b>  C_in<br> <br>);<br>
   <b>assign</b>  {C_out, Sum}   A   B   C_in;<br> <br><b>endmodule</b> <br>
 <br>Dataflow HDL models describe combinational circuits by their  <i>function</i>  rather than <br>
by their gate structure. To show how dataflow descriptions facilitate digital design, con-<br>sider the 4-bit magnitude comparator described in HDL Example 4.5. The module <br>specifies two 4-bit inputs  <i>A</i>  and  <i>B</i>  and three outputs. One output ( <i>A_lt_B</i> ) is logic 1 if <br> <br><i>A</i>  is less than  <i>B</i> , a second output ( <i>A_gt_B</i> ) is logic 1 if  <i>A</i>  is greater than  <i>B</i> , and a third <br>output ( <i>A_eq_B</i> ) is logic 1 if  <i>A</i>  is equal to  <i>B</i> . Note that equality (identity) is symbolized <br>with two equals signs (   ) to distinguish the operation from that of the assignment <br>operator ( ). A Verilog HDL synthesis compiler can accept this module description as <br>input, execute synthesis algorithms, and provide an output netlist and a schematic of a <br>circuit equivalent to the one in  Fig.   4.17 , all without manual intervention! The designer <br>need not draw the schematic. <br>
<b> <br>HDL Example 4.5 (Dataflow: Four-Bit Comparator) </b><br>
 <br>// Dataflow description of a four-bit comparator //V2001, 2005 syntax<br>
 <br><b>module</b>  mag_compare<br> <br>(  <b>output</b> <br>
    A_lt_B, A_eq_B, A_gt_B,<br>
   <b>input</b>  [3: 0] <br>
    A, B<br>
 <br>);<br>   <b>assign</b>  A_lt_B   (A   B);<br>   <b>assign</b>  A_gt_B   (A   B);<br>   <b>assign</b>  A_eq_B   (A     B);<br> <br><b>endmodule</b> <br>
 <br>The next example uses the conditional operator ( ? : ). This operator takes three <br>
operands: <br>
 <br><i>condition ? true-expression : false-expression;</i> <br>
 <br>The condition is evaluated. If the result is logic 1, the true expression is evaluated and <br>used to assign a value to the left-hand side of an assignment statement. If the result is <br>
<hr>
<A name=192></a><b>174    Chapter 4  Combinational Logic</b><br>
logic 0, the false expression is evaluated. The two conditions together are equivalent to <br>an if�else condition. HDL Example 4.6 describes a two-to-one-line multiplexer using <br>the conditional operator. The continuous assignment <br>
 <br><b>assign</b> OUT   select ? A : B;  <br>
 <br>specifies the condition that   <i>OUT</i>   <i>A</i> if  <i>select</i>   1,     else     <i>OUT</i>   <i>B</i> if  <i>select</i>   0. <br>
<b> <br>HDL Example 4.6 (Dataflow: Two-to-One Multiplexer) </b><br>
 <br>// Dataflow description of two-to-one-line multiplexer<br>
 <br><b>module</b>  mux_2x1_df(m_out, A, B, select);<br><b>   output</b> m_out;<br>   <b>input</b>  A, <br>
B;<br>
   <b>input</b>  select;<br>
   <b>assign</b>  m_out   (select)? A : B;<br> <br><b>endmodule</b> <br>
<b> <br>Behavioral Modeling </b><br>
 <br>Behavioral modeling represents digital circuits at a functional and algorithmic level. It <br>is used mostly to describe sequential circuits, but can also be used to describe combina-<br>tional circuits. Here, we give two simple combinational circuit examples to introduce the <br>subject. Behavioral modeling is presented in more detail in Section 5.6, after the study <br>of sequential circuits. <br>
 <br>Behavioral descriptions use the keyword  <b>always </b>, followed by an optional event con-<br>
trol expression and a list of procedural assignment statements. The event control expres-<br>sion specifies when the statements will execute. The target output of a procedural <br>assignment statement must be of the  <b>reg</b>  data type. Contrary to the  <b>wire</b>  data type, <br>whereby the target output of an assignment may be continuously updated, a  <b>reg</b>   data <br>type retains its value until a new value is assigned. <br>
 <br>HDL Example 4.7 shows the behavioral description of a two-to-one-line multiplexer. <br>
(Compare it with HDL Example 4.6.) Since variable  <i>m_out</i>  is a target output, it must <br>be declared as  <b>reg</b>  data (in addition to the  <b>output</b>  declaration). The procedural assign-<br>ment statements inside the  <b>always</b>  block are executed every time there is a change in <br>any of the variables listed after the @ symbol. (Note that there is no semicolon (;) at the <br>end of the  <b>always</b>  statement.) In this case, these variables are the input variables  <i>A</i> ,   <i>B</i> , <br>and  <i>select.</i> The statements execute if  <i>A, B</i> , or  <i>select</i>  changes value. Note that the keyword <br> <br><b>or </b>, instead of the bitwise logical OR operator "|", is used between variables. The condi-<br>tional statement  <b>if�else</b>  provides a decision based upon the value of the  <i>select</i>   input.  The <br> <br><b>if</b>  statement can be written without the equality symbol: <br>
 <br><b>if</b> (select) OUT   A; <br>
 <br>The statement implies that  <i>select</i>  is checked for logic 1. <br>
<hr>
<A name=193></a><b>Section 4.12  HDL Models of Combinational Circuits    175</b><br>
<b> <br>HDL Example 4.7 (Behavioral: Two-to-One Line Multiplexer) </b><br>
 <br>// Behavioral description of two-to-one-line multiplexer<br>
 <br><b>module</b>  mux_2x1_beh (m_out, A, B, select);<br>   <b>output</b>  m_out;<br>   <b>input</b> <br>
A, B, select;<br>
   <b>reg</b>  m_out;<br>
   <b>always</b>   <br>
@(A <b>or</b> B <b>or</b> select)<br>
 <br>
 <br><b>if</b>  (select <br>
 1) m_out   A;<br>
 <br>
 <br><b>else</b>  m_out 5 B;<br>
 <br><b>endmodule</b> <br>
 <br>HDL Example 4.8 describes the function of a four-to-one-line multiplexer. The  <i>select</i> <br>
input is defined as a two-bit vector, and output  <i>y</i>  is declared to have type  <b>reg </b>. The  <b>always</b> <br>statement, in this example, has a sequential block enclosed between the keywords  <b>case</b> <br>and  <b>endcase </b>. The block is executed whenever any of the inputs listed after the  <b>@</b>   symbol <br>changes in value. The  <b>case</b>  statement is a multiway conditional branch construct. When-<br>ever  <i>in_0, in_1, in_2, in_3</i>  or  <i>select</i>  change, the case expression ( <i>select</i> ) is evaluated and <br>its value compared, from top to bottom, with the values in the list of statements that <br>follow, the so-called  <b>case</b>  items. The statement associated with the first  <b>case</b>  item that <br>matches the  <b>case</b>  expression is executed. In the absence of a match, no statement is <br>executed. Since  <i>select</i>  is a two-bit number, it can be equal to 00, 01, 10, or 11. The  <b>case</b> <br>items have an implied priority because the list is evaluated from top to bottom. <br>
 <br>The list is called a  <i>sensitivity list</i>  (Verilog 2001, 2005) and is equivalent to the  <i>event </i><br>
<i>control expression</i>  (Verilog 1995) formed by "ORing" the signals. Combinational logic <br>is reactive--when an input changes an output may change.  <br>
<b> <br>HDL Example 4.8 (Behavioral: Four-to-One Line Multiplexer) </b><br>
 <br>// Behavioral description of four-to-one line multiplexer<br>
 <br>// Verilog 2001, 2005 port syntax<br>
 <br><b>module</b>  mux_4x1_beh<br> <br>(  <b>output reg</b>  m_out,<br>   <b>input</b> <br>
in_0, in_1, in_2, in_3,<br>
   <b>input</b>  [1: 0] select<br> <br>);<br> <br><b>always</b>  @ (in_0, in_1, in_2, in_3, select) <br>
// Verilog 2001, 2005 syntax<br>
   <b>case</b>  (select)<br>   2'b00: m_out <br>
 in_0;<br>
   2'b01: m_out <br>
 in_1;<br>
   2'b10: m_out <br>
 in_2;<br>
   2'b11: m_out <br>
 in_3;<br>
   <b>endcase</b> <br> <br><b>endmodule</b> <br>
<hr>
<A name=194></a><b>176    Chapter 4  Combinational Logic</b><br>
 <br>Binary numbers in Verilog are specified and interpreted with the letter  <b>b</b>   preceded <br>
by a prime. The size of the number is written first and then its value. Thus,   2 <i>b</i>01     speci-<br>fies a two-bit binary number whose value is 01. Numbers are stored as a bit pattern in <br>memory, but they can be referenced in decimal, octal, or hexadecimal formats with the <br>letters     <b><i>d </b></i> <b><i>o</b>,</i>     and     <b><i>h</b>,</i>  respectively. For example, 4 HA   4 d10   4 b1010 and have the <br>same internal representation in a simulator. If the base of the number is not specified, <br>its interpretation defaults to decimal. If the size of the number is not specified, the <br>system assumes that the size of the number is at least 32 bits; if a host simulator has a <br>larger word length--say, 64 bits--the language will use that value to store unsized <br>numbers. The integer data type (keyword <b>integer</b>) is stored in a 32-bit representation. <br>The underscore (_) may be inserted in a number to improve readability of the code <br>(e.g.,     16 b0101_1110_0101_0011   ).  It  has no other effect. <br>
 The   <b>case</b>  construct has two important variations:  <b>casex</b>  and  <b>casez </b>. The first will treat <br>
as don't-cares any bits of the  <b>case</b>  expression or the  <b>case</b>  item that have logic value  <b>x</b>   or <br><b> z </b>.<b> </b>The  <b>casez</b>  construct treats as don't-cares only the logic value  <b>z </b>, for the purpose of <br>detecting a match between the  <b>case</b>  expression and a  <b>case</b>   item. <br>
 <br>The list of case items need not be complete. If the list of  <b>case</b>  items does not include <br>
all possible bit patterns of the  <b>case</b>  expression, no match can be detected. Unlisted  <b>case</b> <br>items, i.e., bit patterns that are not explicitly decoded can be treated by using the  <b>default</b> <br>keyword as the last item in the list of  <b>case</b>  items. The associated statement will execute <br>when no other match is found. This feature is useful, for example, when there are more <br>possible state codes in a sequential machine than are actually used. Having a  <b>default</b> <br>case item lets the designer map all of the unused states to a desired next state without <br>having to elaborate each individual state, rather than allowing the synthesis tool to <br>arbitrarily assign the next state. <br>
 <br>The examples of behavioral descriptions of combinational circuits shown here are <br>
simple ones. Behavioral modeling and procedural assignment statements require knowl-<br>edge of sequential circuits and are covered in more detail in Section 5.6. <br>
<b> <br>Writing a Simple Test Bench </b><br>
 <br>A test bench is an HDL program used for describing and applying a stimulus to an HDL <br>model of a circuit in order to test it and observe its response during simulation. Test <br>benches can be quite complex and lengthy and may take longer to develop than the <br>design that is tested. The results of a test are only as good as the test bench that is used <br>to test a circuit. Care must be taken to write stimuli that will test a circuit thoroughly, <br>exercising all of the operating features that are specified. However, the test benches <br>considered here are relatively simple, since the circuits we want to test implement only <br>combinational logic. The examples are presented to demonstrate some basic features of <br>HDL stimulus modules.  Chapter   8   considers test benches in greater depth. <br>
 <br>In addition to employing the  <b>always</b>  statement, test benches use the  <b>initial</b>   statement <br>
to provide a stimulus to the circuit being tested. We use the term " <b>always</b>   statement" <br>loosely. Actually,  <b>always</b>  is a Verilog language construct specifying  <i>how</i>  the associated <br>statement is to execute (subject to the event control expression). The  <b>always</b>   statement <br>
<hr>
<A name=195></a><b>Section 4.12  HDL Models of Combinational Circuits    177</b><br>
executes repeatedly in a loop. The  <b>initial</b>  statement executes only once, starting from <br>simulation time 0, and may continue with any operations that are delayed by a given <br>number of time units, as specified by the symbol #. For example, consider the  <b>initial</b> <br>block <br>
 <br><b>initial</b> <br>
 <br><b>begin</b> <br>
 <br> A <br>
 0; B   0;<br>
   #10 A   1;<br>   #20 A   0; B   1;<br> <br><b>end</b> <br>
 <br>The block is enclosed between the keywords  <b>begin</b>  and  <b>end .  </b>At time 0,  <i>A</i>  and  <i>B</i>  are set <br>to 0. Ten time units later,  <i>A</i>  is changed to 1. Twenty time units after that (at   <i>t</i>   30 ),  <i>A</i>  is <br>changed to 0 and  <i>B</i>  to 1. Inputs specified by a three-bit truth table can be generated with <br>the  <b>initial</b>   block:  <br>
 <br><b>initial</b> <br>
 <br><b>begin</b> <br> <br> D   3'b000;<br>   <b>repeat</b>  (7)<br> <br> #10 <br>
D   D   3'b001;<br>
 <br><b>end</b> <br>
 <br>When the simulator runs, the three-bit vector  <i>D</i>  is initialized to 000 at   time   0. The <br>keyword  <b>repeat</b>  specifies a looping statement:  <i>D</i>  is incremented by 1 seven times, once <br>every 10 time units. The result is a sequence of binary numbers from 000 to 111. <br>
 <br>A stimulus module has the following form: <br>
 <br><b>module</b>  test_module_name;<br>   // Declare local  <b>reg</b>  and  <b>wire</b>  identifiers.<br>   // Instantiate the design module under test.<br>   // Specify a stopwatch, using $finish to terminate the simulation.<br>   // Generate stimulus, using <b>initial</b> and <b>always</b> statements.<br>   // Display the output response (text or graphics (or both)).<br> <br><b>endmodule</b> <br>
 <br>A test module is written like any other module, but it typically has no inputs or outputs. <br>The signals that are applied as inputs to the design module for simulation are declared <br>in the stimulus module as local  <b>reg</b>  data type. The outputs of the design module that are <br>displayed for testing are declared in the stimulus module as local  <b>wire</b>  data type. The <br>module under test is then instantiated, using the local identifiers in its port list. <br> <br>Figure  4.34   clarifies this relationship. The stimulus module generates inputs for the <br>design module by declaring local identifiers  <i>t_A</i>  and  <i>t_B</i>  as  <b>reg</b>  type and checks the <br>output of the design unit with the  <b>wire</b>  identifier  <i>t_C</i> . The local identifiers are then used <br>to instantiate the design module being tested. The simulator associates the (actual) local <br>identifiers within the test bench,  <i>t_A, t_B</i> , and  <i>t_C,</i>  with the formal identifiers of the <br>
<hr>
<A name=196></a><b>178    Chapter 4  Combinational Logic</b><br>
<b>module </b>t_circuit;<br>
<b>reg </b>t_A, t_B;<br>
<b>module </b>circuit ( C , A, B )<br>
<b>wire </b>t_C;<br>
<b>parameter </b>stop_time<br>
 1000 ;<br>
<b>input</b><br>
A, B;<br>
  circuit M ( t_C,  t_A, t_B );<br>
<b>output</b><br>
C;<br>
// Stimulus generators for<br>
// Description goes here<br>
// t_A and t_B go here<br>
<b>endmodule</b><br>
<b>initial </b># stop_time <b>$finish</b>;<br>
<b>endmodule</b><br>
<b> <br>FIGURE 4.34 <br> <br>Interaction between stimulus and design modules  </b><br>
module ( <i>A, B, C</i> ). The association shown here is based on  <i>position</i>  in the port list, which <br>is adequate for the examples that we will consider. The reader should note, however, <br>that Verilog  provides a more flexible  <i>name association</i>  mechanism for connecting ports <br>in larger circuits. <br>
 <br>The response to the stimulus generated by the  <b>initial</b>  and  <b>al</b> <b>ways</b> blocks will <br>
appear in text format as standard output and as waveforms (timing diagrams) in <br>simulators having graphical output capability. Numerical outputs are displayed by <br>using Verilog  <i>system tasks</i> . These are built-in system functions that are recognized <br>by keywords that begin with the symbol  <b>$ .  </b>Some of the system tasks that are useful <br>for display are <br>
 <br>
 <br><b>$display</b> --display a one-time value of variables or strings with an end-of-line return, <br>
 <br>
 <br><b>$write</b> --same as  <b>$display ,</b> but without going to next line, <br>
 <br>
 <br><b>$monitor</b> --display variables whenever a value changes during a simulation run, <br>
 <br>
 <br><b>$time</b> --display the simulation time, <br>
 <br>
 <br><b>$finish</b> --terminate  the  simulation.   <br>
 <br>The syntax for  <b>$display, $write, </b>and<b> $monitor</b>  is of the form <br>
 <br><i>Task-name </i>( <i>format specification, argumentlist</i>);   <br>
 <br>The format specification uses the symbol % to specify the radix of the numbers that are <br>displayed and may have a string enclosed in quotes ( ). The base may be binary, decimal, <br>hexadecimal, or octal, identified with the symbols %b, %d, %h, and %o, respectively <br>(%B, %D, %H, and %O are valid too). For example, the statement <br>
 <br><b>$display</b> (&quot;%d %b %b&quot;, C, A, B);  <br>
 <br>specifies the display of  <i>C</i>  in decimal and of  <i>A</i>  and  <i>B</i>  in binary. Note that there are no <br>commas in the format specification, that the format specification and argument list <br>
<hr>
<A name=197></a><b>Section 4.12  HDL Models of Combinational Circuits    179</b><br>
are separated by a comma, and that the argument list has commas between the <br> <br>variables. An example that specifies a string enclosed in quotes may look like the <br>statement <br>
 <br><b>$display</b> (&quot;time   %0d A   %b&quot;, <b>$time,</b> A, B);  <br>
 <br>and will produce the display <br>
 <br>time   3 A   10 B   1  <br>
 where  (<i>time</i>   ), (<i>A</i>   ), and (<i>B</i>   ) are part of the string to be displayed. The format <br>specifiers %0d, %b, and %b specify the base for  <b>$time ,</b>  <i>A</i> , and  <i>B</i> , respectively. In display-<br>ing time values, it is better to use the format %0d instead of %d. This provides a display <br>of the significant digits without the leading spaces that %d will include. (%d will display <br>about 10 leading spaces because time is calculated as a 32-bit number.) <br>
 <br>An example of a stimulus module is shown in HDL Example 4.9. The circuit to be <br>
tested is the two-to-one-line multiplexer described in Example 4.6. The module <br> <br><i>t_mux_2x1_df</i>  has no ports. The inputs for the mux are declared with a  <b>reg</b>  keyword and <br>the outputs with a  <b>wire</b>  keyword. The mux is instantiated with the local variables. The <br> <br><b>initial</b>  block specifies a sequence of binary values to be applied during the simulation. <br>The output response is checked with the  <b>$monitor</b>  system task. Every time a variable in <br>its argument changes value, the simulator displays the inputs, output, and time. The result <br>of the simulation is listed under the simulation log in the example. It shows that <br> <br><i>m</i>_<i>out</i>   <i>A</i>     when     <i>select</i>   1     and     <i>m</i>_<i>out</i>   <i>B</i>     when     <i>select</i>   0  verifying the operation of <br>the multiplexer.  <br>
<b> <br>HDL Example 4.9 (Test Bench) </b><br>
 <br>// Test bench with stimulus for mux_2x1_df<br>
 <br><b>module</b>  t_mux_2x1_df;<br>   <b>wire</b>  t_mux_out;<br>   <b>reg</b>  t_A, <br>
t_B;<br>
   <b>reg</b>  t_select;<br>   <b>parameter</b>  stop_time   50;<br>
 <br>mux_2x1_df M1 (t_mux_out, t_A, t_B, t_select); <br>
// Instantiation of circuit to be tested<br>
 <br><b>initial</b>  # stop_time <b>$finish;</b><br>
   <b>initial</b>   <b>begin</b> <br>
// Stimulus generator<br>
 <br>
 <br>t_select   1; t_A   0; t_B   1;<br>
     #10 t_A   1; t_B   0;<br>    #10 t_select   0;<br>    #10 t_A   0; t_B   1;<br>  <b>end</b> <br>
  <b>initial begin</b> <br>
// Response monitor<br>
    //  <br>
<b>$display</b>  (   time Select A B m_out );<br>
    //  <br>
<b>$monitor</b>  ( <b>$time</b> ,,   <br>
%b %b %b %b ,  t_select, t_A, t_B, t_m_out);<br>
<hr>
<A name=198></a><b>180    Chapter 4  Combinational Logic</b><br>
    <b>$monitor</b>  (  time    ,  <b>$time</b> ,,   select   %b A   %b B   %b OUT   %b  ,<br>     t_select, t_A, t_B, t_mux_out);<br>  <b>end</b> <br> <br><b>endmodule</b> <br>
 <br>// Dataflow description of two-to-one-line multiplexer<br>
 <br>// from Example 4.6<br> <br><b>module</b>  mux_2x1_df (m_out, A, B, select);<br>   <b>output</b>  m_out;<br>   <b>input</b>  A, <br>
B;<br>
   <b>input</b>  select;<br>
  <b>assign</b>  m_out   (select)? A : B;<br> <br><b>endmodule</b> <br>
 <br>Simulation log:<br> <br>select   1 A   0 B   1 OUT   0 time   0<br> <br>select   1 A   1 B   0 OUT   1 time   10<br> <br>select   0 A   1 B   0 OUT   0 time   20<br> <br>select   0 A   0 B   1 OUT   1 time   30  <br>
 <br>Logic simulation is a fast and accurate method of verifying that a model of a <br>
combinational circuit is correct. There are two types of verification: functional and <br>timing. In  <i>functional</i>  verification, we study the circuit logical operation indepen-<br>dently of timing considerations. This can be done by deriving the truth table of the <br>combinational circuit. In  <i>timing</i>  verification, we study the circuit's operation by <br>including the effect of delays through the gates. This can be done by observing the <br>waveforms at the outputs of the gates when they respond to a given input. An exam-<br>ple of a circuit with gate delays was presented in Section 3.10 in HDL  Example   3.3  . <br>We next show an HDL example that produces the truth table of a combinational <br>circuit. A  <b>$monitor</b>  system task displays the output caused by the given stimulus. <br>A commented alternative statement having a  <b>$displ ay</b> task would create a header <br>that could be used with a  <b>$monitor</b>  statement to eliminate the repetition of names <br>on each line of output. <br>
 <br>The analysis of combinational circuits was covered in Section 4.3. A multilevel <br>
circuit of a full adder was analyzed, and its truth table was derived by inspection. The <br>gate-level description of this circuit is shown in HDL Example 4.10. The circuit has <br>three inputs, two outputs, and nine gates. The description of the circuit follows the <br>interconnections between the gates according to the schematic diagram of  Fig.   4.2  . <br>The stimulus for the circuit is listed in the second module. The inputs for simulating <br>the circuit are specified with a three-bit  <b>reg</b>  vector  <i>D</i> .   <i>D[2]</i>  is equivalent to input  <i>A</i> , <br> <br><i>D[1]</i>  to input  <i>B</i> , and  <i>D[0]</i>  to input  <i>C</i> . The outputs of the circuit   <i>F</i>1     and     <i>F</i>2     are  declared <br>as <b>wire.</b> The complement of  <i>F2</i>  is named  <i>F2_b</i>  to illustrate a common industry practice <br>for designating the complement of a signal (instead of appending  <i>_not</i> ).  This   procedure <br>
<hr>
<A name=199></a><b>Section 4.12  HDL Models of Combinational Circuits    181</b><br>
follows the steps outlined in  Fig.   4.34  . The  <b>repeat</b>  loop provides the seven binary num-<br>bers after 000 for the truth table. The result of the simulation generates the output <br>truth table displayed with the example. The truth table listed shows that the circuit is <br>a full adder. <br>
<b> <br>HDL Example 4.10 (Gate-Level Circuit) </b><br>
 <br>// Gate-level description of circuit of  Fig.   4.2  <br>
 <br><b>module</b>  Circuit_of_Fig_4_2 (A, B, C, F1, F2);<br>   <b>input</b>  A, B, C;<br>   <b>output</b>   F1, F2;<br>   <b>wire</b>  T1, T2, T3, F2_b, E1, E2, E3;<br>   <b>or</b>  g1 (T1, A, B, C);<br>   <b>and</b>  g2 (T2, A, B, C);<br>   <b>and</b>  g3 (E1, A, B);<br>   <b>and</b>  g4 (E2, A, C);<br>   <b>and</b>  g5 (E3, B, C);<br>   <b>or</b>  g6 (F2, E1, E2, E3);<br>   <b>not</b>   g7 (F2_b, F2);<br>   <b>and</b>  g8 (T3, T1, F2_b);<br>   <b>or</b>  g9 (F1, T2, T3);<br> <br><b>endmodule</b> <br>
 <br>// Stimulus to analyze the circuit<br>
 <br><b>module</b>  test_circuit;<br>   <b>reg</b>  [2: 0] D;<br>   <b>wire</b>  F1, F2;<br>   Circuit_of_Fig_4_2 (D[2], D[1], D[0], F1, F2);<br>   <b>initial</b> <br>    <b>begin</b> <br>     D   3'b000;<br>     <b>repeat</b>  (7) #10 D   D 1 1'b1;<br>    <b>end</b> <br>   <b>initial</b> <br>   <b>$monitor</b>  (  ABC   %b F1   %b F2  %b  , D, F1, F2);<br>
 <br><b>endmodule</b> <br>
 <br>Simulation log:  ABC   000 F1   0 F2  0<br> <br>ABC   001 F1   1 F2  0 ABC   010 F1   1 F2  0<br> <br>ABC   011 F1   0 F2  1 ABC   100 F1   1 F2  0<br> <br>ABC   101 F1   0 F2  1 ABC   110 F1   0 F2  1<br> <br>ABC   111 F1   1 F2  1  <br>
<hr>
<A name=200></a><b>182    Chapter 4  Combinational Logic</b><br>
<b> <br>P R O B L E M S </b><br>
 <br>(Answers to problems marked with <b>*</b> appear at the end of the text. Where appropriate, a logic <br>design and its related HDL modeling problem are cross-referenced.) <br>
 <br><b> 4.1 </b><br>
 <br>Consider the combinational circuit shown in  Fig.   P4.1 . (HDL--see Problem 4.49.) <br>
<i>A</i><br>
<i>T</i>3<br>
<i>B</i><br>
<i>T</i><br>
<i>C</i><br>
1<br>
<i>F</i>1<br>
<i>T</i>2<br>
<i>T</i><br>
<i>D</i><br>
4<br>
<i>F</i>2<br>
<b> <br>FIGURE P4.1  </b><br>
 <br>
(a)<b>*</b>   Derive the Boolean expressions for   <i>T</i>1     through     <i>T</i>4.     Evaluate  the  outputs     <i>F</i>1     and     <i>F</i>2 <br>
as a function of the four inputs. <br>
 <br>
(b)   List the truth table with 16 binary combinations of the four input variables. Then list <br>
the binary values for   <i>T</i>1     through     <i>T</i>4     and  outputs     <i>F</i>1     and     <i>F</i>2     in  the  table.  <br>
 <br>
(c)   Plot the output Boolean functions obtained in part (b) on maps and show that the <br>
simplified Boolean expressions are equivalent to the ones obtained in part (a). <br>
 <br><b> 4.2*  </b> Obtain the simplified Boolean expressions for output  <i>F</i>  and  <i>G</i>  in terms of the input <br>
 variables  in  the  circuit  of   Fig.    P4.2   . <br>
<i>A</i><br>
<i>F</i><br>
<i>B</i><br>
<i>C</i><br>
<i>G</i><br>
<i>D</i><br>
<b> <br>FIGURE P4.2  </b><br>
 <br><b> 4.3 </b><br>
  For  the  circuit  shown  in   Fig.    4.26     (Section  4.11), <br>
 <br>
(a)   Write the Boolean functions for the four outputs in terms of the input variables. <br>
   <br>
(b)<b>*</b>   If the circuit is described in a truth table, how many rows and columns would there <br>
be  in  the  table?     <br>
 <br><b> 4.4 </b><br>
 <br>Design a combinational circuit with three inputs and one output. <br>
 <br>
(a)<b>*</b>   The output is 1 when the binary value of the inputs is less than 3. The output is 0 otherwise. <br>
 <br>
(b)   The output is 1 when the binary value of the inputs is an even number. <br>
<hr>
<A name=201></a><b>Problems    183</b><br>
 <br><b> 4.5 </b><br>
 <br>Design a combinational circuit with three inputs,  <i>x</i> ,   <i>y</i> , and  <i>z</i> , and three outputs,  <i>A, B</i> ,  and  <i>C</i> . <br>When the binary input is 0, 1, 2, or 3, the binary output is one greater than the input. When <br>the binary input is 4, 5, 6, or 7, the binary output is two less than the input. <br>
 <br><b> 4.6 </b><br>
 <br>A majority circuit is a combinational circuit whose output is equal to 1 if the input variables <br>have more 1's than 0's. The output is 0 otherwise. <br>
 <br>
(a)<b>*</b>   Design a 3-input majority circuit by finding the circuit's truth table, Boolean equation, <br>
and a logic diagram. <br>
 <br>
(b)   Write and verify a Verilog gate-level model of the circuit. <br>
 <br><b> 4.7 </b><br>
 <br>Design a combinational circuit that converts a four-bit Gray code (Table 1.6) to a bit four-<br>binary number. <br>
 <br>
(a)<b>*</b>   Implement the circuit with exclusive-OR gates. <br>
 <br>
(b)   Using a case statement, write and verify a Verilog model of the circuit. <br>
 <br><b> 4.8 </b><br>
 <br>Design a code converter that converts a decimal digit from <br>
 <br>
(a)<b>*</b>   The 8, 4, �2, �1 code to BCD (see Table 1.5). (HDL--see Problem 4.50.)  <br>
 <br>
(b)   The 8, 4, �2, �1 code to Gray code. <br>
 <br><b> 4.9 </b><br>
 <br>An ABCD-to-seven-segment decoder is a combinational circuit that converts a decimal digit <br>in BCD to an appropriate code for the selection of segments in an indicator used to display <br>the decimal digit in a familiar form. The seven outputs of the decoder  <i>(a, b, c, d, e, f, g)</i>   select <br>the corresponding segments in the display, as shown in  Fig.   P4.9(a)  . The numeric display <br>chosen to represent the decimal digit is shown in  Fig.   P4.9(b)  . Using a truth table and <br> <br>Karnaugh maps, design the BCD-to-seven-segment decoder using a minimum number of <br>gates. The six invalid combinations should result in a blank display. (HDL--see Problem 4.51.) <br>
<i>a</i><br>
<i>f</i><br>
<i>b</i><br>
<i>g</i><br>
<i>b</i><br>
<i>e</i><br>
<i>c</i><br>
<i>c</i><br>
<i>d</i><br>
(a) Segment designation<br>
(b) Numerical designation for display<br>
<b> <br>FIGURE P4.9  </b><br>
 <br><b> 4.10* </b> Design a four-bit combinational circuit 2's complementer. (The output generates the 2's <br>
complement of the input binary number.) Show that the circuit can be constructed with <br>exclusive-OR gates. Can you predict what the output functions are for a five-bit 2's com-<br>plementer?   <br>
 <br><b> 4.11 </b><br>
 <br>Using four half-adders (HDL--see Problem 4.52), <br>
 <br>
(a)   Design a full-subtractor circuit incrementer. (A circuit that adds one to a four-bit <br>
binary number.)  <br>
   <br>
(b)<b>*</b>   Design a four-bit combinational decrementer (a circuit that subtracts 1 from a four-<br>
bit  binary  number).     <br>
 <br><b> 4.12 </b><br>
 <br>Design a half-subtractor circuit with inputs  <i>x</i>  and  <i>y</i>  and outputs  <i>Diff</i>  and B <i>out</i> .  The  circuit <br>subtracts the bits  <i>x � y</i>  and places the difference in  <i>D</i>  and the borrow in  <i>B out </i> . <br>
    <br>
(a) <br>
  Design  a  full-subtractor  circuit  with  three  inputs   <i>x</i> ,   <i>y</i> ,   <i>B in </i> and two outputs  <i>Diff</i>   and <br> <br><i>B out </i>. The circuit subtracts  <i>x</i>   �   <i>y</i>  �  <i>B in </i>, where  <i>B in </i> is the input borrow,  <i>B out </i> is the output <br>borrow, and  <i>Diff</i>   is  the  difference.     <br>
<hr>
<A name=202></a><b>184    Chapter 4  Combinational Logic</b><br>
 <br><b> 4.13* </b> The adder�subtractor circuit of  Fig.   4.13   has the following values for mode input  <i>M</i>   and <br>
data inputs  <i>A</i>  and  <i>B</i> .   <br>
<i> </i><br>
<i>  M  </i><br>
<i>  A  </i><br>
<i>  B  </i><br>
 (a) <br>
 0 <br>
 0111 <br>
 0110 <br>
 (b) <br>
 0 <br>
 1000 <br>
 1001 <br>
 (c) <br>
 1 <br>
 1100 <br>
 1000 <br>
 (d) <br>
 1 <br>
 0101 <br>
 1010 <br>
 (e) <br>
 1 <br>
 <br>0000  <br>
0001 <br>
 <br>
 <br>
 <br>In each case, determine the values of the four  <i>SUM</i>  outputs, the carry  <i>C</i> , and overflow  <i>V</i> . <br>(HDL--see Problems 4.37 and 4.40.)  <br>
 <br><b> 4.14* </b> Assume that the exclusive-OR gate has a propagation delay of 10 ns and that the AND or <br>
OR gates have a propagation delay of 5 ns. What is the total propagation delay time in the <br>four-bit  adder  of   Fig.    4.12   ?   <br>
 <br><b> 4.15 </b><br>
 <br>Derive the two-level Boolean expression for the output carry  <i>C</i> 4  shown in the lookahead <br>carry  generator  of   Fig.    4.12   .   <br>
 <br><b> 4.16 </b><br>
 <br>Define the carry propagate and carry generate as <br>
 <br>
 <br>
 <br><i>Pi</i>   <i>Ai</i>   <i>Bi</i> <br>
 <br>
 <br>
 <br><i>Gi</i>   <i>AiBi</i> <br>
 <br>
 <br>
 <br>respectively. Show that the output carry and output sum of a full adder becomes <br>
 <br>
 <br><i>Ci</i>+1 = (<i>Ci Gi</i>  + <i>Pi</i>)<br>
 <br>
<i>Si </i>= (<i>PiG i</i>) { <i>Ci</i> <br>
 <br>
 <br>
 <br>The logic diagram of the first stage of a four-bit parallel adder as implemented in IC type <br>74283  is  shown  in   Fig.   P4.16   .  Identify  the     <i>Pi </i>     and     <i>Gi </i>  terminals and show that the circuit <br>implements a full-adder circuit. <br>
<i>C</i>1<br>
<i>B</i>0<br>
<i>S</i>0<br>
<i>A</i>0<br>
<i>C</i>0<br>
<b> <br>FIGURE P4.16 <br> <br>First stage of a parallel adder  </b><br>
<hr>
<A name=203></a><b>Problems    185</b><br>
 <br><b> 4.17 </b><br>
 <br>Show that the output carry in a full adder circuit can be expressed in the AND-OR- <br>INVERT form <br>
 <br><i>Ci</i>+1 = <i>Gi </i>+ <i>PiCi </i>= (<i>GiPi </i>+ <i>GiCi</i>)  <br>
 <br>
 <br>
 <br>IC type 74182 is a lookahead carry generator circuit that generates the carries with AND-<br>OR-INVERT gates (see Section 3.8). The circuit assumes that the input terminals have <br>the complements of the  <i>G</i> 's, the  <i>P</i> 's, and of  <i>C</i> 1 . Derive the Boolean functions for the <br>lookahead carries  <i>C</i> 2 ,   <i>C</i> 3 , and  <i>C</i> 4  in this IC. ( <i>Hint:</i>  Use the equation-substitution method <br>to derive the carries in terms of C <i>i</i>  )   <br>
 <br><b> 4.18 </b><br>
 <br>Design a combinational circuit that generates the 9's complement of a <br>
 <br>
(a)<b>*</b>   BCD digit. (HDL--see Problem 4.54(a).)  <br>
   <br>
(b)    Gray-code  digit.  (HDL--see  Problem  4.54(b).)     <br>
 <br><b> 4.19 </b><br>
 <br>Construct a BCD adder�subtractor circuit. Use the BCD adder of  Fig.   4.14   and the 9's <br>complementer of problem 4.18. Use block diagrams for the components. (HDL--see Prob-<br>lem  4.55.)   <br>
 <br><b> 4.20 </b><br>
 <br>For a binary multiplier that multiplies two unsigned four-bit numbers, <br>
    <br>
(a) <br>
  Using  AND  gates  and  binary  adders  (see   Fig.    4.16   ),  design  the  circuit.  <br>
 <br>
(b)   Write and verify a Verilog dataflow model of the circuit. <br>
 <br><b> 4.21 </b><br>
 <br>Design a combinational circuit that compares two 4-bit numbers to check if they are equal. <br>The circuit output is equal to 1 if the two numbers are equal and 0 otherwise. <br>
 <br><b> 4.22* </b> Design an excess-3-to-binary decoder using the unused combinations of the code as <br>
 <br>don't-care conditions. (HDL--see Problem 4.42.)  <br>
 <br><b> 4.23 </b><br>
 <br>Draw the logic diagram of a 2-to-4-line decoder using (a) NOR gates only and (b) NAND <br>gates only. Include an enable input. (HDL--see Problems 4.36, 4.45.)  <br>
 <br><b> 4.24 </b><br>
 <br>Design a BCD-to-decimal decoder using the unused combinations of the BCD code as <br>don't-care  conditions.   <br>
 <br><b> 4.25 </b><br>
 <br>Construct a 5-to-32-line decoder with four 3-to-8-line decoders with enable and a 2-to-<br>4-line decoder. Use block diagrams for the components. (HDL--see Problem 4.63.)  <br>
 <br><b> 4.26 </b><br>
 <br>Construct a 4-to-16-line decoder with five 2-to-4-line decoders with enable. (HDL--see <br>Problem  4.64.)   <br>
 <br><b> 4.27 </b><br>
 <br>A combinational circuit is specified by the following three Boolean functions: <br>
 <br><i>F</i>11<i>A</i>, <i>B</i>, <i>C</i>2 =<br>
11, 4, 62<br>
 <br><i>F</i>21<i>A</i>, <i>B</i>, <i>C</i>2 =<br>
13, 52<br>
 <br><i>F</i>31<i>A</i>, <i>B</i>, <i>C</i>2 =<br>
12, 4, 6, 72 <br>
 <br>
 <br>
 <br>Implement the circuit with a decoder constructed with NAND gates (similar to  Fig.   4.19  ) <br>and NAND or AND gates connected to the decoder outputs. Use a block diagram for the <br>decoder. Minimize the number of inputs in the external gates. <br>
 <br><b> 4.28 </b><br>
 <br>Using a decoder and external gates, design the combinational circui defined by the <br>following  three Boolean functions: <br>
    <br>
(a)      <i>F</i>1 = <i>x yz </i>+ <i>xz</i>  <br>
(b) <br>
 <br>
<i>F</i>1 = 1<i>y </i>+ <i>x</i>2<i>z</i><br>
 <br>
 <br>
<i>F</i>2 = <i>xy z </i>+ <i>x y</i> <br>
 <br>
<i>F</i>2 = <i>y z </i>+ <i>x y </i>+ <i>yz</i><br>
 <br>
 <br>
<i>F</i>3 = <i>x y z </i>+ <i>xy</i> <br>
 <br>
<i>F</i>3 = 1<i>x </i>+ <i>y</i>2<i>z</i> <br>
<hr>
<A name=204></a><b>186    Chapter 4  Combinational Logic</b><br>
 <br><b> 4.29* </b> Design a four-input priority encoder with inputs as in  Table   4.8  , but with input  <i>D</i> 0   having <br>
the highest priority and input  <i>D</i> 3  the lowest priority. <br>
 <br><b> 4.30 </b><br>
 <br>Specify the truth table of an octal-to-binary priority encoder. Provide an output  <i>V</i>  to in-<br>dicate that at least one of the inputs is present. The input with the highest subscript num-<br>ber has the highest priority. What will be the value of the four outputs if inputs  <i>D</i> 2  and  <i>D</i> 6 <br>are 1 at the same time? (HDL--see Problem 4.65.)  <br>
 <br><b> 4.31 </b><br>
  Construct  a  16 <br>
 1 multiplexer with two 8   1 and one 2   1 multiplexers. Use block dia-<br>
grams. (HDL--see Problem 4.67.)  <br>
 <br><b> 4.32 </b><br>
 <br>Implement the following Boolean function with a multiplexer (HDL--see Problem 4.46): <br>
    <br>
(a) <br>
    <br><i>F </i>1<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>2 =<br>
10, 2, 5, 8, 10, 142 <br>
   <br>
(b)      <i>F </i>1<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>2 =<br>
12, 6, 112 <br>
 <br><b> 4.33 </b><br>
 <br>Implement a full adder with two 4   1 multiplexers. <br>
 <br><b> 4.34 </b><br>
  An  8 <br>
 1 multiplexer has inputs  <i>A</i> ,   <i>B</i> , and  <i>C</i>  connected to the selection inputs  <i>S</i> 2 ,   <i>S</i> 1 ,  and <br>
 <br><i>S</i> 0 , respectively. The data inputs  <i>I</i> 0  through  <i>I</i>7     are  as  follows: <br>
 <br>
(a)<b>*</b>   <i>I</i> 1    <i>I</i> 2    <i>I</i> 7   0;  <i>I</i> 3    <i>I</i> 5   1;  <i>I</i> 0    <i>I</i> 4    <i>D</i> ; and  <i>I</i> 6    <i>D</i> '. <br>
   <br>
(b)     <i>I</i> 1    <i>I</i> 2   0;  <i>I</i> 3    <i>I</i> 7   1;  <i>I</i> 4    <i>I</i> 5    <i>D</i> ; and  <i>I</i> 0    <i>I</i> 6    <i>D</i> '. <br>
 <br>
 <br>Determine the Boolean function that the multiplexer implements. <br>
 <br><b> 4.35 </b><br>
 <br>Implement the following Boolean function with a 4   1 multiplexer and external gates. <br>
 <br>
(a)<b>*</b>   <i>F</i>11<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>2 =<br>
11, 3, 4, 11, 12, 13, 14, 152 <br>
   <br>
(b)      <i>F</i>21<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>2 =<br>
11, 2, 5, 7, 8, 10, 11, 13, 152 <br>
 <br>
 <br>
 <br>Connect inputs  <i>A</i>  and  <i>B</i>  to the selection lines. The input requirements for the four data <br>lines will be a function of variables  <i>C</i>  and  <i>D</i> . These values are obtained by expressing  <i>F</i>   as <br>a function of  <i>C</i>  and  <i>D</i>  for each of the four cases when  <i>AB</i>   00, 01, 10, and 11. These func-<br>tions may have to be implemented with external gates. (HDL--see Problem 4.47.)  <br>
 <br><b> 4.36 </b><br>
 <br>Write the HDL gate-level description of the priority encoder circuit shown in  Fig.   4.23  . <br>(HDL--see Problem 4.45.)  <br>
 <br><b> 4.37 </b><br>
 <br>Write the HDL gate-level hierarchical description of a four-bit adder�subtractor for un-<br>signed binary numbers. The circuit is similar to  Fig.   4.13   but without output  <i>V</i> .  You  can <br>instantiate the four-bit full adder described in HDL Example 4.2. (HDL--see Problems <br>4.13 and 4.40.)  <br>
 <br><b> 4.38 </b><br>
 <br>Write the HDL dataflow description of a quadruple 2-to-1-line multiplexer with enable <br>(see   Fig.    4.26   ).   <br>
 <br><b> 4.39* </b> Write an HDL behavioral description of a four-bit comparator with a six-bit output   <i>Y </i>35:04 . <br>
Bit 5 of  <i>Y</i>  is for "equals," bit 4 for "not equal to," bit 3 for "greater than," bit 2 for "less <br>than," bit 1 for "greater than or equal," and bit 0 for "less than or equal to." <br>
 <br><b> 4.40 </b><br>
 <br>Using the conditional operator (?:), write an HDL dataflow description of a four-bit adder�<br>subtractor of unsigned numbers. (See Problems 4.13 and 4.37.)  <br>
 <br><b> 4.41 </b><br>
 <br>Repeat problem 4.40 using an always statement. <br>
<hr>
<A name=205></a><b>Problems    187</b><br>
 <br><b> 4.42 </b><br>
 <br>(a)   Write an HDL gate-level description of the BCD-to-excess-3 converter circuit shown <br>
in   Fig.    4.4     (see  Problem  4.22).  <br>
 <br>
(b)   Write a dataflow description of the BCD-to-excess-3 converter using the Boolean <br>
expressions  listed  in   Fig.    4.3   .  <br>
   <br>
(c)<b>*</b>   Write an HDL behavioral description of a BCD-to-excess-3 converter. <br>
 <br>
(d)   Write a test bench to simulate and test the BCD-to-excess-3 converter circuit in order <br>
to verify the truth table. Check all three circuits. <br>
 <br><b> 4.43 </b><br>
 <br>Explain the function of the circuit specified by the following HDL description: <br>
 <br><b>module</b>  Prob4_43 (A, B, S, E, Q);<br>   <b>input</b>  [1:0] A, B;<br>   <b>input</b>    <br>
S, <br>
E;<br>
   <b>output</b>  [1:0] Q;<br>   <b>assign</b>  Q   E ? (S ? A : B) : 'bz;<br> <br><b>endmodule</b> <br>
 <br><b> 4.44 </b><br>
 <br>Using a case statement, write an HDL behavioral description of a eight-bit arithmetic-<br>logic unit (ALU). The circuit has a three-bit select bus (Sel), sixteen-bit input datapaths <br>(A[15:0] and B[15:0]), an eight-bit output datapath (y[15:0]), and performs the arithmetic <br>and logic operations listed below. <br>
<b> </b><br>
<b> </b><br>
<b> <br>Sel Operation Description</b><br>
 <br>
 <br>
 <br>000 y <br>
 8 b0<br>
 <br>
 <br>
 <br>001 y <br>
 A &amp; B <br>
Bitwise AND<br>
 <br>
 <br>
 <br>010 y <br>
 A | B <br>
Bitwise OR<br>
 <br>
 <br>
 <br>011 y <br>
 A ^ B <br>
Bitwise exclusive OR<br>
 <br>
 <br>
 <br>100 y <br>
 ~ A <br>
Bitwise complement<br>
 <br>
 <br>
 <br>101 y <br>
 A   B <br>
Subtract<br>
 <br>
 <br>
 <br>110 y <br>
 A   B <br>
Add (Assume A and B are unsigned)<br>
 <br>
 <br>
 <br>111 y <br>
 8 hFF  <br>
 <br><b> 4.45 </b><br>
 <br>Write an HDL behavioral description of a four-input priority encoder. Use a four-bit  vector <br>for the  <i>D</i>  inputs and an  <b>always</b>  block with if�else statements. Assume that input  <i>D</i> [3]  has <br>the highest priority (see Problem 4.36). <br>
 <br><b> 4.46 </b><br>
 <br>Write a Verilog dataflow description of the logic circuit described by the Boolean function <br>in Problem 4.32. <br>
 <br><b> 4.47 </b><br>
 <br>Write a Verilog dataflow description of the logic circuit described by the Boolean function <br>in Problem 4.35. <br>
 <br><b> 4.48 </b><br>
 <br>Develop and modify the eight-bit ALU specified in Problem 4.44 so that it has three-state <br>output controlled by an enable input,  <i>En</i> . Write a test bench and simulate the circuit. <br>
 <br><b> 4.49 </b><br>
 <br>For the circuit shown in Fig. P4.1, <br>
 <br>
(a)   Write and verify a gate-level HDL model of the circuit. <br>
 <br>
(b)   Compare your results with those obtained for Problem 4.1. <br>
 <br><b> 4.50 </b><br>
 <br>Using a case statement, develop and simulate a behavioral model of <br>
 <br>
(a)<b>*</b>   The 8, 4, �2, �1 to BCD code converter described in Problem 4.8(a). <br>
 <br>
(b)   The 8, 4, �2, �1 to Gray code converter described in Problem 4.8(b). <br>
<hr>
<A name=206></a><b>188    Chapter 4  Combinational Logic</b><br>
 <br><b> 4.51 </b><br>
 <br>Develop and simulate a behavioral model of the ABCD-to-seven-segment decoder <br> <br>described in Problem 4.9. <br>
 <br><b> 4.52 </b><br>
 <br>Using a continuous assignment, develop and simulate a dataflow model of <br>
 <br>
(a)   The four-bit incrementer described in Problem 4.11(a). <br>
   <br>
(b)    The  four-bit  decrementer  described  in  Problem  4.11(b).     <br>
 <br><b> 4.53 </b><br>
 <br>Develop and simulate a structural model of the decimal adder shown in  Fig.   4.14  . <br>
 <br><b> 4.54 </b><br>
 <br>Develop and simulate a behavioral model of a circuit that generates the 9's complement of <br>
    <br>
(a) <br>
  a  BCD  digit  (see  Problem  4.18(a)).  <br>
   <br>
(b)    a  Gray-code  digit  (see  Problem  4.18(b).)     <br>
 <br><b> 4.55 </b><br>
 <br>Construct a hierarchical model of the BCD adder�subtractor described in Problem 4.19. <br>The BCD adder and the 9's complementer are to be described as behavioral models in <br>separate modules, and they are to be instantiated in a top-level module. <br>
 <br><b> 4.56* </b> Write a continuous assignment statement that compares two 4-bit numbers to check if <br>
their bit patterns match. The variable to which the assignment is made is to equal 1 if the <br>numbers match and 0 otherwise. <br>
 <br><b> 4.57* </b> Develop and verify a behavioral model of the four-bit priority encoder described in <br>
 Problem  4.29.   <br>
 <br><b> 4.58 </b><br>
 <br>Write a Verilog model of a circuit whose 32-bit output is formed by shifting its 32-bit input <br>three positions to the right and filling the vacant positions with the bit that was in the MSN <br>before the shift occurred (shift arithmetic right).Write a Verilog model of a circuit whose <br>32-bit output is formed by shifting its 32-bit input three positions to the left and filling the <br>vacant positions with 0 (shift logical left). <br>
 <br><b> 4.59 </b><br>
 <br>Write a Verilog model of a BCD-to-decimal decoder using the unused combinations of <br>the BCD code as don't-care conditions (see Problem 4.24). <br>
 <br><b> 4.60 </b><br>
 <br>Using the port syntax of the IEEE 1364-2001 standard, write and verify a gate-level model <br>of the four-bit even parity checker shown in  Fig.   3.34  . <br>
 <br><b> 4.61 </b><br>
 <br>Using continuous assignment statements and the port syntax of the IEEE 1364-2001 standard, <br>write and verify a gate-level model of the four-bit even parity checker shown in  Fig.   3.34  . <br>
 <br><b> 4.62 </b><br>
 <br>Write and verify a gate-level hierarchical model of the circuit described in Problem 4.25. <br>
 <br><b> 4.63 </b><br>
 <br>Write and verify a gate-level hierarchical model of the circuit described in Problem 4.26. <br>
 <br><b> 4.64 </b><br>
 <br>Write and verify a Verilog model of the octal-to-binary circuit described in Problem 4.30. <br>
 <br><b> 4.65 </b><br>
 <br>Write a hierarchical gate-level model of the multiplexer described in Problem 4.31. <br>
<b> <br>R E F E R E N C E S </b><br>
 <br>
 <br><b>1. </b> <br>
B hasker ,  J.  1997.  <i>A Verilog HDL Primer</i>. Allentown, PA: Star Galaxy Press. <br>
<b> </b><br>
<b> <br>2.</b>  <br>
B hasker ,  J.  1998.  <i>Verilog HDL Synthesis</i>. Allentown, PA: Star Galaxy Press. <br>
<b> </b><br>
<b> <br>3.</b>  <br>
C iletti ,  M.  D.  1999.  <i>Modeling, Synthesis, and Rapid Prototyping with Verilog HDL</i>. Upper <br>Saddle River, NJ: Prentice Hall. <br>
<b> </b><br>
<b> <br>4.</b>  <br>
D ietmeyer ,  D.  L.  1988.  <i>Logic Design of Digital Systems</i>, 3rd ed. Boston: Allyn Bacon. <br>
<hr>
<A name=207></a><b>Web Search Topics    189</b><br>
<b> </b><br>
<b> <br>5.</b>  <br>
G ajski ,  D.  D.  1997.  <i>Principles of Digital Design</i>. Upper Saddle River, NJ: Prentice Hall. <br>
<b> </b><br>
<b> <br>6.</b>  <br>
H ayes ,  J.  P.  1993.  <i>Introduction to Digital Logic Design</i>. Reading, MA: Addison-Wesley. <br>
<b> </b><br>
<b> <br>7</b>.  <br>
K atz ,  R.  H.  2005.  <i>Contemporary Logic Design</i>. Upper Saddle River, NJ: Pearson Prentice Hall. <br>
 <br>
 <br><b>8. </b> <br>
M ano , M. M. and C. R. K ime . 2007. <i>Logic and Computer Design Fundamentals</i>, 4th ed. <br>Upper Saddle River, NJ: Prentice Hall. <br>
<b> </b><br>
<b> <br>9. </b> <br>
N elson, V. P., H. T. N agle , J. D. I rwin , and B. D. C arroll . 1995. <i>Digital Logic Circuit <br>Analysis and Design</i>. Englewood Cliffs, NJ: Prentice Hall. <br>
<b> </b><br>
<b> <br>10.</b>  <br>
P alnitkar ,  S.  1996.  <i>Verilog HDL: A Guide to Digital Design and Synthesis</i>. Mountain View, <br>CA: SunSoft Press (a Prentice Hall title). <br>
<b> </b><br>
<b> <br>11.</b>  <br>
R oth ,  C.  H.  2009.  <i>Fundamentals of Logic Design</i>, 6th ed. St. Paul, MN: West. <br>
<b> </b><br>
<b> <br>12.</b> <br>
T homas , D. E. and P. R. M oorby . 2002. <i>The Verilog Hardware Description Language</i>, <br>5th ed. Boston: Kluwer Academic Publishers. <br>
<b> </b><br>
<b> <br>13.</b>  <br>
W akerly ,  J.  F.  2005.  <i>Digital Design: Principles and Practices</i>, 4th ed. Upper Saddle River, <br>NJ: Prentice Hall. <br>
<b> <br>W E B   S E A R C H   T O P I C S </b><br>
 <br>
 <br>
   Boolean  equation  <br>
 <br>
 <br>
  Combinational  logic  <br>
 <br>
 <br>
  Truth  table  <br>
 <br>
 <br>
  Exclusive�OR  <br>
 <br>
 <br>
  Comparator  <br>
 <br>
 <br>
  Multiplexer  <br>
 <br>
 <br>
  Decoder  <br>
 <br>
 <br>
  Priority  encoder  <br>
 <br>
 <br>
  Three-state  inverter  <br>
 <br>
 <br>
  Three-state  buffer      <br>
<hr>
<A name=208></a> <br>Chapter 5 <br>
<b> <br>Synchronous Sequential Logic </b> <br>
<b> <br>5 . 1       IN T R O D U C T I O N </b><br>
 <br>Hand-held devices, cell phones, navigation receivers, personal computers, digital cameras, <br>personal media players, and virtually all electronic consumer products have the ability to <br>send, receive, store, retrieve, and process information represented in a binary format. The <br>technology enabling and supporting these devices is critically dependent on electronic <br>components that can store information, i.e., have memory. This chapter examines the <br>operation and control of these devices and their use in circuits and enables you to better <br>understand what is happening in these devices when you interact with them. The digital <br>circuits considered thus far have been combinational--their output depends only and <br>immediately on their inputs--they have no memory, i.e., dependence on past values of <br>their inputs. Sequential circuits, however, act as storage elements and have memory. They <br>can store, retain, and then retrieve information when needed at a later time. Our treatment <br>will distinguish sequential logic from combinational logic. <br>
<b> <br>5 . 2       S E Q U E N T I A L   C I R C U I T S </b><br>
 <br>A block diagram of a sequential circuit is shown in  Fig.   5.1 . It consists of a combinational <br>circuit to which storage elements are connected to form a feedback path. The storage <br>elements are devices capable of storing binary information. The binary information <br>stored in these elements at any given time defines the  <i>state</i>  of the sequential circuit at <br>that time. The sequential circuit receives binary information from external inputs that, <br>together with the present state of the storage elements, determine the binary value of <br>the outputs. These external inputs also determine the condition for changing the state <br>
<b>190</b><br>
<hr>
<A name=209></a><b>Section 5.2  Sequential Circuits    191</b><br>
<i>Inputs</i><br>
<i>Outputs</i><br>
Combinational<br>
circuit<br>
Memory<br>
elements<br>
<b> <br>FIGURE 5.1 <br> <br>Block diagram of sequential circuit  </b><br>
in the storage elements. The block diagram demonstrates that the outputs in a sequen-<br>tial circuit are a function not only of the inputs, but also of the present state of the stor-<br>age elements. The next state of the storage elements is also a function of external inputs <br>and the present state. Thus,  <b>a sequential circuit is specified by a time sequence of inputs, <br>outputs, and internal states</b> . In contrast, the outputs of combinational logic depend only <br>on the present values of the inputs. <br>
 <br>There are two main types of sequential circuits, and their classification is a function of <br>
the timing of their signals. A  <i>synchronous</i>  sequential circuit is a system whose behavior <br>can be defined from the knowledge of its signals at discrete instants of time. The behavior <br>of an  <i>asynchronous</i>  sequential circuit depends upon the input signals at any instant of time <br> <br><i>and</i>  the order in which the inputs change. The storage elements commonly used in asyn-<br>chronous sequential circuits are time-delay devices. The storage capability of a time-delay <br>device varies with the time it takes for the signal to propagate through the device. In prac-<br>tice, the internal propagation delay of logic gates is of sufficient duration to produce the <br>needed delay, so that actual delay units may not be necessary. In gate-type asynchronous <br>systems, the storage elements consist of logic gates whose propagation delay provides the <br>required storage. Thus, an asynchronous sequential circuit may be regarded as a combina-<br>tional circuit with feedback. Because of the feedback among logic gates, an asynchronous <br>sequential circuit may become unstable at times. The instability problem imposes many <br>difficulties on the designer. These circuits will not be covered in this text. <br>
 <br>A synchronous sequential circuit employs signals that affect the storage elements at <br>
only discrete instants of time. Synchronization is achieved by a timing device called a <br> <br><i>clock generator</i>,  which provides a clock signal having the form of a periodic train of  <i>clock <br>pulses</i> . The clock signal is commonly denoted by the identifiers  <i>clock</i>  and  <i>clk</i> .  The  clock <br>pulses are distributed throughout the system in such a way that storage elements are <br>affected only with the arrival of each pulse. In practice, the clock pulses determine  <i>when</i> <br>computational activity will occur within the circuit, and other signals (external inputs <br>and otherwise) determine  <i>what</i>  changes will take place affecting the storage elements <br>and the outputs. For example, a circuit that is to add and store two binary numbers would <br>compute their sum from the values of the numbers and store the sum at the occurrence <br>of a clock pulse. Synchronous sequential circuits that use clock pulses to control storage <br>elements are called  <i>clocked sequential circuits</i>  and are the type most frequently encoun-<br>tered in practice. They are called  <i>synchronous circuits</i>  because the activity within the <br>circuit and the resulting updating of stored values is synchronized to the occurrence of <br>
<hr>
<A name=210></a><b>192    Chapter 5  Synchronous Sequential Logic</b><br>
Inputs<br>
Outputs<br>
Combinational<br>
circuit<br>
Flip-flops<br>
Clock pulses<br>
(a) Block diagram<br>
(b) Timing diagram of clock pulses<br>
<b> <br>FIGURE 5.2 <br> <br>Synchronous clocked sequential circuit  </b><br>
clock pulses. The design of synchronous circuits is feasible because they seldom manifest <br>instability problems and their timing is easily broken down into independent discrete <br>steps, each of which can be considered separately. <br>
 <br>The storage elements (memory) used in clocked sequential circuits are called  <i>flip-</i><br>
<i>flops.</i> A flip-flop is a binary storage device capable of storing one bit of information. In <br>a stable state, the output of a flip-flop is either 0 or 1. A sequential circuit may use many <br>flip-flops to store as many bits as necessary. The block diagram of a synchronous clocked <br>sequential circuit is shown in  Fig.   5.2  . The  <i>outputs</i>  are formed by a combinational logic <br>function of the inputs to the circuit or the values stored in the flip-flops (or both). The <br>value that is stored in a flip-flop when the clock pulse occurs is also determined by the <br>inputs to the circuit or the values presently stored in the flip-flop (or both). The new <br>value is stored (i.e., the flip-flop is updated) when a pulse of the clock signal occurs. <br>Prior to the occurrence of the clock pulse, the combinational logic forming the next <br>value of the flip-flop must have reached a stable value. Consequently, the speed at <br>which the combinational logic circuits operate is critical. If the clock (synchronizing) <br>pulses arrive at a regular interval, as shown in the timing diagram in  Fig.   5.2  , the com-<br>binational logic must respond to a change in the state of the flip-flop in time to be <br>updated before the next pulse arrives. Propagation delays play an important role in <br>determining the minimum interval between clock pulses that will allow the circuit to <br>operate correctly. A change in state of the flip-flops is initiated only by a clock pulse <br>transition--for example, when the value of the clock signals changes from 0 to 1. When <br>a clock pulse is not active, the feedback loop between the value stored in the flip-flop <br>and the value formed at the input to the flip-flop is effectively broken because the flip-<br>flop outputs cannot change even if the outputs of the combinational circuit driving their <br>inputs change in value. Thus, the transition from one state to the next occurs only at <br>predetermined intervals dictated by the clock pulses. <br>
<hr>
<A name=211></a><b>Section 5.3  Storage Elements: Latches    193</b><br>
<b> <br>5 . 3       S T O R A G E   E L E M E N T S :   L AT C H E S </b><br>
 <br>A storage element in a digital circuit can maintain a binary state indefinitely (as long <br>as power is delivered to the circuit), until directed by an input signal to switch states. <br>The major differences among various types of storage elements are in the number of <br>inputs they possess and in the manner in which the inputs affect the binary state.  <i>Storage <br>elements that operate with signal levels (rather than signal transitions) are referred to as</i> <br> <br><i>latches</i> ;   <i>those controlled by a clock transition are flip-flops</i> . Latches are said to be level <br>sensitive devices; flip-flops are edge-sensitive devices. The two types of storage elements <br>are related because latches are the basic circuits from which all flip-flops are con-<br>structed. Although latches are useful for storing binary information and for the design <br>of asynchronous sequential circuits, they are not practical for use as storage elements <br>in synchronous sequential circuits. Because they are the building blocks of flip-flops, <br>however, we will consider the fundamental storage mechanism used in latches before <br>considering flip-flops in the next section. <br>
<b> <br><i>SR</i>  Latch </b><br>
 The   <i>SR</i>  latch is a circuit with two cross-coupled NOR gates or two cross-coupled NAND <br>gates, and two inputs labeled  <i>S</i>  for set and  <i>R</i>  for reset. The  <i>SR</i>  latch constructed with two <br>cross-coupled NOR gates is shown in  Fig.   5.3  .The latch has two useful states. When output <br> <br><i>Q </i>= 1     and     <i>Q </i>= 0,  the latch is said to be in the  <i>set state</i> .  When     <i>Q </i>= 0     and     <i>Q </i>= 1,     it  is <br>in the  <i>reset state</i> . Outputs  <i>Q</i>   and     <i>Q </i>  are normally the complement of each other. However, <br>when both inputs are equal to 1 at the same time, a condition in which both outputs are <br>equal to 0 (rather than be mutually complementary) occurs. If both inputs are then switched <br>to 0 simultaneously, the device will enter an unpredictable or undefined state or a meta-<br>stable state. Consequently, in practical applications, setting both inputs to 1 is forbidden. <br>
 <br>Under normal conditions, both inputs of the latch remain at 0 unless the state has to be <br>
changed. The application of a momentary 1 to the  <i>S</i>  input causes the latch to go to the set <br>state. The  <i>S</i>  input must go back to 0 before any other changes take place, in order to avoid <br>the occurrence of an undefined next state that results from the forbidden input condition. <br>As shown in the function table of  Fig.   5.3  (b), two input conditions cause the circuit to be in <br>
1<br>
<i>S R</i><br>
<i>Q Q</i><br>
0<br>
<i>R</i> (reset)<br>
<i>Q</i><br>
1<br>
0<br>
1<br>
0<br>
0<br>
0<br>
1<br>
0 (after <i>S</i><br>
 1, <i>R</i><br>
 0)<br>
1<br>
0<br>
1<br>
0<br>
1<br>
0<br>
0<br>
0<br>
1 (after <i>S</i><br>
 0, <i>R</i><br>
 1)<br>
<i>Q</i><br>
1<br>
1<br>
0<br>
0 (forbidden)<br>
0<br>
<i>S</i> (set)<br>
(a) Logic diagram<br>
(b) Function table<br>
<b> <br>FIGURE 5.3 <br> <br><i>SR</i>  latch with NOR gates  </b><br>
<hr>
<A name=212></a><b>194    Chapter 5  Synchronous Sequential Logic</b><br>
1<br>
<i>S R</i><br>
<i>Q Q</i><br>
0<br>
<i>S</i> (set)<br>
<i>Q</i><br>
1<br>
0<br>
0<br>
1<br>
1<br>
1<br>
0<br>
1 (after <i>S</i><br>
 1, <i>R</i><br>
 0)<br>
1<br>
0<br>
1<br>
1<br>
0<br>
1<br>
1<br>
1<br>
0 (after <i>S</i><br>
 0, <i>R</i><br>
 1)<br>
<i>Q</i><br>
0<br>
0<br>
1<br>
1 (forbidden)<br>
0<br>
<i>R</i> (reset)<br>
(a) Logic diagram<br>
(b) Function table<br>
<b> <br>FIGURE 5.4 <br> <br><i>SR</i>  latch with NAND gates  </b><br>
the set state. The first condition   (<i>S </i>= 1, <i>R </i>= 0)  is the action that must be taken by input <br> <br><i>S</i>  to bring the circuit to the set state. Removing the active input from  <i>S</i>  leaves the circuit in <br>the same state. After both inputs return to 0, it is then possible to shift to the reset state by <br>momentary applying a 1 to the  <i>R</i>  input. The 1 can then be removed from  <i>R</i>,  whereupon the <br>circuit remains in the reset state. Thus, when both inputs  <i>S</i>  and  <i>R</i>  are equal to 0, the latch <br>can be in either the set or the reset state, depending on which input was most recently a 1. <br>
 <br>If a 1 is applied to both the  <i>S</i>  and  <i>R</i>  inputs of the latch, both outputs go to 0. This <br>
action produces an undefined next state, because the state that results from the input <br>transitions depends on the order in which they return to 0. It also violates the require-<br>ment that outputs be the complement of each other. In normal operation, this condition <br>is avoided by making sure that 1's are not applied to both inputs simultaneously. <br>
 The   <i>SR</i>  latch with two cross-coupled NAND gates is shown in  Fig.   5.4  . It operates with <br>
both inputs normally at 1, unless the state of the latch has to be changed. The application <br>of 0 to the <i>S</i> input causes output  <i>Q</i>  to go to 1, putting the latch in the set state. When the  <i>S</i> <br>input goes back to 1, the circuit remains in the set state. After both inputs go back to 1, we <br>are allowed to change the state of the latch by placing a 0 in the  <i>R</i>  input. This action causes <br>the circuit to go to the reset state and stay there even after both inputs return to 1. The <br>condition that is forbidden for the NAND latch is both inputs being equal to 0 at the same <br>time, an input combination that should be avoided. <br>
 <br>In comparing the NAND with the NOR latch, note that the input signals for the <br>
NAND require the complement of those values used for the NOR latch. Because the <br>NAND latch requires a 0 signal to change its state, it is sometimes referred to as an   <i>S R </i> <br>latch. The primes (or, sometimes, bars over the letters) designate the fact that the inputs <br>must be in their complement form to activate the circuit. <br>
 <br>The operation of the basic  <i>SR</i>  latch can be modified by providing an additional input <br>
signal that determines (controls)  <i>when</i>  the state of the latch can be changed by determining <br>whether  <i>S</i>  and  <i>R</i>  (or  <i>S</i>   and  <i>R</i>  ) can affect the circuit. An  <i>SR</i>  latch with a control input is <br>shown in  Fig.   5.5  . It consists of the basic  <i>SR</i>  latch and two additional NAND gates. The <br>control input  <i>En</i>  acts as an  <i>enable</i>  signal for the other two inputs.  <b>The outputs of</b> <b>the</b>  <b>NAND <br>gates stay at the logic-1 level as long as the enable signal remains at 0.</b> This is the quiescent <br>condition for the  <i>SR</i>  latch. When the enable input goes to 1, information from the  <i>S</i>  or  <i>R</i> <br>input is allowed to affect the latch. The set state is reached with   <i>S </i>= 1, <i>R </i>= 0,     and     <i>En </i>= 1    <br>
<hr>
<A name=213></a><b>Section 5.3  Storage Elements: Latches    195</b><br>
<i>S</i><br>
<i>Q</i><br>
<i>En S</i><br>
<i>R</i><br>
Next state of <i>Q</i><br>
0<br>
X X<br>
No change<br>
<i>En</i><br>
1<br>
0<br>
0<br>
No change<br>
1<br>
0<br>
1<br>
<i>Q</i><br>
 0; reset state<br>
1<br>
1<br>
0<br>
<i>Q</i><br>
 1; set state<br>
<i>Q</i><br>
1<br>
1<br>
1<br>
Indeterminate<br>
<i>R</i><br>
(a) Logic diagram<br>
(b) Function table<br>
<b> <br>FIGURE 5.5 <br> <br><i>SR</i>  latch with control input  </b><br>
(active-high enabled). To change to the reset state, the inputs must be   <i>S </i>= 0, <i>R </i>= 1, and <br> <br><i>En </i>= 1.  In either case, when  <i>En</i>  returns to 0, the circuit remains in its current state. The <br>control input disables the circuit by applying 0 to  <i>En</i>,  so that the state of the output does <br>not change regardless of the values of  <i>S</i>  and  <i>R</i> . Moreover, when   <i>En </i>= 1  and both the  <i>S</i> <br>and  <i>R</i>  inputs are equal to 0, the state of the circuit does not change. These conditions are <br>listed in the function table accompanying the diagram. <br>
 <br>An indeterminate condition occurs when all three inputs are equal to 1. This condition <br>
places 0's on both inputs of the basic  <i>SR</i>  latch, which puts it in the undefined state. When <br>the enable input goes back to 0, one cannot conclusively determine the next state, because <br>it depends on whether the  <i>S</i>  or  <i>R</i>  input goes to 0 first. This indeterminate condition makes <br>this circuit difficult to manage, and it is seldom used in practice. Nevertheless, the <i>SR</i> latch <br>is an important circuit because other useful latches and flip-flops are constructed from it. <br>
<b> <br><i>D</i>  Latch (Transparent Latch) </b><br>
 <br>One way to eliminate the undesirable condition of the indeterminate state in the  <i>SR</i> <br>latch is to ensure that inputs  <i>S</i>  and  <i>R</i>  are never equal to 1 at the same time. This is <br>done in the  <i>D</i>  latch, shown in  Fig.   5.6  . This latch has only two inputs:  <i>D</i>  (data) and <br>
<i>D</i><br>
<i>Q</i><br>
<i>En D</i><br>
Next state of <i>Q</i><br>
<i>En</i><br>
0 X<br>
No change<br>
1<br>
0<br>
<i>Q</i><br>
 0; reset state<br>
1<br>
1<br>
<i>Q</i><br>
 1; set state<br>
<i>Q</i><br>
(a) Logic diagram<br>
(b) Function table<br>
<b> <br>FIGURE 5.6 <br> <br><i>D</i>  latch  </b><br>
<hr>
<A name=214></a><b>196    Chapter 5  Synchronous Sequential Logic</b><br>
<i>S</i><br>
<i>S</i><br>
<i>D</i><br>
<i>R</i><br>
<i>R</i><br>
<i>En</i><br>
<i>SR</i><br>
<i>SR</i><br>
<i>D</i><br>
<b> <br>FIGURE 5.7 <br> <br>Graphic symbols for latches  </b><br>
 <br><i>En</i>  (enable).  The   <i>D</i>  input goes directly to the  <i>S</i>  input, and its complement is applied <br>to the  <i>R</i>  input. As long as the enable input is at 0, the cross-coupled  <i>SR</i>  latch has both <br>inputs at the 1 level and the circuit cannot change state regardless of the value of  <i>D</i> . <br>The  <i>D</i>  input is sampled when   <i>En </i>= 1. If  <i>D </i>= 1,     the   <i>Q</i>  output goes to 1, placing the <br>circuit in the set state. If   <i>D </i>= 0,     output   <i>Q</i>  goes to 0, placing the circuit in the reset <br>state. <br>
 The   <i>D</i>  latch receives that designation from its ability to hold  <i>data</i>  in its internal stor-<br>
age. It is suited for use as a temporary storage for binary information between a unit <br>and its environment. The binary information present at the data input of the  <i>D</i>  latch is <br>transferred to the  <i>Q</i>  output when the enable input is asserted. The output follows <br>changes in the data input as long as the enable input is asserted. This situation provides <br>a path from input  <i>D</i>  to the output, and for this reason, the circuit is often called a  <i>trans-<br>parent</i>  latch. When the enable input signal is de-asserted, the binary information that <br>was present at the data input at the time the transition occurred is retained (i.e., stored) <br>at the  <i>Q</i>  output until the enable input is asserted again. Note that an inverter could be <br>placed at the enable input. Then, depending on the physical circuit, the external enabling <br>signal will be a value of 0 (active low) or 1 (active high). <br>
 <br>The graphic symbols for the various latches are shown in  Fig.   5.7 .A latch is designated <br>
by a rectangular block with inputs on the left and outputs on the right. One output <br>designates the normal output, and the other (with the bubble designation) designates <br>the complement output. The graphic symbol for the  <i>SR</i>  latch has inputs  <i>S</i>  and  <i>R</i>   indi-<br>cated inside the block. In the case of a NAND gate latch, bubbles are added to the inputs <br>to indicate that setting and resetting occur with a logic-0 signal. The graphic symbol for <br>the  <i>D</i>  latch has inputs  <i>D</i>  and  <i>En</i>  indicated inside the block. <br>
<b> <br>5 . 4       S T O R A G E   E L E M E N T S :   F L I P - F L O P S </b><br>
 <br>The state of a latch or flip-flop is switched by a change in the control input. This momentary <br>change is called a  <i>trigger</i>,  and the transition it causes is said to trigger the flip-flop. The  <i>D</i> <br>latch with pulses in its control input is essentially a flip-flop that is triggered every time the <br>pulse goes to the logic-1 level. As long as the pulse input remains at this level, any changes <br>in the data input will change the output and the state of the latch. <br>
<hr>
<A name=215></a><b>Section 5.4  Storage Elements: Flip-Flops    197</b><br>
 <br>As seen from the block diagram of  Fig.   5.2  , a sequential circuit has a feedback path <br>
from the outputs of the flip-flops to the input of the combinational circuit. Conse-<br>quently, the inputs of the flip-flops are derived in part from the outputs of the same and <br>other flip-flops. When latches are used for the storage elements, a serious difficulty <br>arises. The state transitions of the latches start as soon as the clock pulse changes to the <br>logic-1 level. The new state of a latch appears at the output while the pulse is still active. <br>This output is connected to the inputs of the latches through the combinational circuit. <br>If the inputs applied to the latches change while the clock pulse is still at the logic-1 <br>level, the latches will respond to new values and a new output state may occur. The <br>result is an unpredictable situation, since the state of the latches may keep changing for <br>as long as the clock pulse stays at the active level. Because of this unreliable operation, <br>the output of a latch cannot be applied directly or through combinational logic to the <br>input of the same or another latch when all the latches are triggered by a common clock <br>source. <br>
 <br>Flip-flop circuits are constructed in such a way as to make them operate properly <br>
when they are part of a sequential circuit that employs a common clock. The problem <br>with the latch is that it responds to a change in the  <i>level</i>  of a clock pulse. As shown in <br> <br>Fig.   5.8  (a), a positive level response in the enable input allows changes in the output <br>when the  <i>D</i>  input changes while the clock pulse stays at logic 1. The key to the proper <br>operation of a flip-flop is to trigger it only during a signal  <i>transition</i> . This can be accom-<br>plished by eliminating the feedback path that is inherent in the operation of the sequen-<br>tial circuit using latches. A clock pulse goes through two transitions: from 0 to 1 and the <br>return from 1 to 0. As shown in  Fig.   5.8  , the positive transition is defined as the positive <br>edge and the negative transition as the negative edge. There are two ways that a latch <br>can be modified to form a flip-flop. One way is to employ two latches in a special con-<br>figuration that isolates the output of the flip-flop and prevents it from being affected <br>while the input to the flip-flop is changing. Another way is to produce a flip-flop that <br>
(a) Response to positive level<br>
(b) Positive-edge response<br>
(c) Negative-edge response<br>
<b> <br>FIGURE 5.8 <br> <br>Clock response in latch and flip-flop  </b><br>
<hr>
<A name=216></a><b>198    Chapter 5  Synchronous Sequential Logic</b><br>
triggers only during a signal transition (from 0 to 1 or from 1 to 0) of the synchronizing <br>signal (clock) and is disabled during the rest of the clock pulse. We will now proceed to <br>show the implementation of both types of flip-flops. <br>
<b> <br>Edge-Triggered  <i>D</i>  Flip-Flop </b><br>
 <br>The construction of a  <i>D</i>  flip-flop with two  <i>D</i>  latches and an inverter is shown in  Fig.   5.9  . <br>The first latch is called the master and the second the slave. The circuit samples the  <i>D</i> <br>input and changes its output  <i>Q</i>  only at the negative edge of the synchronizing or control-<br>ling clock (designated as  <i>Clk</i> ). When the clock is 0, the output of the inverter is 1. The <br>slave latch is enabled, and its output  <i>Q</i>  is equal to the master output  <i>Y</i> . The master latch <br>is disabled because   <i>Clk </i>= 0. When the input pulse changes to the logic-1 level, the data <br>from the external  <i>D</i>  input are transferred to the master. The slave, however, is disabled <br>as long as the clock remains at the 1 level, because its  <i>enable</i>  input is equal to 0. Any <br>change in the input changes the master output at  <i>Y</i>,  but cannot affect the slave output. <br>When the clock pulse returns to 0, the master is disabled and is isolated from the  <i>D</i> <br>input. At the same time, the slave is enabled and the value of  <i>Y</i>  is transferred to the <br>output of the flip-flop at  <i>Q</i> .  Thus,   <i>a change in the output of the flip-flop can be triggered <br>only by and during the transition of the clock from 1</i>  to 0. <i> </i><br>
 <br>The behavior of the master�slave flip-flop just described dictates that (1) the output <br>
may change only once, (2) a change in the output is triggered by the negative edge of <br>the clock, and (3) the change may occur only during the clock's negative level. The value <br>that is produced at the output of the flip-flop is the value that was  <i>stored in the master <br>stage immediately before the negative edge occurred</i> . It is also possible to design the <br>circuit so that the flip-flop output changes on the positive edge of the clock. This hap-<br>pens in a flip-flop that has an additional inverter between the  <i>Clk</i>  terminal and the <br>junction between the other inverter and input  <i>En</i>  of the master latch. Such a flip-flop is <br>triggered with a negative pulse, so that the negative edge of the clock affects the master <br>and the positive edge affects the slave and the output terminal. <br>
 <br>Another construction of an edge-triggered  <i>D</i>  flip-flop uses three  <i>SR</i>  latches as shown <br>
in  Fig.   5.10  . Two latches respond to the external  <i>D</i>  (data) and  <i>Clk</i>  (clock) inputs. The <br>third latch provides the outputs for the flip-flop. The  <i>S</i>  and  <i>R</i>  inputs of the output latch <br>
<i>Y</i><br>
<i>D</i><br>
<i>D</i><br>
<i>D</i><br>
<i>Q</i><br>
D latch<br>
D latch<br>
(master)<br>
(slave)<br>
<i>En</i><br>
<i>En</i><br>
<i>Clk</i><br>
<b> <br>FIGURE 5.9 <br> <br>Master�slave  <i>D</i>  flip-flop  </b><br>
<hr>
<A name=217></a><b>Section 5.4  Storage Elements: Flip-Flops    199</b><br>
<i>S</i><br>
<i>Q</i><br>
<i>Clk</i><br>
<i>R</i><br>
<i>Q</i><br>
<i>D</i><br>
<b> <br>FIGURE 5.10 <br> <br><i>D</i> -type positive-edge-triggered flip-flop  </b><br>
are maintained at the logic-1 level when   <i>Clk </i>= 0. This causes the output to remain in <br>its present state. Input  <i>D</i>  may be equal to 0 or 1. If   <i>D </i>= 0     when   <i>Clk</i>  becomes 1,  <i>R</i> <br>changes to 0. This causes the flip-flop to go to the reset state, making   <i>Q </i>= 0.     If  there  is <br>a change in the  <i>D</i>  input while   <i>Clk </i>= 1,     terminal   <i>R</i>  remains at 0 because  <i>Q</i>  is 0. Thus, the <br>flip-flop is locked out and is unresponsive to further changes in the input. When the <br>clock returns to 0,  <i>R</i>  goes to 1, placing the output latch in the quiescent condition with-<br>out changing the output. Similarly, if   <i>D </i>= 1     when   <i>Clk</i>  goes from 0 to 1,  <i>S</i>  changes to 0. <br>This causes the circuit to go to the set state, making   <i>Q </i>= 1.     Any  change  in   <i>D</i>   while <br> <br><i>Clk </i>= 1  does not affect the output. <br>
 <br>In sum, when the input clock in the positive-edge-triggered flip-flop makes a positive <br>
transition, the value of  <i>D</i>  is transferred to  <i>Q</i> .A negative transition of the clock (i.e., from <br>1 to 0) does not affect the output, nor is the output affected by changes in <i>D</i> when  <i>Clk</i> <br>is in the steady logic-1 level or the logic-0 level. Hence, this type of flip-flop responds to <br>the transition from 0 to 1 and nothing else. <br>
 <br>The timing of the response of a flip-flop to input data and to the clock must be taken <br>
into consideration when one is using edge-triggered flip-flops. There is a minimum time <br>called the  <i>setup time</i>  during which the  <i>D</i>  input must be maintained at a constant value prior <br>to the occurrence of the clock transition. Similarly, there is a minimum time called the  <i>hold <br>time</i>  during which the  <i>D</i>  input must not change after the application of the positive transi-<br>tion of the clock. The propagation delay time of the flip-flop is defined as the interval <br>between the trigger edge and the stabilization of the output to a new state. These and other <br>parameters are specified in manufacturers' data books for specific logic families. <br>
<hr>
<A name=218></a><b>200    Chapter 5  Synchronous Sequential Logic</b><br>
<i>D</i><br>
<i>D</i><br>
<i>Clk</i><br>
<i>Clk</i><br>
(a) Positive-edge<br>
(a) Negative-edge<br>
<b> <br>FIGURE 5.11 <br> <br>Graphic symbol for edge-triggered  <i>D</i>  flip-flop  </b><br>
 <br>The graphic symbol for the edge-triggered  <i>D</i>  flip-flop is shown in  Fig.   5.11 . It is simi-<br>
lar to the symbol used for the  <i>D</i>  latch, except for the arrowhead-like symbol in front of <br>the letter  <i>Clk</i>,  designating a  <i>dynamic</i>  input. The  <i>dynamic indicator</i>  (&gt;) denotes the fact <br>that the flip-flop responds to the edge transition of the clock. A bubble outside the block <br>adjacent to the dynamic indicator designates a negative edge for triggering the circuit. <br>The absence of a bubble designates a positive-edge response. <br>
<b> <br>Other Flip-Flops </b><br>
 <br>Very large-scale integration circuits contain several thousands of gates within one pack-<br>age. Circuits are constructed by interconnecting the various gates to provide a digital <br>system. Each flip-flop is constructed from an interconnection of gates. The most eco-<br>nomical and efficient flip-flop constructed in this manner is the edge-triggered  <i>D</i>   flip-<br>flop, because it requires the smallest number of gates. Other types of flip-flops can be <br>constructed by using the  <i>D</i>  flip-flop and external logic. Two flip-flops less widely used <br>in the design of digital systems are the  <i>JK</i>  and  <i>T</i>   flip-flops.  <br>
 <br>There are three operations that can be performed with a flip-flop: Set it to 1, reset it <br>
to 0, or complement its output. With only a single input, the  <i>D</i>  flip-flop can set or reset <br>the output, depending on the value of the  <i>D</i>  input immediately before the clock transi-<br>tion. Synchronized by a clock signal, the  <i>JK</i>  flip-flop has two inputs and performs all <br>three operations. The circuit diagram of a  <i>JK</i>  flip-flop constructed with a  <i>D</i>  flip-flop and <br>gates  is  shown  in   Fig.    5.12   (a).  The   <i>J</i>  input sets the flip-flop to 1, the  <i>K</i>  input resets it to <br>0, and when both inputs are enabled, the output is complemented. This can be verified <br>by investigating the circuit applied to the  <i>D</i>   input: <br>
 <br><i>D </i>= <i>JQ </i>+ <i>K Q</i> <br>
 When     <i>J </i>= 1     and     <i>K </i>= 0, <i>D </i>= <i>Q </i>+ <i>Q </i>= 1,  so the next clock edge sets the output to 1. <br>When     <i>J </i>= 0     and     <i>K </i>= 1, <i>D </i>= 0,  so the next clock edge resets the output to 0. When <br>both     <i>J </i>= <i>K </i>= 1     and     <i>D </i>= <i>Q </i>,  the next clock edge complements the output. When both <br> <i>J </i>= <i>K </i>= 0     and     <i>D </i>= <i>Q</i>,  the clock edge leaves the output unchanged. The graphic sym-<br>bol for the  <i>JK</i>  flip-flop is shown in  Fig.   5.12  (b). It is similar to the graphic symbol of the <br> <br><i>D</i>  flip-flop, except that now the inputs are marked  <i>J</i>  and  <i>K</i> . <br>
 The   <i>T</i>  (toggle) flip-flop is a complementing flip-flop and can be obtained from a  <i>JK</i> <br>
flip-flop when inputs  <i>J</i>  and  <i>K</i>  are tied together. This is shown in  Fig.   5.13  (a). When <br>
<hr>
<A name=219></a><b>Section 5.4  Storage Elements: Flip-Flops    201</b><br>
<i>J</i><br>
<i>D</i><br>
<i>Q</i><br>
<i>J</i><br>
<i>K</i><br>
<i>Clk</i><br>
<i>Clk</i><br>
<i>Clk</i><br>
<i>Q</i><br>
<i>K</i><br>
(a) Circuit diagram<br>
(b) Graphic symbol<br>
<b> <br>FIGURE 5.12   <br> <br><i>JK</i>  flip-flop  </b><br>
<i>T</i><br>
<i>J</i><br>
<i>D</i><br>
<i>T</i><br>
<i>T</i><br>
<i>Clk</i><br>
<i>K</i><br>
<i>Clk</i><br>
<i>Clk</i><br>
(a) From <i>JK </i>flip-flop<br>
(b) From <i>D </i>flip-flop<br>
(c) Graphic symbol<br>
 <br><b>FIGURE 5.13 <br> <br><i>T</i>  flip-flop  </b><br>
 <br><i>T </i>= 0 (<i>J </i>= <i>K </i>= 0),  a clock edge does not change the output. When   <i>T </i>= 1 (<i>J </i>= <i>K </i>= 1),    <br>a clock edge complements the output. The complementing flip-flop is useful for design-<br>ing binary counters. <br>
 The   <i>T</i>  flip-flop can be constructed with a  <i>D</i>  flip-flop and an exclusive-OR gate as <br>
shown in  Fig.   5.13  (b). The expression for the  <i>D</i>  input is <br>
 <br><i>D </i>= <i>T </i>{ <i>Q </i>= <i>TQ </i>+ <i>T Q</i> <br>
 When     <i>T </i>= 0, <i>D </i>= <i>Q</i>  and there is no change in the output. When   <i>T </i>= 1, <i>D </i>= <i>Q </i> and <br>the output complements. The graphic symbol for this flip-flop has a  <i>T</i>  symbol in the input. <br>
<b> <br>Characteristic Tables </b><br>
 <br>A characteristic table defines the logical properties of a flip-flop by describing its oper-<br>ation in tabular form. The characteristic tables of three types of flip-flops are presented <br>in  Table   5.1 . They define the next state (i.e., the state that results from a clock transition) <br>
<hr>
<A name=220></a><b>202    Chapter 5  Synchronous Sequential Logic</b><br>
<b> <br>Table 5.1 <br><i> <br>Flip-Flop Characteristic Tables </b></i><br>
<b> <br><i>JK</i>  Flip-Flop </b><br>
<i><b> <br>J  </b></i><br>
<i><b> <br>K  </b></i><br>
<b> <br><i>Q</i>(<i>t</b></i><br>
<b>1)   </b><br>
 0 <br>
 0 <br>
  <br><i>Q</i> ( <i>t</i> ) <br>
 No  change <br>
 0 <br>
 1 <br>
 0 <br>
 Reset <br>
 1 <br>
 0 <br>
 1 <br>
 Set <br>
 1 <br>
 1 <br>
 <br><i>Q </i>(<i>t</i>)    <br>
 Complement <br>
<b> <br><i>D</i>  Flip-Flop </b><br>
<b> <br><i>T</i>  Flip-Flop </b><br>
<i><b> <br>D  </b></i><br>
<b> <br><i>Q</i>(<i>t</b></i><br>
<b>1)   </b><br>
<i><b> <br>T  </b></i><br>
<b> <br><i>Q</i>(<i>t</b></i><br>
<b>1)   </b><br>
 0 <br>
 0 <br>
 Reset <br>
 0 <br>
  <br><i>Q</i> ( <i>t</i> ) <br>
 No  change <br>
 1 <br>
 1 <br>
 Set <br>
 1 <br>
 <br><i>Q </i>(<i>t</i>)    <br>
 Complement <br>
as a function of the inputs and the present state.  <i>Q</i> ( <i>t</i> ) refers to the present state (i.e., the <br>state present prior to the application of a clock edge).   <i>Q</i>(<i>t </i>+ 1)  is the next state one <br>clock period later. Note that the clock edge input is not included in the characteristic <br>table, but is implied to occur between times  <i>t</i>   and     <i>t </i>+ 1. Thus,  <i>Q(t)</i>  denotes the state of <br>the flip-flop immediately before the clock edge, and   <i>Q</i>(<i>t </i>+ 1)  denotes the state that <br>results from the clock transition. <br>
 <br>The characteristic table for the  <i>JK</i>  flip-flop shows that the next state is equal to the <br>
present state when inputs  <i>J</i>  and  <i>K</i>  are both equal to 0. This condition can be expressed <br>as     <i>Q</i>(<i>t </i>+ 1) = <i>Q</i>(<i>t</i>),  indicating that the clock produces no change of state. When   <i>K </i>= 1    <br>and     <i>J </i>= 0,  the clock resets the flip-flop and   <i>Q</i>(<i>t </i>+ 1) = 0.     With     <i>J </i>= 1     and     <i>K </i>= 0,     the <br>flip-flop sets and   <i>Q</i>(<i>t </i>+ 1) = 1.     When  both   <i>J</i>  and  <i>K</i>  are equal to 1, the next state changes <br>to the complement of the present state, a transition that can be expressed as <br> <br><i>Q</i>(<i>t </i>+ 1) = <i>Q </i>(<i>t</i>). <br>
 <br>The next state of a  <i>D</i>  flip-flop is dependent only on the  <i>D</i>  input and is independent <br>
of the present state. This can be expressed as   <i>Q</i>(<i>t </i>+ 1) = <i>D</i>.  It means that the next-state <br>value is equal to the value of  <i>D</i> . Note that the  <i>D</i>  flip-flop does not have a "no-change" <br>condition. Such a condition can be accomplished either by disabling the clock or by <br>operating the clock by having the output of the flip-flop connected into the  <i>D</i>   input. <br>Either method effectively circulates the output of the flip-flop when the state of the <br>flip-flop must remain unchanged. <br>
 <br>The characteristic table of the  <i>T</i>  flip-flop has only two conditions: When   <i>T </i>= 0,     the <br>
clock edge does not change the state; when   <i>T </i>= 1,  the clock edge complements the state <br>of the flip-flop. <br>
<hr>
<A name=221></a><b>Section 5.4  Storage Elements: Flip-Flops    203</b><br>
<b> <br>Characteristic Equations </b><br>
 <br>The logical properties of a flip-flop, as described in the characteristic table, can be <br>expressed algebraically with a characteristic equation. For the  <i>D</i>  flip-flop, we have the <br>characteristic equation <br>
 <br><i>Q</i>(<i>t </i>+ 1) = <i>D</i> <br>
 <br>which states that the next state of the output will be equal to the value of input  <i>D</i>  in the <br>present state. The characteristic equation for the  <i>JK</i>  flip-flop can be derived from the <br>characteristic table or from the circuit of  Fig.   5.12  . We obtain <br>
 <br><i>Q</i>(<i>t </i>+ 1) = <i>JQ </i>+ <i>K Q</i> <br>
 where   <i>Q</i>  is the value of the flip-flop output prior to the application of a clock edge. The <br>characteristic equation for the  <i>T</i>  flip-flop is obtained from the circuit of  Fig.   5.13  : <br>
 <br><i>Q</i>(<i>t </i>+ 1) = <i>T </i>{ <i>Q </i>= <i>TQ </i>+ <i>T Q</i> <br>
<b> <br>Direct Inputs </b><br>
 <br>Some flip-flops have asynchronous inputs that are used to force the flip-flop to a par-<br>ticular state independently of the clock. The input that sets the flip-flop to 1 is called <br> <br><i>preset</i>  or  <i>direct set</i> . The input that clears the flip-flop to 0 is called  <i>clear</i>  or  <i>direct reset</i> . <br>When power is turned on in a digital system, the state of the flip-flops is unknown. The <br>direct inputs are useful for bringing all flip-flops in the system to a known starting state <br>prior to the clocked operation. <br>
 <br>A positive-edge-triggered  <i>D</i>  flip-flop with active-low asynchronous reset is shown <br>
in  Fig.   5.14  . The circuit diagram is the same as the one in  Fig.   5.10  , except for the <br>additional reset input connections to three NAND gates. When the reset input is 0, <br>it forces output   <i>Q </i>  to stay at 1, which, in turn, clears output  <i>Q</i>  to 0, thus resetting the <br>flip-flop. Two other connections from the reset input ensure that the  <i>S</i>  input of the <br>third  <i>SR</i>  latch stays at logic 1 while the reset input is at 0, regardless of the values of <br> <br><i>D</i>  and  <i>Clk</i> . <br>
 <br>The graphic symbol for the  <i>D</i>  flip-flop with a direct reset has an additional input <br>
marked with  <i>R</i> . The bubble along the input indicates that the reset is active at the logic-0 <br>level. Flip-flops with a direct set use the symbol  <i>S</i>  for the asynchronous set input. <br>
 <br>The function table specifies the operation of the circuit. When   <i>R </i>= 0,     the  output <br>
is reset to 0. This state is independent of the values of  <i>D</i>  or  <i>Clk</i> . Normal clock opera-<br>tion can proceed only after the reset input goes to logic 1. The clock at  <i>Clk</i>  is shown <br>with an upward arrow to indicate that the flip-flop triggers on the positive edge of <br>the clock. The value in  <i>D</i>  is transferred to  <i>Q</i>  with every positive-edge clock signal, <br>provided that   <i>R </i>= 1.     <br>
<hr>
<A name=222></a><b>204    Chapter 5  Synchronous Sequential Logic</b><br>
<i>S</i><br>
<i>Q</i><br>
<i>Clock</i><br>
<i>R</i><br>
<i>Q</i><br>
<i>D</i><br>
<i>Reset</i><br>
(a) Circuit diagram<br>
<i>Data</i><br>
<i>D</i><br>
<i>Q</i><br>
<i>R</i><br>
<i>Clk</i><br>
<i>D</i><br>
<i>Q Q</i><br>
<i>Clock</i><br>
<i>Clk</i><br>
<i>Q</i><br>
0<br>
X<br>
X<br>
0<br>
1<br>
<i>R</i><br>
0<br>
0<br>
0<br>
1<br>
0<br>
1<br>
1<br>
0<br>
<i>Reset</i><br>
(b) Graphic symbol<br>
(b) Function table<br>
<b> <br>FIGURE 5.14 <br> <br><i>D</i>  flip-flop with asynchronous reset  </b><br>
<b> <br>5 . 5       A N A L Y S I S   O F   C L O C K E D </b><br>
<b>S E Q U E N T I A L   C I R C U I T S </b><br>
 <br>Analysis describes what a given circuit will do under certain operating conditions. The <br>behavior of a clocked sequential circuit is determined from the inputs, the outputs, and <br>the state of its flip-flops. The outputs and the next state are both a function of the inputs <br>and the present state. The analysis of a sequential circuit consists of obtaining a table or <br>a diagram for the time sequence of inputs, outputs, and internal states. It is also possible <br>
<hr>
<A name=223></a><b>Section 5.5    Analysis of Clocked Sequential Circuits         205</b><br>
to write Boolean expressions that describe the behavior of the sequential circuit. These <br>expressions must include the necessary time sequence, either directly or indirectly. <br>
 <br>A logic diagram is recognized as a clocked sequential circuit if it includes flip-flops <br>
with clock inputs. The flip-flops may be of any type, and the logic diagram may or may <br>not include combinational logic gates. In this section, we introduce an algebraic repre-<br>sentation for specifying the next-state condition in terms of the present state and inputs. <br>A state table and state diagram are then presented to describe the behavior of the <br>sequential circuit. Another algebraic representation is introduced for specifying the logic <br>diagram of sequential circuits. Examples are used to illustrate the various procedures. <br>
<b> <br>State Equations </b><br>
 <br>The behavior of a clocked sequential circuit can be described algebraically by means of <br>state equations. A  <i>state equation</i>  (also called a  <i>transition equation</i> ) specifies the next <br>state as a function of the present state and inputs. Consider the sequential circuit shown <br>in  Fig.   5.15  . We will later show that it acts as a 0-detector by asserting its output when a <br>
<i>x</i><br>
<i>x</i><br>
<i>D</i><br>
<i>A</i><br>
<i>Clk</i><br>
<i>A</i><br>
<i>y</i><br>
<i>D</i><br>
<i>B</i><br>
<i>Clk</i><br>
<i>B</i><br>
<i>Clock</i><br>
<i>y</i><br>
<b> <br>FIGURE 5.15 <br> <br>Example of sequential circuit  </b><br>
<hr>
<A name=224></a><b>206    Chapter 5  Synchronous Sequential Logic</b><br>
0 is detected in a stream of 1s. It consists of two  <i>D</i>  flip-flops  <i>A</i>  and  <i>B,</i>  an input  <i>x</i>  and an <br>output  <i>y</i> . Since the  <i>D</i>  input of a flip-flop determines the value of the next state (i.e., the <br>state reached after the clock transition), it is possible to write a set of state equations <br>for the circuit:  <br>
 <br><i>A</i>(<i>t </i>+ 1) = <i>A</i>(<i>t</i>)<i>x</i>(<i>t</i>) + <i>B</i>(<i>t</i>)<i>x</i>(<i>t</i>)<br>
 <br><i>B</i>(<i>t </i>+ 1) = <i>A </i>(<i>t</i>)<i>x</i>(<i>t</i>)<br>
 <br>
 <br>A state equation is an algebraic expression that specifies the condition for a flip-flop <br>state transition. The left side of the equation, with   (<i>t </i>+ 1),  denotes the next state of the <br>flip-flop one clock edge later. The right side of the equation is a Boolean expression that <br>specifies the present state and input conditions that make the next state equal to 1. Since <br>all the variables in the Boolean expressions are a function of the present state, we can <br>omit the designation ( <i>t</i> ) after each variable for convenience and can express the state <br>equations in the more compact form <br>
 <i>A</i>(<i>t </i>+ 1) - <i>Ax </i>+ <i>Bx<br>B</i>(<i>t </i>+ 1) - <i>A x</i><br>
 <br>
 <br>The Boolean expressions for the state equations can be derived directly from the gates <br>that form the combinational circuit part of the sequential circuit, since the  <i>D</i>  values of <br>the combinational circuit determine the next state. Similarly, the present-state value of <br>the output can be expressed algebraically as <br>
 <i>y</i>(<i>t</i>) = [<i>A</i>(<i>t</i>) + <i>B</i>(<i>t</i>)]<i>x </i>(<i>t</i>)   <br>
 <br>By removing the symbol  <i>(t)</i>  for the present state, we obtain the output Boolean equation: <br>
 <i>y </i>= (<i>A </i>+ <i>B</i>)<i>x </i> <br>
<b> <br>State Table </b><br>
 <br>The time sequence of inputs, outputs, and flip-flop states can be enumerated in a  <i>state <br>table</i>  (sometimes called a  <i>transition table</i> ). The state table for the circuit of  Fig.   5.15   is <br>shown in  Table   5.2  . The table consists of four sections labeled  <i>present state</i>,<i> input</i>,<i> next <br>state</i>,  and  <i>output</i> . The present-state section shows the states of flip-flops  <i>A</i>  and  <i>B</i>   at <br>any given time  <i>t</i> . The input section gives a value of  <i>x</i>  for each possible present state. <br>The next-state section shows the states of the flip-flops one clock cycle later, at time <br> <br><i>t </i>+ 1. The output section gives the value of  <i>y</i>  at time  <i>t</i>  for each present state and input <br>condition. <br>
 <br>The derivation of a state table requires listing all possible binary combinations of <br>
present states and inputs. In this case, we have eight binary combinations from 000 to <br>111. The next-state values are then determined from the logic diagram or from the state <br>equations. The next state of flip-flop  <i>A</i>  must satisfy the state equation <br>
 <i>A</i>(<i>t </i>+ 1) = <i>Ax </i>+ <i>Bx</i> <br>
<hr>
<A name=225></a><b>Section 5.5    Analysis of Clocked Sequential Circuits         207</b><br>
<b> <br>Table 5.2 <br><i> <br>State Table for the Circuit of  Fig.   5.15  </b></i><br>
<b> <br>Present </b><br>
<b> </b><br>
<b> <br>Next </b><br>
<b>State </b><br>
<b>Input </b><br>
<b>State </b><br>
<b> <br>Output </b><br>
<b> <br><i>A</i> </b><br>
<b> <br><i>B</i> </b><br>
<b> <br><i>x</i> </b><br>
<b> <br><i>A</i> </b><br>
<b> <br><i>B</i> </b><br>
<b> <br><i>y</i> </b><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 <br>The next-state section in the state table under column  <i>A</i>  has three 1's where the present <br>state of  <i>A</i>  and input  <i>x</i>  are both equal to 1 or the present state of  <i>B</i>  and input  <i>x</i>   are  both <br>equal to 1. Similarly, the next state of flip-flop  <i>B</i>  is derived from the state equation <br>
 <br><i>B</i>(<i>t </i>+ 1) = <i>A x</i> <br>
 <br>and is equal to 1 when the present state of  <i>A</i>  is 0 and input  <i>x</i>  is equal to 1. The output <br>column is derived from the output equation <br>
 <i>y </i>= <i>Ax </i>+ <i>Bx </i> <br>
 <br>The state table of a sequential circuit with  <i>D</i> -type flip-flops is obtained by the same <br>
procedure outlined in the previous example. In general, a sequential circuit with  <i>m</i>   flip-<br>flops and  <i>n</i>  inputs needs   2<i>m</i>+<i>n</i>  rows in the state table. The binary numbers from 0 through <br> <br>2<i>m</i>+<i>n </i>- 1  are listed under the present-state and input columns. The next-state section <br>has  <i>m</i>  columns, one for each flip-flop. The binary values for the next state are derived <br>directly from the state equations. The output section has as many columns as there are <br>output variables. Its binary value is derived from the circuit or from the Boolean func-<br>tion in the same manner as in a truth table. <br>
 <br>It is sometimes convenient to express the state table in a slightly different form hav-<br>
ing only three sections: present state, next state, and output. The input conditions are <br>enumerated under the next-state and output sections. The state table of  Table   5.2   is <br>repeated in  Table   5.3   in this second form. For each present state, there are two possible <br>next states and outputs, depending on the value of the input. One form may be prefer-<br>able to the other, depending on the application. <b> </b><br>
<b> <br>State Diagram </b><br>
 <br>The information available in a state table can be represented graphically in the form <br>of a state diagram. In this type of diagram, a state is represented by a circle, and the <br>(clock-triggered) transitions between states are indicated by directed lines connecting <br>
<hr>
<A name=226></a><b>208    Chapter 5  Synchronous Sequential Logic</b><br>
<b> <br>Table 5.3 <br><i> <br>Second Form of the State Table </b></i><br>
<b> </b><br>
<b> <br>Next State </b><br>
<b> <br>Output </b><br>
<b>Present </b><br>
<b>State </b><br>
<b> <br><i>x</i>  = 0        <i>x</i>  = 1 </b><br>
<b> <br><i>x</i>  = 0     <i>x</i>  = 1 </b><br>
<b> <br><i>A</i> </b><br>
<b> <br><i>B</i> </b><br>
<b> <br><i>A</i>   <i>B</i> </b><br>
<b> <br><i>A</i>   <i>B</i> </b><br>
<b> <br><i>y</i> </b><br>
<b> <br><i>y</i> </b><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
0/0<br>
0/1<br>
1/0<br>
00<br>
10<br>
1/0<br>
0/1<br>
0/1<br>
1/0<br>
1/0<br>
01<br>
11<br>
<b> <br>FIGURE 5.16 <br> <br>State diagram of the circuit of  Fig.   5.15  </b><br>
the circles. The state diagram of the sequential circuit of  Fig.   5.15   is shown in  Fig.   5.16  . <br>The state diagram provides the same information as the state table and is obtained <br>directly  from   Table    5.2     or   Table    5.3   .  The  binary  number  inside  each  circle  identifies  the <br>state of the flip-flops. The directed lines are labeled with two binary numbers separated <br>by a slash. The input value during the present state is labeled first, and the number after <br>the slash gives the output during the present state with the given input. (It is important <br>to remember that the bit value listed for the output along the directed line occurs dur-<br>ing the present state and with the indicated input, and has nothing to do with the <br>transition to the next state.) For example, the directed line from state 00 to 01 is labeled <br>1/0, meaning that when the sequential circuit is in the present state 00 and the input is <br>1, the output is 0. After the next clock cycle, the circuit goes to the next state, 01. If the <br>input changes to 0, then the output becomes 1, but if the input remains at 1, the output <br>stays at 0. This information is obtained from the state diagram along the two directed <br>lines emanating from the circle with state 01. A directed line connecting a circle with <br>itself indicates that no change of state occurs. <br>
 <br>The steps presented in this example are summarized below: <br>
 Circuit  diagram  S  Equations � State table  S  State diagram <br>
<hr>
<A name=227></a><b>Section 5.5    Analysis of Clocked Sequential Circuits         209</b><br>
 <br>This sequence of steps begins with a structural representation of the circuit and proceeds <br>to an abstract representation of its behavior. An HDL model can be in the form of a <br>gate-level description or in the form of a behavioral description. It is important to note <br>that a gate-level approach requires that the designer understands how to select and <br>connect gates and flip-flops to form a circuit having a particular behavior. That under-<br>standing comes with experience. On the other hand, an approach based on behavioral <br>modeling does not require the designer to know how to invent a schematic--the designer <br>needs only to know how to describe behavior using the constructs of the HDL, because <br>the circuit is produced automatically by a synthesis tool. Therefore, one does not have <br>to accumulate years of experience in order to become a productive designer of digital <br>circuits; nor does one have to acquire an extensive background in electrical engineering. <br>
 <br>There is no difference between a state table and a state diagram, except in the manner <br>
of representation. The state table is easier to derive from a given logic diagram and the <br>state equation. The state diagram follows directly from the state table.  <i>The state diagram <br>gives a pictorial view of state transitions and is the form more suitable for human interpre-<br>tation of the circuit's operation</i> . For example, the state diagram of  Fig.   5.16   clearly shows <br>that, starting from state 00, the output is 0 as long as the input stays at 1. The first 0 input <br>after a string of 1's gives an output of 1 and transfers the circuit back to the initial state, <br>00. The machine represented by this state diagram acts to detect a zero in the bit stream <br>of data. It corresponds to the behavior of the circuit in  Fig.   5.15.  Other circuits that detect <br>a zero in a stream of data may have a simpler circuit diagram and state diagram. <br>
<b> <br>Flip-Flop Input Equations </b><br>
 <br>The logic diagram of a sequential circuit consists of flip-flops and gates. The interconnec-<br>tions among the gates form a combinational circuit and may be specified algebraically <br>with Boolean expressions. The knowledge of the type of flip-flops and a list of the Bool-<br>ean expressions of the combinational circuit provide the information needed to draw the <br>logic diagram of the sequential circuit. The part of the combinational circuit that gener-<br>ates external outputs is described algebraically by a set of Boolean functions called <br> <br><i>output equations</i> .The part of the circuit that generates the inputs to flip-flops is described <br>algebraically by a set of Boolean functions called flip-flop  <i>input equations</i>  (or, sometimes, <br> <br><i>excitation equations</i> ). We will adopt the convention of using the flip-flop input symbol to <br>denote the input equation variable and a subscript to designate the name of the flip-flop <br>output. For example, the following input equation specifies an OR gate with inputs  <i>x</i>   and <br> <br><i>y</i>  connected to the  <i>D</i>  input of a flip-flop whose output is labeled with the symbol  <i>Q</i> : <br>
 <br><i>DQ </i>= <i>x </i>+ <i>y</i> <br>
 <br>The sequential circuit of  Fig.   5.15   consists of two  <i>D</i>  flip-flops  <i>A</i>  and  <i>B</i>,  an input  <i>x</i>,   and <br>
an output  <i>y</i> . The logic diagram of the circuit can be expressed algebraically with two <br>flip-flop input equations and an output equation: <br>
 <br><i>DA </i>= <i>Ax </i>+ <i>Bx</i><br>
 <br><i>DB </i>= <i>A x</i><br>
 <br><i>y </i>= (<i>A </i>+ <i>B</i>)<i>x </i> <br>
<hr>
<A name=228></a><b>210    Chapter 5  Synchronous Sequential Logic</b><br>
 <br>The three equations provide the necessary information for drawing the logic diagram <br>of the sequential circuit. The symbol   <i>DA</i>     specifies  a   <i>D</i>  flip-flop labeled  <i>A</i> .  <i>DB</i>     specifies <br>a second  <i>D</i>  flip-flop labeled  <i>B</i> . The Boolean expressions associated with these two vari-<br>ables and the expression for output  <i>y</i>  specify the combinational circuit part of the <br>sequential circuit. <br>
 <br>The flip-flop input equations constitute a convenient algebraic form for specifying <br>
the logic diagram of a sequential circuit. They imply the type of flip-flop from the letter <br>symbol, and they fully specify the combinational circuit that drives the flip-flops. Note <br>that the expression for the input equation for a  <i>D</i>  flip-flop is identical to the expression <br>for the corresponding state equation. This is because of the characteristic equation that <br>equates the next state to the value of the  <i>D</i>   input:     <i>Q</i>(<i>t </i>+ 1) = <i>DQ</i>. <br>
<b> <br>Analysis with  <i>D</i>  Flip-Flops </b><br>
 <br>We will summarize the procedure for analyzing a clocked sequential circuit with  <i>D</i>   flip-<br>flops by means of a simple example. The circuit we want to analyze is described by the <br>input equation <br>
 <br><i>DA </i>= <i>A </i>{ <i>x </i>{ <i>y</i> <br>
 The     <i>DA</i>  symbol implies a  <i>D</i>  flip-flop with output  <i>A</i> .  The   <i>x</i>  and  <i>y</i>  variables are the inputs <br>to the circuit. No output equations are given, which implies that the output comes from <br>the output of the flip-flop. The logic diagram is obtained from the input equation and is <br>drawn  in   Fig.    5.17   (a). <br>
 <br>The state table has one column for the present state of flip-flop  <i>A</i>,  two columns for <br>
the two inputs, and one column for the next state of  <i>A</i> . The binary numbers under  <i>Axy</i> <br>are listed from 000 through 111 as shown in  Fig.   5.17  (b). The next-state values are <br>obtained from the state equation <br>
 <i>A</i>(<i>t </i>+ 1) = <i>A </i>{ <i>x </i>{ <i>y</i> <br>
 <br>The expression specifies an odd function and is equal to 1 when only one variable is 1 <br>or when all three variables are 1. This is indicated in the column for the next state of  <i>A</i> . <br>
 <br>The circuit has one flip-flop and two states. The state diagram consists of two circles, <br>
one for each state as shown in  Fig.   5.17  (c). The present state and the output can be either <br>0 or 1, as indicated by the number inside the circles. A slash on the directed lines is not <br>needed, because there is no output from a combinational circuit. The two inputs can <br>have four possible combinations for each state. Two input combinations during each <br>state transition are separated by a comma to simplify the notation. <br>
<b> <br>Analysis with  <i>JK</i>  Flip-Flops </b><br>
 <br>A state table consists of four sections: present state, inputs, next state, and outputs. The <br>first two are obtained by listing all binary combinations. The output section is deter-<br>mined from the output equations. The next-state values are evaluated from the state <br>equations. For a  <i>D</i> -type flip-flop, the state equation is the same as the input equation. <br>When a flip-flop other than the  <i>D</i>  type is used, such as  <i>JK</i>  or  <i>T</i>,  it is necessary to refer <br>
<hr>
<A name=229></a><b>Section 5.5    Analysis of Clocked Sequential Circuits         211</b><br>
Present<br>
Next<br>
state<br>
Inputs state<br>
<i>A</i><br>
<i>x y</i><br>
<i>A</i><br>
0<br>
0 0<br>
0<br>
0<br>
0 1<br>
1<br>
<i>x</i><br>
<i>D</i><br>
<i>A</i><br>
0<br>
1 0<br>
1<br>
<i>y</i><br>
0<br>
1 1<br>
0<br>
<i>Clk</i><br>
1<br>
0 0<br>
1<br>
1<br>
0 1<br>
0<br>
1<br>
1 0<br>
0<br>
1<br>
1 1<br>
1<br>
<i>Clock</i><br>
(a) Circuit diagram<br>
(b) State table<br>
01, 10<br>
00, 11<br>
00, 11<br>
0<br>
1<br>
01, 10<br>
(c) State diagram<br>
<b> <br>FIGURE 5.17 <br> <br>Sequential circuit with <i>D</i> flip-flop  </b><br>
to the corresponding characteristic table or characteristic equation to obtain the next-<br>state values. We will illustrate the procedure first by using the characteristic table and <br>again by using the characteristic equation. <br>
 <br>The next-state values of a sequential circuit that uses  <i>JK</i> - or  <i>T</i> -type flip-flops can be <br>
derived as follows: <br>
 <br><b> 1. </b><br>
 <br>Determine the flip-flop input equations in terms of the present state and input <br>variables.  <br>
 <br><b> 2. </b><br>
 <br>List the binary values of each input equation. <br>
 <br><b> 3. </b><br>
 <br>Use the corresponding flip-flop characteristic table to determine the next-state <br>values in the state table. <br>
 <br>As an example, consider the sequential circuit with two  <i>JK</i>  flip-flops  <i>A</i>  and  <i>B</i>   and <br>
one input  <i>x</i>,  as shown in  Fig.   5.18  . The circuit has no outputs; therefore, the state table <br>does not need an output column. (The outputs of the flip-flops may be considered as <br>the outputs in this case.) The circuit can be specified by the flip-flop input equations <br>
 <br><i>JA </i>= <i>B KA </i>= <i>Bx</i><br>
 <br><i>JB </i>= <i>x</i><br>
 <i>KB </i>= <i>A x </i>+ <i>Ax </i>= <i>A</i><br>
<i>x</i> <br>
 <br>The state table of the sequential circuit is shown in  Table   5.4  . The present-state and <br>
input columns list the eight binary combinations. The binary values listed under the <br>
<hr>
<A name=230></a><b>212    Chapter 5  Synchronous Sequential Logic</b><br>
<i>J</i><br>
<i>A</i><br>
<i>Clk</i><br>
<i>x</i><br>
<i>K</i><br>
<i>J</i><br>
<i>B</i><br>
<i>Clk</i><br>
<i>K</i><br>
<i>Clock</i><br>
<b> <br>FIGURE 5.18 <br> <br>Sequential circuit with  <i>JK</i>  flip-flop  </b><br>
columns labeled  <i>flip-flop inputs</i>  are not part of the state table, but they are needed for <br>the purpose of evaluating the next state as specified in step 2 of the procedure. These <br>binary values are obtained directly from the four input equations in a manner similar <br>to that for obtaining a truth table from a Boolean expression. The next state of each <br>flip-flop is evaluated from the corresponding  <i>J</i>  and  <i>K</i>  inputs and the characteristic table <br>of the  <i>JK</i>  flip-flop listed in  Table   5.1 . There are four cases to consider. When   <i>J </i>= 1     and <br>
<b> <br>Table 5.4 <br><i> <br>State Table for Sequential Circuit with JK Flip-Flops </b></i><br>
<b> <br>Present </b><br>
<b> <br>Next </b><br>
<b> <br>Flip-Flop </b><br>
<b>State </b><br>
<b> <br>Input </b><br>
<b>State </b><br>
<b>Inputs </b><br>
<b> <br><i>A</i> </b><br>
<b> <br><i>B</i> </b><br>
<b> <br><i>x</i> </b><br>
<b> <br><i>A</i> </b><br>
<b> <br><i>B</i> </b><br>
<b> <br><i>J A </b></i><br>
<b> <br><i>K A </b></i><br>
<b> <br><i>J B </b></i><br>
<b> <br><i>K B </b></i><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
<hr>
<A name=231></a><b>Section 5.5    Analysis of Clocked Sequential Circuits         213</b><br>
 <br><i>K </i>= 0,  the next state is 1. When   <i>J </i>= 0     and     <i>K </i>= 1,  the next state is 0. When   <i>J </i>= <i>K </i>= 0, <br>there is no change of state and the next-state value is the same as that of the present <br>state.  When     <i>J </i>= <i>K </i>= 1,  the next-state bit is the complement of the present-state bit. <br>Examples of the last two cases occur in the table when the present state  <i>AB</i>  is 10 and <br>input  <i>x</i>  is 0.  <i>JA</i>  and  <i>KA</i>  are both equal to 0 and the present state of  <i>A</i>  is 1. Therefore, the <br>next state of  <i>A</i>  remains the same and is equal to 1. In the same row of the table,  <i>JB</i>   and <br> <br><i>KB</i>  are both equal to 1. Since the present state of  <i>B</i>  is 0, the next state of  <i>B</i>  is comple-<br>mented and changes to 1. <br>
 <br>The next-state values can also be obtained by evaluating the state equations from the <br>
characteristic equation. This is done by using the following procedure: <br>
 <br><b> 1. </b><br>
 <br>Determine the flip-flop input equations in terms of the present state and input <br>variables.  <br>
 <br><b> 2. </b><br>
 <br>Substitute the input equations into the flip-flop characteristic equation to obtain <br>the state equations. <br>
 <br><b> 3. </b><br>
 <br>Use the corresponding state equations to determine the next-state values in the <br>state  table.   <br>
 <br>The input equations for the two  <i>JK</i>  flip-flops of  Fig.   5.18   were listed a couple of para-<br>
graphs ago. The characteristic equations for the flip-flops are obtained by substituting <br> <br><i>A</i>  or  <i>B</i>  for the name of the flip-flop, instead of  <i>Q</i> : <br>
 <br><i>A</i>(<i>t </i>+ 1) = <i>JA </i>+ <i>K A</i><br>
 <br><i>B</i>(<i>t </i>+ 1) = <i>JB </i>+ <i>K B</i> <br>
 <br>Substituting the values of   <i>JA</i>     and     <i>KA</i>  from the input equations, we obtain the state equa-<br>tion for  <i>A</i> : <br>
 <i>A</i>(<i>t </i>+ 1) = <i>BA </i>+ (<i>Bx </i>)  <i>A </i>= <i>A B </i>+ <i>AB </i>+ <i>Ax</i> <br>
 <br>The state equation provides the bit values for the column headed "Next State" for  <i>A</i>   in <br>the state table. Similarly, the state equation for flip-flop  <i>B</i>  can be derived from the char-<br>acteristic equation by substituting the values of   <i>JB</i>     and     <i>KB</i>:    <br>
 <br><i>B</i>(<i>t </i>+ 1) = <i>x B </i>+ (<i>A </i>{ <i>x</i>) <i>B </i>= <i>B x </i>+ <i>ABx </i>+ <i>A Bx </i> <br>
 <br>The state equation provides the bit values for the column headed "Next State" for  <i>B</i>   in <br>the state table. Note that the columns in  Table   5.4   headed "Flip-Flop Inputs" are not <br>needed when state equations are used. <br>
 <br>The state diagram of the sequential circuit is shown in  Fig.   5.19  . Note that since the <br>
circuit has no outputs, the directed lines out of the circles are marked with one binary <br>number only, to designate the value of input  <i>x</i> .  <br>
<b> <br>Analysis with  <i>T</i>  Flip-Flops </b><br>
 <br>The analysis of a sequential circuit with  <i>T</i>  flip-flops follows the same procedure outlined <br>for  <i>JK</i>  flip-flops. The next-state values in the state table can be obtained by using either <br>
<hr>
<A name=232></a><b>214    Chapter 5  Synchronous Sequential Logic</b><br>
1<br>
1<br>
0<br>
<i>S0 </i>00<br>
11 <i>S3</i><br>
0<br>
0<br>
0<br>
<i>S1 </i>01<br>
10 <i>S2</i><br>
1<br>
1<br>
<b> <br>FIGURE 5.19 <br> <br>State diagram of the circuit of  Fig.   5.18  </b><br>
the characteristic table listed in  Table   5.1   or the characteristic equation <br>
 <br><i>Q</i>(<i>t </i>+ 1) = <i>T </i>{ <i>Q </i>= <i>T Q </i>+ <i>TQ </i> <br>
 <br>Now consider the sequential circuit shown in  Fig.   5.20  . It has two flip-flops  <i>A</i>  and  <i>B,</i>   one <br>input  <i>x,</i>  and one output  <i>y</i>  and can be described algebraically by two input equations and <br>an output equation: <br>
 <br><i>TA </i>= <i>Bx</i><br>
 <br><i>TB </i>= <i>x</i><br>
 <br><i>y </i>= <i>AB</i> <br>
 <br>The state table for the circuit is listed in  Table   5.5  . The values for  <i>y</i>  are obtained from <br>the output equation. The values for the next state can be derived from the state equa-<br>tions by substituting   <i>TA</i>     and     <i>TB</i>  in the characteristic equations, yielding <br>
 <br><i>A</i>(<i>t </i>+ 1) = (<i>Bx</i>) <i>A </i>+ (<i>Bx</i>)<i>A </i>= <i>AB </i>+ <i>Ax </i>+ <i>A Bx</i><br>
 <br><i>B</i>(<i>t </i>+ 1) = <i>x</i><br>
<i>B</i><br>
 <br> <br>
 <br>The next-state values for  <i>A</i>  and  <i>B</i>  in the state table are obtained from the expressions <br>of the two state equations. <br>
 <br>The state diagram of the circuit is shown in  Fig.   5.20  (b). As long as input  <i>x</i>  is equal to 1, the <br>
circuit behaves as a binary counter with a sequence of states 00, 01, 10, 11, and back to 00. <br>When     <i>x </i>= 0,  the circuit remains in the same state. Output  <i>y</i>  is equal to 1 when the present <br>state is 11. Here, the output depends on the present state only and is independent of the input. <br>The two values inside each circle and separated by a slash are for the present state and output. <br>
<b> <br>Mealy and Moore Models of Finite State Machines </b><br>
 <br>The most general model of a sequential circuit has inputs, outputs, and internal states. It <br>is customary to distinguish between two models of sequential circuits: the Mealy model <br>and the Moore model. Both are shown in  Fig.   5.21 .They differ only in the way the output <br>
<hr>
<A name=233></a><b>Section 5.5    Analysis of Clocked Sequential Circuits         215</b><br>
<i>x</i><br>
<i>A</i><br>
<i>T</i><br>
<i>y</i><br>
<i>Clk</i><br>
<i>R</i><br>
0<br>
0<br>
1<br>
<i>T</i><br>
00/0<br>
01/0<br>
<i>B</i><br>
<i>Clk</i><br>
1<br>
1<br>
<i>R</i><br>
11/1<br>
10/0<br>
1<br>
0<br>
0<br>
<i>Clock</i><br>
<i>reset</i><br>
(a) Circuit diagram<br>
(b) State diagram<br>
<b> <br>FIGURE 5.20 <br> <br>Sequential circuit with  <i>T</i>  flip-flops (Binary Counter)  </b><br>
<b> <br>Table 5.5 <br><i> <br>State Table for Sequential Circuit with T Flip-Flops </b></i><br>
<b> <br>Present </b><br>
<b> </b><br>
<b> <br>Next </b><br>
<b> </b><br>
<b>State </b><br>
<b>Input </b><br>
<b>State </b><br>
<b>Output </b><br>
<b> <br><i>A</i> </b><br>
<b> <br><i>B</i> </b><br>
<b> <br><i>x</i> </b><br>
<b> <br><i>A</i> </b><br>
<b> <br><i>B</i> </b><br>
<b> <br><i>y</i> </b><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
<hr>
<A name=234></a><b>216    Chapter 5  Synchronous Sequential Logic</b><br>
<i><b>Mealy Machine</b></i><br>
<i>Inputs</i><br>
<i>Next State</i><br>
<i>Output</i><br>
<i>State</i><br>
<i>Outputs</i><br>
<i>Combinational</i><br>
<i>Combinational</i><br>
<i>Register</i><br>
<i>(Mealy-type)</i><br>
<i>Logic</i><br>
<i>Logic</i><br>
<i>Clock</i><br>
(a)<br>
<i><b>Moore Machine</b></i><br>
<i>Inputs</i><br>
<i>Next State</i><br>
<i>Output</i><br>
<i>State</i><br>
<i>Outputs</i><br>
<i>Combinational</i><br>
<i>Combinational</i><br>
<i>Register</i><br>
<i>(Moore-type)</i><br>
<i>Logic</i><br>
<i>Logic</i><br>
<i>Clock</i><br>
(b)<br>
<b> <br>FIGURE 5.21 <br> <br>Block diagrams of Mealy and Moore state machines  </b><br>
is generated. In the Mealy model, the output is a function of both the present state and <br>the input. In the Moore model, the output is a function of only the present state. A circuit <br>may have both types of outputs. The two models of a sequential circuit are commonly <br>referred to as a finite state machine, abbreviated FSM. The Mealy model of a sequential <br>circuit is referred to as a Mealy FSM or Mealy machine. The Moore model is referred <br>to as a Moore FSM or Moore machine. <br>
 <br>The circuit presented previously in  Fig.   5.15   is an example of a Mealy machine. Out-<br>
put  <i>y</i>  is a function of both input  <i>x</i>  and the present state of  <i>A</i>  and  <i>B</i> .  The  corresponding <br>state diagram in  Fig.   5.16   shows both the input and output values, separated by a slash <br>along the directed lines between the states. <br>
 <br>An example of a Moore model is given in  Fig.   5.18  . Here, the output is a function of <br>
the present state only. The corresponding state diagram in  Fig.   5.19   has only inputs marked <br>along the directed lines. The outputs are the flip-flop states marked inside the circles. <br>Another example of a Moore model is the sequential circuit of  Fig.   5.20  . The output <br>depends only on flip-flop values, and that makes it a function of the present state only. <br>The input value in the state diagram is labeled along the directed line, but the output <br>value is indicated inside the circle together with the present state. <br>
 <br><b>In a Moore model, the outputs of the sequential circuit are synchronized with the </b><br>
<b>clock, because they depend only on flip-flop outputs that are synchronized with the <br>clock.</b>  In a Mealy model, the outputs may change if the inputs change during the clock <br>
<hr>
<A name=235></a><b>Section 5.6    Synthesizable HDL Models of Sequential Circuits        217</b><br>
cycle. Moreover, the outputs may have momentary false values because of the delay <br>encountered from the time that the inputs change and the time that the flip-flop outputs <br>change. In order to synchronize a Mealy-type circuit, the inputs of the sequential circuit <br>must be synchronized with the clock and the outputs must be sampled immediately <br>before the clock edge. The inputs are changed at the inactive edge of the clock to ensure <br>that the inputs to the flip-flops stabilize before the active edge of the clock occurs. Thus, <br> <br><b>the output of the Mealy machine is the value that is present immediately before the <br>active edge of the clock.</b> <br>
<b> <br>5 . 6       S Y N T H E S I Z A B L E   H D L   M O D E L S </b><br>
<b>O F   S E Q U E N T I A L   C I R C U I T S </b><br>
 <br>The Verilog HDL was introduced in Section 3.9. Combinational circuits were described <br>in Section 4.12, and behavioral modeling with Verilog was introduced in that section <br>as well. Behavioral models are abstract representations of the functionality of digi-<br>tal hardware. That is, they describe how a circuit behaves, but don't specify the internal <br>details of the circuit. Historically, the abstraction has been described by truth tables, <br>state  tables, and state diagrams. An HDL describes the functionality differently, <br>by   language constructs that represent the operations of registers in a machine. <br>This  representation has "added value," i.e., it is important for you to know how to use, <br>because it can be simulated to produce waveforms demonstrating the behavior of the <br>machine. <br>
<b> <br>Behavioral Modeling </b><br>
 <br>There are two kinds of abstract behaviors in the Verilog HDL. Behavior declared by <br>the keyword  <b>initial</b>  is called  <i>single-pass behavior</i>  and specifies a single statement or <br>a block statement (i.e., a list of statements enclosed by either a  <b>begin</b>  . . .  <b>end</b>  or a <br> <br><b>fork</b>  . . .   <b>join</b>  keyword pair). A single-pass behavior expires after the associated state-<br>ment executes. In practice, designers use single-pass behavior primarily to prescribe <br>stimulus signals in a test bench--never to model the behavior of a circuit--because <br>synthesis tools do not accept descriptions that use the  <b>initial</b>  statement. The  <b>always</b> <br>keyword declares a  <i>cyclic behavior.</i>  Both types of behaviors begin executing when <br>the simulator launches at time   <i>t </i>= 0. The  <b>initial</b>  behavior expires after its statement <br>executes; the  <b>always</b>  behavior executes and reexecutes indefinitely, until the simula-<br>tion is stopped. A module may contain an arbitrary number of  <b>initial</b>   or   <b>always</b>   behav-<br>ioral statements. They execute concurrently with respect to each other, starting at <br>time 0, and may interact through common variables. Here's a word description of how <br>an  <b>always</b>  statement works for a simple model of a  <i>D</i>  flip-flop: Whenever the rising <br>edge of the clock occurs, if the reset input is asserted, the output  <i>q</i>  gets 0; otherwise <br>the output  <i>Q</i>  gets the value of the input  <i>D</i> . The execution of statements triggered by <br>the clock is repeated until the simulation ends. We'll see shortly how to write this <br>description in Verilog. <br>
<hr>
<A name=236></a><b>218    Chapter 5  Synchronous Sequential Logic</b><br>
 An   <b>initial</b>  behavioral statement executes only once. It begins its execution at the start <br>
of simulation and expires after all of its statements have completed execution. As men-<br>tioned at the end of Section 4.12, the <b>initial</b> statement is useful for generating input <br>signals to simulate a design. In simulating a sequential circuit, it is necessary to generate <br>a clock source for triggering the flip-flops. The following are two possible ways to pro-<br>vide a free-running clock that operates for a specified number of cycles: <br>
<b> <br>initial  </b><br>
<b> <br>initial </b><br>
<b>    begin  </b><br>
<b>begin</b><br>
      clock = 1'b0; <br>
  clock = 1'b0;<br>
      <b>repeat</b> (30) <br>
   <b>end</b> <br>
      #10 clock = ~clock;<br>   <b>end</b> <br>
 <br><b>initial</b>  300 $<b> finish</b> ;<br>
 <br>
 <br><b>always</b>  #10 clock = ~clock; <br>
 <br>In the first version, the  <b>initial</b>  block contains two statements enclosed within the  <b>begin</b> <br>and  <b>end</b>  keywords. The first statement sets  <i>clock</i>  to 0 at   time = 0.     The  second  statement <br>specifies a loop that reexecutes 30 times to wait 10 time units and then complement the <br>value of  <i>clock</i> . This produces 15 clock cycles, each with a cycle time of 20 time units. In <br>the second version, the first  <b>initial</b>  behavior has a single statement that sets  <i>clock</i>  to 0 at <br> <br>time = 0,  and it then expires (causes no further simulation activity). The second single-<br>pass behavior declares a stopwatch for the simulation. The system task  <b>finish</b>  causes the <br>simulation to terminate unconditionally after 300 time units have elapsed. Because this <br>behavior has only one statement associated with it, there is no need to write the  <b>begin</b>  . . . <br> <br><b>end</b>  keyword pair. After 10 time units, the  <b>always</b>  statement repeatedly complements  <i>clock,</i> <br>providing a clock generator having a cycle time of 20 time units. The three behavioral <br>statements in the second example can be written in any order. <br>
 <br>Here is another way to describe a free-running clock: <br>
 <br><b>initial</b>   <b>begin</b>  clock = 0; <b>forever</b> #10 clock = ~clock; <b>end</b> <br>
 <br>This version, with two statements in one block statement, initializes the clock and then <br>executes an indefinite loop ( <b>forever</b> ) in which the clock is complemented after a delay <br>of 10 time steps. Note that the single-pass behavior never finishes executing and so does <br>not expire. Another behavior would have to terminate the simulation. <br>
 <br>The activity associated with either type of behavioral statement can be controlled by <br>
a delay operator that waits for a certain time or by an event control operator that waits <br>for certain conditions to become true or for specified events (changes in signals) to <br>occur. Time delays specified with the #  <i>delay control operator</i>  are commonly used in <br>single-pass behaviors. The delay control operator suspends execution of statements until <br>a specified time has elapsed. We've already seen examples of its use to specify signals in <br>a test bench. Another operator @ is called the  <i>event control operator</i>  and is used to <br> <br><i>suspend</i>  activity until an event occurs. An event can be an unconditional change in a <br>signal value (e.g., @ A) or a specified transition of a signal value (e.g., @ ( <b>posedge</b> <br>clock)). The general form of this type of statement is <br>
 <br><b>always</b>  @ (event control expression)  <b>begin</b> <br>
 <br>// Procedural assignment statements that execute when the condition is met<br>
 <br><b>end</b> <br>
<hr>
<A name=237></a><b>Section 5.6    Synthesizable HDL Models of Sequential Circuits        219</b><br>
 <br>The event control expression specifies the condition that must occur to launch execu-<br>tion of the procedural assignment statements. The variables in the left-hand side of the <br>procedural statements must be of the  <b>reg</b>  data type and must be declared as such. The <br>right-hand side can be any expression that produces a value using Verilog-defined <br>operators. <br>
 <br>The event control expression (also called the sensitivity list) specifies the events that <br>
must occur to initiate execution of the procedural statements associated with the  <b>always</b> <br>block. Statements within the block execute sequentially from top to bottom. After <br>the last statement executes, the behavior waits for the event control expression to be <br>satisfied. Then the statements are executed again. The sensitivity list can specify level-<br>sensitive events, edge-sensitive events, or a combination of the two. In practice, design-<br>ers do not make use of the third option, because this third form is not one that synthesis <br>tools are able to translate into physical hardware. Level-sensitive events occur in com-<br>binational circuits and in latches. For example, the statement <br>
 <br><b>always</b> <b>@</b> (A <b>or</b> B <b>or</b> C) <br>
 <br>will initiate execution of the procedural statements in the associated  <b>always</b>  block if a <br>change occurs in  <i>A,</i>  <i>B,</i>  or  <i>C</i> . In synchronous sequential circuits, changes in flip-flops <br>occur only in response to a transition of a clock pulse. The transition may be either a <br>positive edge or a negative edge of the clock, but not both. Verilog HDL takes care of <br>these conditions by providing two keywords:  <b>posedge</b>  and  <b>negedge</b> . For example, the <br>expression <br>
 <br><b>always</b> <b>@</b>(<b>posedge</b> clock  <b>or negedge</b>  reset) <br>
// Verilog 1995 <br>
 <br>will initiate execution of the associated procedural statements only if the clock goes <br>through a positive transition or if  <i>reset</i>  goes through a negative transition. The 2001 and <br>2005 revisions to the Verilog language allow a comma-separated list for the event con-<br>trol expression (or sensitivity list): <br>
 <br><b>always</b> <b>@</b>(<b>posedge</b> clock,  <b>negedge</b>  reset) <br>
// Verilog 2001, 2005 <br>
 <br>A procedural assignment is an assignment of a logic value to a variable within an <br>
 <br><b>initial</b>  or  <b>always</b>  statement. This is in contrast to a continuous assignment discussed in <br>Section 4.12 with dataflow modeling. A continuous assignment has an implicit level-<br>sensitive sensitivity list consisting of all of the variables on the right-hand side of its <br>assignment statement. The updating of a continuous assignment is triggered whenever <br>an event occurs in a variable included on the right-hand side of its expression. In con-<br>trast, a procedural assignment is made only when an assignment statement is executed <br>and assigns value to it within a behavioral statement. For example, the clock signal in <br>the preceding example was complemented only when the statement  <i>clock</i>  = ~ <i>clock</i> <br>executed; the statement did not execute until 10 time units after the simulation began. <br>It is important to remember that a variable having type  <b>reg</b>  remains unchanged until a <br>procedural assignment is made to give it a new value. <br>
 <br>There are two kinds of procedural assignments:  <i>blocking</i>  and  <i>nonblocking</i> .  The  two <br>
are distinguished by the symbols that they use. Blocking assignments use the symbol (=) <br>as the assignment operator, and nonblocking assignments use (&lt; =) as the operator. <br>
<hr>
<A name=238></a><b>220    Chapter 5  Synchronous Sequential Logic</b><br>
Blocking assignment statements are executed sequentially in the order they are listed <br>in a block of statements. Nonblocking assignments are executed concurrently by evalu-<br>ating the set of expressions on the right-hand side of the list of statements; they do not <br>make assignments to their left-hand sides until all of the expressions are evaluated. The <br>two types of assignments may be better understood by means of an illustration. Consider <br>these two procedural blocking assignments: <br>
 <br>B = A<br> <br>C = B + 1 <br>
 <br>The first statement transfers the value of  <i>A</i>  into  <i>B</i> .The second statement increments the <br>value of  <i>B</i>  and transfers the new value to  <i>C</i> . At the completion of the assignments,  <i>C</i> <br>contains the value of   <i>A </i>+ 1. <br>
 <br>Now consider the two statements as nonblocking assignments: <br>
 <br>B &lt;= A<br>
 <br>C &lt;= B + 1 <br>
 <br>When the statements are executed, the expressions on the right-hand side are evaluated <br>and stored in a temporary location. The value of  <i>A</i>  is kept in one storage location and <br>the value of   <i>B </i>+ 1  in another. After all the expressions in the block are evaluated and <br>stored, the assignment to the targets on the left-hand side is made. In this case,  <i>C</i>   will <br>contain the original value of  <i>B,</i>  plus 1. A general rule is to  <b>use blocking assignments when <br>sequential ordering is imperative and in cyclic behavior that is level sensitive</b>  (i.e., in <br>combinational logic).  <b>Use nonblocking assignments when modeling concurrent execu-<br>tion</b>  (e.g., edge-sensitive behavior such as synchronous, concurrent register transfers) <br> <br><b>and when modeling latched behavior .</b> Nonblocking assignments are imperative in deal-<br>ing with register transfer level design, as shown in  Chapter   8  .They model the concurrent <br>operations of physical hardware synchronized by a common clock. Today's designers <br>are expected to know what features of an HDL are useful in a practical way and how to <br>avoid features that are not. Following these rules for using the assignment operators will <br>prevent conditions that lead synthesis tools astray and create mismatches between <br>the  behavior of a model and the behavior of physical hardware that is produced by a <br>synthesis tool. <br>
<b> <br>HDL Models of Flip-Flops and Latches </b><br>
 <br>HDL Examples 5.1 through 5.4 show Verilog descriptions of various flip-flops and a <i>D</i> <br>latch. The <i>D</i> latch is said to be  <i>transparent</i>  because it responds to a change in data input <br>with a change in the output as long as the enable input is asserted--viewing the output <br>is the same as viewing the input. The description of a <i>D</i> latch is shown in HDL Example <br>5.1 It has two inputs,  <i>D</i>  and  <i>enable,</i>  and one output,  <i>Q</i> . Since  <i>Q</i>  is assigned value in a <br>behavior, its type must be declared to be  <b>reg .</b> Hardware latches respond to input signal <br> <br><i>levels,</i>  so the two inputs are listed without edge qualifiers in the sensitivity list following <br>the @ symbol in the  <b>always</b>  statement. In this model, there is only one blocking proce-<br>dural assignment statement, and it specifies the transfer of input  <i>D</i>  to output  <i>Q</i>  if enable <br>
<hr>
<A name=239></a><b>Section 5.6    Synthesizable HDL Models of Sequential Circuits        221</b><br>
is true (logic 1).  1  Note that this statement is executed every time there is a change in  <i>D</i> <br>if  <i>enable</i>  is 1. <br>
 A  <i>D</i>-type flip-flop is the simplest example of a sequential machine. HDL Example <br>
5.2 describes two positive-edge  <i>D</i>  flip-flops in two modules. The first responds only to <br>the clock; the second includes an asynchronous reset input. Output  <i>Q</i>  must be declared <br>as a  <b>reg</b>  data type in addition to being listed as an output. This is because it is a target <br>output of a procedural assignment statement. The keyword <b>posedge</b> ensures that the <br>transfer of input  <i>D</i>  into  <i>Q</i>  is synchronized by the positive-edge transition of  <i>Clk</i> . <br>A change in  <i>D</i>  at any other time does not change  <i>Q</i> . <br>
<b>  HDL  Example  5.1     (<i>D</i>-Latch) </b><br>
 <br>// Description of D latch (See  Fig.   5.6  )<br> <br><b>module</b>  D_latch (Q, D, enable);<br> <br>  <b>output</b>  Q;<br>  <b>input</b>  D, <br>
enable;<br>
  <b>reg</b>  Q;<br>  <b>always</b> <b> @</b> (enable or D)<br>  <b> if </b>(enable) Q &lt;= D; <br>
// Same as: <b>if</b> (enable == 1)<br>
 <br><b>endmodule</b> <br>
 <br>// Alternative syntax (Verilog 2001, 2005)<br> <br><b>module</b>  D_latch (<b>output reg</b> Q,  <b>input</b>  enable, D);<br>  <b>always  @</b> (enable, D)<br>   <b>if</b>  (enable) Q &lt;= D; <br>
// No action if <i>enable</i> not asserted<br>
 <br><b>endmodule</b> <br>
<b>  HDL  Example  5.2     (<i>D</i>-Type Flip-Flop) </b><br>
 <br>// D fl ip-fl op without reset<br> <br><b>module</b>  D_FF (Q, D, Clk);<br>  <b>output</b>  Q;<br>  <b>input</b>  D, <br>
Clk;<br>
  <b>reg</b>  Q;<br>  <b>always  @</b> ( <b>posedge</b>  Clk)<br>    Q &lt;= D;<br>   <b>endmodule</b> <br>
 <br>// D fl ip-fl op with asynchronous reset (V2001, V2005)<br> <br><b>module</b>  DFF ( <b>output</b>   <b>reg</b>  Q,  <b>input</b>  D, Clk, rst);<br>  <b>always  @</b> ( <b>posedge</b>  Clk,  <b>negedge</b>  rst)<br>   if (!rst) Q &lt;= 1'b0; <br>
// Same as:  <b>if</b>  (rst == 0)<br>
  <b>else</b>  Q &lt;= D;<br> <br><b>endmodule</b> <br>
 <br>1 The statement (single or block) associated with  <b>if</b> (Boolean expression) executes if the Boolean expression <br>is true. <br>
<hr>
<A name=240></a><b>222    Chapter 5  Synchronous Sequential Logic</b><br>
 <br>The second module includes an asynchronous reset input in addition to the synchro-<br>
nous clock. A specific form of an  <b>if</b>  statement is used to describe such a flip-flop so that <br>the model can be synthesized by a software tool. The event expression after the @ sym-<br>bol in the  <b>always</b>  statement may have any number of edge events, either  <b>posedge</b>   or <br> <br><b>negedge</b> . For modeling hardware, one of the events must be a clock event. The remain-<br>ing events specify conditions under which asynchronous logic is to be executed. The <br>designer knows which signal is the clock, but  <i>clock</i>  is not an identifier that software tools <br>automatically recognize as the synchronizing signal of a circuit. The tool must be able <br>to infer which signal is the clock, so  <i>you need to write the description in a way that enables <br>the tool to infer the clock correctly</i> . The rules are simple to follow: (1) Each  <b>if</b>  or  <b>else if</b> <br>statement in the procedural assignment statements is to correspond to an asynchronous <br>event, (2) the last  <b>else</b>  statement corresponds to the clock event, and (3) the asynchro-<br>nous events are tested first. There are two edge events in the second module of HDL <br>Example 5.2. The  <b>negedge</b>  rst (reset) event is asynchronous, since it matches the  <b>if</b>   (!rst) <br>statement. As long as  <i>rst</i>  is 0,  <i>Q</i>  is cleared to 0. If  <i>Clk</i>  has a positive transition, its effect <br>is blocked. Only if  <i>rst</i>  = 1 can the  <b>posedge</b>  clock event synchronously transfer  <i>D</i>  into  <i>Q</i> . <br>
 <br>Hardware always has a reset signal. It is strongly recommended that all models of <br>
edge-sensitive behavior include a reset (or preset) input signal; otherwise, the initial <br>state of the flip-flops of the sequential circuit cannot be determined. A sequential circuit <br>cannot be tested with HDL simulation unless an initial state can be assigned with an <br>input signal. <br>
 <br>HDL Example 5.3 describes the construction of a  <i>T</i>  or  <i>JK</i>  flip-flop from a  <i>D</i>   flip-flop <br>
and gates. The circuit is described with the characteristic equations of the flip-flops: <br>
 <br><i>Q</i>(<i>t </i>+ 1) = <i>Q </i>{ <i>T</i>    <br>
for  a   <i>T</i>   flip-flop <br>
 <br><i>Q</i>(<i>t </i>+ 1) = <i>JQ </i>+ <i>K Q</i>    <br>
for  a   <i>JK</i>   flip-flop <br>
 <br>The first module,  <i>TFF,</i>  describes a  <i>T</i>  flip-flop by instantiating  <i>DFF</i> . (Instantiation is <br>explained in Section 4.12.) The declared  <b>wire</b>,    <i>DT,</i>  is assigned the exclusive-OR of  <i>Q</i> <br>and  <i>T,</i>  as is required for building a  <i>T</i>  flip-flop with a  <i>D</i>  flip-flop. The instantiation with <br>the value of  <i>DT</i>  replacing  <i>D</i>  in module  <i>DFF</i>  produces the required  <i>T</i>  flip-flop. The  <i>JK</i> <br>flip-flop is specified in a similar manner by using its characteristic equation to define a <br>replacement for  <i>D</i>  in the instantiated  <i>DFF</i> . <br>
<b> <br>HDL Example 5.3 (Alternative Flip-Flop Models) </b><br>
 <br>// T fl ip-fl op from D fl ip-fl op and gates<br> <br><b>module</b>  TFF (Q, T, Clk, rst);<br>   <b>output</b>  Q;<br>   <b>input</b>  T, Clk, rst;<br>  <b>wire</b>  DT;<br>   <b>assign</b>  DT = Q ^ T ; <br>
// Continuous assignment<br>
 <br>// Instantiate the D fl ip-fl op<br>  DFF TF1 (Q, DT, Clk, rst);<br> <br><b>endmodule</b> <br>
<hr>
<A name=241></a><b>Section 5.6    Synthesizable HDL Models of Sequential Circuits        223</b><br>
 <br>// JK fl ip-fl op from D fl ip-fl op and gates (V2001, 2005)<br> <br><b>module</b>  JKFF ( <b>output</b>   <b>reg</b>  Q,  <b>input</b>  J, K, Clk, rst);<br>  <b>wire</b>  JK;<br>  <b>assign</b>  JK = (J &amp; ~Q)   (~K &amp; Q);<br> <br>// Instantiate D fl ip-fl op<br>  DFF JK1 (Q, JK, Clk, rst);<br> <br><b>endmodule</b> <br>
 <br>// D fl ip-fl op (V2001, V2005)<br> <br><b>module</b>  DFF ( <b>output</b>   <b>reg</b>  Q,  <b>input</b>  D, Clk, rst);<br>  <b>always @</b>  ( <b>p osedge</b> Clk,  <b>negedge</b>  rst)<br>  <b>if</b>  (!rst) Q &lt;= 1'b0;<br>  <b>else</b>  Q &lt;= D;<br> <br><b>endmodule</b> <br>
 <br>HDL Example 5.4 shows another way to describe a  <i>JK</i>  flip-flop. Here, we describe <br>
the flip-flop by using the characteristic table rather than the characteristic equation. The <br> <br><b>case</b>  multiway branch condition checks the two-bit number obtained by concatenating <br>the bits of  <i>J</i>  and  <i>K</i> .  The   <b>case</b>  expression ({ <i>J</i>,<i> K</i> }) is evaluated and compared with the <br>values in the list of statements that follows. The first value that matches the true condi-<br>tion is executed. Since the concatenation of  <i>J</i>  and  <i>K</i>  produces a two-bit number, it can <br>be equal to 00, 01, 10, or 11. The first bit gives the value of  <i>J</i>  and the second the value of <br> <br><i>K</i> . The four possible conditions specify the value of the next state of  <i>Q</i>  after the applica-<br>tion of a positive-edge clock. <br>
<b>    HDL  Example  5.4  (<i>JK</i> Flip-Flop) </b><br>
 <br>// Functional description of JK fl ip-fl op (V2001, 2005)<br> <br>module JK_FF ( <b>input</b>  J, K, Clk,  <b>output</b>   <b>reg</b>  Q,  <b>output</b>  Q_b);<br>  <b>assign</b>  Q_b = ~ Q ;<br>  <b>always</b>   <b>@</b>  ( <b>posedge</b>  Clk)<br>  <b>case</b>  ({J,K})<br>  2'b00: Q &lt;= Q;<br>  2'b01: Q &lt;= 1'b0;<br>  2'b10: Q &lt;= 1'b1;<br>  2'b11: Q &lt;= !Q;<br>  <b>endcase</b> <br> <br><b>endmodule</b> <br>
<b> <br>State diagram-Based HDL Models </b><br>
 <br>An HDL model of the operation of a sequential circuit can be based on the format of the <br>circuit's state diagram. A Mealy HDL model is presented in HDL Example 5.5 for the <br>zero-detector machine described by the sequential circuit in  Fig.   5.15   and its state diagram <br>shown in  Fig.   5.16  . The input, output, clock, and reset are declared in the usual manner. <br>
<hr>
<A name=242></a><b>224    Chapter 5  Synchronous Sequential Logic</b><br>
The state of the flip-flops is declared with identifiers  <i>state</i>  and  <i>next_state</i> .  These  variables <br>hold the values of the present state and the next value of the sequential circuit. The state's <br>binary assignment is done with a  <b>parameter</b>  statement. (Verilog allows constants to be <br>defined in a module by the keyword  <b>parameter .</b>) The four states  <i>S0</i>  through  <i>S3</i>  are assigned <br>binary 00 through 11. The notation   <i>S2 </i>= 2 b10  is preferable to the alternative   <i>S2 </i>= 2. The <br>former uses only two bits to store the constant, whereas the latter results in a binary num-<br>ber with 32 (or 64) bits because an unsized number is interpreted and sized as an integer. <br>
<b> <br>HDL Example 5.5 (Mealy Machine: Zero Detector) </b><br>
 <br>// Mealy FSM zero detector (See Fig. 5.15 and  Fig.   5.16  ) <br>
Verilog 2001, 2005 syntax<br>
 <br><b>module</b>  Mealy_Zero_Detector (<br>  <b>output reg</b> y_out,<br>   <b>input</b>  x_in, clock, reset<br> <br>);<br>  <b>reg</b> [1: 0] <br>
state, next_state;<br>
   <b>parameter</b> <br>
S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;<br>
  <b>always  @</b>  ( <b>posedge</b>  clock,  <b>negedge</b>  reset) <br>
Verilog 2001, 2005 syntax<br>
   if (reset == 0) state &lt;= S0;<br>  <b>else</b> state &lt;= next_state;<br>
  <b>always @</b> (state, x_in) <br>
// Form the next state<br>
  <b>case</b> (state)<br>  S0: <br>
 <br>
<b>if</b>  (x_in)  next_state = S1;  <b>else</b>  next_state = S0;<br>
 <br>  S1: <br>
 <br>
<b>if</b>  (x_in)  next_state = S3;  <b>else</b>  next_state = S0;<br>
 <br>  S2: <br>
 <br>
<b>if</b>  (~x_in)  next_state = S0;  <b>else</b>  next_state = S2;<br>
 <br>  S3: <br>
 <br>
<b>if</b>  (x_in)  next_state = S2;  <b>else</b>  next_state = S0;<br>
  <b>endcase</b><br>
  <b>always  @ </b> (state, x_in) <br>
// Form the Mealy output<br>
  <b>case</b> (state)<br> <br>  S0:   y_out <br>
= <br>
0;<br>
    S1, S2, S3: y_out = ~x_in;<br>  <b>endcase<br></b> <br><b>endmodule</b> <br>
 <br><b>module</b>  t_Mealy_Zero_Detector;<br>  <b>wire</b>  <br>
t_y_out;<br>
   <b>reg</b> <br>
 t_x_in, t_clock, t_reset;<br>
 <br>Mealy_Zero_Detector M0 (t_y_out, t_x_in, t_clock, t_reset);<br> <br><b>initial</b>  #200  <b>$finish</b> ;<br> <br><b>initial</b>   <b>begin</b>  t_clock = 0;  <b>forever</b>  #5 t_clock = ~t_clock;  <b>end</b> <br>
 <br><b>initial</b>   <b>fork</b> <br> <br>  t_reset <br>
= <br>
0;<br>
  #2 t_reset = 1;<br>  #87 t_reset = 0;<br>   #89 t_reset = 1;<br>
<hr>
<A name=243></a><b>Section 5.6    Synthesizable HDL Models of Sequential Circuits        225</b><br>
  #10 t_x_in = 1;<br>   #30 t_x_in = 0;<br>   #40 t_x_in = 1;<br>   #50 t_x_in = 0;<br>   #52 t_x_in = 1;<br>   #54 t_x_in = 0;<br>   #70 t_x_in = 1;<br>   #80 t_x_in = 1;<br>   #70 t_x_in = 0;<br>   #90 t_x_in = 1;<br>   #100 t_x_in = 0;<br>   #120 t_x_in = 1;<br>   #160 t_x_in = 0;<br>   #170 t_x_in = 1;<br>   <b>join</b> <br> <br><b>endmodule</b> <br>
 <br>The circuit I HDL Example 5.5 detects a 0 following a sequence of 1s in a serial bit <br>
stream. Its Verilog model uses three <b>always</b> blocks that execute concurrently and inter-<br>act through common variables. The first  <b>always</b>  statement resets the circuit to the initial <br>state     <i>S0 </i>= 00  and specifies the synchronous clocked operation. The statement  <i>state &lt;= <br>next_state</i>  is synchronized to a positive-edge transition of the clock. This means that any <br>change in the value of  <i>next_state</i>  in the second  <b>always</b>  block can affect the value of  <i>state</i> <br>only as a result of a  <b>posedge</b>  event of  <i>clock</i> . The second  <b>always</b>  block determines the <br>value of the next state transition as a function of the present state and input. The value <br>assigned to  <i>state</i>  by the nonblocking assignment is the value of  <i>next_state</i>   immediately <br>before the rising edge of  <i>clock</i> . Notice how the multiway branch condition implements <br>the state transitions specified by the annotated edges in the state diagram of  Fig.  5.16  . <br>The third  <b>always</b>  block specifies the output as a function of the present state and the <br>input. Although this block is listed as a separate behavior for clarity, it could be com-<br>bined with the second block. Note that the value of output  <i>y_out</i>  may change if the value <br>of input  <i>x_in</i>  changes while the circuit is in any given state. <br>
 <br>So let's summarize how the model describes the behavior of the machine: At every ris-<br>
ing edge of  <i>clock</i>,  if  <i>reset</i>  is not asserted, the state of the machine is updated by the first <br> <br><b>always</b>  block; when  <i>state</i>  is updated by the first  <b>always</b>  block, the change in  <i>state</i>  is detected <br>by the sensitivity list mechanism of the second  <b>always</b>  block; then the second  <b>always</b>   block <br>updates the value of  <i>next_state</i>  (it will be used by the first  <b>always</b>  block at the next tick of <br>the clock); the third  <b>always</b>  block also detects the change in  <i>state</i>  and updates the value of <br>the output. In addition, the second and third  <b>always</b>  blocks detect changes in  <i>x_in</i>   and <br>update  <i>next_state</i>  and  <i>y_out</i>  accordingly. The test bench provided with  <i>Mealy_Zero_ <br>Detector</i>  provides some waveforms to stimulate the model, producing the results shown in <br> Fig.    5.22   .  Notice  how  <i>t</i>_ <i>y_out</i>  responds to changes in both the state and the input, and has <br>a glitch (a transient logic value). We display both to  <i>state</i> [1:0] and  <i>next_state</i> [1:0] to illus-<br>trate how changes in  <i>t_x_in</i>  influence the value of next_state and <i>t</i>_<i>y</i>_<i>out</i>. The Mealy glitch <br>in  <i>t_y_out</i>  is due to the (intentional) dynamic behavior of  <i>t_x_in</i> . The input,  <i>t_x_in,</i>   settles <br>
<hr>
<A name=244></a><b>226    Chapter 5  Synchronous Sequential Logic</b><br>
Stream of 1s<br>
0<br>
30<br>
60<br>
90<br>
<i>t_clock</i><br>
<i>t_reset</i><br>
<i>t_x_in</i><br>
<i>state[1:0]</i><br>
0<br>
1<br>
3<br>
0<br>
1<br>
0<br>
0<br>
1<br>
0<br>
<i>next_state[1:0]</i><br>
0<br>
1<br>
3<br>
2<br>
0<br>
1<br>
3<br>
0<br>
1<br>
1<br>
3<br>
0<br>
<i>t_y_out</i><br>
<i>valid Mealy output</i><br>
<i>Mealy glitch</i><br>
<b> <br>FIGURE 5.22 <br> <br>Simulation output of <i>Mealy_Zero_Detector</i> </b><br>
to a value of 0 immediately before the clock, and at the clock, the state makes a transition <br>from 0 to 1, which is consistent with  Fig.   5.16  .The output is 1 in state  <i>S</i> 1 immediately before <br>the clock, and changes to 0 as the state enters  <i>S</i> 0. <br>
 <br>The description of waveforms in the test bench uses the  <b>fork </b>. . .<b> join</b>  construct. State-<br>
ments with the  <b>fork </b>. . .<b> join</b>  block execute in parallel, so the time delays are relative to <br>a common reference of <i>t</i> = 0, the time at which the block begins execution.  2  It is usually <br>more convenient to use the  <b>fork </b>. . .<b> join</b>  block instead of the  <b>begin </b>. . .<b> end</b>  block in <br>describing waveforms. Notice that the waveform of reset is triggered "on the fly" to <br>demonstrate that the machine recovers from an unexpected (asynchronous) reset con-<br>dition during any state.  <br>
 <br>How does our Verilog model  <i>Mealy_Zero_Detector</i>  correspond to hardware? The first <br>
 <br><b>always</b>  block corresponds to a  <i>D</i>  flip-flop implementation of the state register in  Fig.   5.21  ; <br>the second  <b>always</b>  block is the combinational logic block describing the next state; the <br>third  <b>always</b>  block describes the output combinational logic of the zero-detecting Mealy <br>machine. The register operation of the state transition uses the nonblocking assignment <br>operator (&lt; =) because the (edge-sensitive) flip-flops of a sequential machine are updated <br>concurrently by a common clock. The second and third  <b>always</b>  blocks describe combina-<br>tional logic, which is level sensitive, so they use the blocking (=) assignment operator. <br>
 <br>2 A  <b>fork </b>. . .<b> join</b>  block completes execution when the last executing statement within it completes its <br>execution. <br>
<hr>
<A name=245></a><b>Section 5.6    Synthesizable HDL Models of Sequential Circuits        227</b><br>
Their sensitivity lists include both the state and the input because their logic must respond <br>to a change in either or both of them. <br>
 <br>Note: The modeling style illustrated by  <i>Mealy_Zero_Detector</i>  is commonly used by <br>
designers because it has a close relationship to the state diagram of the machine that is <br>being described. Notice that the reset signal is associated with the  <b>always</b>  block that <br>synchronizes the state transitions. In this example, it is modeled as an active-low reset. <br>Because the reset condition is included in the description of the state transitions, there <br>is no need to include it in the combinational logic that specifies the next state and the <br>output, and the resulting description is less verbose, simpler, and more readable. <br>
 <br>HDL Example 5.6 presents the Verilog behavioral model of the Moore FSM shown <br>
in  Fig.   5.18   and having the state diagram given in  Fig.   5.19  . The model illustrates an <br>alternative style in which the state transitions of the machine are described by a single <br>clocked (i.e., edge-sensitive) cyclic behavior, i.e., by one  <b>always</b>  block. The present state <br>of the circuit is identified by the variable state, and its transitions are triggered by the <br>rising edge of the clock according to the conditions listed in the  <b>case</b>   statement.  The <br>combinational logic that determines the next state is included in the nonblocking assign-<br>ment to state. In this example, the output of the circuits is independent of the input and <br>is taken directly from the outputs of the flip-flops. The two-bit output <i>y_out</i> is specified <br>with a continuous assignment statement and is equal to the value of the present state <br>vector.  Figure   5.23   shows some simulation results for <i>Moore_Model_Fig_5_19</i>. Here <br>are some important observations: (1) the output depends on only the state, (2) reset <br>"on-the-fly" forces the state of the machine back to S0 (00), and (3) the state transitions <br>are  consistent  with   Fig.    5.19   . <br>
<b> <br>HDL Example 5.6 (Moore Machine: Zero Detector) </b><br>
 <br>// Moore model FSM (see  Fig.   5.19  ) <br>
 Verilog 2001, 2005 syntax<br>
 <br><b>module</b>  Moore_Model_Fig_5_19 (<br>   <b>output</b>  [1: 0]  <br>
y_out,<br>
   <b>input</b> <br>
x_in, clock, reset<br>
 <br>);<br>  <b>reg</b>  [1: 0] <br>
state;<br>
  <b>parameter</b> <br>
S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;<br>
  <b>always</b>  @ ( <b>posedge</b>  clock,  <b>negedge</b>  reset)<br>  <b>if</b>  (reset == 0) state &lt;= S0; <br>
// Initialize to state S0<br>
   <b>else</b>   <b>case</b>  (state)<br> <br>  <br>
S0: <br>
 <br>
<b>if</b>  (~x_in) state &lt;= S1;  <b>else</b>  state &lt;= S0;<br>
 <br>  <br>
S1: <br>
   <br>
<b>if</b>  (x_in)   state &lt;= S2;  <b>else</b>  state &lt;= S3;<br>
 <br>  <br>
S2: <br>
 <br>
<b>if</b>  (~x_in) state &lt;= S3;  <b>else</b>  state &lt;= S2;<br>
 <br>   S3:  <br>
 <br>
<b>if</b>  (~x_in) state &lt;= S0;  <b>else</b>  state &lt;= S3;<br>
    <b>endcase</b> <br>
  <b>assign</b>  y_out = state; <br>
// Output of fl ip-fl ops<br>
 <br><b>endmodule</b> <br>
<hr>
<A name=246></a><b>228    Chapter 5  Synchronous Sequential Logic</b><br>
0<br>
30<br>
60<br>
90<br>
<i>t_clock</i><br>
<i>t_reset</i><br>
reset on-the-fly<br>
<i>t_x_in</i><br>
<i>state[1:0]</i><br>
0<br>
1<br>
2<br>
3<br>
0<br>
1<br>
0<br>
1<br>
3<br>
<i>t_y_out[1:0]</i><br>
0<br>
1<br>
2<br>
3<br>
0<br>
1<br>
0<br>
1<br>
3<br>
<b> <br>FIGURE 5.23 <br> <br>Simulation output of HDL Example 5.6  </b><br>
<b> <br>Structural Description of Clocked Sequential Circuits </b><br>
 <br>Combinational logic circuits can be described in Verilog by a connection of gates <br>(primitives and UDPs), by dataflow statements (continuous assignments), or by level-<br>sensitive cyclic behaviors ( <b>always</b>  blocks). Sequential circuits are composed of com-<br>binational logic and flip-flops, and their HDL models use sequential UDPs and <br>behavioral statements (edge-sensitive cyclic behaviors) to describe the operation of <br>flip-flops. One way to describe a sequential circuit uses a combination of dataflow <br>and behavioral statements. The flip-flops are described with an  <b>always</b>   statement.  The <br>combinational part can be described with  <b>assign</b>  statements and Boolean equations. <br>The separate modules can be combined to form a structural model by instantiation <br>within a  <b>module</b> . <br>
 <br>The structural description of a Moore-type zero detector sequential circuit is shown <br>
in HDL Example 5.7. We want to encourage the reader to consider alternative ways to <br>model a circuit, so as a point of comparison, we first present  <i>Moore_Model_Fig_5_20,</i> <br>a Verilog behavioral description of a binary counter having the state diagram examined <br>earlier shown in  Fig.   5.20  (b). This style of modeling follows directly from the state dia-<br>gram. An alternative style, used in  <i>Moore_Model_STR_Fig_5_20</i>,  represents the struc-<br>ture shown in  Fig.   5.20  (a). This style uses two modules. The first describes the circuit of <br> Fig.    5.20   (a).  The  second  describes  the   <i>T</i>  flip-flop that will be used by the circuit. We also <br>show two ways to model the <i>T</i> flip-flop. The first asserts that, at every clock tick, the <br>value of the output of the flip-flop toggles if the toggle input is asserted. The second <br>model describes the behavior of the toggle flip-flop in terms of its characteristic equa-<br>tion. The first style is attractive because it does not require the reader to remember the <br>characteristic equation. Nonetheless, the models are interchangeable and will synthesize <br>to the same hardware circuit. A test bench module provides a stimulus for verifying the <br>functionality of the circuit. The sequential circuit is a two-bit binary counter controlled <br>by input  <i>x_in</i> . The output,  <i>y_out</i>,  is enabled when the count reaches binary 11. Flip-flops <br>
<hr>
<A name=247></a><b>Section 5.6    Synthesizable HDL Models of Sequential Circuits        229</b><br>
 <br><i>A</i>  and  <i>B</i>  are included as outputs in order to check their operation. The flip-flop input <br>equations and the output equation are evaluated with continuous assignment (<b>assign</b>) <br>statements having the corresponding Boolean expressions. The instantiated  <i>T</i>   flip-flops <br>use  <i>TA</i>  and  <i>TB</i>  as defined by the input equations. <br>
 <br>The second module describes the  <i>T</i>  flip-flop. The  <i>reset</i>  input resets the flip-flop to 0 <br>
with an active-low signal. The operation of the flip-flop is specified by its characteristic <br>equation,     <i>Q</i>(<i>t </i>+ 1) = <i>Q </i>{ <i>T</i>.    <br>
 <br>The test bench includes both models of the machine. The stimulus module provides <br>
common inputs to the circuits to simultaneously display their output responses. The <br>first <b>initial</b> block provides eight clock cycles with a period of 10 ns. The second  <b>initial</b> <br>block specifies a toggling of input  <i>x_in</i>  that occurs at the negative edge transition of <br>the clock. The result of the simulation is shown in  Fig.   5.24  . The pair ( <i>A, B</i> )  goes <br>through the binary sequence 00, 01, 10, 11, and back to 00. The change in the count is <br>triggered by a positive edge of the clock, provided that   <i>x</i>_<i>in </i>= 1. If  <i>x</i>_<i>in </i>= 0, the <br>count does not change.  <i>y_out</i>  is equal to 1 when both  <i>A</i>  and  <i>B</i>  are equal to 1. This <br>verifies the main functionality of the circuit, but not a recovery from an unexpected <br>reset event. <br>
<b> <br>HDL Example 5.7 (Binary Counter_Moore Model) </b><br>
 <br>// State-diagram-based model (V2001, 2005)<br> <br><b>module</b>  Moore_Model_Fig_5_20 (<br>  <b>output</b>  y_out,<br>  <b>input</b>  x_in, clock, reset<br> <br>);<br>  <b>reg</b>  [1: 0] <br>
state;<br>
  <b>parameter</b> <br>
S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;<br>
  <b>always</b>   <b>@</b>  ( <b>posedge</b>  clock,  <b>negedge</b>  reset)<br>   <b>if</b>  (reset == 0) state &lt;= S0; <br>
// Initialize to state S0<br>
  <b>else</b>   <b>case</b>  (state)<br> <br>  <br>
S0:   <br>
<b>if</b>  (x_in)  state &lt;= S1;  <b>else</b>  state &lt;= S0;<br>
 <br>  <br>
S1:   <br>
<b>if</b>  (x_in)  state &lt;= S2;  <b>else</b>  state &lt;= S1;<br>
 <br>  <br>
S2:   <br>
<b>if</b>  (x_in)  state &lt;= S3;  <b>else</b>  state &lt;= S2;<br>
 <br>  <br>
S3:   <br>
<b>if</b>  (x_in)  state &lt;= S0;  <b>else</b>  state &lt;= S3;<br>
  <b>endcase</b> <br>
  <b>assign</b>  y_out = (state == S3); <br>
// Output of fl ip-fl ops<br>
 <br><b>endmodule</b> <br>
 <br>// Structural model<br> <br><b>module</b>  Moore_Model_STR_Fig_5_20 (<br>  <b>output</b> <br>
y_out, A, B,<br>
  <b>input</b> <br>
x_in, clock, reset<br>
 <br>);<br>  <b>wire</b>  TA, <br>
TB;<br>
 <br>// Flip-fl op input equations<br>  <b>assign</b>  TA = x_in &amp; B;<br>
<hr>
<A name=248></a><b>230    Chapter 5  Synchronous Sequential Logic</b><br>
   <b>assign</b>  TB = x_in;<br> <br>// Output equation<br>  <b>assign</b>  y_out = A &amp; B;<br>
 <br>// Instantiate Toggle fl ip-fl ops<br>  Toggle_fl ip_fl op_3 M_A (A, TA, clock, reset);<br>  Toggle_fl ip_fl op_3 M_B (B, TB, clock, reset);<br>
 <br><b>endmodule</b> <br>
 <br><b>module</b>  Toggle_fl ip_fl op (Q, T, CLK, RST_b);<br>  <b>output</b>   <br>
Q;<br>
  <b>input</b> <br>
T, CLK, RST_b;<br>
  <b>reg</b>   <br>
Q;<br>
  <b>always</b>   <b>@</b>  ( <b>posedge</b>  CLK,  <b>negedge</b>  RST_b)<br>    <b>if</b>  (RST_b == 0) Q &lt;= 1'b0;<br>  <b>else</b>   <b>if</b>  (T) Q &lt;= ~Q; <br>
 <br><b>endmodule</b> <br>
 <br>// Alternative model using characteristic equation<br> <br>//   <b>module</b>  Toggle_fl ip_fl op (Q, T, CLK, RST_b);<br> <br>//   <b>output</b>    Q;<br> <br>//   <b>input</b> <br>
T, CLK, RST_b;<br>
 <br>//   <b>reg</b>   <br>
Q;<br>
 <br>//   <b>always</b>   <b>@</b>  ( <b>posedge</b>  CLK,  <b>negedge</b>  RST)<br> <br>//     <b>if</b>  (RST_b == 0) Q &lt;= 1'b0;<br> <br>//     <b>else</b>  Q &lt;= Q ^ T;<br> <br>//   <b>endmodule</b> <br>
 <br><b>module</b>  t_Moore_Fig_5_20;<br>  <b>wire</b>   <br>
t_y_out_2, t_y_out_1;<br>
   <b>reg</b> <br>
t_x_in, t_clock, t_reset;<br>
 <br>Moore_Model_Fig_5_20  <br>
M1(t_y_out_1, t_x_in, t_clock, t_reset);<br>
 <br>Moore_Model_STR_Fig_5_20 <br>
M2 (t_y_out_2, A, B, t_x_in, t_clock, t_reset);<br>
 <br><b>initial</b>  #200  <b>$finish</b> ;<br> <br><b>initial</b>   <b>begin</b> <br>    t_reset = 0;<br>     t_clock = 0;<br>    #5 t_reset = 1;<br>  <b>repeat</b>  (16)<br>     #5 t_clock = ~t_clock;<br> <br><b>end</b> <br> <br><b>initial begin</b> <br>       t_x_in = 0;<br>   #15 t_x_in = 1;<br>   <b>repeat</b>  (8)<br>  #10 t_x_in = ~t_x_in;<br>  <b>end</b> <br> <br><b>endmodule</b> <br>
<hr>
<A name=249></a><b>Section 5.7  State Reduction and Assignment    231</b><br>
0<br>
50<br>
100<br>
150<br>
<i>Name</i><br>
<i>t_clock</i><br>
<i>t_reset</i><br>
<i>t_x_in</i><br>
<i>t_y_out_1</i><br>
<i>t_y_out_2</i><br>
<i>A</i><br>
<i>B</i><br>
<b> <br>FIGURE 5.24 <br> <br>Simulation output of HDL Example 5.7  </b><br>
<b> <br>5 . 7       S TAT E   R E D U C T I O N   A N D   A S S I G N M E N T </b><br>
 The   <i>analysis</i>  of sequential circuits starts from a circuit diagram and culminates in a state <br>table or diagram. The  <i>design</i>  (synthesis) of a sequential circuit starts from a set of <br>specifications and culminates in a logic diagram. Design procedures are presented in <br>Section 5.8. Two sequential circuits may exhibit the same input�output behavior, but <br>have a different number of internal states in their state diagram. The current section <br>discusses certain properties of sequential circuits that may simplify a design by reduc-<br>ing the number of gates and flip-flops it uses. In general, reducing the number of flip-<br>flops reduces the cost of a circuit. <br>
<b> <br>State Reduction </b><br>
 <br>The reduction in the number of flip-flops in a sequential circuit is referred to as the <br> <br><i>state-reduction</i>  problem. State-reduction algorithms are concerned with procedures for <br>reducing the number of states in a state table, while keeping the external input�output <br>requirements unchanged. Since  <i>m</i>  flip-flops produce   2<i>m</i>  states, a reduction in the number <br>of states may (or may not) result in a reduction in the number of flip-flops. An unpre-<br>dictable effect in reducing the number of flip-flops is that sometimes the equivalent <br>circuit (with fewer flip-flops) may require more combinational gates to realize its next <br>state and output logic. <br>
 <br>We will illustrate the state-reduction procedure with an example. We start with a sequen-<br>
tial circuit whose specification is given in the state diagram of  Fig.   5.25  . In our example, only <br>the input�output sequences are important; the internal states are used merely to provide <br>the required sequences. For that reason, the states marked inside the circles are denoted <br>
<hr>
<A name=250></a><b>232    Chapter 5  Synchronous Sequential Logic</b><br>
0/0<br>
0/0<br>
<i>a</i><br>
0/0<br>
1/0<br>
0/0<br>
0/0<br>
<i>b</i><br>
<i>c</i><br>
1/0 1/0 0/0<br>
<i>g</i><br>
<i>d</i><br>
<i>e</i><br>
1/1<br>
1/1<br>
0/0<br>
<i>f</i><br>
1/1<br>
1/1<br>
<b> <br>FIGURE 5.25 <br> <br>State diagram  </b><br>
by letter symbols instead of their binary values. This is in contrast to a binary counter, <br>wherein the binary value sequence of the states themselves is taken as the outputs. <br>
 <br>There are an infinite number of input sequences that may be applied to the circuit; <br>
each results in a unique output sequence. As an example, consider the input sequence <br>01010110100 starting from the initial state  <i>a</i> . Each input of 0 or 1 produces an output <br>of 0 or 1 and causes the circuit to go to the next state. From the state diagram, we obtain <br>the output and state sequence for the given input sequence as follows: With the circuit <br>in initial state  <i>a</i>,  an input of 0 produces an output of 0 and the circuit remains in state  <i>a</i> . <br>With present state  <i>a</i>  and an input of 1, the output is 0 and the next state is  <i>b</i> .  With  pres-<br>ent state  <i>b</i>  and an input of 0, the output is 0 and the next state is  <i>c</i> . Continuing this <br>process, we find the complete sequence to be as follows: <br>
<b> state </b><br>
<i><b> <br>a  </b></i><br>
<i><b> <br>a  </b></i><br>
<i><b> <br>b  </b></i><br>
<i><b> <br>c  </b></i><br>
<i><b> <br>d  </b></i><br>
<i><b> <br>e  </b></i><br>
<i><b> <br>f  </b></i><br>
<i><b> <br>f  </b></i><br>
<i><b> <br>g  </b></i><br>
<i><b> <br>f  </b></i><br>
<i><b> <br>g  </b></i><br>
<i><b> <br>a  </b></i><br>
 input <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
  <br>
 output <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
  <br>
 <br>In each column, we have the present state, input value, and output value. The next state <br>is written on top of the next column. It is important to realize that in this circuit the states <br>themselves are of secondary importance, because we are interested only in output <br>sequences caused by input sequences. <br>
 <br>Now let us assume that we have found a sequential circuit whose state diagram has <br>
fewer than seven states, and suppose we wish to compare this circuit with the circuit <br>whose state diagram is given by  Fig.   5.25  . If identical input sequences are applied to the <br>two circuits and identical outputs occur for all input sequences, then the two circuits are <br>said to be equivalent (as far as the input�output is concerned) and one may be replaced <br>by the other. The problem of state reduction is to find ways of reducing the number of <br>states in a sequential circuit without altering the input�output relationships. <br>
<hr>
<A name=251></a><b>Section 5.7  State Reduction and Assignment    233</b><br>
 <br>We now proceed to reduce the number of states for this example. First, we need the <br>
state table; it is more convenient to apply procedures for state reduction with the use of <br>a table rather than a diagram. The state table of the circuit is listed in  Table   5.6   and is <br>obtained directly from the state diagram. <br>
 <br>The following algorithm for the state reduction of a completely specified state table <br>
is given here without proof: "Two states are said to be equivalent if, for each member of <br>the set of inputs, they give exactly the same output and send the circuit either to the <br>same state or to an equivalent state." When two states are equivalent, one of them can <br>be removed without altering the input�output relationships. <br>
 <br>Now apply this algorithm to  Table   5.6  . Going through the state table, we look for two <br>
present states that go to the same next state and have the same output for both input <br>combinations. States  <i>e</i>  and  <i>g</i>  are two such states: They both go to states  <i>a</i>  and  <i>f</i>  and have <br>outputs of 0 and 1 for   <i>x </i>= 0     and     <i>x </i>= 1,     respectively. Therefore,  states   <i>g</i>  and  <i>e</i>   are  equiv-<br>alent, and one of these states can be removed. The procedure of removing a state and <br>replacing it by its equivalent is demonstrated in  Table   5.7 . The row with present state  <i>g</i> <br>is removed, and state  <i>g</i>  is replaced by state  <i>e</i>  each time it occurs in the columns headed <br>"Next State." <br>
 <br>Present state  <i>f</i>  now has next states  <i>e</i>  and  <i>f</i>  and outputs 0 and 1 for   <i>x </i>= 0     and     <i>x </i>= 1, <br>
respectively. The same next states and outputs appear in the row with present state  <i>d</i> . <br>Therefore, states  <i>f</i>  and  <i>d</i>  are equivalent, and state  <i>f</i>  can be removed and replaced by  <i>d</i> . <br>The final reduced table is shown in  Table   5.8  . The state diagram for the reduced table <br>consists of only five states and is shown in  Fig.   5.26  . This state diagram satisfies the <br>original input�output specifications and will produce the required output sequence for <br>any given input sequence. The following list derived from the state diagram of  Fig.   5.26  <br>is for the input sequence used previously (note that the same output sequence results, <br>although the state sequence is different): <br>
<b> state </b><br>
<i><b> <br>a  </b></i><br>
<i><b> <br>a  </b></i><br>
<i><b> <br>b  </b></i><br>
<i><b> <br>c  </b></i><br>
<i><b> <br>d  </b></i><br>
<i><b> <br>e  </b></i><br>
<i><b> <br>d  </b></i><br>
<i><b> <br>d  </b></i><br>
<i><b> <br>e  </b></i><br>
<i><b> <br>d  </b></i><br>
<i><b> <br>e  </b></i><br>
<i><b> <br>a  </b></i><br>
 input <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
  <br>
 output <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
  <br>
<b> <br>Table 5.6 <br><i> <br>State Table </b></i><br>
<b> </b><br>
<b> <br>Next State </b><br>
<b> <br>Output </b><br>
<b> <br>Present State </b><br>
<b> <br><i>x</i> </b><br>
<b>0  </b><br>
<b> <br><i>x</i> </b><br>
<b>1  </b><br>
<b> <br><i>x</i> </b><br>
<b>0  </b><br>
<b> <br><i>x</i> </b><br>
<b>1 </b><br>
 <br><i>a</i> <br>
 <br><i>a</i> <br>
 <br><i>b</i>  <br>
 0 <br>
 0 <br>
 <br><i>b</i> <br>
 <br><i>c</i> <br>
 <br><i>d</i>  <br>
 0 <br>
 0 <br>
 <br><i>c</i> <br>
 <br><i>a</i> <br>
 <br><i>d</i>  <br>
 0 <br>
 0 <br>
 <br><i>d</i> <br>
 <br><i>e</i> <br>
 <br><i>f</i>  <br>
 0 <br>
 1 <br>
 <br><i>e</i> <br>
 <br><i>a</i> <br>
 <br><i>f</i>  <br>
 0 <br>
 1 <br>
 <br><i>f</i> <br>
 <br><i>g</i> <br>
 <br><i>f</i>  <br>
 0 <br>
 1 <br>
 <br><i>g</i> <br>
 <br><i>a</i> <br>
 <br><i>f</i>  <br>
 0 <br>
 1 <br>
<hr>
<A name=252></a><b>234    Chapter 5  Synchronous Sequential Logic</b><br>
<b> <br>Table 5.7 <br><i> <br>Reducing the State Table </b></i><br>
<b> </b><br>
<b> <br>Next State </b><br>
<b> <br>Output </b><br>
<b> <br>Present State </b><br>
<b> <br><i>x</i> </b><br>
<b>0  </b><br>
<b> <br><i>x</i> </b><br>
<b>1  </b><br>
<b> <br><i>x</i> </b><br>
<b>0  </b><br>
<b> <br><i>x</i> </b><br>
<b>1 </b><br>
 <br><i>a</i> <br>
 <br><i>a</i> <br>
 <br><i>b</i>  <br>
 0 <br>
 0 <br>
 <br><i>b</i> <br>
 <br><i>c</i> <br>
 <br><i>d</i>  <br>
 0 <br>
 0 <br>
 <br><i>c</i> <br>
 <br><i>a</i> <br>
 <br><i>d</i>  <br>
 0 <br>
 0 <br>
 <br><i>d</i> <br>
 <br><i>e</i> <br>
 <br><i>f</i>  <br>
 0 <br>
 1 <br>
 <br><i>e</i> <br>
 <br><i>a</i> <br>
 <br><i>f</i>  <br>
 0 <br>
 1 <br>
 <br><i>f</i> <br>
 <br><i>e</i> <br>
 <br><i>f</i>  <br>
 0 <br>
 1 <br>
<b> <br>Table 5.8 <br><i> <br>Reduced State Table </b></i><br>
<b> </b><br>
<b> <br>Next State </b><br>
<b> <br>Output </b><br>
<b> <br>Present State </b><br>
<b> <br><i>x</i> </b><br>
<b>0  </b><br>
<b> <br><i>x</i> </b><br>
<b>1  </b><br>
<b> <br><i>x</i> </b><br>
<b>0  </b><br>
<b> <br><i>x</i> </b><br>
<b>1 </b><br>
 <br><i>a</i> <br>
 <br><i>a</i> <br>
 <br><i>b</i>  <br>
 0 <br>
 0 <br>
 <br><i>b</i> <br>
 <br><i>c</i> <br>
 <br><i>d</i>  <br>
 0 <br>
 0 <br>
 <br><i>c</i> <br>
 <br><i>a</i> <br>
 <br><i>d</i>  <br>
 0 <br>
 0 <br>
 <br><i>d</i> <br>
 <br><i>e</i> <br>
 <br><i>d</i>  <br>
 0 <br>
 1 <br>
 <br><i>e</i> <br>
 <br><i>a</i> <br>
 <br><i>d</i>  <br>
 0 <br>
 1 <br>
 <br>In fact, this sequence is exactly the same as that obtained for  Fig.   5.25   if we replace  <i>g</i>   by <br> <br><i>e</i>  and  <i>f</i>  by  <i>d</i> . <br>
 <br>Checking each pair of states for equivalency can be done systematically by means of <br>
a procedure that employs an implication table, which consists of squares, one for every <br>suspected pair of possible equivalent states. By judicious use of the table, it is possible <br>to determine all pairs of equivalent states in a state table.  <br>
0/0<br>
<i>a</i><br>
0/0<br>
0/0<br>
1/0<br>
0/0<br>
<i>e</i><br>
<i>b</i><br>
<i>c</i><br>
0/0<br>
1/1<br>
1/0<br>
<i>d</i><br>
1/0<br>
1/1<br>
<b> <br>FIGURE 5.26 <br> <br>Reduced state diagram  </b><br>
<hr>
<A name=253></a><b>Section 5.7  State Reduction and Assignment    235</b><br>
 <br>The sequential circuit of this example was reduced from seven to five states. In <br>
general, reducing the number of states in a state table may result in a circuit with <br>less equipment. However, the fact that a state table has been reduced to fewer states <br>does not guarantee a saving in the number of flip-flops or the number of gates. In <br>actual practice designers may skip this step because target devices are rich in <br>resources.  <br>
<b> <br>State Assignment </b><br>
 <br>In order to design a sequential circuit with physical components, it is necessary to assign <br>unique coded binary values to the states. For a circuit with  <i>m</i>  states, the codes must con-<br>tain  <i>n</i>  bits, where   2<i>n </i>� <i>m</i>.  For example, with three bits, it is possible to assign codes to <br>eight states, denoted by binary numbers 000 through 111. If the state table of  Table   5.6   is <br>used, we must assign binary values to seven states; the remaining state is unused. If the <br>state table of  Table   5.8   is used, only five states need binary assignment, and we are left <br>with three unused states. Unused states are treated as don't-care conditions during the <br>design. Since don't-care conditions usually help in obtaining a simpler circuit, it is more <br>likely but not certain that the circuit with five states will require fewer combinational <br>gates than the one with seven states. <br>
 <br>The simplest way to code five states is to use the first five integers in binary counting <br>
order, as shown in the first assignment of  Table   5.9  . Another similar assignment is the <br>Gray code shown in assignment 2. Here, only one bit in the code group changes when <br>going from one number to the next. This code makes it easier for the Boolean functions <br>to be placed in the map for simplification. Another possible assignment often used in <br>the design of state machines to control data-path units is the one-hot assignment. This <br>configuration uses as many bits as there are states in the circuit. At any given time, only <br>one bit is equal to 1 while all others are kept at 0. This type of assignment uses one flip-<br>flop per state, which is not an issue for register-rich field-programmable gate arrays. (See <br> Chapter    7   .)   <i>One-hot encoding usually leads to simpler decoding logic for the next state <br>and output.</i>  One-hot machines can be faster than machines with sequential binary <br>encoding, and the silicon area required by the extra flip-flops can be offset by the area <br>
<b> <br>Table 5.9 <br><i> <br>Three Possible Binary State Assignments </b></i><br>
<b> <br>Assignment 1, </b><br>
<b> <br>Assignment 2,   Assignment 3, </b><br>
<b> <br>State </b><br>
<b>Binary </b><br>
<b>Gray Code </b><br>
<b>One-Hot </b><br>
 <br><i>a</i>  <br>
 000 <br>
 000 <br>
 00001 <br>
 <br><i>b</i>  <br>
 001 <br>
 001 <br>
 00010 <br>
 <br><i>c</i>  <br>
 010 <br>
 011 <br>
 00100 <br>
 <br><i>d</i>  <br>
 011 <br>
 010 <br>
 01000 <br>
 <br><i>e</i>  <br>
 100 <br>
 110 <br>
 10000 <br>
<hr>
<A name=254></a><b>236    Chapter 5  Synchronous Sequential Logic</b><br>
<b> <br>Table 5.10 <br><i> <br>Reduced State Table with Binary Assignment 1 </b></i><br>
<b> </b><br>
<b> <br>Next State </b><br>
<b> <br>Output </b><br>
<b> <br>Present State </b><br>
<b> <br><i>x</i> </b><br>
<b>0  </b><br>
<b> <br><i>x</i> </b><br>
<b>1  </b><br>
<b> <br><i>x</i> </b><br>
<b>0 </b><br>
<b> <br><i>x</i> </b><br>
<b>1 </b><br>
 000 <br>
 000 <br>
 001 <br>
 0 <br>
 0 <br>
 001 <br>
 010 <br>
 011 <br>
 0 <br>
 0 <br>
 010 <br>
 000 <br>
 011 <br>
 0 <br>
 0 <br>
 011 <br>
 100 <br>
 011 <br>
 0 <br>
 1 <br>
 100 <br>
 000 <br>
 011 <br>
 0 <br>
 1 <br>
saved by using simpler decoding logic. This trade-off is not guaranteed, so it must be <br>evaluated for a given design. <br>
 <br>Table   5.10   is the reduced state table with binary assignment 1 substituted for the let-<br>
ter symbols of the states. A different assignment will result in a state table with different <br>binary values for the states. The binary form of the state table is used to derive the next-<br>state and output-forming combinational logic part of the sequential circuit. The com-<br>plexity of the combinational circuit depends on the binary state assignment chosen. <br>
 <br>Sometimes, the name  <i>transition table</i>  is used for a state table with a binary assignment. <br>
This convention distinguishes it from a state table with symbolic names for the states. <br>In this book, we use the same name for both types of state tables. <br>
<b> <br>5 . 8       D E S I G N   P R O C E D U R E </b><br>
 <br>Design procedures or methodologies specify hardware that will implement a desired <br>behavior. The design effort for small circuits may be manual, but industry relies on <br>automated synthesis tools for designing massive integrated circuits. The sequential build-<br>ing block used by synthesis tools is the  <i>D</i>  flip-flop. Together with additional logic, it can <br>implement the behavior of  <i>JK</i>  and  <i>T</i>  flip-flops. In fact, designers generally do not con-<br>cern themselves with the type of flip-flop; rather, their focus is on correctly describing <br>the sequential functionality that is to be implemented by the synthesis tool. Here we <br>will illustrate manual methods using  <i>D,</i>    <i>JK,</i>  and  <i>T</i>   flip-flops. <br>
 <br>The design of a clocked sequential circuit starts from a set of specifications and cul-<br>
minates in a logic diagram or a list of Boolean functions from which the logic diagram <br>can be obtained. In contrast to a combinational circuit, which is fully specified by a truth <br>table, a sequential circuit requires a state table for its specification. The first step in the <br>design of sequential circuits is to obtain a state table or an equivalent representation, <br>such as a state diagram.3 <br>
 <br>A synchronous sequential circuit is made up of flip-flops and combinational gates. The <br>
design of the circuit consists of choosing the flip-flops and then finding a combinational <br>
3 We will examine later another important representation of a machine's behavior--the algorithmic state <br>machine (ASM) chart.<br>
<hr>
<A name=255></a><b>Section 5.8  Design Procedure    237</b><br>
gate structure that, together with the flip-flops, produces a circuit which fulfills the stated <br>specifications. The number of flip-flops is determined from the number of states needed <br>in the circuit and the choice of state assignment codes. The combinational circuit is <br>derived from the state table by evaluating the flip-flop input equations and output equa-<br>tions. In fact, once the type and number of flip-flops are determined, the design process <br>involves a transformation from a sequential circuit problem into a combinational circuit <br>problem. In this way, the techniques of combinational circuit design can be applied. <br>
 <br>The procedure for designing synchronous sequential circuits can be summarized by <br>
a list of recommended steps: <br>
 <br><b> 1. </b><br>
 <br>From the word description and specifications of the desired operation, derive a <br>state diagram for the circuit. <br>
 <br><b> 2. </b><br>
 <br>Reduce the number of states if necessary. <br>
 <br><b> 3. </b><br>
 <br>Assign binary values to the states. <br>
 <br><b> 4. </b><br>
 <br>Obtain the binary-coded state table. <br>
 <br><b> 5. </b><br>
 <br>Choose the type of flip-flops to be used. <br>
 <br><b> 6. </b><br>
 <br>Derive the simplified flip-flop input equations and output equations. <br>
 <br><b> 7. </b><br>
  Draw  the  logic  diagram.   <br>
 <br>The word specification of the circuit behavior usually assumes that the reader is famil-<br>
iar with digital logic terminology. It is necessary that the designer use intuition and expe-<br>rience to arrive at the correct interpretation of the circuit specifications, because word <br>descriptions may be incomplete and inexact. Once such a specification has been set down <br>and the state diagram obtained, it is possible to use known synthesis procedures to com-<br>plete the design. Although there are formal procedures for state reduction and assign-<br>ment (steps 2 and 3), they are seldom used by experienced designers. Steps 4 through 7 <br>in the design can be implemented by exact algorithms and therefore can be automated. <br>The part of the design that follows a well-defined procedure is referred to as  <i>synthesis</i> . <br>Designers using logic synthesis tools (software) can follow a simplified process that devel-<br>ops an HDL description directly from a state diagram, letting the synthesis tool deter-<br>mine the circuit elements and structure that implement the description. <br>
 <br>The first step is a critical part of the process, because succeeding steps depend on it. <br>
We will give one simple example to demonstrate how a state diagram is obtained from <br>a word specification.  <br>
 <br>Suppose we wish to design a circuit that detects a sequence of three or more con-<br>
secutive 1's in a string of bits coming through an input line (i.e., the input is a  <i>serial bit <br>stream</i> ). The state diagram for this type of circuit is shown in  Fig.   5.27 . It is derived by <br>starting with state   <i>S</i>0,  the reset state. If the input is 0, the circuit stays in   <i>S</i>0,     but  if  the <br>input is 1, it goes to state   <i>S</i>1  to indicate that a 1 was detected. If the next input is 1, the <br>change is to state   <i>S</i>2  to indicate the arrival of two consecutive 1's, but if the input is 0, <br>the state goes back to   <i>S</i>0. The third consecutive 1 sends the circuit to state   <i>S</i>3.     If  more <br>1's are detected, the circuit stays in   <i>S</i>3. Any 0 input sends the circuit back to   <i>S</i>0.     In  this <br>way, the circuit stays in   <i>S</i>3  as long as there are three or more consecutive 1's received. <br>This is a Moore model sequential circuit, since the output is 1 when the circuit is in state <br> <br><i>S</i>3  and is 0 otherwise. <br>
<hr>
<A name=256></a><b>238    Chapter 5  Synchronous Sequential Logic</b><br>
0<br>
0<br>
1<br>
<i>S </i>/<br>
/<br>
0 0<br>
<i>S</i>1 0<br>
0<br>
0<br>
1<br>
<i>S </i>/<br>
/<br>
3 1<br>
<i>S</i>2 0<br>
1<br>
1<br>
<b> <br>FIGURE 5.27 <br> <br>State diagram for sequence detector  </b><br>
<b> <br>Synthesis Using  <i>D</i>  Flip-Flops </b><br>
 <br>Once the state diagram has been derived, the rest of the design follows a straight-<br>forward synthesis procedure. In fact, we can design the circuit by using an HDL <br>description of the state diagram and the proper HDL synthesis tools to obtain a <br>synthesized netlist. (The HDL description of the state diagram will be similar to <br>HDL Example 5.6 in Section 5.6.) To design the circuit by hand, we need to assign <br>binary codes to the states and list the state table. This is done in  Table   5.11 . The table <br>is derived from the state diagram of  Fig.   5.27   with a sequential binary assignment. <br>We choose two  <i>D</i>  flip-flops to represent the four states, and we label their outputs <br> <br><i>A</i>  and  <i>B</i> . There is one input  <i>x</i>  and one output  <i>y</i> . The characteristic equation of the <br> <br><i>D</i>   flip-flop  is     <i>Q</i>(<i>t </i>+ 1) = <i>DQ</i>,  which means that the next-state values in the state <br>table specify the  <i>D</i>  input condition for the flip-flop. The flip-flop input equations <br>
<b> <br>Table 5.11 <br><i> <br>State Table for Sequence Detector </b></i><br>
<b> <br>Present </b><br>
<b> <br>Next </b><br>
<b>State </b><br>
<b> <br>Input </b><br>
<b>State </b><br>
<b> <br>Output </b><br>
<b> <br><i>A</i> </b><br>
<b> <br><i>B</i> </b><br>
<b> <br><i>x</i> </b><br>
<b> <br><i>A</i> </b><br>
<b> <br><i>B</i> </b><br>
<b> <br><i>y</i> </b><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
<hr>
<A name=257></a><b>Section 5.8  Design Procedure    239</b><br>
<i>B</i><br>
<i>Bx</i><br>
<i>B</i><br>
<i>Bx</i><br>
<i>B</i><br>
<i>Bx</i><br>
<i>A</i><br>
00<br>
01<br>
11<br>
10<br>
<i>A</i><br>
00<br>
01<br>
11<br>
10<br>
<i>A</i><br>
00<br>
01<br>
11<br>
10<br>
<i>m</i>0<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
1<br>
3<br>
2<br>
0<br>
1<br>
3<br>
2<br>
0<br>
1<br>
3<br>
2<br>
0<br>
1<br>
0<br>
1<br>
0<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
7<br>
6<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
7<br>
6<br>
4<br>
5<br>
7<br>
6<br>
<i>A </i>1<br>
1<br>
1<br>
<i>A </i>1<br>
1<br>
1<br>
<i>A </i>1<br>
1<br>
1<br>
<i>x</i><br>
<i>x</i><br>
<i>x</i><br>
<i>DA  Ax   Bx</i><br>
<i>DB  Ax   B x</i><br>
<i>y   AB</i><br>
<b> <br>FIGURE 5.28 <br> <br>K-Maps for sequence detector  </b><br>
can be obtained directly from the next-state columns of  <i>A</i>  and  <i>B</i>  and expressed in <br>sum-of-minterms form as <br>
 <i>A</i>(<i>t </i>+ 1) = <i>DA</i>(<i>A</i>, <i>B</i>, <i>x</i>) = �(3, 5, 7)<br>
 <i>B</i>(<i>t </i>+ 1) = <i>DB</i>(<i>A</i>, <i>B</i>, <i>x</i>) = �(1, 5, 7)<br>
 <i>y</i>(<i>A</i>, <i>B</i>, <i>x</i>) =  �(6,  7)   <br>
 where   <i>A</i>  and  <i>B</i>  are the present-state values of flip-flops  <i>A</i>  and  <i>B</i>,    <i>x</i>  is the input, and   <i>DA</i> <br>and     <i>DB</i>  are the input equations. The minterms for output  <i>y</i>  are obtained from the output <br>column in the state table. <br>
 <br>The Boolean equations are simplified by means of the maps plotted in  Fig.   5.28  . The <br>
simplified equations are <br>
 <i>DA </i>= <i>Ax </i>+ <i>Bx</i><br>
 <i>DB </i>= <i>Ax </i>+ <i>B x</i><br>
 <i>y </i>= <i>AB</i> <br>
 <br>The advantage of designing with  <i>D</i>  flip-flops is that the Boolean equations describing <br>the inputs to the flip-flops can be obtained directly from the state table. Software tools <br>automatically infer and select the  <i>D</i> -type flip-flop from a properly written HDL model. <br>The schematic of the sequential circuit is drawn in  Fig.   5.29  .  <br>
<b> <br>Excitation Tables </b><br>
 <br>The design of a sequential circuit with flip-flops other than the  <i>D</i>  type is complicated <br>by the fact that the input equations for the circuit must be derived indirectly from the <br>state table. When  <i>D</i> -type flip-flops are employed, the input equations are obtained <br>directly from the next state. This is not the case for the  <i>JK</i>  and  <i>T</i>  types of flip-flops. In <br>order to determine the input equations for these flip-flops, it is necessary to derive a <br>functional relationship between the state table and the input equations. <br>
 <br>The flip-flop characteristic tables presented in  Table   5.1   provide the value of the <br>
next state when the inputs and the present state are known. These tables are useful <br>
<hr>
<A name=258></a><b>240    Chapter 5  Synchronous Sequential Logic</b><br>
<i>D</i><br>
<i>A</i><br>
<i>Clk</i><br>
<i>x</i><br>
<i>D</i><br>
<i>B</i><br>
<i>Clk</i><br>
<i>B</i><br>
<i>Clock</i><br>
<i>y</i><br>
<b> <br>FIGURE 5.29 <br> <br>Logic diagram of a Moore-type sequence detector  </b><br>
for analyzing sequential circuits and for defining the operation of the flip-flops. Dur-<br>ing the design process, we usually know the transition from the present state to the <br>next state and wish to find the flip-flop input conditions that will cause the required <br>transition. For this reason, we need a table that lists the required inputs for a given <br>change of state. Such a table is called an  <i>excitation table</i> . <br>
 <br>Table   5.12   shows the excitation tables for the two flip-flops (<i>JK</i> and <i>T</i>). Each table <br>
has a column for the present state  <i>Q</i> ( <i>t</i> ), a column for the next state   <i>Q</i>(<i>t </i>+ 1),     and  a <br>column for each input to show how the required transition is achieved. There are four <br>possible transitions from the present state to the next state. The required input condi-<br>tions for each of the four transitions are derived from the information available in the <br>characteristic table. The symbol X in the tables represents a don't-care condition, which <br>means that it does not matter whether the input is 1 or 0. <br>
 <br>The excitation table for the  <i>JK</i>  flip-flop is shown in part (a). When both present state <br>
and next state are 0, the  <i>J</i>  input must remain at 0 and the  <i>K</i>  input can be either 0 or 1. <br>Similarly, when both present state and next state are 1, the  <i>K</i>  input must remain at 0, <br>
<hr>
<A name=259></a><b>Section 5.8  Design Procedure    241</b><br>
<b> <br>Table 5.12 <br><i> <br>Flip-Flop Excitation Tables </b></i><br>
<b> <br><i>Q</i> ( <i>t</i> )  </b><br>
<b> <br><i>Q</i> ( <i>t</i> </b><br>
<b>1)  </b><br>
<b> <br><i>J</i> </b><br>
<b> <br><i>K</i> </b><br>
<b> <br><i>Q</i> ( <i>t</i> )  </b><br>
<b> <br><i>Q</i> ( <i>t</i> </b><br>
<b>1)  </b><br>
<b> <br><i>T</i> </b><br>
 0 <br>
 0 <br>
 0 <br>
 X <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 X <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 X <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 X <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 (a)   <i>JK</i>   Flip-Flop <br>
 (b)   <i>T</i>   Flip-Flop <br>
while the  <i>J</i>  input can be 0 or 1. If the flip-flop is to have a transition from the 0-state <br>to the 1-state,  <i>J</i>  must be equal to 1, since the  <i>J</i>  input sets the flip-flop. However, input <br> <br><i>K</i>  may be either 0 or 1. If   <i>K </i>= 0,     the     <i>J </i>= 1  condition sets the flip-flop as required; if <br> <br><i>K </i>= 1     and     <i>J </i>= 1,  the flip-flop is complemented and goes from the 0-state to the <br>1-state as required. Therefore, the  <i>K</i>  input is marked with a don't-care condition for the <br>0-to-1 transition. For a transition from the 1-state to the 0-state, we must have   <i>K </i>= 1, <br>since the  <i>K</i>  input clears the flip-flop. However, the  <i>J</i>  input may be either 0 or 1, since <br> <i>J </i>= 0  has no effect and   <i>J </i>= 1     together  with     <i>K </i>= 1  complements the flip-flop with a <br>resultant transition from the 1-state to the 0-state. <br>
 <br>The excitation table for the  <i>T</i>  flip-flop is shown in part (b). From the characteristic <br>
table, we find that when input   <i>T </i>= 1,  the state of the flip-flop is complemented, and <br>when     <i>T </i>= 0,  the state of the flip-flop remains unchanged. Therefore, when the state of <br>the flip-flop must remain the same, the requirement is that   <i>T </i>= 0. When the state of the <br>flip-flop has to be complemented,  <i>T</i>  must equal 1. <br>
<b> <br>Synthesis Using  <i>JK</i>  Flip-Flops </b><br>
 <br>The manual synthesis procedure for sequential circuits with  <i>JK</i>  flip-flops is the same as <br>with  <i>D</i>  flip-flops, except that the input equations must be evaluated from the present-<br>state to the next-state transition derived from the excitation table. To illustrate the pro-<br>cedure, we will synthesize the sequential circuit specified by  Table   5.13  . In addition to <br>having columns for the present state, input, and next state, as in a conventional state table, <br>the table shows the flip-flop input conditions from which the input equations are derived. <br>The flip-flop inputs are derived from the state table in conjunction with the excitation <br>table for the  <i>JK</i>  flip-flop. For example, in the first row of  Table   5.13  , we have a transition <br>for flip-flop  <i>A</i>  from 0 in the present state to 0 in the next state. In  Table   5.12  , for the  <i>JK</i> <br>flip-flop, we find that a transition of states from present state 0 to next state 0 requires <br>that input  <i>J</i>  be 0 and input  <i>K</i>  be a don't-care. So 0 and X are entered in the first row under <br> <i>JA</i>     and     <i>KA</i>,  respectively. Since the first row also shows a transition for flip-flop  <i>B</i>  from 0 <br>in the present state to 0 in the next state, 0 and X are inserted into the first row under   <i>JB</i> <br>and     <i>KB</i>,  respectively. The second row of the table shows a transition for flip-flop  <i>B</i>   from <br>0 in the present state to 1 in the next state. From the excitation table, we find that a tran-<br>sition from 0 to 1 requires that  <i>J</i>  be 1 and  <i>K</i>  be a don't-care, so 1 and X are copied into <br>
<hr>
<A name=260></a><b>242    Chapter 5  Synchronous Sequential Logic</b><br>
<b> <br>Table 5.13 <br><i> <br>State Table and JK Flip-Flop Inputs </b></i><br>
<b> <br>Present </b><br>
<b> <br>Next </b><br>
<b>State </b><br>
<b> <br>Input </b><br>
<b>State </b><br>
<b> <br>Flip-Flop Inputs </b><br>
<b> <br><i>A</i> </b><br>
<b> <br><i>B</i> </b><br>
<b> <br><i>x</i> </b><br>
<b> <br><i>A</i> </b><br>
<b> <br><i>B</i> </b><br>
<b> <br><i>J A </b></i><br>
<b> <br><i>K A </b></i><br>
<b> <br><i>J B </b></i><br>
<b> <br><i>K B </b></i><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 X <br>
 0 <br>
 X <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 X <br>
 1 <br>
 X <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 X <br>
 X <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 X <br>
 X <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 X <br>
 0 <br>
 0 <br>
 X <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 X <br>
 0 <br>
 1 <br>
 X <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 X <br>
 0 <br>
 X <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 X <br>
 1 <br>
 X <br>
 1 <br>
the second row under   <i>JB</i>     and     <i>KB</i>,  respectively. The process is continued for each row in <br>the table and for each flip-flop, with the input conditions from the excitation table copied <br>into the proper row of the particular flip-flop being considered. <br>
 <br>The flip-flop inputs in  Table   5.13   specify the truth table for the input equations as a <br>
function of present state  <i>A</i>,  present state  <i>B</i>,  and input  <i>x</i> . The input equations are simpli-<br>fied in the maps of  Fig.   5.30  . The next-state values are not used during the simplification, <br>
<i>B</i><br>
<i>B</i><br>
<i>Bx</i><br>
<i>Bx</i><br>
<i>A</i><br>
<i>A</i><br>
00<br>
01<br>
11<br>
10<br>
00<br>
01<br>
11<br>
10<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
0<br>
1<br>
3<br>
2<br>
0<br>
1<br>
3<br>
2<br>
0<br>
1<br>
0<br>
X<br>
X<br>
X<br>
X<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
7<br>
6<br>
4<br>
5<br>
7<br>
6<br>
<i>A</i><br>
1<br>
X<br>
X<br>
X<br>
X<br>
<i>A</i><br>
1<br>
1<br>
<i>x</i><br>
<i>x</i><br>
<i>JA  Bx</i><br>
<i>KA  Bx</i><br>
<i>B</i><br>
<i>B</i><br>
<i>Bx</i><br>
<i>Bx</i><br>
<i>A</i><br>
<i>A</i><br>
00<br>
01<br>
11<br>
10<br>
00<br>
01<br>
11<br>
10<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
0<br>
1<br>
3<br>
2<br>
0<br>
1<br>
3<br>
2<br>
0<br>
1<br>
X<br>
X<br>
0<br>
X<br>
X<br>
1<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
2<br>
6<br>
4<br>
5<br>
7<br>
6<br>
<i>A</i><br>
1<br>
1<br>
X<br>
X<br>
<i>A</i><br>
1<br>
X<br>
X<br>
1<br>
<i>x</i><br>
<i>x</i><br>
<i>JB  x</i><br>
<i>KB</i><br>
(<i>A </i><i> x</i>)<br>
<b> <br>FIGURE 5.30 <br> <br>Maps for  <i>J</i>  and  <i>K</i>  input equations  </b><br>
<hr>
<A name=261></a><b>Section 5.8  Design Procedure    243</b><br>
<i>x</i><br>
<i>J</i><br>
<i>A</i><br>
<i>Clk</i><br>
<i>K</i><br>
<i>A</i><br>
<i>J</i><br>
<i>B</i><br>
<i>Clk</i><br>
<i>K</i><br>
<i>B</i><br>
<i>Clock</i><br>
<b> <br>FIGURE 5.31 <br> <br>Logic diagram for sequential circuit with  <i>JK</i>  flip-flops  </b><br>
since the input equations are a function of the present state and the input only. Note the <br>advantage of using  <i>JK</i> -type flip-flops when sequential circuits are designed  <i>manually</i> . <br>The fact that there are so many don't-care entries indicates that the combinational cir-<br>cuit for the input equations is likely to be simpler, because don't-care minterms usually <br>help in obtaining simpler expressions. If there are unused states in the state table, there <br>will be additional don't-care conditions in the map. Nonetheless, <i>D</i>-type flip-flops are <br>more amenable to an automated design flow. <br>
 <br>The four input equations for the pair of  <i>JK</i>  flip-flops are listed under the maps of <br>
 <br>Fig.   5.30  . The logic diagram (schematic) of the sequential circuit is drawn in  Fig.   5.31 . <br>
<b> <br>Synthesis Using  <i>T</i>  Flip-Flops </b><br>
 <br>The procedure for synthesizing circuits using  <i>T</i>  flip-flops will be demonstrated by design-<br>ing a binary counter. An  <i>n</i> -bit binary counter consists of  <i>n</i>  flip-flops that can count in <br>binary from 0 to   2<i>n </i>- 1. The state diagram of a three-bit counter is shown in  Fig.   5.32  .As <br>
000<br>
001<br>
111<br>
010<br>
110<br>
011<br>
101<br>
100<br>
<b> <br>FIGURE 5.32 <br> <br>State diagram of three-bit binary counter  </b><br>
<hr>
<A name=262></a><b>244    Chapter 5  Synchronous Sequential Logic</b><br>
seen from the binary states indicated inside the circles, the flip-flop outputs repeat the <br>binary count sequence with a return to 000 after 111. The directed lines between circles <br>are not marked with input and output values as in other state diagrams. Remember that <br>state transitions in clocked sequential circuits are initiated by a clock edge; the flip-flops <br>remain in their present states if no clock is  applied. For that reason, the clock does not <br>appear explicitly as an input variable in a state  diagram or state table. From this point of <br>view, the state diagram of a counter does not have to show input and output values along <br>the directed lines. The only input to the circuit is the clock, and the outputs are specified <br>by the present state of the flip-flops. The next state of a counter depends entirely on its <br>present state, and the state transition occurs every time the clock goes through a transition. <br>
 <br>Table   5.14   is the state table for the three-bit binary counter. The three flip-flops are <br>
symbolized by   <i>A</i>2, <i>A</i>1,     and     <i>A</i>0.  Binary counters are constructed most efficiently with  <i>T</i> <br>flip-flops because of their complement property. The flip-flop excitation for the  <i>T</i>   inputs <br>is derived from the excitation table of the  <i>T</i>  flip-flop and by inspection of the state <br>transition of the present state to the next state. As an illustration, consider the flip-flop <br>input entries for row 001. The present state here is 001 and the next state is 010, which <br>is the next count in the sequence. Comparing these two counts, we note that   <i>A</i>2     goes <br>from 0 to 0, so   <i>TA</i>2  is marked with 0 because flip-flop   <i>A</i>2  must not change when a clock <br>occurs.  Also,     <i>A</i>1  goes from 0 to 1, so   <i>TA</i>1  is marked with a 1 because this flip-flop must <br>be complemented in the next clock edge. Similarly,   <i>A</i>0  goes from 1 to 0, indicating that <br>it must be complemented, so   <i>TA</i>0  is marked with a 1. The last row, with present state 111, <br>is compared with the first count 000, which is its next state. Going from all 1's to all 0's <br>requires  that  all  three  flip-flops  be  complemented.        <br>
 <br>The flip-flop input equations are simplified in the maps of  Fig.   5.33  . Note that   <i>TA</i>0 <br>
has 1's in all eight minterms because the least significant bit of the counter is comple-<br>mented with each count. A Boolean function that includes all minterms defines a <br>constant value of 1. The input equations listed under each map specify the combina-<br>tional part of the counter. Including these functions with the three flip-flops, we obtain <br>
<b> <br>Table 5.14 <br><i> <br>State Table for Three-Bit Counter </b></i><br>
<b> <br>Present State </b><br>
<b> <br>Next State </b><br>
<b> <br>Flip-Flop Inputs </b><br>
<b> <br><i>A </i>2<i> </b></i><br>
<b> <br><i>A </i>1<i> </b></i><br>
<b> <br><i>A </i>0<i> </b></i><br>
<b> <br><i>A </i>2<i> </b></i><br>
<b> <br><i>A </i>1<i> </b></i><br>
<b> <br><i>A </i>0<i> </b></i><br>
<b> <br><i>T A</i>2<i> </b></i><br>
<b> <br><i>T A</i>1<i> </b></i><br>
<b> <br><i>T A</i>0<i> </b></i><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
<hr>
<A name=263></a><b>Problems    245</b><br>
<i>A</i><br>
<i>A</i><br>
1<br>
<i>A</i><br>
<i>A</i><br>
1<i>A</i>0<br>
<i>A</i><br>
1<br>
<i>A</i><br>
1<i>A</i>0<br>
1<i>A</i>0<br>
1<br>
<i>A</i>2<br>
00<br>
01<br>
11<br>
10<br>
<i>A</i><br>
<i>A</i><br>
2<br>
2<br>
00<br>
01<br>
11<br>
10<br>
00<br>
01<br>
11<br>
10<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
0<br>
1<br>
3<br>
2<br>
0<br>
1<br>
3<br>
2<br>
0<br>
1<br>
3<br>
2<br>
0<br>
1<br>
0<br>
1<br>
1<br>
0<br>
1<br>
1<br>
1<br>
1<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
7<br>
6<br>
4<br>
5<br>
7<br>
6<br>
4<br>
5<br>
7<br>
6<br>
<i>A</i>2 1<br>
1<br>
<i>A</i>2 1<br>
1<br>
1<br>
<i>A</i>2 1<br>
1<br>
1<br>
1<br>
1<br>
<i>A</i><br>
<i>x</i><br>
0<br>
<i>A</i>0<br>
<i>TA</i>2<br>
<i>A</i>1<i>A</i>0<br>
<i>TA</i>1<br>
<i>A</i>0<br>
<i>TA</i>0  1<br>
<b> <br>FIGURE 5.33 <br> <br>Maps for three-bit binary counter  </b><br>
<i>A</i>2<br>
<i>A</i>1<br>
<i>A</i>0<br>
<i>Clk</i><br>
<i>Clk</i><br>
<i>Clk</i><br>
<i>T</i><br>
<i>T</i><br>
<i>T</i><br>
<i>Clock</i><br>
1<br>
<b> <br>FIGURE 5.34 <br> <br>Logic diagram of three-bit binary counter  </b><br>
the logic diagram of the counter, as shown in  Fig.   5.34  . For simplicity, the reset signal <br>is not shown, but be aware that every design should include a reset signal. <br>
<b> <br>P R O B L E M S   </b><br>
 <br>(Answers to problems marked with <b>*</b> appear at the end of the book. Where appropriate, a logic <br>design and its related HDL modeling problem are cross-referenced.) <br> <br>Note: For each problem that requires writing and verifying an HDL model, a test plan should be <br>written to identify which functional features are to be tested during the simulation and how they <br>will be tested. For example, a reset on the fly could be tested by asserting the reset signal while <br>the simulated machine is in a state other than the reset state. The test plan is to guide development <br>of a test bench that will implement the plan. Simulate the model, using the test bench, and verify <br>that the behavior is correct. If synthesis tools and an ASIC cell library are available, the Verilog <br>descriptions developed for Problems 5.34�5.42 can be assigned as synthesis exercises. The gate-<br>level circuit produced by the synthesis tools should be simulated and compared to the simulation <br>results for the pre-synthesis model. The same exercises can be assigned if an FPGA tool suite is <br>available.   <br>
<hr>
<A name=264></a><b>246    Chapter 5  Synchronous Sequential Logic</b><br>
 <br><b> 5.1 </b><br>
  The   <i>D</i>  latch of  Fig.   5.6   is constructed with four NAND gates and an inverter. Consider the <br>following three other ways for obtaining a  <i>D</i>  latch. In each case, draw the logic diagram <br>and verify the circuit operation. <br>
 <br>
(a)   Use NOR gates for the  <i>SR</i>  latch part and AND gates for the other two. An inverter <br>
may be needed. <br>
 <br>
(b)   Use NOR gates for all four gates. Inverters may be needed. <br>
 <br>
(c)<b>  </b> Use four NAND gates only (without an inverter). This can be done by connecting <br>
the output of the upper gate in  Fig.   5.6   (the gate that goes to the  <i>SR</i>  latch) to the input <br>of the lower gate (instead of the inverter output). <br>
 <br><b> 5.2 </b><br>
  Construct  a   <i>JK</i>  flip-flop using a  <i>D</i>  flip-flop, a two-to-one-line multiplexer, and an inverter. <br>(HDL--see Problem 5.34.)  <br>
 <br><b> 5.3 </b><br>
 <br>Show that the characteristic equation for the complement output of a  <i>JK</i>  flip-flop is <br>
 <br><i>Q </i>(<i>t </i>+ 1) = <i>J Q </i>+ <i>KQ</i> <br>
 <br><b> 5.4 </b><br>
  A   <i>PN</i>  flip-flop has four operations: clear to 0, no change, complement, and set to 1, when <br>inputs  <i>P</i>  and  <i>N</i>  are 00, 01, 10, and 11, respectively. <br>
 <br>
(a)    Tabulate  the  characteristic  table.     <br>
(b)  <b>*  </b>Derive the characteristic equation. <br>
   <br>
(c)    Tabulate  the  excitation  table.   <br>
  (d)        Show  how  the   <i>PN</i>  flip-flop can be con-<br>
verted to a <i>D</i>  flip-flop.     <br>
 <br><b> 5.5 </b><br>
 <br>Explain the differences among a truth table, a state table, a characteristic table, and an <br>excitation table. Also, explain the difference among a Boolean equation, a state equation, <br>a characteristic equation, and a flip-flop input equation. <br>
 <br><b> 5.6 </b><br>
 <br>A sequential circuit with two  <i>D</i>  flip-flops  <i>A</i>  and  <i>B</i>,  two inputs,  <i>x</i>  and  <i>y</i> ; and one output  <i>z</i> <br>is specified by the following next-state and output equations (HDL--see Problem 5.35): <br>
 <i>A</i>(<i>t </i>+ 1) = <i>xy </i>+ <i>xB<br></i> <i>B</i>(<i>t </i>+ 1) = <i>xA </i>+ <i>xB</i><br>
 <i>z </i>= <i>A</i> <br>
 <br>
(a)   Draw the logic diagram of the circuit. <br>
 <br>
(b)   List the state table for the sequential circuit. <br>
   <br>
(c) <br>
  Draw  the  corresponding  state  diagram.     <br>
 <br><b> 5.7*  </b> A sequential circuit has one flip-flop  <i>Q</i>,  two inputs  <i>x</i>   and   <i>y</i>,  and one output  <i>S</i> .  It  consists <br>
of a full-adder circuit connected to a  <i>D</i>   flip-flop,  as  shown  in   Fig.    P5.7   .  Derive  the  state <br>table and state diagram of the sequential circuit. <br>
<i>x</i><br>
<i>S</i><br>
<i>y</i><br>
Full<br>
adder<br>
<i>C</i><br>
<i>Q</i><br>
<i>D</i><br>
<i>Clk</i><br>
<i>Clock</i><br>
<b> <br>FIGURE P5.7  </b><br>
<hr>
<A name=265></a><b>Problems    247</b><br>
 <br><b> 5.8*  </b> Derive the state table and the state diagram of the sequential circuit shown in  Fig.   P5.8  . <br>
Explain the function that the circuit performs. (HDL--see Problem 5.36.)  <br>
<i>A</i><br>
<i>A</i><br>
<i>B</i><br>
<i>B</i><br>
<i>Clk</i><br>
<i>Clk</i><br>
<i>T</i><br>
<i>T</i><br>
<i>Clock</i><br>
<b> <br>FIGURE P5.8  </b><br>
 <br><b> 5.9 </b><br>
 <br>A sequential circuit has two  <i>JK</i>  flip-flops  <i>A</i>  and  <i>B</i>  and one input  <i>x</i> . The circuit is described <br>by the following flip-flop input equations: <br>
 <i>JA </i>= <i>x KA </i>= <i>B</i><br>
 <i>JB </i>= <i>x KB </i>= <i>A </i> <br>
 <br>
(a)   Derive the state equations  <i>A</i> ( <i>t</i>  + 1) and  <i>B</i> ( <i>t</i>  + 1) by substituting the input equations <br>
for the  <i>J</i>  and  <i>K</i>   variables.  <br>
   <br>
(b)    Draw  the  state  diagram  of  the  circuit.     <br>
 <br><b> 5.10 </b><br>
 <br>A sequential circuit has two  <i>JK</i>  flip-flops  <i>A</i>  and  <i>B</i>,  two inputs  <i>x</i>  and  <i>y,</i>  and one output  <i>z</i> . <br>The flip-flop input equations and circuit output equation are <br>
 <i>JA </i>= <i>Bx </i>+ <i>B y</i><br>
<i>KA </i>= <i>B xy</i><br>
 <i>JB </i>= <i>A x</i><br>
    <i>KB </i>= <i>A </i>+ <i>xy</i><br>
 <i>z </i>= <i>Ax y </i>+ <i>Bx y </i> <br>
 <br>
(a)   Draw the logic diagram of the circuit. <br>
   <br>
(b)    Tabulate  the  state  table.  <br>
 <br>
(c)   Derive the state equations for  <i>A</i>  and  <i>B</i> . <br>
 <br><b> 5.11 </b><br>
 <br>For the circuit described by the state diagram of  Fig.   5.16  , <br>
 <br>
(a)  <b>*</b>   Determine the state transitions and output sequence that will be generated when an <br>
input sequence of 010110111011110 is applied to the circuit and it is initially in the <br>state 00. <br>
 <br>
(b)   Find all of the equivalent states in  Fig.   5.16   and draw a simpler, but equivalent, state <br>
diagram.  <br>
   <br>
(c) <br>
  Using  <i>D</i> flip-flops, design the equivalent machine (including its logic diagram) <br>described by the state diagram in (b). <br>
<hr>
<A name=266></a><b>248    Chapter 5  Synchronous Sequential Logic</b><br>
 <br><b> 5.12 </b><br>
 <br>For the following state table  <br>
<b> <br>Next State </b><br>
<b> <br>Output </b><br>
<b> <br>Present State </b><br>
<b> <br><i>x</i> </b><br>
<b>0  </b><br>
<b> <br><i>x</i> </b><br>
<b>1  </b><br>
<b> <br><i>x</i> </b><br>
<b>0  </b><br>
<b> <br><i>x</i> </b><br>
<b>1 </b><br>
 <br><i>a</i> <br>
 <br><i>f</i> <br>
 <br><i>b</i>  <br>
 0 <br>
 0 <br>
 <br><i>b</i> <br>
 <br><i>d</i> <br>
 <br><i>c</i>  <br>
 0 <br>
 0 <br>
 <br><i>c</i> <br>
 <br><i>f</i> <br>
 <br><i>e</i>  <br>
 0 <br>
 0 <br>
 <br><i>d</i> <br>
 <br><i>g</i> <br>
 <br><i>a</i>  <br>
 1 <br>
 0 <br>
 <br><i>e</i> <br>
 <br><i>d</i> <br>
 <br><i>c</i>  <br>
 0 <br>
 0 <br>
 <br><i>f</i> <br>
 <br><i>f</i> <br>
 <br><i>b</i>  <br>
 1 <br>
 1 <br>
 <br><i>g</i> <br>
 <br><i>g</i> <br>
 <br><i>h</i>  <br>
 0 <br>
 1 <br>
 <br><i>h</i> <br>
 <br><i>g</i> <br>
 <br><i>a</i>  <br>
 1 <br>
 0 <br>
 <br>
(a)   Draw the corresponding state diagram. <br>
   <br>
(b)  <b>*</b>  Tabulate the reduced state table. <br>
 <br>
(c)   Draw the state diagram corresponding to the reduced state table. <br>
 <br><b> 5.13 </b><br>
 <br>Starting from state  <i>a</i>,  and the input sequence 01110010011, determine the output <br>sequence for <br>
 <br>
(a)   The state table of the previous problem. <br>
 <br>
(b)   The reduced state table from the previous problem. Show that the same output <br>
sequence is obtained for both. <br>
 <br><b> 5.14 </b><br>
  Substitute  the  one-hot  assignment  2  from   Table    5.9     to  the  states  in   Table    5.8     and  obtain <br>the binary state table. <br>
 <br><b> 5.15 </b><br>
 <br>List a state table for the  <i>JK</i>  flip-flop using  <i>Q</i>  as the present and next state and  <i>J</i>  and  <i>K</i>   as <br>inputs. Design the sequential circuit specified by the state table and show that it is equiva-<br>lent  to   Fig.    5.12   (a).   <br>
 <br><b> 5.16 </b><br>
 <br>Design a sequential circuit with two  <i>D</i>  flip-flops  <i>A</i>  and  <i>B</i>,  and one input  <i>x_in</i> . <br>
 <br>
(a)  <b>*</b>   When   <i>x_in</i>  = 0, the state of the circuit remains the same. When  <i>x_in</i>  = 1, the circuit <br>
goes through the state transitions from 00 to 01, to 11, to 10, back to 00, and repeats. <br>
 <br>
(b)    When   <i>x_in</i>  = 0, the state of the circuit remains the same. When  <i>x_in</i>  =1, the circuit <br>
goes through the state transitions from 00 to 11, to 01, to 10, back to 00, and repeats. <br>(HDL--see  Problem  5.38.)     <br>
 <br><b> 5.17 </b><br>
 <br>Design a one-input, one-output serial 2's complementer. The circuit accepts a string of bits <br>from the input and generates the 2's complement at the output. The circuit can be reset <br>asynchronously to start and end the operation. (HDL--see Problem 5.39.)  <br>
 <br><b> 5.18* </b> Design a sequential circuit with two  <i>JK</i>  flip-flops  <i>A</i>  and  <i>B</i>  and two inputs  <i>E</i>  and  <i>F</i> . If  <i>E</i>  = 0, <br>
the circuit remains in the same state regardless of the value of  <i>F</i> .  When   <i>E</i>  = 1 and  <i>F</i>  = 1, the <br>circuit goes through the state transitions from 00 to 01, to 10, to 11, back to 00, and repeats. <br>When  <i>E</i>  = 1 and  <i>F</i>  = 0, the circuit goes through the state transitions from 00 to 11, to 10, to <br>01, back to 00, and repeats. (HDL--see Problem 5.40.) <br>
 <br><b> 5.19 </b><br>
 <br>A sequential circuit has three flip-flops  <i>A, B, C</i> ; one input  <i>x_in</i> ; and one output  <i>y_out</i> .  The <br>state diagram is shown in  Fig.   P5.19  . The circuit is to be designed by treating the unused <br>states as don't-care conditions. Analyze the circuit obtained from the design to determine <br>the effect of the unused states. (HDL--see Problem 5.41.)  <br>
<hr>
<A name=267></a><b>Problems    249</b><br>
 <br>
(a)<b>*</b>    Use   <i>D</i>  flip-flops in the design. <br>
 <br>
(b)<b>  </b>  Use   <i>JK</i>   flip-flops  in  the  design.     <br>
0/0<br>
001<br>
1/1<br>
0/0<br>
1/0<br>
100<br>
011<br>
1/1<br>
0/0<br>
0/0<br>
1/1<br>
0/0<br>
010<br>
1/1<br>
000<br>
<b> <br>FIGURE P5.19  </b><br>
 <br><b> 5.20 </b><br>
 <br>Design the sequential circuit specified by the state diagram of  Fig.   5.19  , using  <i>T</i>   flip-flops.   <br>
 <br><b> 5.21 </b><br>
 <br>What is the main difference between an  <b>initial</b>  statement and an  <b>always</b>  statement in <br>Verilog HDL?  <br>
 <br><b> 5.22 </b><br>
 <br>Draw the waveform generated by the statements below: <br>
 <br>
(a) <br>
    <br><b>initial begin  </b><br>
<b> </b><br>
<b> </b><br>
     w = 0; #10 w = 1; # 40 w = 0;  # 20 w = 1;  #15 w = 0; <br>
 <br>
 <br>
  <b>end</b> <br>
 <br>
  (b)<b>  </b> <b>initial fork  </b><br>
 <br>
 <br>
    w = 0;  #10 w = 1;  # 40 w = 0;  # 20 w = 1;  #15 w = 0; <br>
<b> </b><br>
<b> </b><br>
<b> <br> join </b><br>
<b> </b><br>
 <br><b> 5.23* </b> Consider the following statements assuming that  <i>RegA</i>  contains the value of 50 initially. <br>
 <br>
(a)<b>  </b> RegA = 125; (b) <br>
RegA &lt;= 125; <br>
 <br>
 <br>
 <br>RegB = RegA; <br>
 <br>
RegB &lt;= RegA; <br>
 <br>
 <br>What are the values of RegA and RegB after execution?  <br>
 <br><b> 5.24 </b><br>
 <br>Write and verify an HDL behavioral description of a positive-edge-sensitive  <i>D</i>   flip-flop <br>with asynchronous preset and clear.   <br>
 <br><b> 5.25 </b><br>
 <br>A special positive-edge-triggered flip-flop circuit component has four inputs  <i>D</i> 1,   <i>D</i> 2,   <i>D</i> 3, <br>and  <i>D</i> 4, and a two-bit control input that chooses between them. Write and verify an HDL <br>behavioral description of this component. <br>
 <br><b> 5.26 </b><br>
 <br>Write and verify an HDL behavioral description of the  <i>JK</i>  flip-flop using an if-else statement <br>based on the value of the present state. <br>
 <br>
(a)  <b>*  </b>Obtain the characteristic equation when  <i>Q</i>  = 0 or  <i>Q</i>  = 1. <br>
   <br>
(b)    Specify  how  the   <i>J</i>  and  <i>K</i>  inputs affect the output of the flip-flop at each clock tick. <br>
 <br><b> 5.27 </b><br>
 <br>Rewrite and verify the description of HDL Example 5.5 by combining the state transitions <br>and output into one  <b>always</b>   block.   <br>
 <br><b> 5.28 </b><br>
  Simulate  the  sequential  circuit  shown  in   Fig.    5.17   . <br>
<hr>
<A name=268></a><b>250    Chapter 5  Synchronous Sequential Logic</b><br>
 <br>
(a)<b>  </b> Write the HDL description of the state diagram (i.e., behavioral model). <br>
 <br>
(b)<b>  </b> Write the HDL description of the logic (circuit) diagram (i.e., a structural model). <br>
 <br>
(c)<b>  </b> Write an HDL stimulus with a sequence of inputs: 00, 01, 11, 10. Verify that the <br>
response is the same for both descriptions. <br>
 <br><b> 5.29 </b><br>
 <br>Write a behavioral description of the state machine described by the state diagram shown <br>in Fig. P5.19. Write a test bench and verify the functionality of the description. <br>
 <br><b> 5.30 </b><br>
 <br>Draw the logic diagram for the sequential circuit described by the following HDL module: <br>
 <br>
 <br>
 <br><b>module</b>  Seq_Ckt ( <b>input</b>  A, B, C, E  <b>output</b>   <b>reg</b>  Q,input CLK,); <br>
 <br>
 <br>
  <b>reg E;</b> <br>
 <br>
 <br>
  <b>always   @  ( posedge </b> CLK) <br>
 <br>
 <br>
  <b>begin  </b><br>
 <br>
 <br>
    E &lt;= A || B; <br>
 <br>
 <br>
    Q &lt;= E &amp;&amp; C; <br>
 <br>
 <br>
  <b>end  </b><br>
 <br>
 <br>
 <br><b>endmodule  </b><br>
 <br><b> 5.31 </b><br>
 <br>How should the description in problem 5.30 be written to have the same behavior when <br>the assignments are made with = instead of with &lt;= ?  <br>
 <br><b> 5.32 </b><br>
  Using  an   <b>initial</b>  statement with a  <b>begin</b>  . . .  <b>end</b>  block write a Verilog description of the <br>waveforms shown in  Fig.   P5.32  . Repeat using a  <b>fork</b>  . . .  <b>join</b>   block.    <br>
enable<br>
A<br>
B<br>
C<br>D<br>
E<br>
F<br>
t<br>
0<br>
10<br>
20<br>
30<br>
40<br>
50<br>
60<br>
70<br>
80<br>
<b> <br>FIGURE P5.32 <br> <br>Waveforms for Problem 5.32  </b><br>
 <br><b> 5.33 </b><br>
 <br>Explain why it is important that the stimulus signals in a test bench be synchronized to the <br>inactive edge of the clock of the sequential circuit that is to be tested. <br>
 <br><b> 5.34 </b><br>
 <br>Write and verify an HDL structural description of the machine having the circuit diagram <br>(schematic) shown in Fig. 5.5. <br>
 <br><b> 5.35 </b><br>
 <br>Write and verify an HDL model of the sequential circuit described in Problem 5.6. <br>
 <br><b> 5.36 </b><br>
 <br>Write and verify an HDL structural description of the machine having the circuit diagram <br>(schematic) shown in Fig. P5.8. <br>
 <br><b> 5.37 </b><br>
 <br>Write and verify HDL behavioral descriptions of the state machines shown in  Figs.   5.25  <br>
<hr>
<A name=269></a><b>Problems    251</b><br>
and   5.26  . Write a test bench to compare the state sequences and input�output behaviors <br>of the two machines. <br>
 <br><b> 5.38 </b><br>
 <br>Write and verify an HDL behavioral description of the machine described in Problem 5.16. <br>
 <br><b> 5.39 </b><br>
 <br>Write and verify a behavioral description of the machine specified in Problem 5.17. <br>
 <br><b> 5.40 </b><br>
 <br>Write and verify a behavioral description of the machine specified in Problem 5.18. <br>
 <br><b> 5.41 </b><br>
 <br>Write and verify a behavioral description of the machine specified in Problem 5.19. <br>( <i>Hint</i> : See the discussion of the  <b>default</b>  case item preceding HDL Example 4.8 in <br> Chapter    4   .)   <br>
 <br><b> 5.42 </b><br>
 <br>Write and verify an HDL structural description of the circuit shown in  Fig.   5.29  . <br>
 <br><b> 5.43 </b><br>
 <br>Write and verify an HDL behavioral description of the three-bit binary counter in  Fig.   5.34  . <br>
 <br><b> 5.44 </b><br>
 <br>Write and verify a Verilog model of a  <i>D</i>  flip-flop having asynchronous reset. <br>
 <br><b> 5.45 </b><br>
 <br>Write and verify an HDL behavioral description of the sequence detector described in  Fig.  5.27 . <br>
 <br><b> 5.46 </b><br>
 <br>A synchronous finite state machine has an input  <i>x_in</i>  and an output  <i>y_out</i> .  When   <i>x_in</i> <br>changes from 0 to 1, the output  <i>y_out</i>  is to assert for three cycles, regardless of the value <br>of  <i>x_in,</i>  and then de-assert for two cycles before the machine will respond to another <br>assertion of  <i>x_in</i> . The machine is to have active-low synchronous reset. <br>
 <br>
(a)<b>  </b> Draw the state diagram of the machine. <br>
 <br>
(b)<b>  </b> Write and verify a Verilog model of the machine. <br>
 <br><b> 5.47 </b><br>
 <br>Write a Verilog model of a synchronous finite state machine whose output is the  sequence <br>0, 2, 4, 6, 8 10, 12, 14, 0 . . . . The machine is controlled by a single input,  <i>Run</i>,  so that counting <br>occurs while  <i>Run</i>  is asserted, suspends while  <i>Run</i>  is de-asserted, and resumes the count <br>when  <i>Run</i>  is re-asserted. Clearly state any assumptions that you make. <br>
 <br><b> 5.48 </b><br>
 <br>Write a Verilog model of the Mealy FSM described by the state diagram in Fig. P5.48. <br>Develop a test bench and demonstrate that the machine state transitions and output cor-<br>respond to its state diagram.  <br>
<i>a</i><br>
0 / 1<br>
<i>b</i><br>
1/ 0<br>
1/ 1<br>
0/ 0<br>
0/ 0<br>
1/ 0<br>
1/ 1<br>
<i>d</i><br>
<i>c</i><br>
0/ 1<br>
 <br><b>FIGURE P5.48  </b><br>
<hr>
<A name=270></a><b>252    Chapter 5  Synchronous Sequential Logic</b><br>
 <br><b> 5.49 </b><br>
 <br>Write a Verilog model of the Moore FSM described by the state diagram in Fig. P5.49. <br>Develop a test bench and demonstrate that the machine's state transitions and output <br>correspond to its state diagram. <br>
<i>a</i><br>
0<br>
<i>b</i><br>
0<br>
1<br>
1<br>
1<br>
0<br>
0<br>
1<br>
1<br>
<i>d</i><br>
<i>c</i><br>
0<br>
1<br>
0<br>
<b> <br>FIGURE P5.49  </b><br>
 <br><b> 5.50 </b><br>
 <br>A synchronous Moore FSM has a single input,  <i>x_in</i>,  and a single output  <i>y_out</i> .  The  machine <br>is to monitor the input and remain in its initial state until a second sample of  <i>x_in</i>  is detected <br>to be 1. Upon detecting the second assertion of  <i>x_in y_out</i>  is to asserted and remain asserted <br>until a fourth assertion of  <i>x_in</i>  is detected. When the fourth assertion of  <i>x_in</i>  is detected the <br>machine is to return to its initial state and resume monitoring of  <i>x_in</i> . <br>
 <br>
(a)<b>  </b> Draw the state diagram of the machine. <br>
 <br>
(b)<b>  </b> Write and verify a Verilog model of the machine. <br>
 <br><b> 5.51 </b><br>
 <br>Draw the state diagram of the machine described by the Verilog model given below. <br>
 <br>
 <br>
 <br><b>module</b>  Prob_5_51 ( <b>output   reg</b>  y_out, <b> input</b>  x_in, clk, reset); <br>
 <br>
  <b>parameter</b>  s0 = 2'b00, s1 = 2'b01, s2 = 2'b10, s3 = 2'b11; <br>
 <br>
  <b>reg</b>  [1:0] state, next_state; <br>
 <br>
  <b>always</b>  @ ( <b>posedge</b>  clk,  <b>negedge</b>  reset) begin <br>
 <br>
    <b>if</b>  (reset == 1'b0) state &lt;= s0; <br>
 <br>
    <b>else</b>  state &lt;= next_state; <br>
 <br>
  <b>always</b>  @(state, x_in)  <b>begin</b> <br>
 <br>
 <br>  y_out = 0; <br>
 <br>
 <br>  next_state = s0; <br>
 <br>
    <b>case</b>  (state) <br>
 <br>
 <br>  s0:  <br>
<b>if</b>  x_in = 1  <b>begin</b>  y_out = 0;  <b>if</b>  (x_in) next_state = s1;  <b>else</b>  next_state = s0; end <br>
 <br>
 <br>  s1:  <br>
<b>if</b>  x_in = 1  <b>begin</b>  y_out = 0;  <b>if</b>  (x_in) next_state = s2;  <b>else</b>  next_state = s1; end <br>
<hr>
<A name=271></a><b>Problems    253</b><br>
 <br>
 <br>  s2:  <br>
<b>if</b>  x_in = 1  <b>begin</b>  y_out = 1;  <b>if</b>  (x_in) next_state = s3;  <b>else</b>  next_state = s2; end <br>
 <br>
 <br>  s3:  <br>
<b>if</b>  x_in = 1  <b>begin</b>  y_out = 1;  <b>if</b>  (x_in) next_state = s0;  <b>else</b>  next_state = s3; end <br>
 <br>
    <b>default</b> : next_state = s0; <br>
 <br>
    <b>endcase</b> <br>
 <br>
  <b>end  </b><br>
 <br>
 <br><b>endmodule</b> <br>
 <br><b> 5.52 </b><br>
 <br>Draw the state diagram of the machine described by the Verilog model given below. <br>
 <br>
 <br><b>module</b>  Prob_5_52 ( <b>output</b>   <b>reg</b>  y_out,  <b>input</b>  x_in, clk, reset); <br>
 <br>
    <b>parameter</b>  s0 = 2'b00, s1 = 2'b01, s2 = 2'b10, s3 = 2'b11; <br>
 <br>
  <b>reg</b>  [1:0] state, next_state; <br>
 <br>
  <b>always</b>  @ ( <b>posedge</b>  clk,  <b>negedge</b>  reset) begin <br>
 <br>
    <b>if</b>  (reset == 1'b0) state &lt;= s0; <br>
 <br>
    <b>else</b>  state &lt;= next_state; <br>
 <br>
  <b>always</b>  @(state, x_in)  <b>begin</b> <br>
 <br>
 <br>  y_out = 0; <br>
 <br>
 <br>  next_state = s0; <br>
 <br>
    <b>case</b>  (state) <br>
 <br>
 <br>  s0:  <br>
<b>if</b>  x_in = 1  <b>begin</b>  y_out = 0;  <b>if</b>  (x_in) next_state = s1;  <b>else</b>  next_state = s0; end <br>
 <br>
 <br>  s1:  <br>
<b>if</b>  x_in = 1  <b>begin</b>  y_out = 0;  <b>if</b>  (x_in) next_state = s2;  <b>else</b>  next_state = s1; end <br>
 <br>
 <br>  s2:  <br>
<b>if</b>  x_in = 1  <b>if</b>  (x_in)  <b>begin</b>  next_state = s3; y_out = 0; <br>
 <br>
                             <b>else</b>   <b>begin</b>  next_state = s2; y_out = 1;  <b>end</b> <br>
 <br>
 <br>  s3:  <br>
<b>if</b>  x_in = 1  <b>begin</b>  y_out = 1;  <b>if</b>  (x_in) next_state = s0;  <b>else</b>  next_state = s3; end <br>
 <br>
    <b>default</b> : next_state = s0; <br>
 <br>
    <b>endcase</b> <br>
 <br>
  <b>end</b> <br>
 <br>
 <br><b>endmodule  </b><br>
 <br><b> 5.53 </b><br>
 <br>Draw a state diagram and write a Verilog model of a Mealy synchronous state machine <br>having a single input,  <i>x_in,</i>  and a single output  <i>y_out,</i>  such that  <i>y_out</i>  is asserted if the total <br>number of 1's received is a multiple of 3. <br>
 <br><b> 5.54 </b><br>
 <br>A synchronous Moore machine has two inputs,  <i>x</i> 1, and  <i>x</i> 2, and output  <i>y_out</i> . If both inputs <br>have the same value the output is asserted for one cycle; otherwise the output is 0. Develop <br>a state diagram and a write a Verilog behavioral model of the machine. Demonstrate that <br>the machine operates correctly. <br>
 <br><b> 5.55 </b><br>
 <br>Develop the state diagram for a Mealy state machine that detects a sequence of three or <br>more consecutive 1's in a string of bits coming through an input line. <br>
 <br><b> 5.56 </b><br>
 <br>Using manual methods, obtain the logic diagram of a three-bit counter that counts in the <br>sequence 0, 2, 4, 6, 0, . . . . <br>
 <br><b> 5.57 </b><br>
 <br>Write and verify a Verilog behavioral model of a three-bit counter that counts in the <br>sequence 0, 2, 4, 6, 0, . . . . <br>
 <br><b> 5.58 </b><br>
 <br>Write and verify a Verilog behavioral model of the counter designed in Problem 5.55. <br>
 <br><b> 5.59 </b><br>
 <br>Write and verify a Verilog structural model of the counter described in Problem 5.56. <br>
 <br><b> 5.60 </b><br>
 <br>Write and verify a Verilog behavioral model of a four-bit counter that counts in the <br>sequence 0, 1, . . . , 9, 0, 1, 2, . . . . <br>
<hr>
<A name=272></a><b>254    Chapter 5  Synchronous Sequential Logic</b><br>
<b> <br>R E F E R E N C E S </b><br>
 <br>
 <br><b>1.</b>  <br>
B hasker,   J.  1997.  A  <i>Verilog</i> <i>HDL</i> <i>Primer</i>. Allentown, PA: Star Galaxy Press. <br>
 <br>
 <br><b>2.</b> <br>
 B hasker,   J.  1998.  <i>Verilog</i> <i>HDL</i> <i>Synthesis</i>. Allentown, PA: Star Galaxy Press. <br>
 <br>
 <br><b>3.</b> <br>
 C iletti,   M.  D.  1999.  <i>Modeling, Synthesis, and Rapid Prototyping with Verilog HDL</i>. Upper <br>Saddle River, NJ: Prentice Hall. <br>
 <br>
 <br><b>4.</b>  <br>
D ietmeyer,   D.  L.  1988.  <i>Logic Design of Digital Systems</i>, 3rd ed. Boston: Allyn Bacon. <br>
 <br>
 <br><b>5.</b>  <br>
G ajski,   D.  D.  1997.  <i>Principles of Digital Design</i>. Upper Saddle River, NJ: Prentice Hall. <br>
 <br>
 <br><b>6.</b> <br>
 H ayes,   J.  P.  1993.  <i>Introduction to Digital Logic Design</i>. Reading, MA: Addison-Wesley. <br>
 <br>
 <br><b>7.</b> <br>
 K atz,   R.  H.  2005.  <i>Contemporary Logic Design</i>. Upper Saddle River, NJ: Prentice Hall. <br>
 <br>
 <br><b>8.</b> <br>
 <br>M ano,  M. M. and C. R. K ime . 2007. <i>Logic and Computer Design Fundamentals &amp; Xilinx <br>6.3 Student Edition</i>, 4th ed. Upper Saddle River, NJ: Prentice Hall. <br>
 <br>
 <br><b>9.</b> <br>
 <br>N elson, V. P., H. T. N agle,  J. D. I rwin,  and B. D. C arroll . 1995. <i>Digital Logic Circuit <br>Analysis and Design</i>. Englewood Cliffs, NJ: Prentice Hall. <br>
 <br>
 <br><b>10.</b> <br>
 P alnitkar,   S.  1996.  <i>Verilog HDL: A Guide to Digital Design and Synthesis</i>. Mountain View, <br>CA: SunSoft Press (a Prentice Hall title). <br>
 <br>
 <br><b>11.</b> <br>
 R oth,   C.  H.  2009.  <i>Fundamentals of Logic Design,</i> 6th ed. St. Paul, MN: Brooks/Cole. <br>
 <br>
 <br><b>12.</b> <br>
 <br>T homas,  D. E. and P. R. M oorby,  2002. <i>The Verilog Hardware Description Language</i>, 6th <br>ed. Boston: Kluwer Academic Publishers. <br>
 <br>
 <br><b>13.</b> <br>
 W akerly,   J.  F.  2006.  <i>Digital Design:</i> <i>Principles and Practices</i>, 4th ed. Upper Saddle River, <br>NJ: Prentice Hall. <br>
<b> <br>W E B   S E A R C H   T O P I C S </b><br>
 <br>
 <br>
   Finite  State  Machine  <br>
 <br>
 <br>
  Synchronous  state  machine  <br>
 <br>
 <br>
  Asynchronous  state  machine  <br>
 <br>
 <br>
 <br><i>D</i>-type flip-flop  <br>
 <br>
 <br>
  Toggle  flip-flop  <br>
 <br>
 <br>
 <br><i>J-K</i> type flip-flop  <br>
 <br>
 <br>
  Binary  counter  <br>
 <br>
 <br>
  State  diagram  <br>
 <br>
 <br>
  Mealy  state  machine  <br>
 <br>
 <br>
  Moore  state  machine  <br>
 <br>
 <br>
  One-hot/cold  codes       <br>
<hr>
<A name=273></a> <br>Chapter 6 <br>
<b> <br>Registers and Counters </b> <br>
<b> <br>6 . 1       R E G I S T E R S </b><br>
 <br>A clocked sequential circuit consists of a group of flipflops and combinational gates. The <br>flipflops are essential because, in their absence, the circuit reduces to a purely combinational <br>circuit (provided that there is no feedback among the gates). A circuit with flipflops is <br>considered a sequential circuit even in the absence of combinational gates. Circuits that <br>include flipflops are usually classified by the function they perform rather than by the name <br>of the sequential circuit. Two such circuits are registers and counters. <br>
 A   <i>register</i>  is a group of flipflops, each one of which shares a common clock and is <br>
capable of storing one bit of information. An  <i>n</i> bit register consists of a group of  <i>n</i> <br>flipflops capable of storing  <i>n</i>  bits of binary information. In addition to the flipflops, a <br>register may have combinational gates that perform certain dataprocessing tasks. In <br>its broadest definition, a register consists of a group of flipflops together with gates <br>that affect their operation. The flipflops hold the binary information, and the gates <br>determine how the information is transferred into the register. <br>
 A   <i>counter</i>  is essentially a register that goes through a predetermined sequence of <br>
binary states. The gates in the counter are connected in such a way as to produce the <br>prescribed sequence of states. Although counters are a special type of register, it is <br>common to differentiate them by giving them a different name. <br>
 <br>Various types of registers are available commercially. The simplest register is one that <br>
consists of only flipflops, without any gates.  Figure   6.1   shows such a register constructed <br>with four  <i>D</i> type flipflops to form a fourbit data storage register. The common clock <br>input triggers all flipflops on the positive edge of each pulse, and the binary data available <br>at the four inputs are transferred into the register. The value of ( <i>I</i> 3 ,   <i>I</i> 2 ,   <i>I</i> 1 ,   <i>I</i> 0 )  immediately <br>before the clock edge determines the value of ( <i>A</i> 3 ,   <i>A</i> 2 ,   <i>A</i> 1 ,   <i>A</i> 0 ) after the clock edge. The four <br>
<b>255</b><br>
<hr>
<A name=274></a><b>256    Chapter 6  Registers and Counters</b><br>
<i>I</i>0<br>
<i>D</i><br>
<i>A</i>0<br>
<i>C</i><br>
<i>R</i><br>
<i>I</i>1<br>
<i>D</i><br>
<i>A</i>1<br>
<i>C</i><br>
<i>R</i><br>
<i>I</i>2<br>
<i>D</i><br>
<i>A</i>2<br>
<i>C</i><br>
<i>R</i><br>
<i>I</i>3<br>
<i>D</i><br>
<i>A</i>3<br>
<i>C</i><br>
<i>R</i><br>
<i>Clock Clear_b</i><br>
<b> <br>FIGURE 6.1 <br> <br>Fourbit register  </b><br>
outputs can be sampled at any time to obtain the binary information stored in the register. <br>The input  <i>Clear_b</i>  goes to the activelow  <i>R</i>  (reset) input of all four flipflops. When this <br>input goes to 0, all flipflops are reset asynchronously. The  <i>Clear_b</i>  input is useful for clear-<br>ing the register to all 0's prior to its clocked operation. The  <i>R</i>  inputs must be maintained <br>
<hr>
<A name=275></a><b>Section 6.1  Registers    257</b><br>
at logic 1 (i.e., de-asserted) during normal clocked operation. Note that, depending on the <br>flipflop, either  <i>Clear</i>,    <i>Clear_b</i>,    <i>reset</i>,  or  <i>reset_b</i>  can be used to indicate the transfer of the <br>register to an all 0's state. <br>
<b> <br>Register with Parallel Load </b><br>
 <br>Registers with parallel load are a fundamental building block in digital systems. It is <br>important that you have a thorough understanding of their behavior. Synchronous dig-<br>ital systems have a master clock generator that supplies a continuous train of clock <br>pulses. The pulses are applied to all flipflops and registers in the system. The master <br>clock acts like a drum that supplies a constant beat to all parts of the system. A separate <br>control signal must be used to decide which register operation will execute at each clock <br>pulse. The transfer of new information into a register is referred to as  <i>loading</i>  or  <i>updat-<br>ing</i>  the register. If all the bits of the register are loaded simultaneously with a common <br>clock pulse, we say that the loading is done  <i>in parallel</i> . A clock edge applied to the  <i>C</i> <br>inputs of the register of  Fig.   6.1   will load all four inputs in parallel. In this configuration, <br>if the contents of the register must be left unchanged, the inputs must be held constant <br>or the clock must be inhibited from the circuit. In the first case, the data bus driving the <br>register would be unavailable for other traffic. In the second case, the clock can be <br>inhibited from reaching the register by controlling the clock input signal with an enabling <br>gate. However, inserting gates into the clock path is ill advised because it means that <br>logic is performed with clock pulses. The insertion of logic gates produces uneven prop-<br>agation delays between the master clock and the inputs of flipflops. To fully synchronize <br>the system, we must ensure that all clock pulses arrive at the same time anywhere in the <br>system, so that all flipflops trigger simultaneously. Performing logic with clock pulses <br>inserts variable delays and may cause the system to go out of synchronism. For this <br>reason, it is advisable to control the operation of the register with the  <i>D</i>  inputs, rather <br>than controlling the clock in the  <i>C</i>  inputs of the flipflops. This creates the effect of a <br>gated clock, but without affecting the clock path of the circuit. <br>
 <br>A fourbit datastorage register with a load control input that is directed through gates <br>
and into the  <i>D</i>  inputs of the flipflops is shown in  Fig.   6.2  .The additional gates implement <br>a twochannel mux whose output drives the input to the register with either the data bus <br>or the output of the register. The load input to the register determines the action to be <br>taken with each clock pulse. When the load input is 1, the data at the four external inputs <br>are transferred into the register with the next positive edge of the clock. When the load <br>input is 0, the outputs of the flipflops are connected to their respective inputs. The feed-<br>back connection from output to input is necessary because a  <i>D</i>  flipflop does not have <br>a "no change" condition. With each clock edge, the  <i>D</i>  input determines the next state of <br>the register. To leave the output unchanged, it is necessary to make the  <i>D</i>  input equal to <br>the present value of the output (i.e., the output circulates to the input at each clock <br>pulse). The clock pulses are applied to the  <i>C</i>  inputs without interruption. The load input <br>determines whether the next pulse will accept new information or leave the information <br>in the register intact. The transfer of information from the data inputs or the outputs of <br>the register is done simultaneously with all four bits in response to a clock edge.  <br>
<hr>
<A name=276></a><b>258    Chapter 6  Registers and Counters</b><br>
<i>Load</i><br>
<i>D</i><br>
<i>A</i>0<br>
<i>I</i>0<br>
<i>C</i><br>
<i>D</i><br>
<i>A</i>1<br>
<i>I</i>1<br>
<i>C</i><br>
<i>D</i><br>
<i>A</i>2<br>
<i>I</i>2<br>
<i>C</i><br>
<i>D</i><br>
<i>A</i>3<br>
<i>I</i>3<br>
<i>C</i><br>
<i>Clock</i><br>
<b> <br>FIGURE 6.2 <br> <br>Fourbit register with parallel load  </b><br>
<b> <br>6 . 2       S H I F T   R E G I S T E R S </b><br>
 <br>A register capable of shifting the binary information held in each cell to its neighboring <br>cell, in a selected direction, is called a  <i>shift register.</i> The logical configuration of a shift <br>register consists of a chain of flipflops in cascade, with the output of one flipflop con-<br>nected to the input of the next flipflop. All flipflops receive common clock pulses, <br>which activate the shift of data from one stage to the next. <br>
 <br>The simplest possible shift register is one that uses only flipflops, as shown in  Fig.   6.3  . <br>
The output of a given flipflop is connected to the  <i>D</i>  input of the flipflop at its right. This <br>shift register is unidirectional (lefttoright). Each clock pulse shifts the contents of the <br>
<hr>
<A name=277></a><b>Section 6.2  Shift Registers    259</b><br>
Serial<br>
<i>SI</i><br>
<i>SO</i><br>
Serial<br>
<i>D</i><br>
<i>D</i><br>
<i>D</i><br>
<i>D</i><br>
input<br>
output<br>
<i>C</i><br>
<i>C</i><br>
<i>C</i><br>
<i>C</i><br>
<i>CLK</i><br>
<b> <br>FIGURE 6.3 <br> <br>Fourbit shift register  </b><br>
register one bit position to the right. The configuration does not support a left shift. The <br> <br><i>serial input</i>  determines what goes into the leftmost flipflop during the shift. The  <i>serial <br>output</i>  is taken from the output of the rightmost flipflop. Sometimes it is necessary to <br>control the shift so that it occurs only with certain pulses, but not with others. As with the <br>data register discussed in the previous section, the clock's signal can be suppressed by gat-<br>ing the clock signal to prevent the register from shifting. A preferred alternative in high<br>speed circuits is to suppress the clock  <i>action</i>,  rather than gate the clock signal, by leaving <br>the clock path unchanged, but recirculating the output of each register cell back through a <br>twochannel mux whose output is connected to the input of the cell. When the clock action <br>is not suppressed, the other channel of the mux provides a datapath to the cell. <br>
 <br>It will be shown later that the shift operation can be controlled through the  <i>D</i>  inputs of <br>
the flipflops rather than through the clock input. If, however, the shift register of  Fig.   6.3 <br>is used, the shift can be controlled with an input by connecting the clock through an AND <br>gate. This is not a preferred practice. Note that the simplified schematics do not show a <br>reset signal, but such a signal is required in practical designs. <br>
<b> <br>Serial Transfer </b><br>
 <br>The datapath of a digital system is said to operate in serial mode when information <br>is transferred and manipulated one bit at a time. Information is transferred one bit at <br>a time by shifting the bits out of the source register and into the destination register. <br>This type of transfer is in contrast to parallel transfer, whereby all the bits of the <br>register are transferred at the same time. <br>
 <br>The serial transfer of information from register  <i>A</i>  to register  <i>B</i>  is done with shift <br>
registers, as shown in the block diagram of  Fig.   6.4  (a). The serial output ( <i>SO</i> ) of register <br> <br><i>A</i>  is connected to the serial input ( <i>SI</i> ) of register  <i>B.</i> To prevent the loss of information <br>stored in the source register, the information in register  <i>A</i>  is made to circulate by con-<br>necting the serial output to its serial input. The initial content of register  <i>B</i>  is shifted out <br>through its serial output and is lost unless it is transferred to a third shift register. The <br>shift control input determines when and how many times the registers are shifted. For <br>illustration here, this is done with an AND gate that allows clock pulses to pass into the <br> <br><i>CLK</i>  terminals only when the shift control is active. (This practice can be problematic <br>because it may compromise the clock path of the circuit, as discussed earlier.) <br>
 <br>Suppose the shift registers in  Fig.   6.4   have four bits each. Then the control unit that <br>
supervises the transfer of data must be designed in such a way that it enables the shift <br>
<hr>
<A name=278></a><b>260    Chapter 6  Registers and Counters</b><br>
<i>SIA</i><br>
<i>SOA</i><br>
<i>SIB</i><br>
<i>SOB</i><br>
Shift register <i>A</i><br>
Shift register <i>B</i><br>
<i>CLK</i><br>
<i>CLK</i><br>
<i>Clock</i><br>
Shift<br>
control<br>
(a) Block diagram<br>
<i>Clock</i><br>
Shift<br>
control<br>
<i>CLK</i><br>
<i>T</i>1<br>
<i>T</i>2<br>
<i>T</i>3<br>
<i>T</i>4<br>
(b) Timing diagram<br>
<b> <br>FIGURE 6.4 <br> <br>Serial transfer from register <i>A</i> to register <i>B</i> </b><br>
registers, through the shift control signal, for a fixed time of four clock pulses in order <br>to pass an entire word. This design is shown in the timing diagram of  Fig.   6.4  (b). The shift <br>control signal is synchronized with the clock and changes value just after the negative <br>edge of the clock. The next four clock pulses find the shift control signal in the active <br>state, so the output of the AND gate connected to the  <i>CLK</i>  inputs produces four pulses: <br> <br><i>T</i>1, <i>T</i>2, <i>T</i>3,     and     <i>T</i>4.  Each rising edge of the pulse causes a shift in both registers. The <br>fourth pulse changes the shift control to 0, and the shift registers are disabled. <br>
 <br>Assume that the binary content of  <i>A</i>  before the shift is 1011 and that of  <i>B</i>  is 0010. <br>
The serial transfer from  <i>A</i>  to  <i>B</i>  occurs in four steps, as shown in  Table   6.1 . With the first <br>pulse,     <i>T</i>1,  the rightmost bit of  <i>A</i>  is shifted into the leftmost bit of  <i>B</i>  and is also circulated <br>into the leftmost position of  <i>A.</i> At the same time, all bits of  <i>A</i>  and  <i>B</i>  are shifted one <br>position to the right. The previous serial output from  <i>B</i>  in the rightmost position is lost, <br>and its value changes from 0 to 1. The next three pulses perform identical operations, <br>shifting the bits of  <i>A</i>  into  <i>B,</i>  one at a time. After the fourth shift, the shift control goes <br>to 0, and registers  <i>A</i>  and  <i>B</i>  both have the value 1011. Thus, the contents of  <i>A</i>  are copied <br>into  <i>B</i>,  so that the contents of  <i>A</i>  remain unchanged i.e., the contents of  <i>A</i>  are restored <br>to their original value. <br>
 <br>The difference between the serial and the parallel mode of operation should be appar-<br>
ent from this example. In the parallel mode, information is available from all bits of a <br>register and all bits can be transferred simultaneously during one clock pulse. In the serial <br>
<hr>
<A name=279></a><b>Section 6.2  Shift Registers    261</b><br>
<b> <br>Table 6.1 <br><i> <br>SerialTransfer Example  </b></i><br>
<b> <br>Timing Pulse </b><br>
<b> <br>Shift Register <i>A</i> </b><br>
<b> <br>Shift Register <i>B</i> </b><br>
 Initial  value <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 After     <i>T</i>1    <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 After     <i>T</i>2    <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 After     <i>T</i>3    <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 After     <i>T</i>4    <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
mode, the registers have a single serial input and a single serial output. The information <br>is transferred one bit at a time while the registers are shifted in the same direction. <br>
<b> <br>Serial Addition </b><br>
 <br>Operations in digital computers are usually done in parallel because that is a faster <br>mode of operation. Serial operations are slower because a datapath operation takes <br>several clock cycles, but serial operations have the advantage of requiring fewer hard-<br>ware components. In VLSI circuits, they require less silicon area on a chip. To demon-<br>strate the serial mode of operation, we present the design of a serial adder. The parallel <br>counterpart was presented in Section 4.4. <br>
 <br>The two binary numbers to be added serially are stored in two shift registers. Begin-<br>
ning with the least significant pair of bits, the circuit adds one pair at a time through a <br>single fulladder (FA) circuit, as shown in  Fig.   6.5  . The carry out of the full adder is trans-<br>ferred to a  <i>D</i>  flipflop, the output of which is then used as the carry input for the next <br>pair of significant bits. The sum bit from the  <i>S</i>  output of the full adder could be trans-<br>ferred into a third shift register. By shifting the sum into  <i>A</i>  while the bits of  <i>A</i>  are shifted <br>out, it is possible to use one register for storing both the augend and the sum bits. The <br>serial input of register  <i>B</i>  can be used to transfer a new binary number while the addend <br>bits are shifted out during the addition.  <br>
 <br>The operation of the serial adder is as follows: Initially, register  <i>A</i>  holds the augend, <br>
register  <i>B</i>  holds the addend, and the carry flipflop is cleared to 0. The outputs ( <i>SO</i> ) of  <i>A</i> <br>and  <i>B</i>  provide a pair of significant bits for the full adder at  <i>x</i>  and  <i>y.</i>  Output  <i>Q</i>  of the flipflop <br>provides the input carry at  <i>z.</i> The shift control enables both registers and the carry flipflop, <br>so at the next clock pulse, both registers are shifted once to the right, the sum bit from  <i>S</i> <br>enters the leftmost flipflop of  <i>A</i>,  and the output carry is transferred into flipflop  <i>Q.</i>   The <br>shift control enables the registers for a number of clock pulses equal to the number of bits <br>in the registers. For each succeeding clock pulse, a new sum bit is transferred to  <i>A</i>,  a new <br>carry is transferred to  <i>Q</i>,  and both registers are shifted once to the right. This process con-<br>tinues until the shift control is disabled. Thus, the addition is accomplished by passing each <br>pair of bits together with the previous carry through a single fulladder circuit and transfer-<br>ring the sum, one bit at a time, into register  <i>A.</i> <br>
 <br>Initially, register  <i>A</i>  and the carry flipflop are cleared to 0, and then the first number <br>
is added from  <i>B.</i>   While   <i>B</i>  is shifted through the full adder, a second number is transferred <br>
<hr>
<A name=280></a><b>262    Chapter 6  Registers and Counters</b><br>
Shift<br>
<i>SI</i><br>
<i>SO</i><br>
control<br>
Shift register <i>A</i><br>
<i>CLK</i><br>
(Augend)<br>
<i>x</i><br>
<i>S</i><br>
<i>y</i><br>
FA<br>
Serial<br>
<i>z</i><br>
<i>C</i><br>
<i>SI</i><br>
<i>SO</i><br>
input<br>
Shift register <i>B</i><br>
(Addend)<br>
<i>Q</i><br>
<i>D</i><br>
<i>C</i><br>
Clear<br>
<b> <br>FIGURE 6.5 <br> <br>Serial adder  </b><br>
to it through its serial input. The second number is then added to the contents of register <br> <br><i>A</i> , while a third number is transferred serially into register  <i>B.</i> This can be repeated to <br>perform the addition of two, three, or more fourbit numbers and accumulate their sum <br>in register  <i>A.</i> <br>
 <br>Comparing the serial adder with the parallel adder described in Section 4.4, we note <br>
several differences. The parallel adder uses registers with a parallel load, whereas the <br>serial adder uses shift registers. The number of fulladder circuits in the parallel adder <br>is equal to the number of bits in the binary numbers, whereas the serial adder requires <br>only one fulladder circuit and a carry flipflop. Excluding the registers, the parallel <br>adder is a combinational circuit, whereas the serial adder is a sequential circuit which <br>consists of a full adder and a flipflop that stores the output carry. This design is typical <br>in serial operations because the result of a bittime operation may depend not only on <br>the present inputs, but also on previous inputs that must be stored in flipflops. <br>
 <br>To show that serial operations can be designed by means of sequential circuit proce-<br>
dure, we will redesign the serial adder with the use of a state table. First, we assume that <br>two shift registers are available to store the binary numbers to be added serially. The <br>serial outputs from the registers are designated by  <i>x</i>  and  <i>y.</i> The sequential circuit to <br>be designed will not include the shift registers, but they will be inserted later to show <br>the complete circuit. The sequential circuit proper has the two inputs,  <i>x</i>  and  <i>y</i>,   that <br>provide a pair of significant bits, an output  <i>S</i>  that generates the sum bit, and flipflop <br> <br><i>Q</i>  for storing the carry. The state table that specifies the sequential circuit is listed in <br> Table    6.2   .  The  present  state  of   <i>Q</i>  is the present value of the carry. The present carry in <br>
<hr>
<A name=281></a><b>Section 6.2  Shift Registers    263</b><br>
<b> <br>Table 6.2 <br><i> <br>State Table for Serial Adder </b></i><br>
<b> <br>Present State </b><br>
<b> <br>Inputs  </b><br>
<b>Next State </b><br>
<b> <br>Output </b><br>
<b> <br>FlipFlop Inputs </b><br>
<i><b> <br>Q  </b></i><br>
<i><b> <br>x  </b></i><br>
<i><b> <br>y  </b></i><br>
<i><b> <br>Q  </b></i><br>
<i><b> <br>S  </b></i><br>
<i><b> <br>JQ </b></i><br>
<i><b> <br>KQ </b></i><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 X <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 X <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 X <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 X <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 X <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 X <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 X <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 X <br>
 0 <br>
 <br><i>Q</i>  is added together with inputs  <i>x</i>  and  <i>y</i>  to produce the sum bit in output  <i>S.</i>   The  next <br>state of  <i>Q</i>  is equal to the output carry. Note that the state table entries are identical <br>to the entries in a fulladder truth table, except that the input carry is now the present <br>state of  <i>Q</i>  and the output carry is now the next state of  <i>Q.</i> <br>
 <br>If a  <i>D</i>  flipflop is used for  <i>Q</i>,  the circuit reduces to the one shown in  Fig.   6.5  . If a  <i>JK</i>   flip<br>
flop is used for  <i>Q</i>,  it is necessary to determine the values of inputs  <i>J</i>  and  <i>K</i>  by referring to <br>the excitation table (Table 5.12). This is done in the last two columns of  Table   6.2  . The two <br>flipflop input equations and the output equation can be simplified by means of maps to <br>
 <i>JQ </i>= <i>xy</i><br>
 <i>KQ </i>= <i>x y </i>= (<i>x </i>+ <i>y</i>)<br>
 <i>S </i>= <i>x </i>{ <i>y </i>{ <i>Q</i> <br>
 <br>The circuit diagram is shown in  Fig.   6.6  . The circuit consists of three gates and a  <i>JK</i> <br>flipflop. The two shift registers are included in the diagram to show the complete serial <br>adder. Note that output  <i>S</i>  is a function not only of  <i>x</i>  and  <i>y</i>,  but also of the present state <br>of  <i>Q.</i> The next state of  <i>Q</i>  is a function of the present state of  <i>Q</i>  and of the values of  <i>x</i> <br>and  <i>y</i>  that come out of the serial outputs of the shift registers. <br>
<b> <br>Universal Shift Register </b><br>
 <br>If the flipflop outputs of a shift register are accessible, then information entered serially <br>by shifting can be taken out in parallel from the outputs of the flipflops. If a parallel <br>load capability is added to a shift register, then data entered in parallel can be taken out <br>in serial fashion by shifting the data stored in the register. <br>
 <br>Some shift registers provide the necessary input and output terminals for parallel <br>
transfer. They may also have both shiftright and shiftleft capabilities. The most general <br>shift register has the following capabilities: <br>
 <br><b> 1. </b><br>
 <br>A <i>clear</i> control to clear the register to 0. <br>
 <br><b> 2. </b><br>
 <br>A <i>clock</i> input to synchronize the operations. <br>
<hr>
<A name=282></a><b>264    Chapter 6  Registers and Counters</b><br>
Shift<br>
<i>SI</i><br>
<i>SO</i><br>
<i> x</i><br>
control<br>
Shift register <i>A</i><br>
<i>S</i><br>
<i>CLK</i><br>
Serial<br>
<i>SI</i><br>
input<br>
<i>SO</i><br>
<i>y</i><br>
<i>J</i><br>
Shift register <i>B</i><br>
<i>C</i><br>
<i>K</i><br>
Clear<br>
<b> <br>FIGURE 6.6 <br> <br>Second form of serial adder  </b><br>
 <br><b> 3. </b><br>
 <br>A <i>shiftright</i> control to enable the shiftright operation and the <i>serial input</i> and <br><i>output</i> lines associated with the shift right. <br>
 <br><b> 4. </b><br>
 <br>A <i>shiftleft</i> control to enable the shiftleft operation and the <i>serial input </i>and <i>output</i> <br>lines associated with the shift left. <br>
 <br><b> 5. </b><br>
 <br>A <i>parallelload</i> control to enable a parallel transfer and the <i>n</i> input lines associ-<br>ated with the parallel transfer. <br>
 <br><b> 6. </b><br>
 <br><i>n</i> parallel output lines. <br>
 <br><b> 7. </b><br>
 <br>A control state that leaves the information in the register unchanged in response <br>to the clock. Other shift registers may have only some of the preceding functions, <br>with at least one shift operation. <br>
 <br>A register capable of shifting in one direction only is a  <i>unidirectional</i>  shift register. <br>
One that can shift in both directions is a  <i>bidirectional</i>  shift register. If the register has <br>both shifts and parallelload capabilities, it is referred to as a  <i>universal shift register.</i> <br>
 <br>The block diagram symbol and the circuit diagram of a fourbit universal shift register <br>
that has all the capabilities just listed are shown in  Fig.   6.7 . The circuit consists of four  <i>D</i> <br>flipflops and four multiplexers. The four multiplexers have two common selection inputs <br> <br><i>s</i>1     and     <i>s</i>0.  Input 0 in each multiplexer is selected when   <i>s</i>1<i>s</i>0 = 00,  input 1 is selected when <br> <br><i>s</i>1<i>s</i>0 = 01,  and similarly for the other two inputs. The selection inputs control the mode <br>of operation of the register according to the function entries in  Table   6.3  .When   <i>s</i>1<i>s</i>0 = 00,    <br>the present value of the register is applied to the  <i>D</i>  inputs of the flipflops. This condition <br>forms a path from the output of each flipflop into the input of the same flipflop, so that <br>the output recirculates to the input in this mode of operation. The next clock edge trans-<br>fers into each flipflop the binary value it held previously, and no change of state occurs. <br>
<hr>
<A name=283></a><b>Section 6.2  Shift Registers    265</b><br>
<i>A_ par</i><br>
<i>s1</i><br>
4<br>
<i>s0</i><br>
<i>MSB_in</i><br>
Shift_Register<br>
<i>LSB_in</i><br>
<i>CLK</i><br>
4<br>
<i>Clear_b</i><br>
<i>I_ par</i><br>
(a)<br>
Parallel outputs<br>
<i>A</i>3<br>
<i>A</i>2<br>
<i>A</i>1<br>
<i>A</i>0<br>
<i>Q</i><br>
<i>Q</i><br>
<i>Q</i><br>
<i>Q</i><br>
<i>Clear_b</i><br>
<i>C</i><br>
<i>C</i><br>
<i>C</i><br>
<i>C</i><br>
<i>D</i><br>
<i>D</i><br>
<i>D</i><br>
<i>D</i><br>
<i>CLK</i><br>
<i>y</i><br>
<i>y</i><br>
<i>y</i><br>
<i>y</i><br>
<i>s</i>1<br>
4<br>
 1<br>
4<br>
 1<br>
4<br>
 1<br>
4<br>
 1<br>
MUX<br>
MUX<br>
MUX<br>
MUX<br>
<i>s</i>0<br>
3 2 1 0<br>
3 2 1 0<br>
3 2 1 0<br>
3 2 1 0<br>
Serial<br>
Serial<br>
input for<br>
input for<br>
shift-right<br>
shift-left<br>
<i>I</i>3<br>
<i>I</i>2<br>
<i>I</i>1<br>
<i>I</i>0<br>
Parallel inputs<br>
(b)<br>
<b> <br>FIGURE 6.7 <br> <br>Fourbit universal shift register  </b><br>
<hr>
<A name=284></a><b>266    Chapter 6  Registers and Counters</b><br>
<b> <br>Table 6.3 <br><i> <br>Function Table for the Register of  Fig.   6.7  </b></i><br>
<b> <br>Mode Control </b><br>
<b> </b><br>
<b> <br><i>s</i>1 </b><br>
<i><b>s</i>0</b><br>
<b> <br>Register Operation </b><br>
 0 <br>
 0 <br>
 No  change <br>
 0 <br>
 1 <br>
 Shift  right <br>
 1 <br>
 0 <br>
 Shift  left <br>
 1 <br>
 1 <br>
 Parallel  load <br>
When     <i>s</i>1<i>s</i>0 = 01,  terminal 1 of the multiplexer inputs has a path to the  <i>D</i>  inputs of the <br>flipflops. This causes a shiftright operation, with the serial input transferred into flipflop <br> <i>A</i>3.     When     <i>s</i>1<i>s</i>0 = 10,  a shiftleft operation results, with the other serial input going into <br>flipflop     <i>A</i>0.     Finally,  when     <i>s</i>1<i>s</i>0 = 11,  the binary information on the parallel input lines is <br>transferred into the register simultaneously during the next clock edge. Note that data <br>enters <i>MSB_in</i> for a shiftright operation and enters <i>LSB_in</i> for a shiftleft operation. <br> <br><i>Clear_b</i>  is an activelow signal that clears all of the flipflops. <br>
 <br>Shift registers are often used to interface digital systems situated remotely from each <br>
other. For example, suppose it is necessary to transmit an  <i>n</i> bit quantity between two <br>points. If the distance is far, it will be expensive to use  <i>n</i>  lines to transmit the  <i>n</i>  bits in <br>parallel. It is more economical to use a single line and transmit the information serially, <br>one bit at a time. The transmitter accepts the  <i>n</i> bit data in parallel into a shift register <br>and then transmits the data serially along the common line. The receiver accepts the <br>data serially into a shift register. When all  <i>n</i>  bits are received, they can be taken from <br>the outputs of the register in parallel. Thus, the transmitter performs a paralleltoserial <br>conversion of data and the receiver does a serialtoparallel conversion. <br>
<b> <br>6 . 3       R I P P L E   C O U N T E R S </b><br>
 <br>A register that goes through a prescribed sequence of states upon the application of input <br>pulses is called a  <i>counter</i> . The input pulses may be clock pulses, or they may originate <br>from some external source and may occur at a fixed interval of time or at random. The <br>sequence of states may follow the binary number sequence or any other sequence of <br>states. A counter that follows the binary number sequence is called a  <i>binary counter</i> .  An <br> <br><i>n</i> bit binary counter consists of  <i>n</i>  flipflops and can count in binary from 0 through   2<i>n </i>- 1. <br>
 <br>Counters are available in two categories: ripple counters and synchronous counters. <br>
In a ripple counter, a flipflop output transition serves as a source for triggering other <br>flipflops. In other words, the  <i>C</i>  input of some or all flipflops are triggered, not by the <br>common clock pulses, but rather by the transition that occurs in other flipflop outputs. <br>In a synchronous counter, the  <i>C</i>  inputs of all flipflops receive the common clock. <br> <br>Synchronous counters are presented in the next two sections. Here, we present the <br>binary and BCD ripple counters and explain their operation. <br>
<hr>
<A name=285></a><b>Section 6.3  Ripple Counters    267</b><br>
<b> <br>Binary Ripple Counter </b><br>
 <br>A binary ripple counter consists of a series connection of complementing flipflops, with <br>the output of each flipflop connected to the  <i>C</i>  input of the next higher order flipflop. <br>The flipflop holding the least significant bit receives the incoming count pulses. A com-<br>plementing flipflop can be obtained from a  <i>JK</i>  flipflop with the  <i>J</i>  and  <i>K</i>  inputs tied <br>together or from a  <i>T</i>  flipflop. A third possibility is to use a  <i>D</i>  flipflop with the  complement <br>output connected to the  <i>D</i>  input. In this way, the  <i>D</i>  input is always the complement of <br>the present state, and the next clock pulse will cause the flipflop to complement. The <br>logic diagram of two 4bit binary ripple counters is shown in  Fig.   6.8  . The counter is con-<br>structed with complementing flipflops of the  <i>T</i>  type in part (a) and  <i>D</i>  type in part (b). <br>The output of each flipflop is connected to the  <i>C</i>  input of the next flipflop in sequence. <br>The flipflop holding the least significant bit receives the incoming count pulses. The  <i>T</i> <br>inputs of all the flipflops in (a) are connected to a permanent logic 1, making each flip<br>flop complement if the signal in its  <i>C</i>  input goes through a negative transition. The bub-<br>ble in front of the dynamic indicator symbol next to  <i>C</i>  indicates that the flipflops respond <br>to the negativeedge transition of the input. The negative transition occurs when the <br>output of the previous flipflop to which  <i>C</i>  is connected goes from 1 to 0. <br>
 <br>To understand the operation of the fourbit binary ripple counter, refer to the first <br>
nine binary numbers listed in  Table   6.4  . The count starts with binary 0 and increments <br>by 1 with each count pulse input. After the count of 15, the counter goes back to 0 to <br>repeat the count. The least significant bit,   <i>A</i>0,  is complemented with each count pulse <br>input. Every time that   <i>A</i>0  goes from 1 to 0, it complements   <i>A</i>1.     Every  time  that     <i>A</i>1     goes <br>from 1 to 0, it complements   <i>A</i>2.     Every  time  that     <i>A</i>2  goes from 1 to 0, it complements   <i>A</i>3,    <br>and so on for any other higher order bits of a ripple counter. For example, consider the <br>transition from count 0011 to 0100.   <i>A</i>0  is complemented with the count pulse. Since   <i>A</i>0 <br>goes from 1 to 0, it triggers   <i>A</i>1  and complements it. As a result,   <i>A</i>1  goes from 1 to 0, which <br>in turn complements   <i>A</i>2,  changing it from 0 to 1.   <i>A</i>2     does  not  trigger     <i>A</i>3,     because     <i>A</i>2 <br>produces a positive transition and the flipflop responds only to negative transitions. <br>Thus, the count from 0011 to 0100 is achieved by changing the bits one at a time, so the <br>
<b> <br>Table 6.4 <br><i> <br>Binary Count Sequence </b></i><br>
<i><b>A  </i>3 </b><br>
<b> <br><i>A</i> 2 </b><br>
<i><b>A</i> 1 </b><br>
<b> <br><i>A</i> 0 </b><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
<hr>
<A name=286></a><b>268    Chapter 6  Registers and Counters</b><br>
<i>T</i><br>
<i>A</i>0<br>
<i>D</i><br>
<i>A</i>0<br>
<i>Count</i><br>
<i>C</i><br>
<i>Count</i><br>
<i>C</i><br>
<i>R</i><br>
<i>R</i><br>
<i>T</i><br>
<i>A</i>1<br>
<i>D</i><br>
<i>A</i>1<br>
<i>C</i><br>
<i>C</i><br>
<i>R</i><br>
<i>R</i><br>
<i>T</i><br>
<i>A</i>2<br>
<i>D</i><br>
<i>A</i>2<br>
<i>C</i><br>
<i>C</i><br>
<i>R</i><br>
<i>R</i><br>
<i>T</i><br>
<i>A</i>3<br>
<i>D</i><br>
<i>A</i>3<br>
<i>C</i><br>
<i>C</i><br>
<i>R</i><br>
<i>R</i><br>
Logic 1<br>
<i>Reset</i><br>
<i>Reset</i><br>
(a) With <i>T</i> flip-flops<br>
(b) With <i>D</i> flip-flops<br>
<b> <br>FIGURE 6.8 <br> <br>Fourbit binary ripple counter  </b><br>
<hr>
<A name=287></a><b>Section 6.3  Ripple Counters    269</b><br>
count goes from 0011 to 0010, then to 0000, and finally to 0100. The flipflops change <br>one at a time in succession, and the signal propagates through the counter in a ripple <br>fashion from one stage to the next. <br>
 <br>A binary counter with a reverse count is called a  <i>binary countdown counter</i> . In a <br>
countdown counter, the binary count is decremented by 1 with every input count pulse. <br>The count of a fourbit countdown counter starts from binary 15 and continues to binary <br>counts 14, 13, 12, . . . , 0 and then back to 15. A list of the count sequence of a binary <br>countdown counter shows that the least significant bit is complemented with every count <br>pulse. Any other bit in the sequence is complemented if its previous least significant bit <br>goes from 0 to 1. Therefore, the diagram of a binary countdown counter looks the same <br>as the binary ripple counter in  Fig.   6.8  , provided that all flipflops trigger on the positive <br>edge of the clock. (The bubble in the  <i>C</i>  inputs must be absent.) If negativeedgetriggered <br>flipflops are used, then the  <i>C</i>  input of each flipflop must be connected to the comple-<br>mented output of the previous flipflop. Then, when the true output goes from 0 to 1, the <br>complement will go from 1 to 0 and complement the next flipflop as required. <br>
<b> <br>BCD Ripple Counter </b><br>
 <br>A decimal counter follows a sequence of 10 states and returns to 0 after the count of 9. <br>Such a counter must have at least four flipflops to represent each decimal digit, since <br>a decimal digit is represented by a binary code with at least four bits. The sequence of <br>states in a decimal counter is dictated by the binary code used to represent a decimal <br>digit. If BCD is used, the sequence of states is as shown in the state diagram of  Fig.   6.9  . <br>A decimal counter is similar to a binary counter, except that the state after 1001 (the <br>code for decimal digit 9) is 0000 (the code for decimal digit 0). <br>
 <br>The logic diagram of a BCD ripple counter using  <i>JK</i>   flipflops  is  shown  in   Fig.    6.10   . <br>
The four outputs are designated by the letter symbol  <i>Q</i>,  with a numeric subscript equal <br>to the binary weight of the corresponding bit in the BCD code. Note that the output of <br> <br><i>Q</i>1  is applied to the  <i>C</i>  inputs of both   <i>Q</i>2     and     <i>Q</i>8  and the output of   <i>Q</i>2  is applied to the <br> <br><i>C</i>  input of   <i>Q</i>4.     The   <i>J</i>  and  <i>K</i>  inputs are connected either to a permanent 1 signal or to <br>outputs of other flipflops. <br>
 <br>A ripple counter is an asynchronous sequential circuit. Signals that affect the flipflop <br>
transition depend on the way they change from 1 to 0. The operation of the counter can <br>
0000<br>
0001<br>
0010<br>
0011<br>
0100<br>
1001<br>
1000<br>
0111<br>
0110<br>
0101<br>
<b> <br>FIGURE 6.9 <br> <br>State diagram of a decimal BCD counter  </b><br>
<hr>
<A name=288></a><b>270    Chapter 6  Registers and Counters</b><br>
<i>J</i><br>
<i>Q</i>1<br>
<i>Count</i><br>
<i>C</i><br>
<i>K</i><br>
<i>J</i><br>
<i>Q</i>2<br>
<i>C</i><br>
<i>K</i><br>
<i>J</i><br>
<i>Q</i>4<br>
<i>C</i><br>
<i>K</i><br>
<i>J</i><br>
<i>Q</i>8<br>
<i>C</i><br>
<i>K</i><br>
Logic 1<br>
<b> <br>FIGURE 6.10 <br> <br>BCD ripple counter  </b><br>
be explained by a list of conditions for flipflop transitions. These condi-<br>tions are derived from the logic diagram and from knowledge of how a <br> <br><i>JK</i>  flipflop operates. Remember that when the  <i>C</i>  input goes from 1 to 0, <br>the flipflop is set if   <i>J </i>= 1,     is  cleared  if     <i>K </i>= 1,     is  complemented  if <br> <i>J </i>= <i>K </i>= 1,  and is left unchanged if   <i>J </i>= <i>K </i>= 0. <br>
<hr>
<A name=289></a><b>Section 6.4  Synchronous Counters    271</b><br>
<i>Q</i>8 <i>Q</i>4 <i>Q</i>2 <i>Q</i>1<br>
<i>Q</i>8 <i>Q</i>4 <i>Q</i>2 <i>Q</i>1<br>
<i>Q</i>8 <i>Q</i>4 <i>Q</i>2 <i>Q</i>1<br>
BCD<br>
BCD<br>
BCD<br>
Count<br>
Counter<br>
Counter<br>
Counter<br>
pulses<br>
102 digit<br>
101 digit<br>
100 digit<br>
<b> <br>FIGURE 6.11 <br> <br>Block diagram of a threedecade decimal BCD counter  </b><br>
 <br>To verify that these conditions result in the sequence required by a BCD ripple coun-<br>
ter, it is necessary to verify that the flipflop transitions indeed follow a sequence of <br>states as specified by the state diagram of  Fig.   6.9  .   <i>Q</i>1  changes state after each clock <br>pulse.     <i>Q</i>2     complements  every  time     <i>Q</i>1  goes from 1 to 0, as long as   <i>Q</i>8 = 0.     When     <i>Q</i>8 <br>becomes 1,   <i>Q</i>2     remains  at  0.     <i>Q</i>4     complements  every  time     <i>Q</i>2  goes from 1 to 0.   <i>Q</i>8     remains <br>at 0 as long as   <i>Q</i>2 or  <i>Q</i>4     is  0. When  both     <i>Q</i>2     and     <i>Q</i>4     become  1,     <i>Q</i>8     complements  when     <i>Q</i>1 <br>goes from 1 to 0.   <i>Q</i>8  is cleared on the next transition of   <i>Q</i>1.    <br>
 <br>The BCD counter of  Fig.   6.10   is a  <i>decade</i>  counter, since it counts from 0 to 9. To <br>
count in decimal from 0 to 99, we need a twodecade counter. To count from 0 to 999, <br>we need a threedecade counter. Multiple decade counters can be constructed by con-<br>necting BCD counters in cascade, one for each decade. A threedecade counter is <br>shown in  Fig.   6.11 . The inputs to the second and third decades come from   <i>Q</i>8     of  the <br>previous decade. When   <i>Q</i>8  in one decade goes from 1 to 0, it triggers the count for the <br>next higher order decade while its own decade goes from 9 to 0. <br>
<b> <br>6 . 4       S Y N C H R O N O U S   C O U N T E R S </b><br>
 <br>Synchronous counters are different from ripple counters in that clock pulses are applied <br>to the inputs of all flipflops. A common clock triggers all flipflops simultaneously, <br>rather than one at a time in succession as in a ripple counter. The decision whether a <br>flipflop is to be complemented is determined from the values of the data inputs, such <br>as  <i>T</i>  or  <i>J</i>  and  <i>K</i>  at the time of the clock edge. If   <i>T </i>= 0 or  <i>J </i>= <i>K </i>= 0,     the  flipflop  does <br>not change state. If   <i>T </i>= 1     or     <i>J </i>= <i>K </i>= 1,     the  flipflop  complements. <br>
 <br>The design procedure for synchronous counters was presented in Section 5.8, and the <br>
design of a threebit binary counter was carried out in conjunction with Fig. 5.31. In this <br>section, we present some typical synchronous counters and explain their operation. <br>
<b> <br>Binary Counter </b><br>
 <br>The design of a synchronous binary counter is so simple that there is no need to go <br>through a sequential logic design process. In a synchronous binary counter, the flipflop <br>in the least significant position is complemented with every pulse.  <i>A flipflop in any other </i><br>
<hr>
<A name=290></a><b>272    Chapter 6  Registers and Counters</b><br>
<i>position is complemented when all the bits in the lower significant positions are equal to 1</i> . <br>For example, if the present state of a fourbit counter is   <i>A</i>3<i>A</i>2<i>A</i>1<i>A</i>0 = 0011,     the  next <br>count is 0100.   <i>A</i>0     is  always  complemented.     <i>A</i>1  is complemented because the present <br>state of   <i>A</i>0 = 1.  <i>A</i>2  is complemented because the present state of   <i>A</i>1<i>A</i>0 = 11.     However, <br> <i>A</i>3  is not complemented, because the present state of   <i>A</i>2<i>A</i>1<i>A</i>0 = 011,     which  does  not <br>give an all1's condition. <br>
 <br>Synchronous binary counters have a regular pattern and can be constructed with <br>
complementing flipflops and gates. The regular pattern can be seen from the fourbit <br>counter  depicted  in   Fig.    6.12   .  The   <i>C</i>  inputs of all flipflops are connected to a common <br>clock. The counter is enabled by <i>Count_enable</i>. If the enable input is 0, all  <i>J</i>  and  <i>K</i>   inputs <br>are equal to 0 and the clock does not change the state of the counter. The first stage, <br> <i>A</i>0,     has  its   <i>J</i>  and  <i>K</i>  equal to 1 if the counter is enabled. The other  <i>J</i>  and  <i>K</i>  inputs are <br>equal to 1 if all previous least significant stages are equal to 1 and the count is enabled. <br>The chain of AND gates generates the required logic for the  <i>J</i>  and  <i>K</i>  inputs in each <br>stage. The counter can be extended to any number of stages, with each stage having an <br>additional flipflop and an AND gate that gives an output of 1 if all previous flipflop <br>outputs are 1. <br>
 <br>Note that the flipflops trigger on the positive edge of the clock. The polarity of the <br>
clock is not essential here, but it is with the ripple counter. The synchronous counter can <br>be triggered with either the positive or the negative clock edge. The complementing <br>flipflops in a binary counter can be of either the  <i>JK</i>  type, the  <i>T</i>  type, or the  <i>D</i>  type with <br>XOR gates. The equivalency of the three types is indicated in Fig. 5.13. <br>
<b> <br>Up�Down Binary Counter </b><br>
 <br>A synchronous countdown binary counter goes through the binary states in reverse order, <br>from 1111 down to 0000 and back to 1111 to repeat the count. It is possible to design a <br>countdown counter in the usual manner, but the result is predictable by inspection of the <br>downward binary count. The bit in the least significant position is complemented with each <br>pulse.  <i>A bit in any other position is complemented if all lower significant bits are equal to 0.</i> <br>For example, the next state after the present state of 0100 is 0011. The least significant <br>bit is always complemented. The second significant bit is complemented because the first <br>bit is 0. The third significant bit is complemented because the first two bits are equal to 0. <br>But the fourth bit does not change, because not all lower significant bits are equal to 0. <br>
 <br>A countdown binary counter can be constructed as shown in  Fig.   6.12  , except that <br>
the inputs to the AND gates must come from the complemented outputs, instead of <br>the normal outputs, of the previous flipflops. The two operations can be combined in <br>one circuit to form a counter capable of counting either up or down. The circuit of an <br>up�down binary counter using  <i>T</i>  flipflops is shown in  Fig.   6.13  . It has an up control <br>input and a down control input. When the up input is 1, the circuit counts up, since the <br> <br><i>T</i>  inputs receive their signals from the values of the previous normal outputs of the <br>flipflops. When the down input is 1 and the up input is 0, the circuit counts down, <br>since the complemented outputs of the previous flipflops are applied to the  <i>T</i>   inputs. <br>When the up and down inputs are both 0, the circuit does not change state and remains <br>
<hr>
<A name=291></a><b>Section 6.4  Synchronous Counters    273</b><br>
<i>J</i><br>
<i>A</i>0<br>
<i>C</i><br>
<i>Count_enable</i><br>
<i>K</i><br>
<i>J</i><br>
<i>A</i>1<br>
<i>C</i><br>
<i>K</i><br>
<i>J</i><br>
<i>A</i>2<br>
<i>C</i><br>
<i>K</i><br>
<i>J</i><br>
<i>A</i>3<br>
<i>C</i><br>
<i>K</i><br>
To next stage<br>
<i>CLK</i><br>
<b> <br>FIGURE 6.12 <br> <br>Fourbit synchronous binary counter  </b><br>
<hr>
<A name=292></a><b>274    Chapter 6  Registers and Counters</b><br>
<i>Up</i><br>
<i>T</i><br>
<i>A</i>0<br>
<i>Down</i><br>
<i>C</i><br>
<i>T</i><br>
<i>A</i>1<br>
<i>C</i><br>
<i>T</i><br>
<i>A</i>2<br>
<i>C</i><br>
<i>T</i><br>
<i>A</i>3<br>
<i>C</i><br>
<i>CLK</i><br>
<b> <br>FIGURE 6.13 <br> <br>Fourbit up�down binary counter  </b><br>
<hr>
<A name=293></a><b>Section 6.4  Synchronous Counters    275</b><br>
in the same count. When the up and down inputs are both 1, the circuit counts up. This <br>set of conditions ensures that only one operation is performed at any given time. Note <br>that the up input has priority over the down input. <br>
<b> <br>BCD Counter </b><br>
 <br>A BCD counter counts in binarycoded decimal from 0000 to 1001 and back to 0000. <br>Because of the return to 0 after a count of 9, a BCD counter does not have a regular <br>pattern, unlike a straight binary count. To derive the circuit of a BCD synchronous <br>counter, it is necessary to go through a sequential circuit design procedure. <br>
 <br>The state table of a BCD counter is listed in  Table   6.5  . The input conditions for the <br>
 <br><i>T</i>  flipflops are obtained from the present and nextstate conditions. Also shown in the <br>table is an output  <i>y</i>,  which is equal to 1 when the present state is 1001. In this way,  <i>y</i>   can <br>enable the count of the nexthigher significant decade while the same pulse switches the <br>present decade from 1001 to 0000. <br>
 <br>The flipflop input equations can be simplified by means of maps. The unused states <br>
for minterms 10 to 15 are taken as don'tcare terms. The simplified functions are <br>
 <i>TQ</i>1 = 1<br> <i>TQ</i>2 = <i>Q </i>8<i>Q</i>1 <br> <i>TQ</i>4 = <i>Q</i>2<i>Q</i>1<br> <i>TQ</i>8 = <i>Q</i>8<i>Q</i>1 + <i>Q</i>4<i>Q</i>2<i>Q</i>1<br>
 <i>y </i>= <i>Q</i>8<i>Q</i>1 <br>
 <br>The circuit can easily be drawn with four  <i>T</i>  flipflops, five AND gates, and one OR <br>
gate. Synchronous BCD counters can be cascaded to form a counter for decimal  numbers <br>of any length. The cascading is done as in  Fig.   6.11  , except that output  <i>y</i>  must be con-<br>nected to the count input of the nexthigher significant decade. <br>
<b> <br>Table 6.5 <br><i> <br>State Table for BCD Counter </b></i><br>
<b> <br>Present State </b><br>
<b> <br>Next State </b><br>
<b> <br>Output </b><br>
<b> <br>FlipFlop Inputs </b><br>
<b> <br><i>Q</i> 8 </b><br>
<b> <br><i>Q</i> 4 </b><br>
<b> <br><i>Q</i> 2 </b><br>
<b> <br><i>Q</i> 1 </b><br>
<b> <br><i>Q</i> 8 </b><br>
<i><b>Q</i> 4 </b><br>
<b> <br><i>Q</i> 2 </b><br>
<b> <br><i>Q</i>1 </b><br>
<b> <br><i>y</i> </b><br>
<b> <br><i>TQ</i> 8   <i>TQ</i> 4   <i>TQ</i> 2   <i>TQ</i> 1 </b><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
<hr>
<A name=294></a><b>276    Chapter 6  Registers and Counters</b><br>
<b> <br>Binary Counter with Parallel Load </b><br>
 <br>Counters employed in digital systems quite often require a parallelload capability for <br>transferring an initial binary number into the counter prior to the count operation. <br> <br>Figure   6.14   shows the toplevel block diagram symbol and the logic diagram of a fourbit <br>register that has a parallel load capability and can operate as a counter. When equal to <br>1, the input load control disables the count operation and causes a transfer of data from <br>the four data inputs into the four flipflops. If both control inputs are 0, clock pulses do <br>not change the state of the register. <br>
 <br>The carry output becomes a 1 if all the flipflops are equal to 1 while the count input is <br>
enabled. This is the condition for complementing the flipflop that holds the next significant <br>bit. The carry output is useful for expanding the counter to more than four bits. The speed <br>of the counter is increased when the carry is generated directly from the outputs of all four <br>flipflops, because the delay to generate the carry bit is reduced. In going from state 1111 <br>to 0000, only one gate delay occurs, whereas four gate delays occur in the AND gate chain <br>shown in  Fig.   6.12  . Similarly, each flipflop is associated with an AND gate that receives all <br>previous flipflop outputs directly instead of connecting the AND gates in a chain. <br>
 The  operation  of  the  counter  is  summarized  in   Table    6.6   .  The  four  control  inputs--<br>
 <br><i>Clear</i>,    <i>CLK</i>,    <i>Load</i>,  and  <i>Count</i> --determine the next state. The  <i>Clear</i>  input is asynchro-<br>nous and, when equal to 0, causes the counter to be cleared regardless of the presence <br>of clock pulses or other inputs. This relationship is indicated in the table by the X entries, <br>which symbolize don'tcare conditions for the other inputs. The  <i>Clear</i>  input must be in <br>the 1 state for all other operations. With the  <i>Load</i>  and  <i>Count</i>  inputs both at 0, the out-<br>puts do not change, even when clock pulses are applied. A  <i>Load</i>  input of 1 causes a <br>transfer from inputs   <i>I</i>0 - <i>I</i>3  into the register during a positive edge of  <i>CLK</i> .  The  input <br>data are loaded into the register regardless of the value of the  <i>Count</i>  input, because the <br> <br><i>Count</i>  input is inhibited when the  <i>Load</i>  input is enabled. The  <i>Load</i>  input must be 0 for <br>the  <i>Count</i>  input to control the operation of the counter. <br>
 <br>A counter with a parallel load can be used to generate any desired count sequence. <br>
 <br>Figure   6.15   shows two ways in which a counter with a parallel load is used to generate <br>the BCD count. In each case, the  <i>Count</i>  control is set to 1 to enable the count through <br>the  <i>CLK</i>  input. Also, recall that the  <i>Load</i>  control inhibits the count and that the clear <br>operation is independent of other control inputs. <br>
 <br>The AND gate in  Fig.   6.15  (a) detects the occurrence of state 1001. The counter is <br>
initially cleared to 0, and then the  <i>Clear</i>  and  <i>Count</i>  inputs are set to 1, so the counter is <br>active at all times. As long as the output of the AND gate is 0, each positiveedge clock <br>
<b> <br>Table 6.6 <br><i> <br>Function Table for the Counter of  Fig.   6.14  </b></i><br>
<b> <br>Clear </b><br>
<b> <br>CLK </b><br>
<b> <br>Load </b><br>
<b> <br>Count   Function </b><br>
 0 <br>
 X <br>
 X <br>
 X <br>
 Clear  to  0 <br>
 1 <br>
 c  <br>
 1 <br>
 X <br>
 Load  inputs <br>
 1 <br>
 c  <br>
 0 <br>
 1 <br>
 Count  next  binary  state <br>
 1 <br>
 c  <br>
 0 <br>
 0 <br>
 No  change <br>
<hr>
<A name=295></a><b>Section 6.4  Synchronous Counters    277</b><br>
<i>Count</i><br>
<i>Load</i><br>
<i>Data_in</i><br>
4-Bit Binary Counter<br>
<i>A_count</i><br>
4<br>
4<br>
<i>Clear</i><br>
<i>C_out</i><br>
<i>CLK</i><br>
(a)<br>
<i>Count</i><br>
<i>Load</i><br>
<i>I</i>0<br>
<i>J</i><br>
<i>A</i>0<br>
<i>C</i><br>
<i>K</i><br>
<i>I</i>1<br>
<i>J</i><br>
<i>A</i>1<br>
<i>C</i><br>
<i>K</i><br>
<i>I</i>2<br>
<i>J</i><br>
<i>A</i>2<br>
<i>C</i><br>
<i>K</i><br>
<i>I</i>3<br>
<i>J</i><br>
<i>A</i>3<br>
<i>C</i><br>
<i>K</i><br>
<i>Clear</i><br>
<i>CLK</i><br>
<i>C_out</i><br>
(b)<br>
<b> <br>FIGURE 6.14 <br> <br>Fourbit binary counter with parallel load  </b><br>
<hr>
<A name=296></a><b>278    Chapter 6  Registers and Counters</b><br>
<i>A</i>3 <i>A</i>2 <i>A</i>1 <i>A</i>0<br>
<i>A</i>3 <i>A</i>2 <i>A</i>1 <i>A</i>0<br>
<i>Load</i><br>
<i>Count</i><br>
 1<br>
<i>Clear</i><br>
<i>Count</i><br>
 1<br>
Counter<br>
Counter<br>
<i>Clear</i><br>
 1<br>
<i>Load</i><br>
 0<br>
of Fig. 6.14<br>
of Fig. 6.14<br>
<i>CLK</i><br>
<i>CLK</i><br>
Inputs<br>
 0<br>
Inputs have no effect<br>
(a) Using the load input<br>
(b) Using the clear input<br>
<b> <br>FIGURE 6.15 <br> <br>Two ways to achieve a BCD counter using a counter with parallel load  </b><br>
increments the counter by 1. When the output reaches the count of 1001, both   <i>A</i>0     and <br> <i>A</i>3  become 1, making the output of the AND gate equal to 1. This condition activates <br>the  <i>Load</i>  input; therefore, on the next clock edge the register does not count, but is <br>loaded from its four inputs. Since all four inputs are connected to logic 0, an all0's value <br>is loaded into the register following the count of 1001. Thus, the circuit goes through the <br>count from 0000 through 1001 and back to 0000, as is required in a BCD counter. <br>
 <br>In  Fig.   6.15  (b), the NAND gate detects the count of 1010, but as soon as this count <br>
occurs, the register is cleared. The count 1010 has no chance of staying on for any appre-<br>ciable time, because the register goes immediately to 0. A momentary spike occurs in <br>output     <i>A</i>0  as the count goes from 1010 to 1011 and immediately to 0000. The spike may <br>be undesirable, and for that reason, this configuration is not recommended. If the coun-<br>ter has a synchronous clear input, it is possible to clear the counter with the clock after <br>an occurrence of the 1001 count. <br>
<b> <br>6 . 5       O T H E R   C O U N T E R S </b><br>
 <br>Counters can be designed to generate any desired sequence of states. A divideby <i>N</i> <br>counter (also known as a modulo <i>N</i>  counter) is a counter that goes through a repeated <br>sequence of  <i>N</i>  states. The sequence may follow the binary count or may be any other <br>arbitrary sequence. Counters are used to generate timing signals to control the sequence <br>of operations in a digital system. Counters can also be constructed by means of shift <br>registers. In this section, we present a few examples of nonbinary counters. <br>
<b> <br>Counter with Unused States </b><br>
 <br>A circuit with  <i>n</i>  flipflops has   2<i>n</i>  binary states. There are occasions when a sequential <br>circuit uses fewer than this maximum possible number of states. States that are not used <br>
<hr>
<A name=297></a><b>Section 6.5  Other Counters    279</b><br>
in specifying the sequential circuit are not listed in the state table. In simplifying the <br>input equations, the unused states may be treated as don'tcare conditions or may be <br>assigned specific next states. It is important to realize that once the circuit is designed <br>and constructed, outside interference during its operation may cause the circuit to enter <br>one of the unused states. In that case, it is necessary to ensure that the circuit eventually <br>goes into one of the valid states so that it can resume normal operation. Otherwise, if the <br>sequential circuit circulates among unused states, there will be no way to bring it back to <br>its intended sequence of state transitions. If the unused states are treated as don'tcare <br>conditions, then once the circuit is designed, it must be investigated to determine the <br>effect of the unused states. The next state from an unused state can be determined from <br>the analysis of the circuit after it is designed. <br>
 <br>As an illustration, consider the counter specified in  Table   6.7.   The count has a <br>
repeated sequence of six states, with flipflops  <i>B</i>  and  <i>C</i>  repeating the binary count 00, <br>01, 10, and flipflop  <i>A</i>  alternating between 0 and 1 every three counts. The count <br>sequence of the counter is not straight binary, and two states, 011 and 111, are not <br>included in the count. The choice of  <i>JK</i>  flipflops results in the flipflop input conditions <br>listed in the table. Inputs   <i>KB</i>     and     <i>KC</i>  have only 1's and X's in their columns, so these <br>inputs are always equal to 1. The other flipflop input equations can be simplified by <br>using minterms 3 and 7 as don'tcare conditions. The simplified equations are <br>
 <i>JA</i>  = <i>B</i>        <i>KA </i>= <i>B</i><br>
 <i>JB </i>= <i>C</i>        <i>KB </i>= 1<br> <i>JC </i>= <i>B </i>       <i>KC </i>= 1  <br>
 <br>The logic diagram of the counter is shown in  Fig.   6.16  (a). Since there are two unused <br>
states, we analyze the circuit to determine their effect. If the circuit happens to be in <br>state 011 because of an error signal, the circuit goes to state 100 after the application of <br>a clock pulse. This action may be determined from an inspection of the logic diagram by <br>noting that when   <i>B </i>= 1,  the next clock edge complements  <i>A</i>  and clears  <i>C</i>  to 0, and when <br> <br><i>C </i>= 1,  the next clock edge complements  <i>B.</i>  In a similar manner, we can evaluate the <br>next state from present state 111 to be 000. <br>
<b> <br>Table 6.7 <br><i> <br>State Table for Counter </b></i><br>
<b> <br>Present State </b><br>
<b> <br>Next State </b><br>
<b> <br>FlipFlop Inputs </b><br>
<b> <br><i>A</i> </b><br>
<b> <br><i>B</i> </b><br>
<b> <br><i>C</i> </b><br>
<i><b> <br>A  </b></i><br>
<i><b> <br>B  </b></i><br>
<i><b> <br>C  </b></i><br>
<i><b> <br>J A</i> </b><br>
<i><b> <br>K A</i> </b><br>
<i><b> <br>J B </b></i><br>
<i><b> <br>K B </b></i><br>
<i><b> <br>J C </b></i><br>
<i><b> <br>K C</i> </b><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 X <br>
 0 <br>
 X <br>
 1 <br>
 X <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 X <br>
 1 <br>
 X <br>
 X <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 X <br>
 X <br>
 1 <br>
 0 <br>
 X <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 X <br>
 0 <br>
 0 <br>
 X <br>
 1 <br>
 X <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 X <br>
 0 <br>
 1 <br>
 X <br>
 X <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 X <br>
 1 <br>
 X <br>
 1 <br>
 0 <br>
 X <br>
<hr>
<A name=298></a><b>280    Chapter 6  Registers and Counters</b><br>
<i>J</i><br>
<i>A</i><br>
<i>C</i><br>
<i>K</i><br>
<i>J</i><br>
<i>B</i><br>
<i>C</i><br>
<i>K</i><br>
000<br>
111<br>
<i>J</i><br>
<i>C</i><br>
001<br>
110<br>
<i>C</i><br>
Logic 1<br>
<i>K</i><br>
010<br>
101<br>
100<br>
011<br>
<i>Clock</i><br>
(a) Logic circuit diagram<br>
(b) State transition diagram<br>
<b> <br>FIGURE 6.16 <br> <br>Counter with unused states  </b><br>
 <br>The state diagram including the effect of the unused states is shown in  Fig.   6.16  (b). If <br>
the circuit ever goes to one of the unused states because of outside interference, the next <br>count pulse transfers it to one of the valid states and the circuit continues to count cor-<br>rectly. Thus, the counter is selfcorrecting. In a selfcorrecting counter, if the counter <br>happens to be in one of the unused states, it eventually reaches the normal count <br>sequence after one or more clock pulses. An alternative design could use additional logic <br>to direct every unused state to a specific next state. <br>
<b> <br>Ring Counter </b><br>
 <br>Timing signals that control the sequence of operations in a digital system can be gener-<br>ated by a shift register or by a counter with a decoder. A  <i>ring counter</i>  is a circular shift <br>register with only one flipflop being set at any particular time; all others are cleared. <br>The single bit is shifted from one flipflop to the next to produce the sequence of timing <br>signals.  Figure   6.17  (a) shows a fourbit shift register connected as a ring counter. The <br>initial value of the register is 1000 and requires Preset/Clear flipflops. The single bit is <br>
<hr>
<A name=299></a><b>Section 6.5  Other Counters    281</b><br>
Shift<br>
<i>T</i>0<br>
<i>T</i>1<br>
<i>T</i>2<br>
<i>T</i>3<br>
right<br>
(a) Ring-counter (initial value   1000)<br>
<i>CLK</i><br>
<i>T</i>0<br>
<i>T</i>1<br>
<i>T</i>2<br>
<i>T</i>3<br>
(b) Sequence of four timing signals<br>
<i>T</i>0 <i>T</i>1 <i>T</i>2 <i>T</i>3<br>
2<br>
 4<br>
decoder<br>
Count<br>
2-bit counter<br>
enable<br>
(c) Counter and decoder<br>
<b> <br>FIGURE 6.17 <br> <br>Generation of timing signals  </b><br>
shifted right with every clock pulse and circulates back from   <i>T</i>3 to  <i>T</i>0.     Each  flipflop  is <br>in the 1 state once every four clock cycles and produces one of the four timing signals <br>shown in  Fig.   6.17  (b). Each output becomes a 1 after the negativeedge transition of a <br>clock pulse and remains 1 during the next clock cycle. <br>
<hr>
<A name=300></a><b>282    Chapter 6  Registers and Counters</b><br>
 <br>For an alternative design, the timing signals can be generated by a twobit counter <br>
that goes through four distinct states. The decoder shown in  Fig.   6.17  (c) decodes the four <br>states of the counter and generates the required sequence of timing signals. <br>
 To  generate     2<i>n</i>  timing signals, we need either a shift register with   2<i>n</i>     flipflops  or  an <br>
 <br><i>n</i> bit binary counter together with an  <i>n</i> to2 <i> n </i>line decoder. For example, 16 timing sig-<br>nals can be generated with a 16bit shift register connected as a ring counter or with a <br>4bit binary counter and a 4to16line decoder. In the first case, we need 16 flipflops. <br>In the second, we need 4 flipflops and 16 fourinput AND gates for the decoder. It is <br>also possible to generate the timing signals with a combination of a shift register and a <br>decoder. That way, the number of flipflops is less than that in a ring counter, and the <br>decoder requires only twoinput gates. This combination is called a  <i>Johnson counter</i> .  <br>
<b> <br>Johnson Counter </b><br>
 A   <i>k</i> bit ring counter circulates a single bit among the flipflops to provide  <i>k</i>   distinguish-<br>able states. The number of states can be doubled if the shift register is connected as a <br> <br><i>switchtail</i>  ring counter. A switchtail ring counter is a circular shift register with the <br>complemented output of the last flipflop connected to the input of the first flipflop. <br> <br>Figure   6.18  (a) shows such a shift register. The circular connection is made from the <br>
<i>A</i><br>
<i>B</i><br>
<i>C</i><br>
<i>D</i><br>
<i>D</i><br>
<i>D</i><br>
<i>D</i><br>
<i>E</i><br>
<i>C</i><br>
<i>C</i><br>
<i>C</i><br>
<i>C</i><br>
<i>E</i><br>
<i>A</i><br>
<i>B</i><br>
<i>C</i><br>
<i>CLK</i><br>
(a) Four-stage switch-tail ring counter<br>
Flip-flop outputs<br>
Sequence<br>
AND gate required<br>
number<br>
<i>A</i><br>
<i>B</i><br>
<i>C</i><br>
<i>E</i><br>
for output<br>
1<br>
0<br>
0<br>
0<br>
0<br>
<i>A E</i><br>
2<br>
1<br>
0<br>
0<br>
0<br>
<i>AB</i><br>
3<br>
1<br>
1<br>
0<br>
0<br>
<i>BC</i><br>
4<br>
1<br>
1<br>
1<br>
0<br>
<i>CE</i><br>
5<br>
1<br>
1<br>
1<br>
1<br>
<i>AE</i><br>
6<br>
0<br>
1<br>
1<br>
1<br>
<i>A B</i><br>
7<br>
0<br>
0<br>
1<br>
1<br>
<i>B C</i><br>
8<br>
0<br>
0<br>
0<br>
1<br>
<i>C E</i><br>
(b) Count sequence and required decoding<br>
<b> <br>FIGURE 6.18 <br> <br>Construction of a Johnson counter  </b><br>
<hr>
<A name=301></a><b>Section 6.6  HDL for Registers and Counters    283</b><br>
complemented output of the rightmost flipflop to the input of the leftmost flipflop. <br>The register shifts its contents once to the right with every clock pulse, and at the same <br>time, the complemented value of the  <i>E</i>  flipflop is transferred into the  <i>A</i>   flipflop. <br> <br>Starting from a cleared state, the switchtail ring counter goes through a sequence of <br>eight states, as listed in  Fig.   6.18  (b). In general, a  <i>k</i> bit switchtail ring counter will go <br>through a sequence of 2 <i>k</i>  states. Starting from all 0's, each shift operation inserts 1's from <br>the left until the register is filled with all 1's. In the next sequences, 0's are inserted from <br>the left until the register is again filled with all 0's. <br>
 <br>A Johnson counter is a  <i>k</i> bit switchtail ring counter with 2 <i>k</i>  decoding gates to pro-<br>
vide outputs for 2 <i>k</i>  timing signals. The decoding gates are not shown in  Fig.   6.18  , but are <br>specified in the last column of the table. The eight AND gates listed in the table, when <br>connected to the circuit, will complete the construction of the Johnson counter. Since <br>each gate is enabled during one particular state sequence, the outputs of the gates gen-<br>erate eight timing signals in succession. <br>
 <br>The decoding of a  <i>k</i> bit switchtail ring counter to obtain 2 <i>k</i>  timing signals follows a <br>
regular pattern. The all0's state is decoded by taking the complement of the two extreme <br>flipflop outputs. The all1's state is decoded by taking the normal outputs of the two extreme <br>flipflops. All other states are decoded from an adjacent 1, 0 or 0, 1 pattern in the sequence. <br>For example, sequence 7 has an adjacent 0, 1 pattern in flipflops  <i>B</i>  and  <i>C</i> .  The  decoded <br>output is then obtained by taking the complement of  <i>B</i>  and the normal output of  <i>C,</i>   or     <i>B C</i>.    <br>
 <br>One disadvantage of the circuit in  Fig.   6.18  (a) is that if it finds itself in an unused state, <br>
it will persist in moving from one invalid state to another and never find its way to a valid <br>state. The difficulty can be corrected by modifying the circuit to avoid this undesirable <br>condition. One correcting procedure is to disconnect the output from flipflop  <i>B</i>  that goes <br>to the  <i>D</i>  input of flipflop  <i>C</i>  and instead enable the input of flipflop  <i>C</i>  by the function <br>
 <br><i>DC </i>= (<i>A </i>+ <i>C</i>)<i>B</i> <br>
 where     <i>DC</i>  is the flipflop input equation for the  <i>D</i>  input of flipflop  <i>C.</i> <br>
 <br>Johnson counters can be constructed for any number of timing sequences. The num-<br>
ber of flipflops needed is onehalf the number of timing signals. The number of decod-<br>ing gates is equal to the number of timing signals, and only twoinput gates are needed. <br>
<b> <br>6 . 6       H D L   F O R   R E G I S T E R S   A N D   C O U N T E R S </b><br>
 <br>Registers and counters can be described in Verilog at either the behavioral or the struc-<br>tural level. Behavioral modeling describes only the operations of the register, as pre-<br>scribed by a function table, without a preconceived structure. A structurallevel <br>description shows the circuit in terms of a collection of components such as gates, flip<br>flops, and multiplexers. The various components are instantiated to form a hierarchical <br>description of the design similar to a representation of a multilevel logic diagram. The <br>examples in this section will illustrate both types of descriptions. Both are useful. When <br>a machine is complex, a hierarchical description creates a physical partition of the <br>machine into simpler and more easily described units. <br>
<hr>
<A name=302></a><b>284    Chapter 6  Registers and Counters</b><br>
<b> <br>Shift Register </b><br>
 <br>The universal shift register presented in Section 6.2 is a bidirectional shift register with a <br>parallel load. The four clocked operations that are performed with the register are speci-<br>fied in  Table   6.6  . The register also can be cleared asynchronously. Our chosen name for a <br>behavioral description of the fourbit universal shift register shown in  Fig.   6.7  (a), the name <br> <br><i>Shift_Register_4_beh</i>,  signifies the behavioral model of the internal detail of the toplevel <br>block diagram symbol and distinguishes that model from a structural one. The behavioral <br>model is presented in HDL Example 6.1, and the structural model is given in HDL Exam-<br>ple 6.2. The toplevel block diagram symbol in  Fig.   6.7  (a) indicates that the fourbit uni-<br>versal shift register has two selection inputs ( <i>s1</i>,    <i>s0</i> ), two serial inputs ( <i>shift_left</i>,<i> shift_right</i> ), <br>for controlling the shift register, two serial datapath inputs (MSB_in and LSB_in), a four<br>bit parallel input ( <i>I_par</i> ), and a fourbit parallel output ( <i>A_par</i> ). The elements of vector <br> <br><i>I_par[3: 0]</i>  correspond to the bits <i>I</i>3, . . . , <i>I</i>0 in  Fig.   6.7 , and similarly for  <i>A_par[3: 0].</i> <br>The  <b>always</b>  block describes the five operations that can be performed with the register. <br>The  <i>Clear</i>  input clears the register asynchronously with an activelow signal.  <i>Clear</i> <br>must be high for the register to respond to the positive edge of the clock. The four <br>clocked operations of the register are determined from the values of the two select <br>inputs in the  <b>case</b>  statement. ( <i>s1</i>  and  <i>s0</i>  are concatenated into a twobit vector and are used <br>as the expression argument of the  <b>case</b>  statement.) The shifting operation is specified by the <br>concatenation of the serial input and three bits of the register. For example, the statement <br>
A_par &lt;= {MSB_in, A_par [3: 1]}  <br>
 <br>specifies a concatenation of the serial data input for a right shift operation ( <i>MSB_in</i> ) <br>with bits  <i>A_par[3: 1] of the output data bus</i> . A reference to a contiguous range of bits <br>within a vector is referred to as a  <i>part select</i> . The fourbit result of the concatenation is <br>transferred to register  <i>A_par [3: 0]</i>  when the clock pulse triggers the operation. This <br>transfer produces a shiftright operation and updates the register with new information. <br>The shift operation overwrites the contents of  <i>A_par[0]</i>  with the contents of  <i>A_par[1]</i> . <br>Note that only the functionality of the circuit has been described, irrespective of any <br>particular hardware. A synthesis tool would create a netlist of ASIC cells to implement <br>the shift register in the structure of  Fig.   6.7  (b). <br>
<b> <br>HDL Example 6.1 (Universal Shift RegisterBehavioral Model) </b><br>
 <br>// Behavioral description of a 4-bit universal shift register<br>
 <br>//  Fig.   6.7   and  Table   6.3  <br>
 <br><b>module</b>  Shift_Register_4_beh ( <br>
// V2001, 2005<br>
  <b>output</b>  reg <br>
[3: 0] <br>
A_par, <br>
// Register output<br>
  <b>input</b> <br>
[3: 0] <br>
I_par, <br>
// Parallel input<br>
  <b>input</b> <br>
s1, s0,   <br>
// Select inputs<br>
 <br>
MSB_in, LSB_in, <br>
// Serial inputs<br>
 <br>
CLK, Clear_b <br>
// Clock and Clear<br>
 <br>);<br>
<hr>
<A name=303></a><b>Section 6.6  HDL for Registers and Counters    285</b><br>
 <br><b>always @</b>  ( <b>posedge</b>  CLK,  <b>negedge</b>  Clear_b) <br>
// V2001, 2005<br>
  <b>if</b>  (Clear_b == 0) A_par &lt;= 4'b0000;<br>  <b>else</b> <br>    <b>case</b>  ({s1, s0})<br> <br>
2'b00: A_par &lt;= A_par; <br>
// No change<br>
 <br>
 <br>2'b01: A_par &lt;= {MSB_in, A_par[3: 1]}; <br>
// Shift right<br>
 <br>
 <br>2'b10: A_par &lt;= {A_par[2: 0], LSB_in}; <br>
// Shift left<br>
 <br>
 <br>2'b11: A_par &lt;= I_par; <br>
// Parallel load of input<br>
    <b>endcase</b> <br> <br><b>endmodule</b> <br>
  Variables  of  type  <b>reg</b> retain their value until they are assigned a new value by an <br>
assignment statement. Consider the following alternative <b>case</b> statement for the shift <br>register model: <br>
    <b>case</b>  ({s1, s0})<br> <br>
 <br>// 2'b00: A_par &lt;= A_par; <br>
// No change<br>
 <br>
 <br>2'b01: A_par &lt;= {MSB_in, A_par [3: 1]}; <br>
// Shift right<br>
 <br>
 <br>2'b10: A_par &lt;= {A_par [2: 0], LSB_in}; <br>
// Shift left<br>
 <br>
 <br>2'b11: A_par &lt;= I_par; <br>
// Parallel load of input<br>
    <b>endcase</b> <br>
 <br>Without the case item   2 b00,     the   <b>case</b>  statement would not find a match between <br>
 5<i>s1</i>, <i>s0</i>6   and the case items, so register  <i>A_par</i>  would be left unchanged. <br>
 <br>A structural model of the universal shift register can be described by referring to the <br>
logic diagram of  Fig.   6.7  (b). The diagram shows that the register has four multiplexers and <br>four  <i>D</i>  flipflops. A mux and flipflop together are modeled as a stage of the shift register. <br>The stage is a structural model, too, with an instantiation and interconnection of a module <br>for a mux and another for a  <i>D</i>  flipflop. For simplicity, the lowestlevel modules of the <br>structure are behavioral models of the multiplexer and flipflop. Attention must be paid <br>to the details of connecting the stages correctly. The structural description of the register <br>is shown in HDL Example 6.2. The toplevel module declares the inputs and outputs and <br>then instantiates four copies of a stage of the register. The four instantiations specify the <br>interconnections between the four stages and provide the detailed construction of the <br>register as specified in the logic diagram. The behavioral description of the flipflop uses <br>a single edgesensitive cyclic behavior (an  <b>always</b>  block). The assignment statements use <br>the nonblocking assignment operator (&lt;=) the model of the mux employs a single level<br>sensitive behavior, and the assignments use the blocking assignment operator (=). <br>
<b> <br>HDL Example 6.2 (Universal Shift RegisterStructural Model) </b><br>
 <br>// Structural description of a 4-bit universal shift register (see  Fig.   6.7  )<br>
 <br><b>module</b>  Shift_Register_4_str ( <br>
// V2001, 2005<br>
   <b>output</b>  [3: 0] A_par, <br>
// Parallel output<br>
   <b>input</b>  [3: 0]  I_par, <br>
// Parallel input<br>
<hr>
<A name=304></a><b>286    Chapter 6  Registers and Counters</b><br>
  <b>input</b> <br>
s1, s0, <br>
// Mode select<br>
   <b>input</b> <br>
MSB_in, LSB_in, CLK, Clear_b <br>
// Serial inputs, clock, clear<br>
 <br>);<br>
 <br>// bus for mode control<br>
   <b>assign</b>  [1:0]  select = {s1, s0};<br>
 <br>// Instantiate the four stages<br>
   stage ST0 (A_par[0], A_par[1], LSB_in, I_par[0], A_par[0], select, CLK, Clear_b);<br>
   stage ST1 (A_par[1], A_par[2], A_par[0], I_par[1], A_par[1], select, CLK, Clear_b);<br>
   stage ST2 (A_par[2], A_par[3], A_par[1], I_par[2], A_par[2], select, CLK, Clear_b);<br>
   stage ST3 (A_par[3], MSB_in, A_par[2], I_par[3], A_par[3], select, CLK, Clear_b);<br>
 <br><b>endmodule</b> <br>
 <br>// One stage of shift register<br>
 <br><b>module</b>  stage (i0, i1, i2, i3, Q, select, CLK, Clr_b);<br>   <b>input</b> <br>
i0, <br>
// circulation bit selection<br>
 <br>
i1, <br>
// data from left neighbor or serial input for shift-right<br>
 <br>
i2, <br>
// data from right neighbor or serial input for shift-left<br>
 <br>
i3; <br>
// data from parallel input<br>
   <b>output</b>  Q;<br>   <b>input</b>  [1: 0]  select; <br>
// stage mode control bus<br>
   <b>input</b> <br>
CLK, Clr_b;  // Clock, Clear for fl ip-fl ops<br>
   <b>wire</b>  mux_out;<br>
 <br>// instantiate mux and fl ip-fl op<br>
   Mux_4_x_1  M0 <br>
(mux_out, i0, i1, i2, i3, select);<br>
   D_fl ip_fl op <br>
M1 <br>
(Q, mux_out, CLK, Clr_b);<br>
 <br><b>endmodule</b> <br>
 <br>// 4x1 multiplexer <br>
// behavioral model<br>
 <br><b>module</b>  Mux_4_x_1 (mux_out, i0, i1, i2, i3, select);<br>   <b>output</b>  mux_out;<br>   <b>input</b> <br>
i0, i1, i2, i3;<br>
   <b>input</b>  [1: 0]  select;<br>   <b>reg</b>  mux_out;<br>   <b>always</b>  @ (select, i0, i1, i2, i3)<br>   <b>case</b>  (select)<br> <br>
 <br>2'b00: <br>
mux_out = i0;<br>
 <br>
 <br>2'b01: <br>
mux_out = i1;<br>
 <br>
 <br>2'b10: <br>
mux_out = i2;<br>
 <br>
 <br>2'b11: <br>
mux_out = i3;<br>
  <b>endcase</b> <br> <br><b>endmodule</b> <br>
<hr>
<A name=305></a><b>Section 6.6  HDL for Registers and Counters    287</b><br>
 <br>// Behavioral model of D fl ip-fl op<br>
 <br><b>module</b>  D_fl ip_fl op (Q, D, CLK, Clr_b);<br>  <b>output</b>  Q;<br>   <b>input</b> <br>
D, CLK, Clr;<br>
   <b>reg</b>  Q;<br>
  <b>always @</b>  ( <b>posedge</b>  CLK,  <b>negedge</b>  Clr_b)<br>   <b>if</b>  (!Clr_b) Q &lt;= 1'b0; <b>else</b> Q &lt;= D;<br> <br><b>endmodule</b> <br>
 <br>The above examples presented two descriptions of a universal shift register to illus-<br>
trate the different styles for modeling a digital circuit. A simulation should verify that <br>the models have the same functionality. In practice, a designer develops only the behav-<br>ioral model, which is then synthesized. The function of the synthesized circuit can be <br>compared with the behavioral description from which it was compiled. Eliminating the <br>need for the designer to develop a structural model produces a huge improvement in <br>the efficiency of the design process. <br>
<b> <br>Synchronous Counter </b><br>
 <br>HDL Example 6.3 presents  <i>Binary_Counter_4_Par_Load,</i>  a behavioral model of the <br>synchronous counter with a parallel load from  Fig.   6.14  .  <i>Count</i>,    <i>Load</i>,    <i>CLK</i>,  and  <i>Clear_b</i> <br>are inputs that determine the operation of the counter according to the function speci-<br>fied in  Table   6.6  . The counter has four data inputs, four data outputs, and a carry output. <br>The internal data lines ( <i>I3</i>,    <i>I2</i>,    <i>I1</i>,    <i>I0</i> ) are bundled as  <i>Data_in[3: 0]</i>  in the behavioral <br>model. Likewise, the register that holds the bits of the count ( <i>A3</i>,    <i>A2</i>,    <i>A1</i>,    <i>A0</i> ) is  <i>A_<br>count[3: 0].</i>  It is good practice to have identifiers in the HDL model of a circuit corre-<br>spond exactly to those in the documentation of the model. That is not always feasible, <br>however, if the circuitlevel identifiers are those found in a handbook, for they are often <br>short and cryptic and do not exploit the text that is available with an HDL. The toplevel <br>block diagram symbol in  Fig.   6.14  (a) serves as an interface between the names used in <br>a circuit diagram and the expressive names that can be used in the HDL model. The <br>carry output  <i>C_out</i>  is generated by a combinational circuit and is specified with an  <b>assign</b> <br>statement.     <i>C</i>_<i>out </i>= 1 when the count reaches 15 and the counter is in the count state. <br>Thus,     <i>C</i>_<i>out </i>= 1 if  <i>Count </i>= 1, <i>Load </i>= 0,     and     <i>A </i>= 1111;     otherwise     <i>C</i>_<i>out </i>= 0. The <br> <br><b>always</b>  block specifies the operation to be performed in the register, depending on the <br>values of  <i>Clear_b,</i>  <i>Load,</i>  and  <i>Count</i> . A 0 (activelow signal) at  <i>Clear_b</i>  resets  <i>A</i>  to 0. <br>Otherwise, if   <i>Clear</i>_<i>b </i>= 1,  one out of three operations is triggered by the positive edge <br>of the clock. The  <b>if</b>,    <b>else if</b>,   and  <b>else</b> statements establish a precedence among the control <br>signals  <i>Clear</i>,    <i>Load</i>,  and  <i>Count</i>   corresponding  to  the  specification  in   Table    6.6   .   <i>Clear_b</i> <br>overrides  <i>Load</i>  and  <i>Count</i> ;   <i>Load</i>  overrides  <i>Count</i> . A synthesis tool will produce the <br>circuit of  Fig.   6.14  (b) from the behavioral model. <b> </b><br>
<hr>
<A name=306></a><b>288    Chapter 6  Registers and Counters</b><br>
<b> <br>HDL Example 6.3 (Synchronous Counter) </b><br>
 <br>// Four-bit binary counter with parallel load (V2001, 2005)<br>
 <br>// See  Figure   6.14   and  Table   6.6  <br>
 <br><b>module</b>  Binary_Counter_4_Par_Load (<br>   <b>output reg</b>  [3: 0] <br>
A_count, <br>
// Data output<br>
   <b>output</b> <br>
C_out, <br>
// Output carry<br>
   <b>input</b>  [3: 0] <br>
Data_in, <br>
// Data input<br>
   <b>input</b> <br>
Count, <br>
// Active high to count<br>
 <br>
Load, <br>
// Active high to load<br>
 <br>
CLK, <br>
// Positive-edge sensitive<br>
 <br>
Clear_b <br>
// Active low<br>
 <br>);<br>
 <br><b>assign</b>  C_out = Count &amp;&amp; (~Load) &amp;&amp; (A_count == 4'b1111);<br> <br><b>always</b>  @ ( <b>posedge</b>  CLK,  <b>negedge</b>  Clear_b)<br>   <b>if</b>  (~Clear_b) <br>
A_count &lt;= 4'b0000;<br>
   <b>else if</b>  (Load) <br>
A_count &lt;= Data_in;<br>
   <b>else if</b>  (Count) <br>
A_count &lt;= A_count + 1'b1;<br>
   <b>else</b> <br>
A_count &lt;= A_count;  // redundant statement<br>
 <br><b>endmodule</b> <br>
<b> <br>Ripple Counter </b><br>
 <br>The structural description of a ripple counter is shown in HDL Example 6.4. The first <br>module instantiates four internally complementing flipflops defined in the second mod-<br>ule as  <i>Comp_D_flip_flop (Q, CLK, Reset)</i> . The clock (input  <i>CLK</i> ) of the first flipflop <br>is connected to the external control signal  <i>Count</i> .  ( <i>Count</i>  replaces  <i>CLK</i>  in the port list <br>of instance  <i>F0</i> .) The clock input of the second flipflop is connected to the output of the <br>first. ( <i>A0</i>  replaces  <i>CLK</i>  in instance  <i>F1</i> .) Similarly, the clock of each of the other flipflops <br>is connected to the output of the previous flipflop. In this way, the flipflops are chained <br>together to create a ripple counter as shown in  Fig.   6.8  (b). <br>
 <br>The second module describes a complementing flipflop with delay. The circuit of a <br>
complementing flipflop is constructed by connecting the complement output to the  <i>D</i> <br>input. A reset input is included with the flipflop in order to be able to initialize the <br>counter; otherwise the simulator would assign the unknown value (<i>x</i>) to the output of <br>the flipflop and produce useless results. The flipflop is assigned a delay of two time <br>units from the time that the clock is applied to the time that the flipflop complements <br>its output. The delay is specified by the statement   <i>Q </i>6 = #2<br>
<i>Q</i>.  Notice that the delay <br>
operator is placed to the right of the nonblocking assignment operator. This form of <br>delay, called  <i>intraassignment delay</i>,  has the effect of postponing the assignment of the <br>complemented value of  <i>Q</i>  to  <i>Q</i> . The effect of modeling the delay will be apparent in <br>the simulation results. This style of modeling might be useful in simulation, but it is to <br>be avoided when the model is to be synthesized. The results of synthesis depend on the <br>ASIC cell library that is accessed by the tool, not on any propagation delays that might <br>appear within the model that is to be synthesized. <b> </b><br>
<hr>
<A name=307></a><b>Section 6.6  HDL for Registers and Counters    289</b><br>
<b> <br>HDL Example 6.4 (Ripple Counter) </b><br>
 <br>// Ripple counter (See  Fig.   6.8  (b))<br>
 <br>'timescale 1ns / 100 ps<br>
 <br><b>module</b>  Ripple_Counter_4bit (A3, A2, A1, A0, Count, Reset);<br>  <b>output</b>  A3, A2, A1, A0;<br>  <b>input</b>  Count, Reset;<br> <br>// Instantiate complementing fl ip-fl op<br>
  Comp_D_fl ip_fl op F0 (A0, Count, Reset);<br>
  Comp_D_fl ip_fl op F1 (A1, A0, Reset);<br>
  Comp_D_fl ip_fl op F2 (A2, A1, Reset);<br>
  Comp_D_fl ip_fl op F3 (A3, A2, Reset);<br>
 <br><b>endmodule</b> <br> <br>// Complementing fl ip-fl op with delay<br>
 <br>// Input to D fl ip-fl op = Q'<br>
 <br><b>module</b>  Comp_D_fl ip_fl op (Q, CLK, Reset);<br>   <b>output</b>  Q;<br>   <b>input</b>  CLK, <br>
Reset;<br>
   <b>reg</b>  Q;<br>   <b>always @</b>  ( <b>negedge</b>  CLK,  <b>posedge</b>  Reset)<br>   <b>if</b>  (Reset) Q &lt;= 1'b0;<br>   <b>else</b>  Q &lt;= #2 ~Q;  <br>
// intra-assignment delay<br>
 <br><b>endmodule</b> <br> <br>// Stimulus for testing ripple counter<br>
 <br><b>module</b>  t_Ripple_Counter_4bit;<br>   <b>reg</b>  Count;<br>   <b>reg</b>  Reset;<br>   <b>wire</b> <br>
A0, A1, A2, A3;<br>
 <br>// Instantiate ripple counter<br>
   Ripple_Counter_4bit M0 (A3, A2, A1, A0, Count, Reset);<br>
  <b>always</b> <br>   #5 Count = ~Count;<br>
  <b>initial</b> <br>    <b>begin</b> <br>   Count = 1'b0;<br>
   Reset = 1'b1;<br>
   #4 Reset = 1'b0;<br>
     <b>end</b> <br>
   <b>initial</b>  #170  <b>$finish;</b> <br>
 <br><b>endmodule</b> <br>
<hr>
<A name=308></a><b>290    Chapter 6  Registers and Counters</b><br>
 <br>The test bench module in HDL Example 6.4 provides a stimulus for simulating and <br>
verifying the functionality of the ripple counter. The  <b>always</b>  statement generates a free <br>running clock with a cycle of 10 time units. The flipflops trigger on the negative edge of <br>the clock, which occurs at   <i>t </i>= 10, 20, 30,  and every 10 time units thereafter. The waveforms <br>obtained from this simulation are shown in  Fig.   6.19  .The control signal  <i>Count</i>  goes negative <br>every 10 ns.  <i>A0</i>  is complemented with each negative edge of  <i>Count</i>,  but is delayed by 2 ns. <br>Each flipflop is complemented when its previous flipflop goes from 1 to 0. After   <i>t </i>= 80  ns,    <br>all four flipflops complement because the counter goes from 0111 to 1000. Each output is <br>delayed by 2 ns, and because of that,  <i>A</i> 3 goes from 0 to 1 at   <i>t </i>= 88 ns  and from 1 to 0 at <br>168 ns. Notice how the propagation delays accumulate to the last bit of the counter, result-<br>ing in very slow counter action. This limits the practical utility of the counter.  <br>
0.0 ns<br>
57.0 ns<br>
114.0 ns<br>
171.0 ns<br>
Reset<br>
Count<br>
A0<br>
A1<br>
A2<br>
A3<br>
t<br>
 88 ns<br>
t<br>
 168 ns<br>
(a) From 0 to 180 ns<br>
70.0 ns<br>
77.0 ns<br>
84.0 ns<br>
91.0 ns<br>
98.0 ns<br>
Reset<br>
Count<br>
A0<br>
A1<br>
A2<br>
A3<br>
(b) From 70 to 98 ns<br>
<b> <br>FIGURE 6.19 <br> <br>Simulation output of HDL Example 6.4  </b><br>
<hr>
<A name=309></a><b>Problems    291</b><br>
<b> <br>P R O B L E M S </b><br>
 <br>(Answers to problems marked with <b>*</b> appear at the end of the book. Where appropriate, a logic <br>design and its related HDL modeling problem are cross-referenced.) <br>Note: For each problem that requires writing and verifying a Verilog description, a test plan is to <br>be written to identify which functional features are to be tested during the simulation and how <br>they will be tested. For example, a reset on the fly could be tested by asserting the reset signal <br>while the simulated machine is in a state other than the reset state. The test plan is to guide the <br>development of a test bench that will implement the plan. Simulate the model using the test bench <br>and verify that the behavior is correct. If synthesis tools and an ASIC cell library or a field pro-<br>grammable gate array (FPGA) tool suite are available, the Verilog descriptions developed for <br>Problems 6.34�6.51 can be assigned as synthesis exercises. The gatelevel circuit produced by the <br>synthesis tools should be simulated and compared to the simulation results for the presynthesis <br>model  . <br>
 <br>In some of the HDL problems, there may be a need to deal with the issue of unused states (see <br>
the discussion of the  <b>default</b>    <b>case</b>  item preceding HDL Example 4.8 in  Chapter   4  ). <br>
 <br><b> 6.1 </b><br>
 <br>Include a 2input NAND gate in the register of  Fig.   6.1   and connect the gate output to the <br> <br><i>C</i>  inputs of all the flipflops. One input of the NAND gate receives the clock pulses from <br>the clock generator, and the other input of the NAND gate provides a parallel load control. <br>Explain the operation of the modified register. Explain why this circuit might have opera-<br>tional  problems.   <br>
 <br><b> 6.2 </b><br>
 <br>Include a synchronous clear input to the register of  Fig.   6.2  .The modified register will have <br>a parallel load capability and a synchronous clear capability. The register is cleared syn-<br>chronously when the clock goes through a positive transition and the clear input is equal <br>to 1. (HDL--see Problem 6.35(a), (b).)  <br>
 <br><b> 6.3 </b><br>
 <br>What is the difference between serial and parallel transfer? Explain how to convert serial <br>data to parallel and parallel data to serial. What type of register is needed?  <br>
 <br><b> 6.4*  </b> The contents of a fourbit register is initially 0110. The register is shifted six times to the <br>
right with the serial input being 1011100. What is the content of the register after each <br>shift?   <br>
 <br><b> 6.5 </b><br>
 <br>The fourbit universal shift register shown in  Fig.   6.7   is enclosed within one IC component <br>package. (HDL--see Problem 6.52.) <br>
 <br>
(a)<b>  </b> Draw a block diagram of the IC showing all inputs and outputs. Include two pins for <br>
the power supply. <br>
 <br>
(b)<b>  </b> Draw a block diagram using two of these ICs to produce an eightbit universal shift <br>
register.     <br>
 <br><b> 6.6 </b><br>
 <br>Design a fourbit shift register with parallel load using  <i>D</i>  flipflops. There are two control <br>inputs:  <i>shift</i>   and   <i>load</i> .  When   <i>shift</i>  = 1, the content of the register is shifted by one posi-<br>tion. New data are transferred into the register when  <i>load</i>  = 1 and  <i>shift</i>  = 0. If both <br>control inputs are equal to 0, the content of the register does not change. (HDL--see <br>Problem 6.35(c), (d).) <br>
 <br><b> 6.7 </b><br>
 <br>Draw the logic diagram of a fourbit register with four  <i>D</i>  flipflops and four 4 � 1 mul-<br>tiplexers with mode selection inputs  <i>s</i> 1  and  <i>s</i> 0 . The register operates according to the <br>following function table. (HDL--see Problem 6.35(e), (f).) <br>
 <br>
<hr>
<A name=310></a><b>292    Chapter 6  Registers and Counters</b><br>
<b> <br><i>s</i> 1 </b><br>
<b> <br><i>s</i> 0 </b><br>
<b> <br>Register Operation </b><br>
 0 <br>
 0 <br>
 No  change <br>
 1 <br>
 0 <br>
 Complement  the  four  outputs <br>
 <br>0 <br>
 <br>1 <br>
 <br>Clear register to 0 (synchronous with the clock) <br>
 1 <br>
 1 <br>
 Load  parallel  data <br>
 <br><b> 6.8*  </b> The serial adder of  Fig.   6.6   uses two fourbit registers. Register  <i>A</i>  holds the binary number <br>
0101 and register  <i>B</i>  holds 0111. The carry flipflop is initially reset to 0. List the binary <br>values in register  <i>A</i>  and the carry flipflop after each shift. (HDL--see Problem 6.54). <br>
 <br><b> 6.9 </b><br>
 <br>Two ways for implementing a serial adder ( <i>A</i> +  <i>B</i> ) is shown in Section 6.2. It is necessary <br>to modify the circuits to convert them to serial subtractors ( <i>A</i> -  <i>B</i> ). <br>
 <br>
(a)<b>  </b>  Using  the  circuit  of   Fig.    6.5   ,  show  the  changes  needed  to  perform   <i>A</i> + 2's complement <br>
of  <i>B</i> . (HDL--see Problem 6.35(h).)  <br>
 <br>
(b)    <b>*</b>Using the circuit of  Fig.   6.6  , show the changes needed by modifying  Table   6.2   from an <br>
adder to a subtractor circuit. (See Problem 4.12). (HDL--see Problem 6.35(i).)  <br>
 <br><b> 6.10 </b><br>
 <br>Design a serial 2's complementer with a shift register and a flipflop. The binary number <br>is shifted out from one side and it's 2's complement shifted into the other side of the shift <br>register. (HDL--see Problem 6.35(j).)  <br>
 <br><b> 6.11 </b><br>
 <br>A binary ripple counter uses flipflops that trigger on the positiveedge of the clock. What <br>will be the count if <br>
 <br>
(a)<b>  </b> the normal outputs of the flipflops are connected to the clock and  <br>
 <br>
(b)<b>  </b> the complement outputs of the flipflops are connected to the clock?  <br>
 <br><b> 6.12 </b><br>
 <br>Draw the logic diagram of a fourbit binary ripple countdown counter using <br>
 <br>
(a)<b>  </b> flipflops that trigger on the positiveedge of the clock and  <br>
 <br>
(b)<b>  </b> flipflops that trigger on the negativeedge of the clock. <br>
 <br><b> 6.13 </b><br>
 <br>Show that a BCD ripple counter can be constructed using a fourbit binary ripple counter <br>with asynchronous clear and a NAND gate that detects the occurrence of count 1010. <br>(HDL--see Problem 6.35(k).)  <br>
 <br><b> 6.14 </b><br>
 <br>How many flipflop will be complemented in a 10bit binary ripple counter to reach the <br>next count after the following counts? <br>
 <br>
(a)    <b>*</b>1001100111  <br>
 <br>
(b)<b>  </b>  1111000111  <br>
 <br>
(c)<b>  </b>  0000001111     <br>
 <br><b> 6.15* </b> A flipflops has a 3 ns delay from the time the clock edge occurs to the time the output <br>
is complemented. What is the maximum delay in a 10bit binary ripple counter that uses <br>these flipflops? What is the maximum frequency at which the counter can operate <br>reliably?   <br>
 <br><b> 6.16* </b> The BCD ripple counter shown in  Fig.   6.10   has four flipflops and 16 states, of which only <br>
10 are used. Analyze the circuit and determine the next state for each of the other six <br>unused states. What will happen if a noise signal sends the circuit to one of the unused <br>states? (HDL--see Problem 6.54.)  <br>
<hr>
<A name=311></a><b>Problems    293</b><br>
 <br><b> 6.17* </b> Design a fourbit binary synchronous counter with  <i>D</i>   flipflops.   <br>
 <br><b> 6.18 </b><br>
 <br>What operation is performed in the up�down counter of  Fig.   6.13   when both the up and <br>down inputs are enabled? Modify the circuit so that when both inputs are equal to 1, the <br>counter does not change state. (HDL--see Problem 6.35(l).)  <br>
 <br><b> 6.19 </b><br>
 <br>The flipflop input equations for a BCD counter using  <i>T</i>  flipflops are given in Section 6.4. <br>Obtain the input equations for a BCD counter that uses (a)  <i>JK</i>  flipflops and (b)<b>*</b>  <i>D</i>   flip<br>flops. Compare the three designs to determine which one is the most efficient. <br>
 <br><b> 6.20 </b><br>
 <br>Enclose the binary counter with parallel load of  Fig.   6.14   in a block diagram showing, all <br>inputs and outputs. <br>
 <br>
(a)<b>  </b> Show the connections of four such blocks to produce a 16bit counter with parallel <br>
load.  <br>
 <br>
(b)<b>  </b> Construct a binary counter that counts from 0 through binary 127. <br>
 <br><b> 6.21* </b>  The  counter  of   Fig.    6.14     has  two  control  inputs-- <i>Load</i>   ( <i>L</i> ) and  <i>Count</i>   ( <i>C</i> )--and a data <br>
input, ( <i>I i </i> ). <br>
 <br>
(a)<b>  </b> Derive the flipflop input equations for  <i>J</i>  and  <i>K</i>  of the first stage in terms of  <i>L</i>,    <i>C</i>,  <br>
and  <i>I.</i> <br>
 <br>
(b)<b>  </b> The logic diagram of the first stage of an equivalent circuit is shown in  Fig.   P6.21 . <br>
Verify that this circuit is equivalent to the one in (a).  <br>
Load (L)<br>
<i>J</i><br>
<i>CLK</i><br>
Count (C)<br>
<i>K</i><br>
Data (I)<br>
<b> <br>FIGURE P6.21 </b> <br>
 <br><b> 6.22 </b><br>
 <br>For the circuit of  Fig.   6.14  , give three alternatives for a mod10 counter (i.e., the count <br>evolves through a sequence of 12 distinct states). <br>
 <br>
(a)<b>  </b> Using an AND gate and the load input. <br>
 <br>
(b)<b>  </b> Using the output carry. <br>
 <br>
(c)<b>  </b> Using a NAND gate and the asynchronous clear input. <br>
 <br><b> 6.23 </b><br>
 <br>Design a timing circuit that provides an output signal that stays on for exactly twelve clock <br>cycles. A start signal sends the output to the 1 state, and after twelve clock cycles the signal <br>returns to the 0 state. (HDL--see Problem 6.45.)  <br>
 <br><b> 6.24* </b> Design a counter with  <i>T</i>  flipflops that goes through the following binary repeated se-<br>
quence: 0, 1, 3, 7, 6, 4. Show that when binary states 010 and 101 are considered as don't <br>care conditions, the counter may not operate properly. Find a way to correct the design. <br>(HDL--see Problem 6.55.)  <br>
 <br><b> 6.25 </b><br>
 <br>It is necessary to generate six repeated timing signals   <i>T</i>0     through     <i>T</i>5  similar to the ones <br>shown in  Fig.   6.17  (c). Design the circuit using (HDL--see Problem 6.46.): <br>
 <br>
(a)<b>  </b>  flipflops  only.  <br>
 <br>
(b)<b>  </b>  a  counter  and  a  decoder.     <br>
<hr>
<A name=312></a><b>294    Chapter 6  Registers and Counters</b><br>
 <br><b> 6.26* </b> A digital system has a clock generator that produces pulses at a frequency of 80 MHz. <br>
Design a circuit that provides a clock with a cycle time of 50 ns. <br>
 <br><b> 6.27 </b><br>
  Using   <i>JK</i>   flipflops, <br>
 <br>
(a)<b>  </b> Design a counter with the following repeated binary sequence: 0, 1, 2, 3, 4, 5, 6. <br>
(HDL--see Problem 6.50(a), 6.51.). <br>
 <br>
(b)<b>  </b> Draw the logic diagram of the counter. <br>
 <br><b> 6.28 </b><br>
  Using   <i>D</i>   flipflops, <br>
 <br>
(a)    <b>*</b>Design a counter with the following repeated binary sequence: 0, 1, 2, 4, 6. (HDL--see <br>
Problem 6.50(b).)  <br>
 <br>
(b)<b>  </b> Draw the logic diagram of the counter. <br>
 <br>
(c)<b>  </b> Design a counter with the following repeated binary sequence: 0, 2, 4, 6, 8. <br>
 <br>
(d)<b>  </b> Draw the logic diagram of the counter. <br>
 <br><b> 6.29 </b><br>
 <br>List the eight unused states in the switchtail ring counter of  Fig.   6.18  (a).   Determine the <br>next state for each of these states and show that, if the counter finds itself in an invalid <br>state, it does not return to a valid state. Modify the circuit as recommended in the text and <br>show that the counter produces the same sequence of states and that the circuit reaches a <br>valid state from any one of the unused states. <br>
 <br><b> 6.30 </b><br>
 <br>Show that a Johnson counter with  <i>n</i>  flipflops produces a sequence of 2 <i>n</i>  states. List the <br>10 states produced with five flipflops and the Boolean terms of each of the 10 AND gate <br>outputs.   <br>
 <br><b> 6.31 </b><br>
 <br>Write and verify the HDL behavioral and structural descriptions of the fourbit register <br> <br>Fig.  6.1 . <br>
 <br><b> 6.32 </b><br>
 <br>(a)<b>   </b>Write and verify an HDL behavioral description of a fourbit register with parallel <br>
load and asynchronous clear. <br>
 <br>
(b)<b>  </b> Write and verify the HDL structural description of the fourbit register with parallel <br>
load shown in  Fig.   6.2  . Use a 2 * 1 multiplexer for the flipflop inputs. Include an <br>asynchronous clear input. <br>
 <br>
(c)<b>  </b>  Verify  both  descriptions,  using  a  test  bench.      <br>
 <br><b> 6.33 </b><br>
 <br>The following stimulus program is used to simulate the binary counter with parallel load <br>described in HDL Example 6.3. Draw waveforms showing the output of the counter and <br>the carry output from  <i>t</i> = 0 to  <i>t</i> = 155 ns. <br>
 <br>// Stimulus for testing the binary counter of Example 6.3 <br>
 <br><b>module</b>  testcounter; <br>
 <br>   <b>reg</b>  Count, Load, CLK, Clr; <br>
 <br>   <b>reg</b>  [3: 0] IN; <br>
 <br>   <b>wire</b>  C0; <br>
 <br>   <b>wire</b>  [3: 0] A; <br>
 <br>  counter cnt (Count, Load, IN, CLK, Clr, A, CO); <br>
 <br>   <b>always</b> <br>
 <br>    #5 CLK = ~CLK; <br>
 <br>   <b>initial</b> <br>
 <br>     <b>begin</b> <br>
 <br>      Clr = 0; <br>
 <br>      CLK = 1; <br>
 <br>      Load = 0; Count = 1; <br>
<hr>
<A name=313></a><b>Problems    295</b><br>
 <br>      #5 Clr = 1; <br>
 <br>      #40 Load = 1; IN = 4'b1001; <br>
 <br>      #10 Load = 0; <br>
 <br>      #70 Count = 0; <br>
 <br>      #20  <b>$finish</b> ; <br>
 <br>     <b>end</b> <br>
 <br><b>endmodule</b> <br>
 <br><b> 6.34* </b> Write and verify the HDL behavioral description of a fourbit shift register (see  Fig.   6.3  ). <br>
 <br><b> 6.35 </b><br>
  Write  and  verify <br>
 <br>
(a)<b>  </b> A structural HDL model for the register described in Problem 6.2  <br>
 <br>
(b)    <b>*</b>A behavioral HDL model for the register described in Problem 6.2  <br>
 <br>
(c)<b>  </b> A structural HDL model for the register described in Problem 6.6  <br>
 <br>
(d)<b>  </b> A behavioral HDL model for the register described in Problem 6.6  <br>
 <br>
(e)<b>  </b> A structural HDL model for the register described in Problem 6.7  <br>
 <br>
(f)<b>  </b> A behavioral HDL model for the register described in Problem 6.7  <br>
 <br>
(g)<b>  </b> A behavioral HDL model of the binary counter described in  Fig.   6.8  (b)  <br>
 <br>
(h)<b>  </b> A behavioral HDL model of the serial subtractor described in Problem 6.9(a)  <br>
 <br>
(i)<b>  </b> A behavioral HDL model of the serial subtractor described in Problem 6.9(b)  <br>
 <br>
(j)<b>  </b> A behavioral HDL model of the serial 2's complementer described in Problem 6.10  <br>
 <br>
(k)<b>  </b> A behavioral HDL model of the BCD ripple counter described in Problem 6.13  <br>
 <br>
(l)<b>  </b> A behavioral HDL model of the up�down counter described in Problem 6.18. <br>
 <br><b> 6.36 </b><br>
 <br>Write and verify the HDL behavioral and structural descriptions of the fourbit up�down <br>counter  whose  logic  diagram  is  described  by   Fig.    6.13   ,   Table    6.5   ,  and   Table    6.6   .   <br>
 <br><b> 6.37 </b><br>
 <br>Write and verify a behavioral description of the counter described in Problem 6.24. <br>
 <br>
(a)    <b>*</b>Using an  <b>if </b>...<b> else</b>   statement  <br>
 <br>
(b)<b>  </b>  Using  a   <b>case</b>   statement  <br>
 <br>
(c)<b>  </b>  A  finite  state  machine.     <br>
 <br><b> 6.38 </b><br>
 <br>Write and verify the HDL behavioral description of a fourbit up�down counter with <br>parallel load using the following control inputs: <br>
 <br>
(a)    <b>*</b>The counter has three control inputs for the three operations:  <i>Up</i>,    <i>Down</i>,  and  <i>Load</i> . <br>
The order of precedence is:  <i>Load</i>,    <i>Up</i>,  and  <i>Down</i> .  <br>
 <br>
(b)<b>  </b> The counter has two selection inputs to specify four operations:  <i>Load</i>,    <i>Up</i>,    <i>Down</i>,   and <br>
no  change.     <br>
 <br><b> 6.39 </b><br>
 <br>Write and verify HDL behavioral and structural descriptions of the counter of  Fig.   6.16  . <br>
 <br><b> 6.40 </b><br>
 <br>Write and verify the HDL description of an eightbit ringcounter similar to the one shown <br>in   Fig.    6.17   (a).   <br>
 <br><b> 6.41 </b><br>
 <br>Write and verify the HDL description of a fourbit switchtail ring (Johnson) counter <br>( Fig.    6.18   a).   <br>
 <br><b> 6.42* </b> The comment with the last clause of the if statement in  <i>Binary_Counter</i> _4_ <i>Par_Load</i>   in <br>
HDL Example 6.3 notes that the statement is redundant. Explain why this statement can <br>be removed without changing the behavior implemented by the description. <br>
 <br><b> 6.43 </b><br>
 <br>The scheme shown in  Fig.   6.4   gates the clock to control the serial transfer of data from shift <br>register A to shift register B. Using multiplexers at the input of each cell of the shift  registers, <br>develop a structural model of an alternative circuit that does not alter the clock path. The <br>
<hr>
<A name=314></a><b>296    Chapter 6  Registers and Counters</b><br>
top level of the design hierarchy is to instantiate the shift registers. The module describing <br>the shift registers is to have instantiations of flipflops and muxes. Describe the mux and <br>flipflop modules with behavioral models. Be sure to consider the need to reset the machine. <br>Develop a test bench to simulate the circuit and demonstrate the transfer of data. <br>
 <br><b> 6.44 </b><br>
 <br>Modify the design of the serial adder shown in  Fig.   6.5   by removing the gated clock to the  <i>D</i> <br>flipflop and supplying the clock signal to it directly. Augment the  <i>D</i>  flipflop with a mux to <br>recirculate the contents of the flipflop when shifting is suspended and provide the carry out <br>of the full adder when shifting is active. The shift registers are to incorporate this feature also, <br>rather than use a gated clock. The toplevel of the design is to instantiate modules using <br>behavioral models for the shift registers, full adder, <i>D</i> flipflop, and mux. Assume asynchro-<br>nous reset. Develop a test bench to simulate the circuit and demonstrate the transfer of data. <br>
 <br><b> 6.45* </b> Write and verify a behavioral description of a finite state machine to implement the coun-<br>
ter described in Problem 6.24. <br>
 <br><b> 6.46 </b><br>
 <br>Problem 6.25 specifies an implementation of a circuit to generate timing signals using <br>
 <br>
(a)<b>  </b>  Only  flipflops.  <br>
 <br>
(b)<b>  </b> A counter and a decoder. <br>
 <br>
 <br>
As an alternative, write a behavioral description (without consideration of the actual hard-<br>ware) of a state machine whose output generates the timing signals  <i>T </i>0<i> </i> through  <i>T </i>5<i> </i>.<br>
 <br><b> 6.47 </b><br>
 <br>Write a behavioral description of the circuit shown in  Fig.   P6.47   and verify that the circuit's <br>output is asserted if successive samples of the input have an odd number of 1s. <br>
<i>D</i><br>
<i>Q</i><br>
<i>P_odd</i><br>
<i>D_in</i><br>
<i>CLK</i><br>
<i>CLK</i><br>
<i>reset</i><br>
<b> <br>FIGURE P6.47 <br>Circuit for Problem 6.47 </b><br>
 <br><b> 6.48 </b><br>
 <br>Write and verify a behavioral description of the counter shown in  Fig.   P6.48  (a); repeat for <br>the counter in Fig. P6.48(b). <br>
 <br><b> 6.49 </b><br>
 <br>Write a test plan for verifying the functionality of the universal shift register described in <br>HDL Example 6.1. Using the test plan, simulate the model given in HDL Example 6.1. <br>
 <br><b> 6.50 </b><br>
 <br>Write and verify a behavioral model of the counter described in <br>
 <br>
(a)<b>  </b>  Problem  6.27  <br>
 <br>
(b)<b>  </b>  Problem  6.28     <br>
 <br><b> 6.51 </b><br>
 <br>Without requiring a state machine, and using a shift register and additional logic, write and <br>verify a model of an alternative to the sequence detector described in Fig. 5.27. Compare <br>the  implementations.   <br>
 <br><b> 6.52 </b><br>
 <br>Write a Verilog structural model of the universal shift register in  Fig.   6.7 . Verify all modes <br>of its operation. <br>
<hr>
<A name=315></a><b>Problems    297</b><br>
<i>count [7: 0]</i><br>
<i>count [7: 0]</i><br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
1<br>
1<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
1<br>
0<br>
0<br>
1<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
1<br>
1<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
1<br>
0<br>
0<br>
0<br>
0<br>
1<br>
0<br>
0<br>
0<br>
0<br>
0<br>
<i>t</i><br>
<i>t</i><br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
1<br>
1<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
1<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
1<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
1<br>
1<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
1<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
1<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
1<br>
1<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
1<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
1<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
1<br>
1<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
1<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
1<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
1<br>
1<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
1<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
1<br>
(a)<br>
(b)<br>
<b> <br>FIGURE P6.48   <br>Circuit for Problem 6.48 </b><br>
 <br><b> 6.53 </b><br>
 <br>Verify that the serial adder in  Fig.   6.5   operates as an accumulator when words are shifted <br>into the addend register repeatedly. <br>
 <br><b> 6.54 </b><br>
 <br>Write and verify a structural model of the serial adder in  Fig.   6.6  . <br>
 <br><b> 6.55 </b><br>
 <br>Write and verify a structural model of the BCD ripple counter in  Fig.   6.10  . <br>
 <br><b> 6.56 </b><br>
 <br>Write and verify a structural model of the synchronous binary counter in  Fig.   6.12  . <br>
 <br><b> 6.57 </b><br>
 <br>Write and verify a structural model of the up�down counter in  Fig.   6.13  . <br>
 <br><b> 6.58 </b><br>
 <br>Write and verify all modes of operation of <br>
 <br>
(a)<b>  </b> A structural model of the binary counter in  Fig.   6.14  <br>
 <br>
(b)<b>  </b>  A  behavioral  model  of  the  binary  counter  in   Fig.    6.14   .     <br>
 <br><b> 6.59 </b><br>
  Write  and  verify <br>
 <br>
(a)<b>  </b> A structural model of the switchtail ring counter in  Fig.   6.18  (a)  <br>
 <br>
(b)<b>  </b>  A  behavioral  model  of  the  switchtail  ringer  counter  in   Fig.    6.18   (a)      <br>
<hr>
<A name=316></a><b>298    Chapter 6  Registers and Counters</b><br>
<b> <br>R E F E R E N C E S </b><br>
 <br><b>  </b><br>
<b>1. </b><br>
<b> </b><br>
M ano,  M. M. and C. R.  Kime . 2007.  <i>Logic and Computer Design Fundamentals</i>,  4th ed. Upper <br>Saddle River, NJ: Prentice Hall. <br>
 <br><b>  </b><br>
<b>2. </b><br>
 <br>N elson  V. P., H. T.  Nagle,  J. D.  Irwin,  and B. D.  Carroll . 1995.  <i>Digital Logic Circuit <br>Analysis and Design</i>.  Upper Saddle River, NJ: Prentice Hall. <br>
 <br><b>  </b><br>
<b>3.</b> <br>
 <br>H ayes,  J. P. 1993.  <i>Introduction to Digital Logic Design</i>.  Reading, MA: AddisonWesley. <br>
 <br><b>  </b><br>
<b>4.</b> <br>
 <br>W akerly,  J. F. 2000.  <i>Digital Design: Principles and Practices</i>,  3rd ed. Upper Saddle River, <br>NJ: Prentice Hall. <br>
 <br><b>  </b><br>
<b>5.</b> <br>
 <br>D ietmeyer,  D. L. 1988.  <i>Logic Design of Digital Systems</i>,  3rd ed. Boston: Allyn Bacon. <br>
 <br><b>  </b><br>
<b>6.</b> <br>
 <br>G ajski,  D. D. 1997.  <i>Principles of Digital Design</i>.  Upper Saddle River, NJ: Prentice Hall. <br>
 <br><b>  </b><br>
<b>7.</b> <br>
 <br>R oth,  C. H. 2009.  <i>Fundamentals of Logic Design</i>,  6th ed. St. Paul: West. <br>
 <br><b>  </b><br>
<b>8.</b> <br>
 <br>K atz,  R. H. 1994.  <i>Contemporary Logic Design</i>.  Upper Saddle River, NJ: Prentice Hall. <br>
 <br><b>  </b><br>
<b>9.</b> <br>
 <br>C iletti,  M. D. 1999.  <i>Modeling, Synthesis, and Rapid Prototyping with Verilog HDL</i>.   Upper <br>Saddle River, NJ: Prentice Hall. <br>
 <br><b> 10.</b> <br>
 B hasker,   J.  1997.   <i>A Verilog HDL Primer</i>. Allentown, PA: Star Galaxy Press. <br>
 <br><b> 11.</b> <br>
 <br>T homas,  D. E. and P. R. Moorby. 2002.  <i>The VeriLog Hardware Description Language</i>,   5th <br>ed. Boston: Kluwer Academic Publishers. <br>
 <br><b> 12.</b> <br>
 B hasker,   J.  1998.   <i>Verilog HDL Synthesis</i>. Allentown, PA: Star Galaxy Press. <br>
 <br><b> 13.</b> <br>
 P alnitkar,   S.  1996.   <i>Verilog HDL: A Guide to Digital Design and Synthesis</i>.   Mountain  View, <br>CA: SunSoft Press (A Prentice Hall Title). <br>
 <br><b> 14.</b> <br>
 <br>C iletti,  M. D. 2010.  <i>Advanced Digital Design with the Verilog HDL</i>,<i> 2e</i>.  Upper Saddle <br>River, NJ: Prentice Hall. <br>
 <br><b> 15.</b> <br>
 <br>C iletti,  M. D. 2004.  <i>Starter</i>'<i>s Guide to Verilog 2001</i>.  Upper Saddle River, NJ: Prentice Hall. <br>
<b> <br>W E B   S E A R C H   T O P I C S </b><br>
    <br>
 <br>
BCD  counter  <br>
 <br>
 <br>
  Johnson  counter  <br>
 <br>
 <br>
  Ring  counter  <br>
 <br>
 <br>
  Sequence  detector  <br>
 <br>
 <br>
  Synchronous  counter  <br>
 <br>
 <br>
  Switchtail  ring  counter  <br>
 <br>
 <br>
  Up�down  counter      <br>
<hr>
<A name=317></a> <br>Chapter 7 <br>
<b> <br>Memory and Programmable Logic </b> <br>
<b> <br>7 . 1       IN T R O D U C T I O N </b><br>
 <br>A memory unit is a device to which binary information is transferred for storage and from <br>which information is retrieved when needed for processing. When data processing takes <br>place, information from memory is transferred to selected registers in the processing unit. <br>Intermediate and final results obtained in the processing unit are transferred back to be <br>stored in memory. Binary information received from an input device is stored in memory, <br>and information transferred to an output device is taken from memory. A memory unit <br>is a collection of cells capable of storing a large quantity of binary information. <br>
 <br>There are two types of memories that are used in digital systems:  <i>randomaccess </i><br>
<i>memory</i>  (RAM) and  <i>readonly memory</i>  (ROM). RAM stores new information for later <br>use. The process of storing new information into memory is referred to as a memory <br> <br><i>write</i>  operation. The process of transferring the stored information out of memory is <br>referred to as a memory  <i>read</i>  operation. RAM can perform both write and read opera-<br>tions. ROM can perform only the read operation. This means that suitable binary infor-<br>mation is already stored inside memory and can be retrieved or read at any time. <br>However, that information cannot be altered by writing. <br>
 <br>ROM is a  <i>programmable logic device</i>  (PLD). The binary information that is stored <br>
within such a device is specified in some fashion and then embedded within the hard-<br>ware in a process is referred to as  <i>programming</i>  the device. The word "programming" <br>here refers to a hardware procedure which specifies the bits that are inserted into the <br>hardware configuration of the device. <br>
 <br>ROM is one example of a PLD. Other such units are the programmable logic array <br>
(PLA), programmable array logic (PAL), and the fieldprogrammable gate array (FPGA). <br>A PLD is an integrated circuit with internal logic gates connected through electronic <br>
<b>299</b><br>
<hr>
<A name=318></a><b>300    Chapter 7  Memory and Programmable Logic</b><br>
(a) Conventional symbol<br>
(b) Array logic symbol<br>
<b> <br>FIGURE 7.1 <br> <br>Conventional and array logic diagrams for OR gate  </b><br>
paths that behave similarly to fuses. In the original state of the device, all the fuses are <br>intact. Programming the device involves blowing those fuses along the paths that must <br>be removed in order to obtain the particular configuration of the desired logic function. <br>In this chapter, we introduce the configuration of PLDs and indicate procedures for their <br>use in the design of digital systems. We also present CMOS FPGAs, which are configured <br>by downloading a stream of bits into the device to configure transmission gates to estab-<br>lish the internal connectivity required by a specified logic function (combinational or <br>sequential).  <br>
 <br>A typical PLD may have hundreds to millions of gates interconnected through hun-<br>
dreds to thousands of internal paths. In order to show the internal logic diagram of such <br>a device in a concise form, it is necessary to employ a special gate symbology applicable <br>to array logic.  Figure   7.1   shows the conventional and array logic symbols for a multiple<br>input OR gate. Instead of having multiple input lines into the gate, we draw a single line <br>entering the gate. The input lines are drawn perpendicular to this single line and are <br>connected to the gate through internal fuses. In a similar fashion, we can draw the array <br>logic for an AND gate. This type of graphical representation for the inputs of gates will <br>be used throughout the chapter in array logic diagrams. <br>
<b> <br>7 . 2       R A N D O M - A C C E S S   M E M O R Y </b><br>
 <br>A memory unit is a collection of storage cells, together with associated circuits needed <br>to transfer information into and out of a device. The architecture of memory is such that <br>information can be selectively retrieved from any of its internal locations. The time it <br>takes to transfer information to or from any desired random location is always the <br>same--hence the name  <i>randomaccess memory,</i>  abbreviated RAM. In contrast, the time <br>required to retrieve information that is stored on magnetic tape depends on the location <br>of the data. <br>
 <br>A memory unit stores binary information in groups of bits called  <i>words</i> . A word in <br>
memory is an entity of bits that move in and out of storage as a unit. A memory word <br>is a group of 1's and 0's and may represent a number, an instruction, one or more <br>alphanumeric characters, or any other binarycoded information. A group of 8 bits is <br>called a  <i>byte</i> . Most computer memories use words that are multiples of 8 bits in length. <br>Thus, a 16bit word contains two bytes, and a 32bit word is made up of four bytes. The <br>capacity of a memory unit is usually stated as the total number of bytes that the unit <br>can store. <br>
<hr>
<A name=319></a><b>Section 7.2  Random-Access Memory    301</b><br>
<i>n</i> data input lines<br>
<i>k</i> address lines<br>
Memory unit<br>
<i>Read</i><br>
2<i>k</i> words<br>
<i>n</i> bit per word<br>
<i>Write</i><br>
<i>n</i> data output lines<br>
<b> <br>FIGURE 7.2 <br> <br>Block diagram of a memory unit  </b><br>
 <br>Communication between memory and its environment is achieved through data input <br>
and output lines, address selection lines, and control lines that specify the direction of <br>transfer. A block diagram of a memory unit is shown in  Fig.   7.2  . The  <i>n</i>  data input lines <br>provide the information to be stored in memory, and the  <i>n</i>  data output lines supply the <br>information coming out of memory. The  <i>k</i>  address lines specify the particular word <br>chosen among the many available. The two control inputs specify the direction of trans-<br>fer desired: The  <i>Write</i>  input causes binary data to be transferred into the memory, and <br>the  <i>Read</i>  input causes binary data to be transferred out of memory. <br>
 <br>The memory unit is specified by the number of words it contains and the number of <br>
bits in each word. The address lines select one particular word. Each word in memory <br>is assigned an identification number, called an  <i>address,</i>  starting from 0 up to   2<i>k </i>- 1, <br>where  <i>k</i>  is the number of address lines. The selection of a specific word inside memory <br>is done by applying the  <i>k</i> bit address to the address lines. An internal decoder accepts <br>this address and opens the paths needed to select the word specified. Memories vary <br>greatly in size and may range from 1,024 words, requiring an address of 10 bits, to   232 <br>words, requiring 32 address bits. It is customary to refer to the number of words (or <br>bytes) in memory with one of the letters K (kilo), M (mega), and G (giga). K is equal to <br> <br>210,  M is equal to   220,  and G is equal to   230.     Thus,     64K = 216, 2M = 221,     and     4G = 232.    <br>
 <br>Consider, for example, a memory unit with a capacity of 1K words of 16 bits each. <br>
Since     1K = 1,024 = 210  and 16 bits constitute two bytes, we can say that the memory <br>can accommodate   2,048 = 2K bytes.      Figure    7.3     shows  possible  contents  of  the  first <br>three and the last three words of this memory. Each word contains 16 bits that can be <br>divided into two bytes. The words are recognized by their decimal address from 0 to <br>1,023. The equivalent binary address consists of 10 bits. The first address is specified with <br>ten 0's; the last address is specified with ten 1's, because 1,023 in binary is equal to <br>1111111111. A word in memory is selected by its binary address. When a word is read or <br>written, the memory operates on all 16 bits as a single unit. <br>
 The     1K * 16  memory of  Fig.   7.3   has 10 bits in the address and 16 bits in each word. <br>
As another example, a   64K * 10  memory will have 16 bits in the address (since <br>   <br>64K = 216 ) and each word will consist of 10 bits. The number of address bits needed in <br>
<hr>
<A name=320></a><b>302    Chapter 7  Memory and Programmable Logic</b><br>
Memory address<br>
Binary<br>
Decimal<br>
Memory content<br>
0000000000<br>
0<br>
1011010101011101<br>
0000000001<br>
1<br>
1010101110001001<br>
0000000010<br>
2<br>
0000110101000110<br>
�<br>
�<br>
�<br>
�<br>
�<br>
�<br>
�<br>
�<br>
1111111101<br>
1021<br>
1001110100010100<br>
1111111110<br>
1022<br>
0000110100011110<br>
1111111111<br>
1023<br>
1101111000100101<br>
<b> <br>FIGURE 7.3 <br> <br>Contents of a   1024 </b>* <b>16   memory  </b><br>
a memory is dependent on the total number of words that can be stored in the memory <br>and is independent of the number of bits in each word. The number of bits in the address <br>is determined from the relationship   2<i>k</i>  � <i>m</i>,     where   <i>m</i>  is the total number of words and <br> <br><i>k</i>  is the number of address bits needed to satisfy the relationship. <br>
<b> <br>Write and Read Operations </b><br>
 <br>The two operations that RAM can perform are the write and read operations. As alluded <br>to earlier, the write signal specifies a transferin operation and the read signal specifies <br>a transferout operation. On accepting one of these control signals, the internal circuits <br>inside the memory provide the desired operation. <br>
 <br>The steps that must be taken for the purpose of transferring a new word to be stored <br>
into memory are as follows: <br>
 <br><b> 1. </b><br>
 <br>Apply the binary address of the desired word to the address lines. <br>
 <br><b> 2. </b><br>
 <br>Apply the data bits that must be stored in memory to the data input lines. <br>
 <br><b> 3. </b><br>
  Activate  the  <i>write</i>  input.   <br>
 <br>The memory unit will then take the bits from the input data lines and store them in the <br>word specified by the address lines. <br>
 <br>The steps that must be taken for the purpose of transferring a stored word out of <br>
memory are as follows: <br>
 <br><b> 1. </b><br>
 <br>Apply the binary address of the desired word to the address lines. <br>
 <br><b> 2. </b><br>
  Activate  the  <i>read</i>  input.   <br>
<hr>
<A name=321></a><b>Section 7.2  Random-Access Memory    303</b><br>
<b> <br>Table 7.1 <br><i> <br>Control Inputs to Memory Chip </b></i><br>
<b> <br>Memory Enable  </b><br>
<b> <br>Read/Write  </b><br>
<b> <br>Memory Operation  </b><br>
 0 <br>
 X <br>
 None <br>
 1 <br>
 0 <br>
 Write  to  selected  word <br>
 1 <br>
 1 <br>
 Read  from  selected  word <br>
 <br>The memory unit will then take the bits from the word that has been selected by the <br>address and apply them to the output data lines. The contents of the selected word do <br>not change after the read operation, i.e., the word operation is nondestructive. <br>
 <br>Commercial memory components available in integratedcircuit chips sometimes <br>
provide the two control inputs for reading and writing in a somewhat different configu-<br>ration. Instead of having separate read and write inputs to control the two operations, <br>most integrated circuits provide two other control inputs: One input selects the unit and <br>the other determines the operation. The memory operations that result from these <br> control  inputs  are  specified  in   Table    7.1   . <br>
 <br>The memory enable (sometimes called the chip select) is used to enable the particu-<br>
lar memory chip in a multichip implementation of a large memory. When the memory <br>enable is inactive, the memory chip is not selected and no operation is performed. When <br>the memory enable input is active, the read/write input determines the operation to be <br>performed. <b> </b><br>
<b> <br>Memory Description in HDL </b><br>
 <br>Memory is modeled in the Verilog hardware description language (HDL) by an array <br>of registers. It is declared with a  <b>reg</b>  keyword, using a twodimensional array. The first <br>number in the array specifies the number of bits in a word (the  <i>word length</i> ) and the <br>second gives the number of words in memory (memory  <i>depth</i> ). For example, a memory <br>of 1,024 words with 16 bits per word is declared as <br>
 <br><b>reg</b> [15: 0] memword [0: 1023];  <br>
 <br>This statement describes a twodimensional array of 1,024 registers, each containing 16 <br>bits. The second array range in the declaration of  <i>memword</i>  specifies the total number <br>of words in memory and is equivalent to the address of the memory. For example, <br> <br><i>memword[512]</i>  refers to the 16bit memory word at address 512. <br>
 <br>The operation of a memory unit is illustrated in HDL Example 7.1. The memory has <br>
64 words of four bits each. There are two control inputs:  <i>Enable</i>  and  <i>ReadWrite</i> .  The <br> <br><i>DataIn</i>  and  <i>DataOut</i>  lines have four bits each. The input  <i>Address</i>  must have six bits <br>(since     26 = 64 ). The memory is declared as a twodimensional array of registers, with <br> <br><i>Mem</i>  used as an identifier that can be referenced with an index to access any of the <br>64 words. A memory operation requires that the  <i>Enable</i>  input be active. The  <i>ReadWrite</i> <br>input determines the type of operation. If  <i>ReadWrite</i>  is 1, the memory performs a read <br>operation symbolized by the statement <br>
<hr>
<A name=322></a><b>304    Chapter 7  Memory and Programmable Logic</b><br>
 <br>DataOut d Mem [Address];  <br>
 <br>Execution of this statement causes a transfer of four bits from the selected memory word <br>specified by  <i>Address</i>  onto the  <i>DataOut</i>  lines. If  <i>ReadWrite</i>  is 0, the memory performs a <br>write operation symbolized by the statement <br>
 <br>Mem [Address] d DataIn;  <br>
 <br>Execution of this statement causes a transfer from the fourbit  <i>DataIn</i>  lines into the <br>memory word selected by  <i>Address</i> .  When   <i>Enable</i>  is equal to 0, the memory is disabled <br>and the outputs are assumed to be in a highimpedance state, indicated by the symbol  <b>z</b> . <br>Thus, the memory has threestate outputs. <b> </b><br>
<b> <br>HDL Example 7.1  </b><br>
 <br>// Read and write operations of memory<br> <br>// Memory size is 64 words of four bits each.<br>
 <br><b>module</b>  memory (Enable, ReadWrite, Address, DataIn, DataOut);<br>  <b>input</b>   Enable, ReadWrite;<br>  <b>input</b>   [3: 0] DataIn;<br>  <b>input</b>   [5: 0] Address;<br>  <b>output</b>  [3: 0] DataOut;<br>  <b>reg</b>  [3: 0] <br>
DataOut;<br>
  <b>reg</b>  [3: 0] <br>
Mem [0: 63]; <br>
// 64 x 4 memory<br>
  <b>always</b>  @ (Enable  <b>or</b>  ReadWrite)<br>     <b>if</b>  (Enable)<br>       <b>if</b>  (ReadWrite) DataOut = Mem [Address]; <br>
// Read<br>
     <b>else</b>  Mem [Address] = DataIn; <br>
// Write<br>
 <br>    <b>else</b>  DataOut = 4'bz; <br>
// High impedance state<br>
<b> <br>endmodule </b><br>
<b> <br>Timing Waveforms </b><br>
 <br>The operation of the memory unit is controlled by an external device such as a central <br>processing unit (CPU). The CPU is usually synchronized by its own clock. The memory, <br>however, does not employ an internal clock. Instead, its read and write operations are <br>specified by control inputs. The  <i>access time</i>  of memory is the time required to select a <br>word and read it. The  <i>cycle time</i>  of memory is the time required to complete a write <br>operation. The CPU must provide the memory control signals in such a way as to syn-<br>chronize its internal clocked operations with the read and write operations of memory. <br>This means that the access time and cycle time of the memory must be within a time <br>equal to a fixed number of CPU clock cycles. <br>
 <br>Suppose as an example that a CPU operates with a clock frequency of 50 MHz, giv-<br>
ing a period of 20 ns for one clock cycle. Suppose also that the CPU communicates with <br>a memory whose access time and cycle time do not exceed 50 ns. This means that the <br>
<hr>
<A name=323></a><b>Section 7.2  Random-Access Memory    305</b><br>
20 nsec<br>
<i>T </i>1<br>
<i>T </i>2<br>
<i>T </i>3<br>
<i>T </i>1<br>
Clock<br>
Memory<br>
Address valid<br>
address<br>
Memory<br>enable<br>
Initiate writing<br>
Latched<br>
Read/<br>Write<br>
Data<br>
Data valid<br>
input<br>
(a) Write cycle<br>
50 nsec<br>
<i>T </i>1<br>
<i>T </i>2<br>
<i>T </i>3<br>
<i>T </i>1<br>
Clock<br>
Memory<br>
Address valid<br>
address<br>
Memory<br>enable<br>
Initiate read<br>
Read/<br>Write<br>
Data<br>
Data valid<br>
output<br>
(b) Read cycle<br>
<b> <br>FIGURE 7.4 <br> <br>Memory cycle timing waveforms  </b><br>
write cycle terminates the storage of the selected word within a 50ns interval and that <br>the read cycle provides the output data of the selected word within 50 ns or less. (The <br>two numbers are not always the same.) Since the period of the CPU cycle is 20 ns, it will <br>be necessary to devote at least twoandahalf, and possibly three, clock cycles for each <br>memory request. <br>
 <br>The memory timing shown in  Fig.   7.4   is for a CPU with a 50MHz clock and a memory <br>
with 50 ns maximum cycle time. The write cycle in part (a) shows three 20ns cycles:  <i>T</i> 1, <br>
<hr>
<A name=324></a><b>306    Chapter 7  Memory and Programmable Logic</b><br>
 <br><i>T</i> 2, and  <i>T</i> 3. For a write operation, the CPU must provide the address and input data to <br>the memory. This is done at the beginning of  <i>T </i> 1. (The two lines that cross each other in <br>the address and data waveforms designate a possible change in value of the multiple <br>lines.) The memory enable and the read/write signals must be activated after the signals <br>in the address lines are stable in order to avoid destroying data in other memory words. <br>The memory enable signal switches to the high level and the read/write signal switches <br>to the low level to indicate a write operation. The two control signals must stay active <br>for at least 50 ns. The address and data signals must remain stable for a short time after <br>the control signals are deactivated. At the completion of the third clock cycle, the mem-<br>ory write operation is completed and the CPU can access the memory again with the <br>next  <i>T </i> 1  cycle. <br>
 <br>The read cycle shown in  Fig.   7.4 (b) has an address for the memory provided by the <br>
CPU. The memoryenable and read/write signals must be in their high level for a read <br>operation. The memory places the data of the word selected by the address into the out-<br>put data lines within a 50ns interval (or less) from the time that the memory enable is <br>activated. The CPU can transfer the data into one of its internal registers during the <br>negative transition of  <i>T</i> 3. The next  <i>T</i> 1 cycle is available for another memory request. <br>
<b> <br>Types of Memories </b><br>
 <br>The mode of access of a memory system is determined by the type of components used. <br>In a randomaccess memory, the word locations may be thought of as being separated <br>in space, each word occupying one particular location. In a sequentialaccess memory, <br>the information stored in some medium is not immediately accessible, but is available <br>only at certain intervals of time. A magnetic disk or tape unit is of this type. Each <br>memory location passes the read and write heads in turn, but information is read out <br>only when the requested word has been reached. In a randomaccess memory, the access <br>time is always the same regardless of the particular location of the word. In a  sequential<br>access memory, the time it takes to access a word depends on the position of the word <br>with respect to the position of the read head; therefore, the access time is variable. <br>
 <br>Integrated circuit RAM units are available in two operating modes:  <i>static</i>   and <br>
 <br><i>dynamic</i> . Static RAM (SRAM) consists essentially of internal latches that store the <br>binary information. The stored information remains valid as long as power is applied to <br>the unit. Dynamic RAM (DRAM) stores the binary information in the form of electric <br>charges on capacitors provided inside the chip by MOS transistors. The stored charge <br>on the capacitors tends to discharge with time, and the capacitors must be periodically <br>recharged by  <i>refreshing</i>  the dynamic memory. Refreshing is done by cycling through the <br>words every few milliseconds to restore the decaying charge. DRAM offers reduced <br>power consumption and larger storage capacity in a single memory chip. SRAM is <br>easier to use and has shorter read and write cycles. <br>
 <br>Memory units that lose stored information when power is turned off are said to be <br>
 <br><i>volatile</i> . CMOS integrated circuit RAMs, both static and dynamic, are of this category, since <br>the binary cells need external power to maintain the stored information. In contrast, a <br>nonvolatile memory, such as magnetic disk, retains its stored information after the removal <br>
<hr>
<A name=325></a><b>Section 7.3  Memory Decoding    307</b><br>
of power. This type of memory is able to retain information because the data stored on <br>magnetic components are represented by the direction of magnetization, which is retained <br>after power is turned off. ROM is another nonvolatile memory. A nonvolatile memory <br>enables digital computers to store programs that will be needed again after the computer <br>is turned on. Programs and data that cannot be altered are stored in ROM, while other <br>large programs are maintained on magnetic disks. The latter programs are transferred into <br>the computer RAM as needed. Before the power is turned off, the binary information from <br>the computer RAM is transferred to the disk so that the information will be retained. <br>
<b> <br>7 . 3       M E M O R Y   D E C O D I N G </b><br>
 <br>In addition to requiring storage components in a memory unit, there is a need for decod-<br>ing circuits to select the memory word specified by the input address. In this section, we <br>present the internal construction of a RAM and demonstrate the operation of the <br>decoder. To be able to include the entire memory in one diagram, the memory unit <br>presented here has a small capacity of 16 bits, arranged in four words of 4 bits each. An <br>example of a twodimensional coincident decoding arrangement is presented to show a <br>more efficient decoding scheme that is used in large memories. We then give an example <br>of address multiplexing commonly used in DRAM integrated circuits. <br>
<b> <br>Internal Construction </b><br>
 <br>The internal construction of a RAM of  <i>m</i>  words and  <i>n</i>  bits per word consists of   <i>m </i>* <i>n</i> <br>binary storage cells and associated decoding circuits for selecting individual words. The <br>binary storage cell is the basic building block of a memory unit. The equivalent logic of <br>a binary cell that stores one bit of information is shown in  Fig.   7.5 . The storage part of <br>the cell is modeled by an  <i>SR</i>  latch with associated gates to form a  <i>D</i>  latch. Actually, the <br>
<i>Select</i><br>
<i>Select</i><br>
<i>S</i><br>
<i>Output</i><br>
<i>Input</i><br>
BC<br>
<i>Output</i><br>
<i>Input</i><br>
<i>R</i><br>
Read/Write<br>
Read/Write<br>
(a) Logic diagram<br>
(b) Block diagram<br>
<b> <br>FIGURE 7.5 <br> <br>Memory cell  </b><br>
<hr>
<A name=326></a><b>308    Chapter 7  Memory and Programmable Logic</b><br>
cell is an electronic circuit with four to six transistors. Nevertheless, it is possible and <br>convenient to model it in terms of logic symbols. A binary storage cell must be very small <br>in order to be able to pack as many cells as possible in the small area available in the <br>integrated circuit chip. The binary cell stores one bit in its internal latch. The select input <br>enables the cell for reading or writing, and the read/write input determines the operation <br>of the cell when it is selected. A 1 in the read/write input provides the read operation by <br>forming a path from the latch to the output terminal. A 0 in the read/write input provides <br>the write operation by forming a path from the input terminal to the latch. <br>
 <br>The logical construction of a small RAM is shown in  Fig.   7.6 . This RAM consists of <br>
four words of four bits each and has a total of 16 binary cells. The small blocks labeled <br>BC represent the binary cell with its three inputs and one output, as specified in <br> <br>Fig.  7.5 (b). A memory with four words needs two address lines. The two address inputs <br>go through a   2 * 4  decoder to select one of the four words. The decoder is enabled with <br>
Input data <br>
Word   0<br>
BC<br>
BC<br>
BC<br>
BC<br>
Address<br>inputs<br>
Word 1<br>
2<br>
 4<br>
BC<br>
BC<br>
BC<br>
BC<br>
decoder<br>
Word 2<br>
BC<br>
BC<br>
BC<br>
BC<br>
Memory<br>
<i>EN</i><br>
enable<br>
Word 3<br>
BC<br>
BC<br>
BC<br>
BC<br>
Read/Write<br>
Output data<br>
<b> <br>FIGURE 7.6 <br> <br>Diagram of a   4 </b>* <b>4   RAM  </b><br>
<hr>
<A name=327></a><b>Section 7.3  Memory Decoding    309</b><br>
the memoryenable input. When the memory enable is 0, all outputs of the decoder are <br>0 and none of the memory words are selected. With the memory select at 1, one of the <br>four words is selected, dictated by the value in the two address lines. Once a word has <br>been selected, the read/write input determines the operation. During the read opera-<br>tion, the four bits of the selected word go through OR gates to the output terminals. <br>(Note that the OR gates are drawn according to the array logic established in  Fig.   7.1 .) <br>During the write operation, the data available in the input lines are transferred into the <br>four binary cells of the selected word. The binary cells that are not selected are disabled, <br>and their previous binary values remain unchanged. When the memory select input that <br>goes into the decoder is equal to 0, none of the words are selected and the contents of <br>all cells remain unchanged regardless of the value of the read/write input. <br>
 <br>Commercial RAMs may have a capacity of thousands of words, and each word may <br>
range from 1 to 64 bits. The logical construction of a largecapacity memory would be a <br>direct extension of the configuration shown here. A memory with   2<i>k</i>     words  of   <i>n</i>  bits per <br>word requires  <i>k</i>  address lines that go into a   <i>k </i>* 2<i>k</i>  decoder. Each one of the decoder <br>outputs selects one word of  <i>n</i>  bits for reading or writing. <b> </b><br>
<b> <br>Coincident Decoding </b><br>
 <br>A decoder with  <i>k</i>  inputs and   2<i>k</i>     outputs  requires     2<i>k</i>     AND  gates  with   <i>k</i>  inputs per gate. <br>The total number of gates and the number of inputs per gate can be reduced by <br>employing two decoders in a twodimensional selection scheme. The basic idea in <br>twodimensional decoding is to arrange the memory cells in an array that is close as <br>possible to square. In this configuration, two  <i>k</i> /2input decoders are used instead of <br>one  <i>k</i> input decoder. One decoder performs the row selection and the other the col-<br>umn selection in a twodimensional matrix configuration. <br>
 <br>The twodimensional selection pattern is demonstrated in  Fig.   7.7   for a 1Kword <br>
memory. Instead of using a single   10 * 1,024  decoder,     we  use  two     5 * 32  decoders.    <br>With the single decoder, we would need 1,024 AND gates with 10 inputs in each. In the <br>twodecoder case, we need 64 AND gates with 5 inputs in each. The five most significant <br>bits of the address go to input  <i>X</i>  and the five least significant bits go to input  <i>Y.</i>   Each <br>word within the memory array is selected by the coincidence of one  <i>X</i>  line and one  <i>Y</i> <br>line. Thus, each word in memory is selected by the coincidence between 1 of 32 rows and <br>1 of 32 columns, for a total of 1,024 words. Note that each intersection represents a word <br>that may have any number of bits. <br>
 <br>As an example, consider the word whose address is 404. The 10bit binary equivalent <br>
of 404 is 01100 10100. This makes   <i>X </i>= 01100     (binary  12)  and     <i>Y </i>= 10100     (binary  20). <br>The  <i>n</i> bit word that is selected lies in the  <i>X</i>  decoder output number 12 and the  <i>Y</i>   decoder <br>output number 20. All the bits of the word are selected for reading or writing. <br>
<b> <br>Address Multiplexing </b><br>
 <br>The SRAM memory cell modeled in  Fig.   7.5   typically contains six transistors. In order to <br>build memories with higher density, it is necessary to reduce the number of transistors in <br>a cell. The DRAM cell contains a single MOS transistor and a capacitor. The charge stored <br>
<hr>
<A name=328></a><b>310    Chapter 7  Memory and Programmable Logic</b><br>
<i>Y</i><br>
5<br>
 32 decoder<br>
0<br>
1<br>
2 . . . . 20 .<br>
.<br>
. 31<br>
0<br>
1<br>
2<br>
.<br>
binary address<br>
.<br>
5<br>
 32<br>
01100<br>
10100<br>
<i>X</i><br>
.<br>
 decoder<br>
<i>X</i><br>
<i>Y</i><br>
12<br>
.<br>.<br>.<br>
31<br>
<b> <br>FIGURE 7.7 <br> <br>Twodimensional decoding structure for a 1Kword memory  </b><br>
on the capacitor discharges with time, and the memory cells must be periodically recharged <br>by refreshing the memory. Because of their simple cell structure, DRAMs typically have <br>four times the density of SRAMs. This allows four times as much memory capacity to be <br>placed on a given size of chip. The cost per bit of DRAM storage is three to four times <br>less than that of SRAM storage. A further cost savings is realized because of the lower <br>power requirement of DRAM cells. These advantages make DRAM the preferred tech-<br>nology for large memories in personal digital computers. DRAM chips are available in <br>capacities from 64K to 256M bits. Most DRAMs have a 1bit word size, so several chips <br>have to be combined to produce a larger word size. <br>
 <br>Because of their large capacity, the address decoding of DRAMs is arranged in a <br>
twodimensional array, and larger memories often have multiple arrays. To reduce the <br>number of pins in the IC package, designers utilize address multiplexing whereby one <br>set of address input pins accommodates the address components. In a twodimensional <br>array, the address is applied in two parts at different times, with the row address first and <br>the column address second. Since the same set of pins is used for both parts of the <br>address, the size of the package is decreased significantly. <br>
 <br>We will use a 64Kword memory to illustrate the addressmultiplexing idea. <br>
A  diagram of the decoding configuration is shown in  Fig.   7.8 . The memory consists of <br>
<hr>
<A name=329></a><b>Section 7.3  Memory Decoding    311</b><br>
8-bit column<br>
<i>CAS</i><br>
register<br>
8<br>
 256<br>
decoder<br>
<i>RAS</i><br>
8-bit<br>
256<br>
 256<br>
8-bit<br>
8<br>
 256<br>
 row<br>
memory<br>
Read/Write<br>
address<br>
decoder<br>
register<br>
cell array<br>
Data<br>
Data<br>
in<br>
out<br>
<b> <br>FIGURE 7.8 <br> <br>Address multiplexing for a 64K DRAM  </b><br>
a twodimensional array of cells arranged into 256 rows by 256 columns, for a total of <br> <br>28 * 28 = 216 = 64K  words. There is a single data input line, a single data output line, <br>and a read/write control, as well as an eightbit address input and two address  <i>strobes,</i> <br>the latter included for enabling the row and column address into their respective regis-<br>ters. The row address strobe (RAS) enables the eightbit row register, and the column <br>address strobe (CAS) enables the eightbit column register. The bar on top of the name <br>of the strobe symbol indicates that the registers are enabled on the zero level of the <br>signal. <br>
 <br>The 16bit address is applied to the DRAM in two steps using RAS and CAS. Initially, <br>
both strobes are in the 1 state. The 8bit row address is applied to the address inputs and <br>RAS is changed to 0. This loads the row address into the row address register. RAS also <br>enables the row decoder so that it can decode the row address and select one row of the <br>array. After a time equivalent to the settling time of the row selection, RAS goes back <br>to the 1 level. The 8bit column address is then applied to the address inputs, and CAS <br>is driven to the 0 state. This transfers the column address into the column register and <br>
<hr>
<A name=330></a><b>312    Chapter 7  Memory and Programmable Logic</b><br>
enables the column decoder. Now the two parts of the address are in their respective <br>registers, the decoders have decoded them to select the one cell corresponding to the <br>row and column address, and a read or write operation can be performed on that cell. <br>CAS must go back to the 1 level before initiating another memory operation. <br>
<b> <br>7 . 4       E R R O R   D E T E C T I O N   A N D   C O R R E C T I O N </b><br>
 <br>The dynamic physical interaction of the electrical signals affecting the data path of a <br>memory unit may cause occasional errors in storing and retrieving the binary informa-<br>tion. The reliability of a memory unit may be improved by employing errordetecting <br>and errorcorrecting codes. The most common error detection scheme is the parity bit. <br>(See Section 3.9.) A parity bit is generated and stored along with the data word in <br>memory. The parity of the word is checked after reading it from memory. The data word <br>is accepted if the parity of the bits read out is correct. If the parity checked results in an <br>inversion, an error is detected, but it cannot be corrected. <br>
 <br>An errorcorrecting code generates multiple parity check bits that are stored with <br>
the data word in memory. Each check bit is a parity over a group of bits in the data <br>word. When the word is read back from memory, the associated parity bits are also <br>read from memory and compared with a new set of check bits generated from the data <br>that have been read. If the check bits are correct, no error has occurred. If the check <br>bits do not match the stored parity, they generate a unique pattern, called a  <i>syndrome</i>,  <br>that can be used to identify the bit that is in error. A single error occurs when a bit <br>changes in value from 1 to 0 or from 0 to 1 during the write or read operation. If the <br>specific bit in error is identified, then the error can be corrected by complementing <br>the erroneous bit. <br>
<b> <br>Hamming Code </b><br>
 <br>One of the most common errorcorrecting codes used in RAMs was devised by R. W. <br>Hamming. In the Hamming code,  <i>k</i>  parity bits are added to an  <i>n</i> bit data word, forming <br>a new word of   <i>n </i>+ <i>k</i>  bits. The bit positions are numbered in sequence from 1 to   <i>n </i>+ <i>k</i>.    <br>Those positions numbered as a power of 2 are reserved for the parity bits. The remain-<br>ing bits are the data bits. The code can be used with words of any length. Before giving <br>the general characteristics of the code, we will illustrate its operation with a data word <br>of eight bits. <br>
 <br>Consider, for example, the 8bit data word 11000100. We  include 4 parity bits with <br>
the 8bit word and arrange the 12 bits as follows: <br>
 Bit  position: <br>
   1 <br>
   2 <br>
 3 <br>
   4 <br>
 5 <br>
 6 <br>
 7 <br>
   8 <br>
 9 <br>
 10 <br>
 11 <br>
 12 <br>
 <br>
 <br><i>P</i>1 <br>
 <br><i>P</i>2 <br>
 <br>1 <br>
 <br><i>P</i>4 <br>
 <br>1 <br>
 <br>0 <br>
 <br>0 <br>
 <br><i>P</i>8    <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
<hr>
<A name=331></a><b>Section 7.4  Error Detection and Correction    313</b><br>
 <br>The 4 parity bits,   <i>P</i>1, <i>P</i>2, <i>P</i>4,     and     <i>P</i>8,  are in positions 1, 2, 4, and 8, respectively. The 8 bits <br>of the data word are in the remaining positions. Each parity bit is calculated as follows: <br>
 <br><i>P</i>1 = XOR of bits (3, 5, 7, 9, 11) = 1 { 1 { 0 { 0 { 0 = 0<br>
 <br><i>P</i>2 = XOR of bits (3, 5, 7, 10, 11) = 1 { 0 { 0 { 1 { 0 = 0<br>
 <br><i>P</i>4 = XOR of bits (5, 6, 7, 12)  =  1 { 0 { 0 { 0 = 1<br>
 <br><i>P</i>8 = XOR of bits (9, 10, 11, 12) = 0 { 1 { 0 { 0 = 1<br>
 <br>
 <br>Remember that the exclusiveOR operation performs the odd function: It is equal to 1 <br>for an odd number of 1's in the variables and to 0 for an even number of 1's. Thus, each <br>parity bit is set so that the total number of 1's in the checked positions, including the <br>parity bit, is always even. <br>
 <br>The 8bit data word is stored in memory together with the 4 parity bits as a 12bit <br>
composite word. Substituting the 4  <i>P</i>  bits in their proper positions, we obtain the 12bit <br>composite word stored in memory: <br>
  <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 Bit  position: <br>
 1 <br>
 2 <br>
 3 <br>
 4 <br>
 5 <br>
 6 <br>
 7 <br>
 8 <br>
 9 <br>
 10 <br>
 11 <br>
 12 <br>
 <br>When the 12 bits are read from memory, they are checked again for errors. The parity is <br>checked over the same combination of bits, including the parity bit. The 4 check bits are <br>evaluated as follows: <br>
 <br><i>C</i>1 = XOR of bits (1, 3, 5, 7, 9, 11)<br>
 <br><i>C</i>2 = XOR of bits (2, 3, 6, 7, 10, 11)<br>
 <br><i>C</i>4 = XOR of bits (4, 5, 6, 7, 12)<br>
 <br><i>C</i>8 = XOR of bits (8, 9, 10, 11, 12)  <br>
 <br>A 0 check bit designates even parity over the checked bits and a 1 designates odd parity. <br>Since the bits were stored with even parity, the result,   <i>C </i>= <i>C</i>8<i>C</i>4<i>C</i>2<i>C</i>1 = 0000,     indicates <br>that no error has occurred. However, if   <i>C</i><br>
0,  then the 4bit binary number formed by <br>
the check bits gives the position of the erroneous bit. For example, consider the following <br>three cases: <br>
 Bit  position: <br>
 1 <br>
 2 <br>
 3 <br>
 4 <br>
 5 <br>
 6 <br>
 7 <br>
 8 <br>
 9 <br>
 10 <br>
 11 <br>
 12 <br>
  <br>
  <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 No  error <br>
  <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 Error  in  bit  1 <br>
  <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 Error  in  bit  5 <br>
 <br>In the first case, there is no error in the 12bit word. In the second case, there is an <br>error in bit position number 1 because it changed from 0 to 1. The third case shows <br>
<hr>
<A name=332></a><b>314    Chapter 7  Memory and Programmable Logic</b><br>
an error in bit position 5, with a change from 1 to 0. Evaluating the XOR of the corre-<br>sponding bits, we determine the 4 check bits to be as follows: <br>
 <br>
 <br><i>C</i>8 <br>
 <br><i>C</i>4 <br>
 <br><i>C</i>2 <br>
 <br><i>C</i>1 <br>
 For  no  error: <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 With  error  in  bit  1: <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 With  error  in  bit  5: <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 <br>Thus, for no error, we have   <i>C </i>= 0000;     with an error in bit 1, we obtain   <i>C </i>= 0001;     and with <br>an error in bit 5, we get   <i>C </i>= 0101.     When the binary number  <i>C</i>  is not equal to 0000, it gives <br>the position of the bit in error. The error can be corrected by complementing the corre-<br>sponding bit. Note that an error can occur in the data word or in one of the parity bits. <br>
 <br>The Hamming code can be used for data words of any length. In general, the Ham-<br>
ming code consists of  <i>k</i>  check bits and  <i>n</i>  data bits, for a total of   <i>n </i>+ <i>k</i>     bits. The  syndrome <br>value  <i>C</i>  consists of  <i>k</i>  bits and has a range of   2<i>k</i>  values between 0 and   2<i>k </i>- 1.     One  of <br>these values, usually zero, is used to indicate that no error was detected, leaving   2<i>k </i>- 1    <br>values to indicate which of the   <i>n </i>+ <i>k</i>  bits was in error. Each of these   2<i>k </i>- 1     values  can <br>be used to uniquely describe a bit in error. Therefore, the range of  <i>k</i>  must be equal to <br>or greater than   <i>n </i>+ <i>k</i>,     giving  the  relationship <br>
 <br>2<i>k </i>- 1 � <i>n </i>+ <i>k</i> <br>
 <br>Solving for  <i>n</i>  in terms of  <i>k,</i>  we obtain <br>
 <br>2<i>k </i>- 1 - <i>k </i>� <i>n</i> <br>
 <br>This relationship gives a formula for establishing the number of data bits that can be <br>used in conjunction with  <i>k</i>  check bits. For example, when   <i>k </i>= 3,  the number of data bits <br>that can be used is   <i>n </i>... (23 - 1 - 3) = 4. For  <i>k </i>= 4,     we  have     24 - 1 - 4 = 11,     giving <br> <br><i>n </i>... 11. The data word may be less than 11 bits, but must have at least 5 bits; otherwise, <br>only 3 check bits will be needed. This justifies the use of 4 check bits for the 8 data bits <br>in the previous example. Ranges of  <i>n</i>  for various values of  <i>k</i>   are  listed  in   Table    7.2   . <br>
 <br>The grouping of bits for parity generation and checking can be determined from a <br>
list of the binary numbers from 0 through   2<i>k </i>- 1. The least significant bit is a 1 in the <br>binary numbers 1, 3, 5, 7, and so on. The second significant bit is a 1 in the binary numbers <br>
<b> <br>Table 7.2 <br><i> <br>Range of Data Bits for k Check Bits </b></i><br>
<i> <br></i><b>Number of Check Bits,  <i>k</i> </b><br>
<i> <br></i><b>Range of Data Bits,  <i>n</i> </b><br>
 3 <br>
 2�4 <br>
 4 <br>
 5�11 <br>
 5 <br>
 12�26 <br>
 6 <br>
 27�57 <br>
 7 <br>
 58�120 <br>
<hr>
<A name=333></a><b>Section 7.5  ReadOnly Memory    315</b><br>
2, 3, 6, 7, and so on. Comparing these numbers with the bit positions used in generating <br>and checking parity bits in the Hamming code, we note the relationship between the bit <br>groupings in the code and the position of the 1bits in the binary count sequence. Note <br>that each group of bits starts with a number that is a power of 2: 1, 2, 4, 8, 16, etc. These <br>numbers are also the position numbers for the parity bits. <br>
<b> <br>SingleError Correction, DoubleError Detection </b><br>
 <br>The Hamming code can detect and correct only a single error. By adding another parity <br>bit to the coded word, the Hamming code can be used to correct a single error and detect <br>double errors. If we include this additional parity bit, then the previous 12bit coded <br>word becomes   001110010100<i>P</i>13,     where     <i>P</i>13  is evaluated from the exclusiveOR of the <br>other 12 bits. This produces the 13bit word 0011100101001 (even parity). When the <br>13bit word is read from memory, the check bits are evaluated, as is the parity  <i>P</i>   over <br>the entire 13 bits. If   <i>P </i>= 0,  the parity is correct (even parity), but if   <i>P </i>= 1,     then  the <br>parity over the 13 bits is incorrect (odd parity). The following four cases can arise: <b> </b><br>
 <br>
  If  <i>C </i>= 0     and     <i>P </i>= 0,     no  error  occurred.  <br>
 <br>
  If  <i>C</i><br>
0     and     <i>P </i>= 1,  a single error occurred that can be corrected. <br>
 <br>
  If  <i>C</i><br>
0     and     <i>P </i>= 0,  a double error occurred that is detected, but that cannot be <br>
corrected.  <br>
 <br>
  If  <i>C </i>= 0     and     <i>P </i>= 1,  an error occurred in the   <i>P</i>13     bit.   <br>
 <br>This scheme may detect more than two errors, but is not guaranteed to detect all such <br>errors. <br>
 <br>Integrated circuits use a modified Hamming code to generate and check parity bits <br>
for singleerror correction and doubleerror detection. The modified Hamming code <br>uses a more efficient parity configuration that balances the number of bits used to cal-<br>culate the XOR operation. A typical integrated circuit that uses an 8bit data word and <br>a 5bit check word is IC type 74637. Other integrated circuits are available for data words <br>of 16 and 32 bits. These circuits can be used in conjunction with a memory unit to correct <br>a single error or detect double errors during write and read operations. <br>
<b> <br>7 . 5       R E A D  O N L Y   M E M O R Y </b><br>
 <br>A readonly memory (ROM) is essentially a memory device in which permanent binary <br>information is stored. The binary information must be specified by the designer and is <br>then embedded in the unit to form the required interconnection pattern. Once the pat-<br>tern is established, it stays within the unit even when power is turned off and on again. <br>
 <br>A block diagram of a ROM consisting of  <i>k</i>  inputs and  <i>n</i>   outputs  is  shown  in   Fig.    7.9   . <br>
The inputs provide the address for memory, and the outputs give the data bits of the <br>stored word that is selected by the address. The number of words in a ROM is deter-<br>mined from the fact that  <i>k</i>  address input lines are needed to specify   2<i>k</i>     words.  Note  that <br>ROM does not have data inputs, because it does not have a write operation. Integrated <br>
<hr>
<A name=334></a><b>316    Chapter 7  Memory and Programmable Logic</b><br>
2<i>k</i><br>
<i>n</i><br>
<i>k </i>inputs (address)<br>
<i>n </i>outputs (data)<br>
ROM<br>
<b> <br>FIGURE 7.9 <br> <br>ROM block diagram  </b><br>
circuit ROM chips have one or more enable inputs and sometimes come with threestate <br>outputs to facilitate the construction of large arrays of ROM. <br>
 Consider,  for  example,  a     32 * 8  ROM. The unit consists of 32 words of 8 bits each. <br>
There are five input lines that form the binary numbers from 0 through 31 for the <br>address.  Figure   7.10   shows the internal logic construction of this ROM. The five inputs <br>are decoded into 32 distinct outputs by means of a   5 * 32  decoder. Each output of the <br>decoder represents a memory address. The 32 outputs of the decoder are connected to <br>each of the eight OR gates. The diagram shows the array logic convention used in com-<br>plex circuits. (See Fig. 6.1.) Each OR gate must be considered as having 32 inputs. Each <br>output of the decoder is connected to one of the inputs of each OR gate. Since each OR <br>gate has 32 input connections and there are 8 OR gates, the ROM contains   32 * 8 = 256    <br>internal connections. In general, a   2<i>k </i>* <i>n</i>  ROM will have an internal   <i>k </i>* 2<i>k</i>     decoder <br>and  <i>n</i>  OR gates. Each OR gate has   2<i>k</i>  inputs, which are connected to each of the outputs <br>of the decoder. <br>
0<br>
1<br>
<i>I</i>0<br>
2<br>
<i>I</i>1<br>
3.<br>
5<br>
 32<br>
<i>I</i>2<br>
.<br>
decoder<br>
.<br>
<i>I</i>3<br>
28<br>
<i>I</i><br>
29<br>
4<br>
30<br>
31<br>
<i>A</i>7<br>
<i>A</i>6<br>
<i>A</i>5<br>
<i>A</i>4<br>
<i>A</i>3<br>
<i>A</i>2<br>
<i>A</i>1<br>
<i>A</i>0<br>
<b> <br>FIGURE 7.10 <br> <br>Internal logic of a   32 </b>: <b>8   ROM  </b><br>
<hr>
<A name=335></a><b>Section 7.5  ReadOnly Memory    317</b><br>
 <br>The 256 intersections in  Fig.   7.10   are programmable. A programmable connection <br>
between two lines is logically equivalent to a switch that can be altered to be either <br>closed (meaning that the two lines are connected) or open (meaning that the two <br>lines are disconnected). The programmable intersection between two lines is some-<br>times called a  <i>crosspoint</i> . Various physical devices are used to implement crosspoint <br>switches. One of the simplest technologies employs a fuse that normally connects the <br>two points, but is opened or "blown" by the application of a highvoltage pulse into <br>the fuse. <br>
 <br>The internal binary storage of a ROM is specified by a truth table that shows the <br>
word content in each address. For example, the content of a   32 * 8     ROM  may  be <br>specified with a truth table similar to the one shown in  Table   7.3  . The truth table shows <br>the five inputs under which are listed all 32 addresses. Each address stores a word of <br>8 bits, which is listed in the outputs columns. The table shows only the first four and <br>the last four words in the ROM. The complete table must include the list of all <br>32 words. <br>
 <br>The hardware procedure that programs the ROM blows fuse links in accordance with <br>
a given truth table. For example, programming the ROM according to the truth table <br>given by  Table   7.3   results in the configuration shown in  Fig.   7.11 . Every 0 listed in the <br>truth table specifies the absence of a connection, and every 1 listed specifies a path that <br>is obtained by a connection. For example, the table specifies the eightbit word 10110010 <br>for permanent storage at address 3. The four 0's in the word are programmed by blowing <br>the fuse links between output 3 of the decoder and the inputs of the OR gates associated <br>with outputs   <i>A</i>6, <i>A</i>3, <i>A</i>2,     and     <i>A</i>0. The four 1's in the word are marked with a   *     to  denote <br>a temporary connection, in place of a dot used for a permanent connection in logic <br>diagrams. When the input of the ROM is 00011, all the outputs of the decoder are 0 <br>except for output 3, which is at logic 1. The signal equivalent to logic 1 at decoder output <br>3 propagates through the connections to the OR gate outputs of   <i>A</i>7, <i>A</i>5, <i>A</i>4,     and     <i>A</i>1.     The <br>other four outputs remain at 0. The result is that the stored word 10110010 is applied to <br>the eight data outputs. <b> </b><br>
<b> <br>Table 7.3 <br><i> <br>ROM Truth Table (Partial) </b></i><br>
<i> <br></i><b>Inputs</b><i> </i><br>
<i> <br></i><b>Outputs</b><i> </i><br>
<i> <br><b>I</i> 4 </b><br>
<i> <br><b>I</i> 3 </b><br>
<i> <br><b>I</i> 2 </b><br>
<i> <br><b>I</i> 1 </b><br>
<i> <br><b>I</i> 0 </b><br>
<i> <br><b>A</i> 7 </b><br>
<i> <br><b>A</i> 6 </b><br>
<i> <br><b>A</i> 5 </b><br>
<i> <br><b>A</i> 4 </b><br>
<i> <br><b>A</i> 3 </b><br>
<i> <br><b>A</i> 2 </b><br>
<i> <br><b>A</i> 1 </b><br>
<i> <br><b>A</i> 0 </b><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 <br>
 <br>
 <br>f <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>f <br>
 <br>
 <br>
 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
<hr>
<A name=336></a><b>318    Chapter 7  Memory and Programmable Logic</b><br>
0<br>
1<br>
<i>I</i>0<br>
2<br>
<i>I</i>1<br>
3.<br>
5<br>
 32<br>
<i>I</i>2<br>
.<br>
decoder<br>
.<br>
<i>I</i>3<br>
28<br>
<i>I</i><br>
29<br>
4<br>
30<br>
31<br>
<i>A</i>7<br>
<i>A</i>6<br>
<i>A</i>5<br>
<i>A</i>4<br>
<i>A</i>3<br>
<i>A</i>2<br>
<i>A</i>1<br>
<i>A</i>0<br>
<b> <br>FIGURE 7.11 <br> <br>Programming the ROM according to  Table   7.3  </b><br>
<b> <br>Combinational Circuit Implementation </b><br>
 <br>In Section 4.9, it was shown that a decoder generates the   2<i>k</i>  minterms of the  <i>k</i>   input <br>variables. By inserting OR gates to sum the minterms of Boolean functions, we were <br>able to generate any desired combinational circuit. The ROM is essentially a device that <br>includes both the decoder and the OR gates within a single device to form a minterm <br>generator. By choosing connections for those minterms which are included in the func-<br>tion, the ROM outputs can be programmed to represent the Boolean functions of the <br>output variables in a combinational circuit. <br>
 <br>The internal operation of a ROM can be interpreted in two ways. The first interpreta-<br>
tion is that of a memory unit that contains a fixed pattern of stored words. The second <br>interpretation is that of a unit which implements a combinational circuit. From this point <br>of view, each output terminal is considered separately as the output of a Boolean func-<br>tion expressed as a sum of minterms. For example, the ROM of  Fig.   7.11   may be consid-<br>ered to be a combinational circuit with eight outputs, each a function of the five input <br>variables. Output   <i>A</i>7  can be expressed in sum of minterms as <br>
 <i>A</i>7(<i>I</i>4, <i>I</i>3, <i>I</i>2, <i>I</i>1, <i>I</i>0) =<br>
(0, 2, 3, c, 29)   <br>
 <br>(The three dots represent minterms 4 through 27, which are not specified in the figure.) <br>A connection marked with   *  in the figure produces a minterm for the sum. All other <br>crosspoints are not connected and are not included in the sum. <br>
 <br>In practice, when a combinational circuit is designed by means of a ROM, it is not <br>
necessary to design the logic or to show the internal gate connections inside the unit. All <br>that the designer has to do is specify the particular ROM by its IC number and provide <br>the applicable truth table. The truth table gives all the information for programming the <br>ROM. No internal logic diagram is needed to accompany the truth table. <br>
<hr>
<A name=337></a><b>Section 7.5  ReadOnly Memory    319</b><br>
<b> <br>EXAMPLE 7.1 </b><br>
 <br>Design a combinational circuit using a ROM. The circuit accepts a threebit number and <br>outputs a binary number equal to the square of the input number. <br>
 <br>The first step is to derive the truth table of the combinational circuit. In most cases, <br>
this is all that is needed. In other cases, we can use a partial truth table for the ROM by <br>utilizing certain properties in the output variables.  Table   7.4   is the truth table for the <br>combinational circuit. Three inputs and six outputs are needed to accommodate all <br>possible binary numbers. We note that output   <i>B</i>0  is always equal to input   <i>A</i>0,     so  there <br>is no need to generate   <i>B</i>0  with a ROM, since it is equal to an input variable. Moreover, <br>output     <i>B</i>1  is always 0, so this output is a known constant. We actually need to generate <br>only four outputs with the ROM; the other two are readily obtained. The minimum size <br>of ROM needed must have three inputs and four outputs. Three inputs specify eight <br>words, so the ROM must be of size   8 * 4. The ROM implementation is shown in <br> <br>Fig.   7.12  . The three inputs specify eight words of four bits each. The truth table in <br> <br>Fig.  7.12  (b) specifies the information needed for programming the ROM. The block <br>diagram of  Fig.   7.12  (a) shows the required connections of the combinational circuit.<br>
<b> <br>Table 7.4 <br><i> <br>Truth Table for Circuit of Example 7.1 </b></i><br>
<i> <br></i><b>Inputs</b><i> </i><br>
<i> <br></i><b>Outputs</b><i> </i><br>
<i> </i><br>
<i> <br><b>A</i> 2 </b><br>
<i> <br><b>A</i> 1 </b><br>
<i> <br><b>A</i> 0 </b><br>
<i> <br><b>B  </i>5 </b><br>
<i> <br><b>B</i> 4 </b><br>
<i> <br><b>B</i> 3 </b><br>
<i> <br><b>B</i> 2 </b><br>
<i> <br><b>B</i> 1 </b><br>
<i> <br><b>B</i> 0 </b><br>
<i> <br></i><b>Decimal</b><i> </i><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
   0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
   1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
   4 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
   9 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 16 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 25 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 36 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 49 <br>
<i>B</i>0<br>
<i>A</i>2 <i>A</i>1 <i>A</i>0 <i>B</i>5 <i>B</i>4 <i>B</i>3 <i>B</i>2<br>
0<br>
<i>B</i>1<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
1<br>
0<br>
0<br>
0<br>
0<br>
<i>B</i>2<br>
0<br>
1<br>
0<br>
0<br>
0<br>
0<br>
1<br>
<i>A</i>0<br>
<i>B</i><br>
0<br>
1<br>
1<br>
0<br>
0<br>
1<br>
0<br>
3<br>
<i>A</i><br>
1<br>
0<br>
0<br>
0<br>
1<br>
0<br>
0<br>
1<br>
8<br>
 4 ROM<br>
<i>B</i><br>
1<br>
0<br>
1<br>
0<br>
1<br>
1<br>
0<br>
4<br>
<i>A</i><br>
1<br>
1<br>
0<br>
1<br>
0<br>
0<br>
1<br>
2<br>
<i>B</i>5<br>
1<br>
1<br>
1<br>
1<br>
1<br>
0<br>
0<br>
(a) Block diagram<br>
(b) ROM truth table<br>
<b> <br>FIGURE 7.12   <br> <br>ROM implementation of Example 7.1  </b><br>
 <br>
<hr>
<A name=338></a><b>320    Chapter 7  Memory and Programmable Logic</b><br>
<b> <br>Types of ROMs </b><br>
 <br>The required paths in a ROM may be programmed in four different ways. The first <br>is called  <i>mask programming</i>  and is done by the semiconductor company during the <br>last fabrication process of the unit. The procedure for fabricating a ROM requires <br>that the customer fill out the truth table he or she wishes the ROM to satisfy. The <br>truth table may be submitted in a special form provided by the manufacturer or in <br>a specified format on a computer output medium. The manufacturer makes the cor-<br>responding mask for the paths to produce the 1's and 0's according to the customer's <br>truth table. This procedure is costly because the vendor charges the customer a <br>special fee for custom masking the particular ROM. For this reason, mask program-<br>ming is economical only if a large quantity of the same ROM configuration is to be <br>ordered. <br>
 <br>For small quantities, it is more economical to use a second type of ROM called  <i>pro-</i><br>
<i>grammable readonly memory,</i>  or PROM. When ordered, PROM units contain all the <br>fuses intact, giving all 1's in the bits of the stored words. The fuses in the PROM are <br>blown by the application of a highvoltage pulse to the device through a special pin. <br>A blown fuse defines a binary 0 state and an intact fuse gives a binary 1 state. This pro-<br>cedure allows the user to program the PROM in the laboratory to achieve the desired <br>relationship between input addresses and stored words. Special instruments called <br>PROM programmers are available commercially to facilitate the procedure. In any case, <br>all procedures for programming ROMs are hardware procedures, even though the word <br> <br><i>programming</i>  is used. <br>
 <br>The hardware procedure for programming ROMs or PROMs is irreversible, and once <br>
programmed, the fixed pattern is permanent and cannot be altered. Once a bit pattern <br>has been established, the unit must be discarded if the bit pattern is to be changed. A <br>third type of ROM is the  <i>erasable PROM,</i>  or EPROM, which can be restructured to the <br>initial state even though it has been programmed previously. When the EPROM is <br>placed under a special ultraviolet light for a given length of time, the shortwave radiation <br>discharges the internal floating gates that serve as the programmed connections. After <br>erasure, the EPROM returns to its initial state and can be reprogrammed to a new set <br>of values. <br>
 <br>The fourth type of ROM is the electrically erasable PROM (EEPROM or   E2PROM ). <br>
This device is like the EPROM, except that the previously programmed connections can <br>be erased with an electrical signal instead of ultraviolet light. The advantage is that the <br>device can be erased without removing it from its socket. <br>
 <br>Flash memory devices are similar to EEPROMs, but have additional builtin circuitry <br>
to selectively program and erase the device incircuit, without the need for a special <br>programmer. They have widespread application in modern technology in cell phones, <br>digital cameras, settop boxes, digital TV, telecommunications, nonvolatile data storage, <br>and microcontrollers. Their low consumption of power makes them an attractive storage <br>medium for laptop and notebook computers. Flash memories incorporate additional <br>circuitry, too, allowing simultaneous erasing of blocks of memory, for example, of size <br>16 to 64 K bytes. Like EEPROMs, flash memories are subject to fatigue, typically having <br>about     105     block  erase  cycles.  <br>
<hr>
<A name=339></a><b>Section 7.6  Programmable Logic Array    321</b><br>
Fixed<br>
<i>Inputs</i><br>
programmable<br>
AND array<br>
<i>Outputs</i><br>
OR array<br>
(decoder)<br>
(a) Programmable read-only memory (PROM)<br>
<i>Inputs</i><br>
programmable<br>
Fixed<br>
<i>Outputs</i><br>
AND array<br>
OR array<br>
(b) Programmable array logic (PAL)<br>
<i>Inputs</i><br>
programmable<br>
programmable<br>
<i>Outputs</i><br>
AND array<br>
OR array<br>
(c) Programmable logic array (PLA)<br>
<b> <br>FIGURE 7.13   <br> <br>Basic configuration of three PLDs  </b><br>
<b> <br>Combinational PLDs </b><br>
 <br>The PROM is a combinational programmable logic device (PLD)--an integrated circuit <br>with programmable gates divided into an AND array and an OR array to provide an <br>AND�OR sumofproduct implementation. There are three major types of combina-<br>tional PLDs, differing in the placement of the programmable connections in the AND�<br>OR array.  Figure   7.13   shows the configuration of the three PLDs. The PROM has a fixed <br>AND array constructed as a decoder and a programmable OR array. The programmable <br>OR gates implement the Boolean functions in sumofminterms form. The PAL has a <br>programmable AND array and a fixed OR array. The AND gates are programmed to <br>provide the product terms for the Boolean functions, which are logically summed in each <br>OR gate. The most flexible PLD is the PLA, in which both the AND and OR arrays can <br>be programmed. The product terms in the AND array may be shared by any OR gate <br>to provide the required sumofproducts implementation. The names PAL and PLA <br>emerged from different vendors during the development of PLDs. The implementation <br>of combinational circuits with PROM was demonstrated in this section. The design of <br>combinational circuits with PLA and PAL is presented in the next two sections. <b> </b><br>
<b> <br>7 . 6       P R O G R A M M A B L E   L O G I C   A R R AY </b><br>
 <br>The PLA is similar in concept to the PROM, except that the PLA does not provide full <br>decoding of the variables and does not generate all the minterms. The decoder is <br>replaced by an array of AND gates that can be programmed to generate any product <br>
<hr>
<A name=340></a><b>322    Chapter 7  Memory and Programmable Logic</b><br>
term of the input variables. The product terms are then connected to OR gates to pro-<br>vide the sum of products for the required Boolean functions. <br>
 <br>The internal logic of a PLA with three inputs and two outputs is shown in  Fig.   7.14 . <br>
Such a circuit is too small to be useful commercially, but is presented here to demonstrate <br>the typical logic configuration of a PLA. The diagram uses the array logic graphic symbols <br>for complex circuits. Each input goes through a buffer�inverter combination, shown in the <br>diagram with a composite graphic symbol, that has both the true and complement outputs. <br>Each input and its complement are connected to the inputs of each AND gate, as indicated <br>by the intersections between the vertical and horizontal lines. The outputs of the AND <br>gates are connected to the inputs of each OR gate. The output of the OR gate goes to an <br>XOR gate, where the other input can be programmed to receive a signal equal to either <br>logic 1 or logic 0. The output is inverted when the XOR input is connected to 1 (since <br> <i>x </i>{ 1 = <i>x </i> ). The output does not change when the XOR input is connected to 0 (since <br> <i>x </i>{ 0 = <i>x</i> ). The particular Boolean functions implemented in the PLA of  Fig.   7.14  are <br>
 <br><i>F</i>1 = <i>AB </i>+ <i>AC </i>+ <i>A BC<br></i> <br><i>F</i>2 = (<i>AC </i>+ <i>BC</i>)<br>
 <br>
<i>A</i><br>
<i>B</i><br>
<i>C</i><br>
1<br>
<i>AB</i><br>
2<br>
<i>AC</i><br>
3<br>
<i>BC</i><br>
4<br>
<i>A BC</i><br>
<i>C C B B A A</i><br>
0<br>
1<br>
<i>F</i>1<br>
<i>F</i>2<br>
<b> <br>FIGURE 7.14   <br> <br>PLA with three inputs, four product terms, and two outputs  </b><br>
<hr>
<A name=341></a><b>Section 7.6  Programmable Logic Array    323</b><br>
 <br>The product terms generated in each AND gate are listed along the output of the gate <br>in the diagram. The product term is determined from the inputs whose crosspoints are <br>connected and marked with a   *. The output of an OR gate gives the logical sum of <br>the selected product terms. The output may be complemented or left in its true form, <br>depending on the logic being realized. <br>
 <br>The fuse map of a PLA can be specified in a tabular form. For example, the program-<br>
ming table that specifies the PLA of  Fig.   7.14  is listed in  Table   7.5  .The PLA programming <br>table consists of three sections. The first section lists the product terms numerically. The <br>second section specifies the required paths between inputs and AND gates. The third <br>section specifies the paths between the AND and OR gates. For each output variable, <br>we may have a T (for true) or C (for complement) for programming the XOR gate. The <br>product terms listed on the left are not part of the table; they are included for reference <br>only. For each product term, the inputs are marked with 1, 0, or -- (dash). If a variable <br>in the product term appears in the form in which it is true, the corresponding input vari-<br>able is marked with a 1. If it appears complemented, the corresponding input variable <br>is marked with a 0. If the variable is absent from the product term, it is marked with a <br>dash. <b> </b><br>
 <br>The paths between the inputs and the AND gates are specified under the column head <br>
"Inputs" in the programming table. A 1 in the input column specifies a connection from <br>the input variable to the AND gate. A 0 in the input column specifies a connection from <br>the complement of the variable to the input of the AND gate. A dash specifies a blown <br>fuse in both the input variable and its complement. It is assumed that an open terminal <br>in the input of an AND gate behaves like a 1. <br>
 <br>The paths between the AND and OR gates are specified under the column head <br>
"Outputs." The output variables are marked with 1's for those product terms which <br>are included in the function. Each product term that has a 1 in the output column <br>requires a path from the output of the AND gate to the input of the OR gate. Those <br>marked with a dash specify a blown fuse. It is assumed that an open terminal in the <br>input of an OR gate behaves like a 0. Finally, a T (true) output dictates that the other <br>input of the corresponding XOR gate be connected to 0, and a C (complement) <br>specifies a connection to 1. <br>
<b> <br>Table 7.5 <br><i> <br>PLA Programming Table </b></i><br>
<i> </i><br>
<i> </i><br>
<i> </i><br>
<i> </i><br>
<i> </i><br>
<i> <br></i><b>Outputs</b><i> </i><br>
<i> </i><br>
<i> </i><br>
<i> <br></i><b>Inputs</b><i> </i><br>
<i> <br></i><b>(T)</b><i>   </i><b>(C)</b><i> </i><br>
<i> </i><br>
<i> <br></i><b>Product Term</b><i> </i><br>
<i> <br><b>A</b> </i><br>
<i><b> <br>B </b></i><br>
<i><b> <br>C </b></i><br>
<i> <br><b>F</i> 1 </b><br>
<i> <br><b>F</i> 2 </b><br>
<i> AB  </i><br>
 1 <br>
 1 <br>
 0 <br>
 -- <br>
 1 <br>
 -- <br>
<i> AC </i><br>
 2 <br>
 1 <br>
 -- <br>
 1 <br>
 1 <br>
 1 <br>
<i> BC </i><br>
 3 <br>
 -- <br>
 1 <br>
 1 <br>
 -- <br>
 1 <br>
<i> A BC  </i><br>
 4 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 -- <br>
<i>  Note:  </i>See text for meanings of dashes. <br>
<hr>
<A name=342></a><b>324    Chapter 7  Memory and Programmable Logic</b><br>
 <br>The size of a PLA is specified by the number of inputs, the number of product terms, <br>
and the number of outputs. A typical integrated circuit PLA may have 16 inputs, 48 <br>product terms, and eight outputs. For  <i>n</i>  inputs,  <i>k</i>  product terms, and  <i>m</i>  outputs, the inter-<br>nal logic of the PLA consists of  <i>n</i>  buffer�inverter gates,  <i>k</i> AND gates,  <i>m</i>  OR gates, and <br> <br><i>m</i>  XOR gates. There are   2<i>n </i>* <i>k</i>  connections between the inputs and the AND array, <br> <br><i>k </i>* <i>m</i>  connections between the AND and OR arrays, and  <i>m</i>  connections associated <br>with the XOR gates. <br>
 <br>In designing a digital system with a PLA, there is no need to show the internal con-<br>
nections of the unit as was done in  Fig.   7.14 . All that is needed is a PLA programming <br>table from which the PLA can be programmed to supply the required logic. As with a <br>ROM, the PLA may be mask programmable or field programmable. With mask pro-<br>gramming, the customer submits a PLA program table to the manufacturer. This table <br>is used by the vendor to produce a custommade PLA that has the required internal <br>logic specified by the customer. A second type of PLA that is available is the field<br>programmable logic array, or FPLA, which can be programmed by the user by means <br>of a commercial hardware programmer unit. <br>
 <br>In implementing a combinational circuit with a PLA, careful investigation must be <br>
undertaken in order to reduce the number of distinct product terms, since a PLA has a <br>finite number of AND gates. This can be done by simplifying each Boolean function to <br>a minimum number of terms. The number of literals in a term is not important, since all <br>the input variables are available anyway. Both the true value and the complement of <br>each function should be simplified to see which one can be expressed with fewer prod-<br>uct terms and which one provides product terms that are common to other functions. <br>
<b> <br>EXAMPLE 7.2 </b><br>
 <br>Implement the following two Boolean functions with a PLA: <br>
 <i>F</i>1(<i>A</i>, <i>B</i>, <i>C</i>) = g(0, 1, 2, 4)<br>
 <i>F</i>2(<i>A</i>, <i>B</i>, <i>C</i>) = g(0, 5, 6, 7) <br>
 <br>The two functions are simplified in the maps of  Fig.   7.15 . Both the true value and the <br>complement of the functions are simplified into sumofproducts form. The combination <br>that gives the minimum number of product terms is <br>
 <br><i>F</i>1 = (<i>AB </i>+ <i>AC </i>+ <i>BC</i>)  <br>
 and <br>
 <br><i>F</i>2 = <i>AB </i>+ <i>AC </i>+ <i>A B C </i> <br>
 <br>This combination gives four distinct product terms: <i>AB</i>, <i>AC</i>, <i>BC</i>, and   <i>A B C </i>.     The  PLA <br>programming table for the combination is shown in the figure. Note that output   <i>F</i>1 is <br>the true output, even though a <i>C</i> is marked over it in the table. This is because   <i>F</i>1 is <br>generated with an AND�OR circuit and is available at the output of the OR gate. The <br>XOR gate complements the function to produce the true   <i>F</i>1     output. <br>
<hr>
<A name=343></a><b>Section 7.7  Programmable Array Logic    325</b><br>
<i>B</i><br>
<i>B</i><br>
PLA programming table<br>
<i>BC</i><br>
<i>BC</i><br>
<i>A</i><br>
00<br>
01<br>
11<br>
10<br>
<i>A</i><br>
00<br>
01<br>
11<br>
10<br>
Outputs<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
0<br>
1<br>
3<br>
2<br>
0<br>
1<br>
3<br>
2<br>
Product<br>
Inputs<br>
(C)<br>
(T)<br>
0<br>
1<br>
1<br>
0<br>
1<br>
0<br>
1<br>
0<br>
0<br>
0<br>
term<br>
<i>A   B   C</i><br>
<i>F</i>1<br>
<i>F</i>2<br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
<i>m</i><br>
4<br>
5<br>
7<br>
6<br>
4<br>
5<br>
7<br>
6<br>
<i>AB</i><br>
1<br>
1<br>
1<br>
�<br>
1<br>
1<br>
<i>A </i>1<br>
1<br>
0<br>
0<br>
0<br>
<i>A </i>1<br>
0<br>
1<br>
1<br>
1<br>
<i>AC</i><br>
2<br>
1<br>
�<br>
1<br>
1<br>
1<br>
<i>BC</i><br>
3<br>
�<br>
1<br>
1<br>
1<br>
�<br>
<i>A B C</i><br>
4<br>
0<br>
0<br>
0<br>
�<br>
1<br>
<i>C</i><br>
<i>C</i><br>
<b> <br>FIGURE 7.15   <br> <br>Solution to Example 7.2</b><br>
<b> </b><br>
 <br>The combinational circuit used in Example 7.2 is too simple for implementing with <br>
a PLA. It was presented merely for purposes of illustration. A typical PLA has a large <br>number of inputs and product terms. The simplification of Boolean functions with so <br>many variables should be carried out by means of computerassisted simplification pro-<br>cedures. The computeraided design (CAD) program simplifies each function and its <br>complement to a minimum number of terms. The program then selects a minimum <br>number of product terms that cover all functions in the form in which they are true or <br>in their complemented form. The PLA programming table is then generated and the <br>required fuse map obtained. The fuse map is applied to an FPLA programmer that goes <br>through the hardware procedure of blowing the internal fuses in the integrated circuit. <br>
<b> <br>7 . 7       P R O G R A M M A B L E   A R R AY   L O G I C </b><br>
 <br>The PAL is a programmable logic device with a fixed OR array and a programmable <br>AND array. Because only the AND gates are programmable, the PAL is easier to pro-<br>gram than, but is not as flexible as, the PLA.  Figure   7.16  shows the logic configuration of <br>a typical PAL with four inputs and four outputs. Each input has a buffer�inverter gate, <br>and each output is generated by a fixed OR gate. There are four sections in the unit, <br>each composed of an AND�OR array that is  <i>three wide</i>,  the term used to indicate that <br>there are three programmable AND gates in each section and one fixed OR gate. Each <br>AND gate has 10 programmable input connections, shown in the diagram by 10 vertical <br>lines intersecting each horizontal line. The horizontal line symbolizes the multipleinput <br>configuration of the AND gate. One of the outputs is connected to a buffer�inverter <br>gate and then fed back into two inputs of the AND gates. <br>
 <br>Commercial PAL devices contain more gates than the one shown in  Fig.   7.16 . A typical <br>
PAL integrated circuit may have eight inputs, eight outputs, and eight sections, each con-<br>sisting of an eightwide AND�OR array. The output terminals are sometimes driven by <br>threestate buffers or inverters. <br>
 <br>In designing with a PAL, the Boolean functions must be simplified to fit into each <br>
section. Unlike the situation with a PLA, a product term cannot be shared among two <br>or more OR gates. Therefore, each function can be simplified by itself, without regard <br>
<hr>
<A name=344></a><b>326    Chapter 7  Memory and Programmable Logic</b><br>
AND gates inputs<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
Product<br>
term<br>
1<br>
2<br>
<i>F</i>1<br>
3<br>
<i>I</i>1<br>
4<br>
5<br>
<i>F</i>2<br>
6<br>
<i>I</i>2<br>
7<br>
8<br>
<i>F</i>3<br>
9<br>
<i>I</i>3<br>
10<br>
11<br>
<i>F</i>4<br>
12<br>
<i>I</i>4<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
<b> <br>FIGURE 7.16   <br> <br>PAL with four inputs, four outputs, and a threewide AND�OR structure  </b><br>
<hr>
<A name=345></a><b>Section 7.7  Programmable Array Logic    327</b><br>
to common product terms. The number of product terms in each section is fixed, and if <br>the number of terms in the function is too large, it may be necessary to use two sections <br>to implement one Boolean function. <br>
 <br>As an example of using a PAL in the design of a combinational circuit, consider the <br>
following Boolean functions, given in sumofminterms form: <br>
 <br><i>w</i>(<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>) = g(2, 12, 13)<br>
 <br><i>x</i>(<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>) = g(7, 8, 9, 10, 11, 12, 13, 14, 15)<br>
 <br><i>y</i>(<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>) = g(0, 2, 3, 4, 5, 6, 7, 8, 10, 11, 15)<br>
 <br><i>z</i>(<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>) = g(1, 2, 8, 12, 13)<br>
 <br>
 <br>Simplifying the four functions to a minimum number of terms results in the following <br>Boolean functions: <br>
 <br><i>w </i>= <i>ABC </i>+ <i>A B CD</i><br>
 <br><i>x </i>= <i>A </i>+ <i>BCD</i><br>
 <br><i>y </i>= <i>A B </i>+ <i>CD </i>+ <i>B D</i><br>
 <br><i>z </i>= <i>ABC </i>+ <i>A B CD </i>+ <i>AC D </i>+ <i>A B C D</i><br>
  = <i>w </i>+ <i>AC D </i>+ <i>A B C D</i><br>
 <br>
 <br>Note that the function for  <i>z</i>  has four product terms. The logical sum of two of these terms <br>is equal to  <i>w</i> . By using  <i>w,</i>  it is possible to reduce the number of terms for  <i>z</i>  from four to <br>three. <br>
 <br>The PAL programming table is similar to the one used for the PLA, except that <br>
only the inputs of the AND gates need to be programmed.  Table   7.6   lists the PAL <br>
<b> <br>Table 7.6 <br><i> <br>PAL Programming Table </b></i><br>
<i> </i><br>
<i> <br></i><b>AND Inputs</b><i> </i><br>
<i> </i><br>
<i> <br></i><b>Product Term</b><i> </i><br>
<i><b> <br>A </b></i><br>
<i><b> <br>B </b></i><br>
<i><b> <br>C </b></i><br>
<i><b> <br>D </b></i><br>
<i><b> <br>w </b></i><br>
<i> <br></i><b>Outputs</b><i> </i><br>
   1 <br>
 1 <br>
 1 <br>
 0 <br>
 -- <br>
 -- <br>
 <br><i>w </i>= <i>ABC </i>+ <i>A B CD </i> <br>
   2 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 -- <br>
  <br>
   3 <br>
 -- <br>
 -- <br>
 -- <br>
 -- <br>
 -- <br>
  <br>
   4 <br>
 1 <br>
 -- <br>
 -- <br>
 -- <br>
 -- <br>
 <i>x </i>= <i>A </i>+ <i>BCD</i> <br>
   5 <br>
 -- <br>
 1 <br>
 1 <br>
 1 <br>
 -- <br>
  <br>
   6 <br>
 -- <br>
 -- <br>
 -- <br>
 -- <br>
 -- <br>
  <br>
   7 <br>
 0 <br>
 1 <br>
 -- <br>
 -- <br>
 -- <br>
 <i>y </i>= <i>A B </i>+ <i>CD </i>+ <i>B D </i> <br>
   8 <br>
 -- <br>
 -- <br>
 1 <br>
 1 <br>
 -- <br>
  <br>
   9 <br>
 -- <br>
 0 <br>
 -- <br>
 0 <br>
 -- <br>
  <br>
 10 <br>
 -- <br>
 -- <br>
 -- <br>
 -- <br>
 1 <br>
 <br><i>z </i>= <i>w </i>+ <i>AC D </i>+ <i>A B C D</i> <br>
 11 <br>
 1 <br>
 -- <br>
 0 <br>
 0 <br>
 -- <br>
  <br>
 12 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 -- <br>
  <br>
<hr>
<A name=346></a><b>328    Chapter 7  Memory and Programmable Logic</b><br>
AND gates inputs<br>
<i>A</i><br>
<i>A</i><br>
<i>B</i><br>
<i>B</i><br>
<i>C</i><br>
<i>C</i><br>
<i>D</i><br>
<i>D</i><br>
<i>w</i><br>
<i>w</i><br>
Product<br>
term<br>
1<br>
2<br>
<i>w</i><br>
3<br>
<i>A</i><br>
4<br>
5<br>
<i>x</i><br>
6<br>
All fuses intact<br>
<i>B</i><br>
(always<br>
 0)<br>
7<br>
8<br>
<i>y</i><br>
9<br>
<i>C</i><br>
10<br>
11<br>
<i>z</i><br>
12<br>
<i>D</i><br>
Fuse intact<br>
Fuse blown<br>
<i>A</i><br>
<i>A</i><br>
<i>B</i><br>
<i>B</i><br>
<i>C</i><br>
<i>C</i><br>
<i>D</i><br>
<i>D</i><br>
<i>w</i><br>
<i>w</i><br>
<b> <br>FIGURE 7.17   <br> <br>Fuse map for PAL as specified in  Table   7.6  </b><br>
<hr>
<A name=347></a><b>Section 7.8  Sequential Programmable Devices    329</b><br>
programming table for the four Boolean functions. The table is divided into four sec-<br>tions with three product terms in each, to conform with the PAL of  Fig.   7.16 . The first <br>two sections need only two product terms to implement the Boolean function. The <br>last section, for output  <i>z,</i>  needs four product terms. Using the output from  <i>w,</i>  we can <br>reduce the function to three terms. <br>
 <br>The fuse map for the PAL as specified in the programming table is shown in  Fig.   7.17 . <br>
For each 1 or 0 in the table, we mark the corresponding intersection in the diagram with <br>the symbol for an intact fuse. For each dash, we mark the diagram with blown fuses in both <br>the true and complement inputs. If the AND gate is not used, we leave all its input fuses <br>intact. Since the corresponding input receives both the true value and the complement of <br>each input variable, we have   <i>AA </i>= 0  and the output of the AND gate is always 0. <br>
 <br>As with all PLDs, the design with PALs is facilitated by using CAD techniques. The <br>
blowing of internal fuses is a hardware procedure done with the help of special elec-<br>tronic instruments. <br>
<b> <br>7 . 8       S E Q U E N T I A L   P R O G R A M M A B L E   D E V I C E S </b><br>
 <br>Digital systems are designed with flipflops and gates. Since the combinational PLD <br>consists of only gates, it is necessary to include external flipflops when they are used in <br>the design. Sequential programmable devices include both gates and flipflops. In this <br>way, the device can be programmed to perform a variety of sequentialcircuit functions. <br>There are several types of sequential programmable devices available commercially, and <br>each device has vendorspecific variants within each type. The internal logic of these <br>devices is too complex to be shown here. Therefore, we will describe three major types <br>without going into their detailed construction: <br>
 <br><b> 1. </b><br>
 <br>Sequential (or simple) programmable logic device (SPLD)  <br>
 <br><b> 2. </b><br>
 <br>Complex programmable logic device (CPLD)  <br>
 <br><b> 3. </b><br>
  Fieldprogrammable  gate  array  (FPGA)   <br>
 <br>The sequential PLD is sometimes referred to as a simple PLD to differentiate it from <br>the complex PLD. The SPLD includes flipflops, in addition to the AND�OR array, <br>within the integrated circuit chip. The result is a sequential circuit as shown in  Fig.   7.18 . <br>A PAL or PLA is modified by including a number of flipflops connected to form a <br>register. The circuit outputs can be taken from the OR gates or from the outputs of the <br>
<i>Inputs</i><br>
AND�OR array<br>
(PAL or PLA)<br>
<i>Outputs</i><br>
Flip-flops<br>
<b> <br>FIGURE 7.18   <br> <br>Sequential programmable logic device  </b><br>
<hr>
<A name=348></a><b>330    Chapter 7  Memory and Programmable Logic</b><br>
flipflops. Additional programmable connections are available to include the flipflop <br>outputs in the product terms formed with the AND array. The flipflops may be of the <br> <br><i>D</i>  or the  <i>JK</i>   type. <br>
 <br>The first programmable device developed to support sequential circuit implementation <br>
is the fieldprogrammable logic sequencer (FPLS). A typical FPLS is organized around a <br>PLA with several outputs driving flipflops. The flipflops are flexible in that they can be <br>programmed to operate as either the  <i>JK</i>  or the  <i>D</i>  type. The FPLS did not succeed com-<br>mercially, because it has too many programmable connections. The configuration mostly <br>used in an SPLD is the combinational PAL together with  <i>D</i>  flipflops. A PAL that includes <br>flipflops is referred to as a  <i>registered</i>  PAL, to signify that the device contains flipflops in <br>addition to the AND�OR array. Each section of an SPLD is called a  <i>macrocell,</i>  which is <br>a circuit that contains a sumofproducts combinational logic function and an optional <br>flipflop. We will assume an AND�OR sumofproducts function, but in practice, it can be <br>any one of the twolevel implementations presented in Section 3.7. <br>
 <br>Figure   7.19  shows the logic of a basic macrocell. The AND�OR array is the same as <br>
in the combinational PAL shown in  Fig.   7.16 . The output is driven by an edgetriggered <br> <br><i>D</i>  flipflop connected to a common clock input and changes state on a clock edge. The <br>output of the flipflop is connected to a threestate buffer (or inverter) controlled by an <br>outputenable signal marked in the diagram as  <i>OE</i> . The output of the flipflop is fed <br>back into one of the inputs of the programmable AND gates to provide the presentstate <br>condition for the sequential circuit. A typical SPLD has from 8 to 10 macrocells within <br>
<i>CLK OE</i><br>
<i>D</i><br>
<i>CLK</i><br>
<b> <br>FIGURE 7.19   <br> <br>Basic macrocell logic  </b><br>
<hr>
<A name=349></a><b>Section 7.8  Sequential Programmable Devices    331</b><br>
one IC package. All the flipflops are connected to the common  <i>CLK</i>  input, and all <br>threestate buffers are controlled by the <i>OE</i> input. <br>
 <br>In addition to programming the AND array, a macrocell may have other program-<br>
ming features. Typical programming options include the ability to either use or bypass <br>the flipflop, the selection of clock edge polarity, the selection of preset and clear for the <br>register, and the selection of the true value or complement of an output. An XOR gate <br>is used to program a true/complement condition. Multiplexers select between two or <br>four distinct paths by programming the selection inputs. <br>
 <br>The design of a digital system using PLDs often requires the connection of several <br>
devices to produce the complete specification. For this type of application, it is more <br>economical to use a complex programmable logic device (CPLD), which is a collection <br>of individual PLDs on a single integrated circuit. A programmable interconnection <br>structure allows the PLDs to be connected to each other in the same way that can be <br>done with individual PLDs. <br>
 <br>Figure   7.20  shows the general configuration of a CPLD. The device consists of mul-<br>
tiple PLDs interconnected through a programmable switch matrix. The input�output <br>(I/O) blocks provide the connections to the IC pins. Each I/O pin is driven by a three<br>state buffer and can be programmed to act as input or output. The switch matrix receives <br>inputs from the I/O block and directs them to the individual macrocells. Similarly, <br>selected outputs from macrocells are sent to the outputs as needed. Each PLD typically <br>contains from 8 to 16 macrocells, usually fully connected. If a macrocell has unused <br>product terms, they can be used by other nearby macrocells. In some cases the macrocell <br>flipflop is programmed to act as a  <i>D</i>,    <i>JK</i>,  or  <i>T</i>   flipflop. <br>
 <br>Different manufacturers have taken different approaches to the general architecture <br>
of CPLDs. Areas in which they differ include the individual PLDs (sometimes called <br>
PLD<br>
PLD<br>
PLD<br>
PLD<br>
I/O<br>
I/O<br>
Programmable switch matrix<br>
block<br>
block<br>
PLD<br>
PLD<br>
PLD<br>
PLD<br>
<b> <br>FIGURE 7.20   <br> <br>General CPLD configuration  </b><br>
<hr>
<A name=350></a><b>332    Chapter 7  Memory and Programmable Logic</b><br>
 <br><i>function blocks</i> ), the type of macrocells, the I/O blocks, and the programmable intercon-<br>nection structure. The best way to investigate a vendorspecific device is to look at the <br>manufacturer's literature. <br>
 <br>The basic component used in VLSI design is the  <i>gate array,</i>  which consists of a pattern <br>
of gates, fabricated in an area of silicon, that is repeated thousands of times until the entire <br>chip is covered with gates. Arrays of one thousand to several hundred thousand gates are <br>fabricated within a single IC chip, depending on the technology used. The design with <br>gate arrays requires that the customer provide the manufacturer the desired interconnec-<br>tion pattern. The first few levels of the fabrication process are common and independent <br>of the final logic function. Additional fabrication steps are required to interconnect the <br>gates according to the specifications given by the designer. <br>
 <br>A fieldprogrammable gate array (FPGA) is a VLSI circuit that can be programmed <br>
at the user's location. A typical FPGA consists of an array of millions of logic blocks, <br>surrounded by programmable input and output blocks and connected together via pro-<br>grammable interconnections. There is a wide variety of internal configurations within <br>this group of devices. The performance of each type of device depends on the circuit <br>contained in its logic blocks and the efficiency of its programmed interconnections. <br>
 <br>A typical FPGA logic block consists of lookup tables, multiplexers, gates, and <br>
flipflops. A lookup table is a truth table stored in an SRAM and provides the com-<br>binational circuit functions for the logic block. These functions are realized from the <br>lookup table, in the same way that combinational circuit functions are implemented <br>with ROM, as described in Section 7.5. For example, a   16 * 2  SRAM can store the <br>truth table of a combinational circuit that has four inputs and two outputs. The <br>combinational logic section, along with a number of programmable multiplexers, is <br>used to configure the input equations for the flipflop and the output of the logic <br>block. <br>
 <br>The advantage of using RAM instead of ROM to store the truth table is that the table <br>
can be programmed by writing into memory. The disadvantage is that the memory is <br>volatile and presents the need for the lookup table's content to be reloaded in the event <br>that power is disrupted. The program can be downloaded either from a host computer <br>or from an onboard PROM. The program remains in SRAM until the FPGA is repro-<br>grammed or the power is turned off. The device must be reprogrammed every time <br>power is turned on. The ability to reprogram the FPGA can serve a variety of applica-<br>tions by using different logic implementations in the program. <br>
 <br>The design with PLD, CPLD, or FPGA requires extensive computeraided design <br>
(CAD) tools to facilitate the synthesis procedure. Among the tools that are available <br>are schematic entry packages and hardware description languages (HDLs), such as <br>ABEL, VHDL, and Verilog. Synthesis tools are available that allocate, configure, and <br>connect logic blocks to match a highlevel design description written in HDL. As an <br>example of CMOS FPGA technology, we will discuss the Xilinx FPGA.  1 <br>
 <br>1 See www.Altera.com for an alternative CMOS FPGA architecture. <br>
<hr>
<A name=351></a><b>Section 7.8  Sequential Programmable Devices    333</b><br>
<b> <br>Xilinx FPGAs </b><br>
 <br>Xilinx launched the world's first commercial FPGA in 1985, with the vintage XC2000 <br>device family.  2 The XC3000 and XC4000 families soon followed, setting the stage for <br>today's SpartanTM, and VirtexTM device families. Each evolution of devices brought <br>improvements in density, performance, power consumption, voltage levels, pin counts, and <br>functionality. For example, the Spartan family of devices initially offered a maximum of <br>40K system gates, but today's Spartan6 offers 150,000 logic cells plus 4.8Mb block RAM. <br>
<b> <br>Basic Xilinx Architecture </b><br>
 <br>The basic architecture of Spartan and earlier device families consists of an array of <br>configurable logic blocks (CLBs), a variety of local and global routing resources, and <br>input�output (I/O) blocks (IOBs), programmable I/O buffers, and an SRAMbased <br>configuration memory, as shown in  Fig.   7.21 . <br>
IOB<br>
IOB<br>
IOB<br>
IOB<br>
IOB<br>
Switch<br>
Switch<br>
Switch<br>
IOB<br>
IOB<br>
Matrix<br>
Matrix<br>
Matrix<br>
IOB<br>
CLB<br>
CLB<br>
IOB<br>
Switch<br>
Switch<br>
Switch<br>
IOB<br>
IOB<br>
Matrix<br>
Matrix<br>
Matrix<br>
IOB<br>
CLB<br>
CLB<br>
IOB<br>
Vertical<br>
long line<br>
Switch<br>
Switch<br>
Switch<br>
IOB<br>
IOB<br>
Matrix<br>
Matrix<br>
Matrix<br>
IOB<br>
IOB<br>
IOB<br>
IOB<br>
IOB<br>
Horizontal<br>
long line<br>
<b> <br>FIGURE 7.21   <br> <br>Basic architecture of Xilinx Spartan and predecessor devices  </b><br>
 <br>2 See www.Xilinx.com for detailed, uptodate information about Xilinx products. <br>
<hr>
<A name=352></a><b>334    Chapter 7  Memory and Programmable Logic</b><br>
<b> <br>Configurable Logic Block (CLB) </b><br>
 <br>Each CLB consists of a programmable lookup table, multiplexers, registers, and paths for <br>control signals, as shown in  Fig.   7.22  .Two of the function generators (F and G) of the lookup <br>table can generate any arbitrary function of four inputs, and the third (H) can generate any <br>Boolean function of three inputs. The Hfunction block can get its inputs from the F and <br>G lookup tables or from external inputs. The three function generators can be programmed <br>to generate (1) three different functions of three independent sets of variables (two with <br>four inputs and one with three inputs--one function must be registered within the CLB), <br>(2) an arbitrary function of five variables, (3) an arbitrary function of four variables together <br>with some functions of six variables, and (4) some functions of nine variables. <br>
 <br>Each CLB has two storage devices that can be configured as edgetriggered flipflops <br>
with a common clock, or, in the XC4000X, they can be configured as flipflops or as <br>transparent latches with a common clock (programmed for either edge and separately <br>invertible) and an enable. The storage elements can get their inputs from the function <br>generators or from the   <i>Din</i>  input. The other element can get an external input from the <br> <br><i>H1</i>  input. The function generators can also drive two outputs ( <i>X</i>   and   <i>Y</i> ) directly and <br>independently of the outputs of the storage elements. All of these outputs can be con-<br>nected to the interconnect network. The storage elements are driven by a global set/<br>reset during powerup; the global set/reset is programmed to match the programming <br>of the local S/R control for a given storage element. <br>
<b> <br>Distributed RAM </b><br>
 <br>The three function generators within a CLB can be used as either a   16 * 2     dualport <br>RAM or a   32 * 1  singleport RAM. The XC4000 devices do not have block RAM, but <br>a group of their CLBs can form an array of memory. Spartan devices have block RAM <br>in addition to distributed RAM. <br>
<b> <br>Interconnect Resources </b><br>
 <br>A grid of switch matrices overlays the architecture of CLBs to provide generalpurpose <br>interconnect for branching and routing throughout the device. The interconnect has <br>three types of generalpurpose interconnects: singlelength lines, doublelength lines, <br>and long lines. A grid of horizontal and vertical singlelength lines connects an array of <br>switch boxes that provide a reduced number of connections between signal paths within <br>each box, not a full crossbar switch. Each CLB has a pair of threestate buffers that can <br>drive signals onto the nearest horizontal lines above or below the CLB. <br>
 <br>Direct (dedicated) interconnect lines provide routing between adjacent vertical and <br>
horizontal CLBs in the same column or row. These are relatively high speed local con-<br>nections through metal, but are not as fast as a hardwired metal connection because of <br>the delay incurred by routing the signal paths through the transmission gates that con-<br>figure the path. Direct interconnect lines do not use the switch matrices, thus eliminating <br>the delay incurred on paths going through a matrix.  3 <br>
 <br>3 See Xilinx documentation for the pinout conventions to establish local interconnects between CLBs. <br>
<hr>
<A name=353></a><i>C1...C4</i><br>
H1<br>
D<br>
SR/H<br>
IN/ H2<br>
0<br>
EC<br>
S/R<br>
DIN<br>
control<br>
<i>G4</i><br>
Logic<br>
F<br>
<i>G3</i><br>
Function<br>
D SD<br>
<i>YQ</i><br>
G<br>
G<br>
<i>G2</i><br>
of<br>
Q<br>
<i>G1</i><br>
G1 ... G4<br>
H<br>
<b>Section </b><br>
EC<br>
G<br>
Logic<br>
RD<br>
H<br>
H<br>
Function<br>
<b>7.8  Sequential </b><br>
of F , G ,<br>
1<br>
and H1<br>
<i>Y</i><br>
S/R<br>
DIN<br>
control<br>
<i>F4</i><br>
Logic<br>
F<br>
<i>XQ</i><br>
SD<br>
<i>F3</i><br>
Function<br>
D<br>
F<br>
G<br>
Q<br>
<i>F2</i><br>
of<br>
H<br>
<b>Programmable </b><br>
<i>F1</i><br>
F1 ... F4<br>
H<br>
EC RD<br>
F<br>
1<br>
<i>K</i><br>
(Clock)<br>
Note: Muxes without a select line<br>
<i>X</i><br>
<b>Devices    335</b><br>
are configured by the program memory.<br>
<b> <br>FIGURE 7.22   <br> <br>CLB architecture  </b><br>
<hr>
<A name=354></a><b>336    Chapter 7  Memory and Programmable Logic</b><br>
Configuration Control<br>
Write<br>
Static RAM<br>
Cell<br>
Read<br>
Interconnect path<br>
<b> <br>FIGURE 7.23   <br> <br>RAM cell controlling a PIP transmission gate  </b><br>
 <br>Doublelength lines traverse the distance of two CLBs before entering a switch <br>
matrix, skipping every other CLB. These lines provide a more efficient implementation <br>of intermediatelength connections by eliminating a switch matrix from the path, thereby <br>reducing the delay of the path. <br>
 <br>Long lines span the entire array vertically and horizontally. They drive lowskew, <br>
highfanout control signals. Long vertical lines have a programmable splitter that seg-<br>ments the lines and allows two independent routing channels spanning onehalf of the <br>array, but located in the same column. The routing resources are exploited automatically <br>by the routing software. There are eight lowskew global buffers for clock distribution. <br>
 <br>The signals that drive long lines are buffered. Long lines can be driven by adjacent <br>
CLBs or IOBs and may connect to threestate buffers that are available to CLBs. Long <br>lines provide threestate buses within the architecture and implement wiredAND logic. <br>Each horizontal long line is driven by a threestate buffer and can be programmed to <br>connect to a pullup resistor, which pulls the line to a logical 1 if no driver is asserted on <br>the line. <br>
 <br>The programmable interconnect resources of the device connect CLBs and IOBs, either <br>
directly or through switch boxes. These resources consist of a grid of two layers of metal <br>segments and programmable interconnect points (PIPs) within switch boxes. A PIP is a <br>CMOS transmission gate whose state (on or off) is determined by the content of a static <br>RAM cell in the programmable memory, as shown in  Fig.   7.23 . The connection is estab-<br>lished when the transmission gate is on (i.e., when a 1 is applied at the gate of the  <i>n</i> channel <br>transistor), and a 0 is applied at the gate of the  <i>p</i> channel transistor. Thus, the device can <br>be reprogrammed simply by changing the contents of the controlling memory cell. <br>
 <br>The architecture of a PIPbased interconnection in a switch box is shown in  Fig.   7.24 , <br>
which shows possible signal paths through a PIP. The configuration of CMOS transmis-<br>sion gates determines the connection between a horizontal line and the opposite hori-<br>zontal line and between the vertical lines at the connection. Each switch matrix PIP <br>requires six pass transistors to establish full connectivity. <br>
<hr>
<A name=355></a><b>Section 7.8  Sequential Programmable Devices    337</b><br>
<b> <br>FIGURE 7.24   <br> <br>Circuit for a programmable PIP  </b><br>
<b> <br>I/O Block (IOB) </b><br>
 <br>Each programmable I/O pin has a programmable IOB having buffers for compatibility <br>with TTL and CMOS signal levels.  Figure   7.25  shows a simplified schematic for a pro-<br>grammable IOB. It can be used as an input, an output, or a bidirectional port. An IOB <br>that is configured as an input can have direct, latched, or registered input. In an output <br>configuration, the IOB has direct or registered output. The output buffer of an IOB has <br>skew and slew control. The registers available to the input and output path of an IOB <br>are driven by separate, invertible clocks. There is a global set/reset. <br>
 <br>Internal delay elements compensate for the delay induced when a clock signal passes <br>
through a global buffer before reaching an IOB. This strategy eliminates the hold condi-<br>tion on the data at an external pin. The threestate output of an IOB puts the output <br>buffer in a highimpedance state. The output and the enable for the output can be <br>inverted. The slew rate of the output buffer can be controlled to minimize transients on <br>the power bus when noncritical signals are switched. The IOB pin can be programmed <br>for pullup or pulldown to prevent needless power consumption and noise. <br>
 <br>The devices have embedded logic to support the IEEE 1149.1 (JTAG) boundary scan <br>
standard. There is an onchip test access port (TAP) controller, and the I/O cells can be <br>configured as a shift register. Under testing, the device can be checked to verify that all <br>the pins on a PC board are connected and operate properly by creating a serial chain of <br>all of the I/O pins of the chips on the board. A master threestate control signal puts all <br>of the IOBs in highimpedance mode for board testing. <br>
<b> <br>Enhancements </b><br>
 <br>Spartan chips can accommodate embedded soft cores, and their onchip distributed, dual<br>port, synchronous RAM (SelectRAM) can be used to implement firstin, firstout register <br>
<hr>
<A name=356></a><b>338    Chapter 7  Memory and Programmable Logic</b><br>
Slew rate<br>
Passive<br>
<i>VCC</i><br>
control<br>
pull-up<br>
pull-down<br>
<i>OE</i><br>
D<br>
Q<br>
I/O<br>
PAD<br>
<i>O</i><br>
Output<br>
buffer<br>
Output<br>
Input<br>
clock<br>
buffer<br>
<i>I</i>1<br>
Delay<br>
<i>I</i>2<br>
Q D<br>
Input<br>
clock<br>
<b> <br>FIGURE 7.25   <br> <br>XC4000 series IOB  </b><br>
<i>n</i><br>
16<br>
 2<br>
<i>A</i>[<i>n </i>1:0]<br>
32<br>
 1<br>
<i>n</i><br>
Ram array<br>
select<br>
Write row<br>
select<br>
Read row<br>
Input register<br>
<i>WE</i><br>
Write<br>
Read<br>
<i>SPO</i><br>
control<br>
out<br>
<i>D0</i> or <i>D1</i><br>
<i>WCLK</i><br>
<b> <br>FIGURE 7.26   <br> <br>Distributed RAM cell formed from a lookup table  </b><br>
files (FIFOs), shift registers, and scratchpad memories. The blocks can be cascaded to any <br>width and depth and located anywhere in the part, but their use reduces the CLBs avail-<br>able for logic.  Figure   7.26  displays the structure of the onchip RAM that is formed by <br>
<hr>
<A name=357></a><b>Section 7.8  Sequential Programmable Devices    339</b><br>
4<br>
16<br>
 1<br>
<i>A</i>[3:0]<br>
RAM array<br>
select<br>
select<br>
4<br>
Write row<br>
Read row<br>
Input register<br>
<i>WE</i><br>
Write<br>
Read<br>
<i>SPO</i><br>
control<br>
out<br>
<i>D</i><br>
<i>WCLK</i><br>
<i>DPRA</i>[3:0]<br>
16<br>
 1<br>
RAM array<br>
select<br>
select<br>
4<br>
Write row<br>
Read row<br>
Write<br>
Read<br>
<i>SPO</i><br>
control<br>
out<br>
<b> <br>FIGURE 7.27   <br> <br>Spartan dualport RAM  </b><br>
programming a lookup table to implement a singleport RAM with synchronous write <br>and asynchronous read. Each CLB can be programmed as a   16 * 2     or     32 * 1     memory.  <br>
 <br>Dualport RAMs are emulated in a Spartan device by the structure shown in  Fig.  7.27 , <br>
which has a single (common) write port and two asynchronous read ports. A CLB can <br>form a memory having a maximum size of   16 * 1. <br>
<b> <br>Xilinx Spartan XL FPGAs </b><br>
 <br>Spartan XL chips are a further enhancement of Spartan chips, offering higher speed and <br>density (40,000 system gates, approximately 6,000 of which are usable) and onchip, <br>distributed SelectRAM memory.  4 The lookup tables of the devices can implement   22n <br>different functions of  <i>n</i>   inputs.    <br>
 <br>4 The maximum number of logic gates for a Xilinx FPGA is an estimate of the maximum number of logic gates that <br>could be realized in a design consisting of only logic functions (no memory). Logic capacity is expressed in terms <br>of the number of twoinput NAND gates that would be required to implement the same number and type of logic <br>functions (Xilinx App. Note). <br>
<hr>
<A name=358></a><b>340    Chapter 7  Memory and Programmable Logic</b><br>
<b> <br>Table 7.7 <br><i> <br>Attributes of the Xilinx Spartan XL Device Family </b></i><br>
<i> <br></i><b>Spartan XL</b><i> </i><br>
<i> <br></i><b>XCS05/XL</b><i> </i><br>
<i> <br></i><b>XCS10/XL</b><i> </i><br>
<i> <br></i><b>XCS20/XL</b><i> </i><br>
<i> <br></i><b>XCS30/XL</b><i> </i><br>
<i> <br></i><b>XCS40/XL</b><i> </i><br>
 System  Gates  1   <br>
 2K�5K <br>
 3K�10K <br>
 7K�20K <br>
 10K�30K <br>
 13K�40K <br>
 Logic  Cells  2   <br>
 238 <br>
 466 <br>
 950 <br>
 1,368 <br>
 1,862 <br>
 Max  Logic  Gates <br>
 3,000 <br>
 5,000 <br>
 10,000 <br>
 13,000 <br>
 20,000 <br>
 FlipFlops <br>
 360 <br>
 616 <br>
 1,120 <br>
 1,536 <br>
 2,016 <br>
 Max  RAM  Bits <br>
 3,200 <br>
 6,272 <br>
 12,800 <br>
 18,432 <br>
 25,088 <br>
 Max  Avail  I/O <br>
 77 <br>
 112 <br>
 160 <br>
 192 <br>
 224 <br>
 <br>1 20�30% of CLBs as RAM. <br> <br>2 1 Logic cell = fourinput lookup table + fl ipfl op. <br>
 <br>The XL series is targeted for applications for which low cost, low power, low packag-<br>
ing, and low test cost are important factors constraining the design. Spartan XL devices <br>offer up to 80MHz system performance, depending on the number of cascaded lookup <br>tables, which reduce performance by introducing longer paths.  Table   7.7   presents sig-<br>nificant attributes of devices in the Spartan XL family. <br>
 <br>The architecture of the Spartan XL and earlier devices consists of an array of CLB <br>
tiles mingled within an array of switch matrices, surrounded by a perimeter of IOBs. <br>These devices support only distributed memory, whose use reduces the number of <br>CLBs that could be used for logic. The relatively small amount of onchip memory <br>limits the devices to applications in which operations with offchip memory devices do <br>not compromise performance objectives. Beginning with the Spartan II series, Xilinx <br>supported configurable embedded block memory, as well as distributed memory in a <br>new architecture. <br>
<b> <br>Xilinx Spartan II FPGAs </b><br>
 <br>Aside from improvements in speed (200MHz I/O switching frequency), density (up to <br>200,000 system gates) and operating voltage (2.5 V), four other features distinguish the <br>Spartan II devices from the Spartan devices: (1) onchip block memory, (2) a novel <br>architecture, (3) support for multiple I/O standards, and (4) delay locked loops (DLLs).  5 <br>
 <br>The Spartan II device family, manufactured in   0.22&gt;0.18@mm     CMOS  technology  with <br>
six layers of metal for interconnect, incorporates configurable block memory in addition <br>to the distributed memory of the previous generations of devices, and the block memory <br>does not reduce the amount of logic or distributed memory that is available for the <br>
 <br>5 Spartan II devices do not support lowvoltage differential signaling (LVDS) or lowvoltage positive emittercoupled <br>logic (LVPECL) I/O standards. <br>
<hr>
<A name=359></a><b>Section 7.8  Sequential Programmable Devices    341</b><br>
application. A large onchip memory can improve system performance by eliminating <br>or reducing the need to access offchip storage. <br>
 <br>Reliable clock distribution is the key to the synchronous operation of highspeed <br>
digital circuits. If the clock signal arrives at different times at different parts of a circuit, <br>the device may fail to operate correctly. Clock skew reduces the available time budget <br>of a circuit by lengthening the setup time at registers. It can also shorten the effective <br>holdtime margin of a flipflop in a shift register and cause the register to shift incor-<br>rectly. At high clock frequencies (shorter clock periods), the effect of skew is more <br>significant because it represents a larger fraction of the clock cycle time. Buffered clock <br>trees are commonly used to minimize clock skew in FPGAs. Xilinx provides alldigital <br>DLLs for clock synchronization or management in highspeed circuits. DLLs eliminate <br>the clock distribution delay and provide frequency multipliers, frequency dividers, and <br>clock mirrors. <br>
 <br>Spartan II devices are suitable for applications such as implementing the glue logic <br>
of a video capture system and the glue logic of an ISDN modem. Device attributes are <br>summarized in  Table   7.8  , and the evolution of technology in the Spartan series is evident <br>in  the  data  in   Table    7.9   .    <br>
<b> <br>Table 7.8 <br><i> <br>Spartan II Device Attributes </b></i><br>
<i> <br></i><b>Spartan II FPGAs</b><i>   </i><b>XC2S15</b><i>   </i><b>XC2S30</b><i>   </i><b>XC2S50</b><i>   </i><b>XC2S100</b><i>   </i><b>XC2S150</b><i>   </i><b>XC2S200</b><i> </i><br>
 System  Gates  1   <br>
 6K�15K <br>
 13K�30K <br>
 23K�50K <br>
 37K�100K <br>
 52K�150K <br>
 71K�200K <br>
 Logic  Cells  2   <br>
 432 <br>
 972 <br>
 1,728 <br>
 2,700 <br>
 3,888 <br>
 5,292 <br>
 Block  RAM  Bits <br>
 16,384 <br>
 24,576 <br>
 32,768 <br>
 40,960 <br>
 49,152 <br>
 57,344 <br>
 Max  Avail  I/O <br>
 86 <br>
 132 <br>
 176 <br>
 196 <br>
 260 <br>
 284 <br>
 <br>1 20�30% of CLBs as RAM. <br> <br>2 1 Logic cell = fourinput lookup table + fl ipfl op. <br>
<b> <br>Table 7.9 <br><i> <br>Comparison of the Spartan Device Families </b></i><br>
<i> <br></i><b>Part</b><i> </i><br>
<i> <br></i><b>Spartan</b><i> </i><br>
<i> <br></i><b>Spartan XL</b><i> </i><br>
<i> <br></i><b>Spartan II</b><i> </i><br>
 Architecture <br>
 XC4000  Based <br>
 XC4000  Based <br>
 Virtex  Based <br>
 Max  #  System  Gates <br>
 5K�40K <br>
 5K�40K <br>
 15K�200K <br>
 Memory <br>
 Distributed  RAM <br>
 Distributed  RAM <br>
    Block  +     Distributed <br>
 I/O  Performance <br>
 80  MHz <br>
 100  MHz <br>
 200  MHz <br>
 I/O  Standards <br>
 4 <br>
 4 <br>
 16 <br>
 Core  Voltage <br>
 5  V <br>
 3.3  V <br>
 2.5  V <br>
 DLLs <br>
 No <br>
 No <br>
 Yes <br>
<hr>
<A name=360></a><b>342    Chapter 7  Memory and Programmable Logic</b><br>
DLL<br>
DLL<br>
CLBs<br>
CLBs<br>
Block Select RAM<br>
Block Select RAM<br>
CLBs<br>
CLBs<br>
Block Select RAM<br>
Block Select RAM<br>
DLL<br>
I/O I/O I/O I/O I/O I/O<br>
DLL<br>
<b> <br>FIGURE 7.28   <br> <br>Spartan II architecture  </b><br>
 <br>The toplevel tiled architecture of the Spartan II device, shown in  Fig.   7.28 , marks <br>
a new organization structure of the Xilinx parts. Each of four quadrants of CLBs is <br>supported by a DLL and is flanked by a 4,096bit block  6  of RAM, and the periphery <br>of the chip is lined with IOBs. <br>
 <br>Each CLB contains four logic cells, organized as a pair of slices. Each logic cell, shown <br>
in  Fig.   7.29 , has a fourinput lookup table, logic for carry and control, and a  <i>D</i> type <br>flipflop. The CLB contains additional logic for configuring functions of five or six inputs. <br>
 <br>The Spartan II part family provides the flexibility and capacity of an onchip block <br>
RAM; in addition, each lookup table can be configured as a   16 * 1     RAM  (distributed), <br>and the pair of lookup tables in a logic cell can be configured as a   16 * 2     bit  RAM  or <br>a     32 * 1     bit  RAM. <br>
 <br>The IOBs of the Spartan II family are individually programmable to support the <br>
reference, output voltage, and termination voltages of a variety of highspeed memory <br>
 <br>6 Parts are available with up to 14 blocks (56K bits). <br>
<hr>
<A name=361></a><b>Section 7.8  Sequential Programmable Devices    343</b><br>
Logic Cell<br>
<i>COUT</i><br>
<i>YB</i><br>
<i>Y</i><br>
<i>G4</i><br>
I4<br>
Lookup<br>
D S Q<br>
<i>YQ</i><br>
Carry<br>
<i>G3</i><br>
I3 Table<br>
and<br>
O<br>
CK<br>
Control<br>
<i>G2</i><br>
I2<br>
Logic<br>
EC R<br>
<i>G1</i><br>
I1<br>
<i>F5IN</i><br>
<i>BY</i><br>
<i>SR</i><br>
<i>XB</i><br>
<i>X</i><br>
<i>F4</i><br>
I4<br>
D S Q<br>
<i>XQ</i><br>
Carry<br>
Lookup<br>
and<br>
CK<br>
<i>F3</i><br>
I3 Table<br>
Control<br>
O<br>
Logic<br>
<i>F2</i><br>
I2<br>
EC R<br>
<i>F1</i><br>
I1<br>
<i>BX</i><br>
<i>CIN</i><br>
<i>CLK</i><br>
<i>CE</i><br>
<b> <br>FIGURE 7.29   <br> <br>Spartan II CLB slice  </b><br>
and bus standards. (See  Fig.   7.30  .) Each IOB has three registers that can function as <br> <br><i>D</i> type flipflops or as levelsensitive latches. One register ( <i>TFF </i> ) can be used to reg-<br>ister the signal that (synchronously) controls the programmable output buffer. A sec-<br>ond register ( <i>OFF </i> ) can be programmed to register a signal from the internal logic. <br>(Alternatively, a signal from the internal logic can pass directly to the output buffer.) <br>The third device can register the signal coming from the I/O pad. (Alternatively, this <br>
<hr>
<A name=362></a><b>344    Chapter 7  Memory and Programmable Logic</b><br>
<i>T</i><br>
D SR Q<br>
VCCO<br>
TFF<br>
Package Pin<br>
<i>CLK</i><br>
CK<br>
VCC<br>
<i>TCE</i><br>
EC<br>
I<br>
OE<br>
/O<br>
Programmable<br>
<i>SR</i><br>
Bias &amp;<br>
Package Pin<br>
ESD Network<br>
<i>O</i><br>
D SR Q<br>
Programmable<br>
OFF<br>
output buffer<br>
CK<br>
Internal<br>
Reference<br>
<i>OCE</i><br>
EC<br>
Programmable<br>
Delay<br>
<i>IQ</i><br>
I/O<br>
<i>I</i><br>
D SR Q<br>
Package Pin<br>
IFF<br>
Programmable<br>
CK<br>
input buffer<br>
<i>ICE</i><br>
EC<br>
To Other<br>
To Next<br>
External<br>
I/O<br>
VREF<br>
Inputs of <br>
Banks<br>
<b> <br>FIGURE 7.30   <br> <br>Spartan II IOB  </b><br>
signal can pass directly to the internal logic.) A common clock drives each register, <br>but each has an independent clock enable. A programmable delay element on the <br>input path can be used to eliminate the padtopad hold time. <br>
<b> <br>Xilinx Virtex FPGAs </b><br>
 <br>The Virtex device series  7  is the leading edge of Xilinx technology. This family of <br>devices addresses four key factors that influence the solution to complex systemlevel <br>and systemonchip designs: (1) the level of integration, (2) the amount of embedded <br>memory, (3) performance (timing), and (4) subsystem interfaces. The family targets <br>applications requiring a balance of highperformance logic, serial connectivity, signal <br>processing, and embedded processing (e.g., wireless communications). Process rules <br>
 <br>7 Virtex, VirtexII, II Platform, IIPro/Pro X, and Virtex5 MultiPlatform FPGA. <br>
<hr>
<A name=363></a><b>Section 7.8  Sequential Programmable Devices    345</b><br>
IOB<br>
Global<br>
DCM<br>
DCM<br>
Clock Mux<br>
Multiplier<br>
Multiplier<br>
Block Select RAM<br>
Block Select RAM<br>
CLBs<br>
CLBs<br>
CLBs<br>
Multiplier<br>
Multiplier<br>
Block Select RAM<br>
Block Select RAM<br>
DCM: Clock Manager<br>
<b> <br>FIGURE 7.31   <br> <br>Virtex II overall architecture  </b><br>
for leadingedge Virtex parts stand at 65 nm, with a 1V operating voltage. The rules <br>allow up to 330,000 logic cells and over 200,000 internal flipflops with clock enable, <br>together with over 10 Mb of block RAM, and 550MHz clock technology packed into <br>a single die. <br>
 <br>The Virtex family incorporates physical (electrical) and protocol support for <br>
20 different I/O standards, including LVDS and LVPECL, with individually program-<br>mable pins. Up to 12 digital clock managers provide support for frequency synthesis <br>and phase shifting in synchronous applications requiring multiple clock domains and <br>highfrequency I/O. The Virtex architecture is shown in  Fig.   7.31 , and its IOB is shown <br>in  Fig.  7.32 . <br>
<hr>
<A name=364></a><b>346    Chapter 7  Memory and Programmable Logic</b><br>
IOB<br>
Reg<br>
DDR mux<br>
OCK1<br>
Input<br>
Reg<br>
Reg<br>
ICK1<br>
OCK2<br>
3-State<br>
Reg<br>
ICK2<br>
Reg<br>
DDR mux<br>
OCK1<br>
PAD<br>
Reg<br>
OCK2<br>
3-State<br>
<b> <br>FIGURE 7.32   <br> <br>Virtex IOB block  </b><br>
<b> <br>P R O B L E M S </b><br>
 <br>
 <br>Answers to problems marked with <b>*</b> appear at the end of the book. <br>
 <br><b> 7.1 </b><br>
 <br>The memory units that follow are specified by the number of words times the number of <br>bits per word. How many address lines and input�output data lines are needed in each <br>case? <br>
 <br>
(a)       8K * 16        <br>
(b)       2G * 8 <br>
   <br>
(c)       16M * 32 <br>
(d)<b>  </b>     256K * 64 <br>
 <br><b> 7.2*  </b> Give the number of bytes stored in the memories listed in Problem 7.1. <br>
 <br><b> 7.3*  </b> Word number 563 in the memory shown in  Fig.   7.3   contains the binary equivalent of 1,212. <br>
List the 10bit address and the 16bit memory content of the word. <br>
 <br><b> 7.4 </b><br>
 <br>Show the memory cycle timing waveforms for the write and read operations. Assume a <br>CPU clock of 150 MHz and a memory cycle time of 20 ns. <br>
 <br><b> 7.5 </b><br>
 <br>Write a test bench for the ROM described in Example 7.1. The test program stores binary <br>7 in address 5 and binary 5 in address 7. Then the two addresses are read to verify their <br>stored  contents.   <br>
 <br><b> 7.6 </b><br>
  Enclose  the     4 * 4  RAM of  Fig.   7.6   in a block diagram showing all inputs and outputs. <br>Assuming threestate outputs, construct an   8 * 8     memory  using  four     4 * 4     RAM  units.   <br>
<hr>
<A name=365></a><b>Problems    347</b><br>
 <br><b> 7.7*  </b> A  16K * 4  memory uses coincident decoding by splitting the internal decoder into <br>
 <br><i>X</i> selection and  <i>Y</i> selection. <br>
 <br>
(a)   What is the size of each decoder, and how many AND gates are required for decoding <br>
the address?  <br>
   <br>
(b)    Determine  the   <i>X</i>  and  <i>Y</i>  selection lines that are enabled when the input address is the <br>
binary  equivalent  of  6,000.     <br>
 <br><b> 7.8*  </b>    (a)     How  many     32K * 8 RAM  chips are needed to provide a memory capacity of 256K <br>
bytes?  <br>
 <br>
(b)<b>  </b> How many lines of the address must be used to access 256K bytes? How many of these <br>
lines are connected to the address inputs of all chips?  <br>
 <br>
(c)<b>  </b> How many lines must be decoded for the chip select inputs? Specify the size of the <br>
decoder.     <br>
 <br><b> 7.9 </b><br>
 <br>A DRAM chip uses twodimensional address multiplexing. It has 13 common address pins, <br>with the row address having one bit more than the column address. What is the capacity <br>of the memory?  <br>
 <br><b> 7.10* </b> Given the 8bit data word 01011011, generate the 13bit composite word for the Hamming <br>
code that corrects single errors and detects double errors. <br>
 <br><b> 7.11* </b> Obtain the 15bit Hamming code word for the 11bit data word 11001001010. <br>
 <br><b> 7.12* </b> A 12bit Hamming code word containing 8 bits of data and 4 parity bits is read from <br>
memory. What was the original 8bit data word that was written into memory if the 12bit <br>word read out is as follows: <br>
 <br>
(a)  <br>
 <br>
000011101010   <br>
  (b)    101110000110  <br>
   <br>
(c)    101111110100     <br>
 <br><b> 7.13* </b> How many parity check bits must be included with the data word to achieve singleerror <br>
correction and doubleerror detection when the data word contains <br>
 <br>
(a)    16  bits.     <br>
(b)    32  bits.  <br>
   <br>
(c)    48  bits.     <br>
 <br><b> 7.14 </b><br>
 <br>It is necessary to formulate the Hamming code for four data bits,   <i>D</i>3, <i>D</i>5, <i>D</i>6,     and     <i>D</i>7,    <br>together with three parity bits,   <i>P</i>1, <i>P</i>2,     and     <i>P</i>4.    <br>
 <br>
<b>(</b>a)  <b>*</b>  Evaluate the 7bit composite code word for the data word 0010. <br>
 <br>
<b>(</b>b)<b>  </b> Evaluate three check bits,   <i>C</i>4, <i>C</i>2,     and     <i>C</i>1,     assuming  no  error.  <br>
 <br>
(c)<b>  </b> Assume an error in bit   <i>D</i>5  during writing into memory. Show how the error in the bit <br>
is detected and corrected. <br>
 <br>
(d)<b>  </b>  Add  parity  bit     <i>P</i>8  to include doubleerror detection in the code. Assume that errors <br>
occurred in bits   <i>P</i>2     and     <i>D</i>5.  Show how the double error is detected. <br>
 <br><b> 7.15 </b><br>
  Using     64  * 8   ROM chips with an enable input, construct a   512  * 8   ROM with eight chips <br>and a decoder. <br>
 <br><b> 7.16* </b> A ROM chip of   4,096 * 8 bits  has two chip select inputs and operates from a 5V power <br>
supply. How many pins are needed for the integrated circuit package? Draw a block dia-<br>gram, and label all input and output terminals in the ROM.  <br>
 <br><b> 7.17 </b><br>
 <br>The  32 * 6  ROM, together with the   20  line, as shown in Fig. P7.17, converts a sixbit binary <br>number to its corresponding twodigit BCD number. For example, binary 100001 converts <br>to BCD 011 0011 (decimal 33). Specify the truth table for the ROM. <br>
<hr>
<A name=366></a><b>348    Chapter 7  Memory and Programmable Logic</b><br>
20<br>
<i>D</i>1<br>
100<br>
21<br>
/1<br>
<i>D</i>2<br>
22<br>
/2<br>
<i>D</i>3<br>
32<br>
 6<br>
23<br>
/3<br>
ROM<br>
<i>D</i>4<br>
24<br>
/4<br>
<i>D</i>5<br>
101<br>
25<br>
/5<br>
<i>D</i>6<br>
<b> <br>FIGURE P7.17   </b><br>
 <br><b> 7.18* </b> Specify the size of a ROM (number of words and number of bits per word) that will <br>
accommodate the truth table for the following combinational circuit components: <br>
 <br>
(a)   a binary multiplier that multiplies two 4bit binary words, <br>
   <br>
(b)    a  4bit  adder�subtractor,  <br>
 <br>
(c)   a quadruple twotooneline multiplexer with common select and enable inputs, and  <br>
   <br>
(d)    a  BCDtosevensegment  decoder  with  an  enable  input.     <br>
 <br><b> 7.19 </b><br>
 <br>Tabulate the PLA programming table for the four Boolean functions listed below. Mini-<br>mize the numbers of product terms. <br>
 <i>A</i>(<i>x</i>, <i>y</i>, <i>z</i>) =<br>
(1, 3, 5, 6)<br>
<i>B</i>(<i>x</i>, <i>y</i>, <i>z</i>) =<br>
(0, 1, 6, 7)<br>
<i>C</i>(<i>x</i>, <i>y</i>, <i>z</i>) =<br>
(3, 5)<br>
<i>D</i>(<i>x</i>, <i>y</i>, <i>z</i>) =<br>
(1, 2, 4, 5, 7)  <br>
 <br><b> 7.20 </b><br>
 <br>Tabulate the truth table for an   8 * 4  ROM that implements the Boolean functions <br>
 <i>A</i>(<i>x</i>, <i>y</i>, <i>z</i>) =<br>
(0, 3, 4, 6)<br>
<i>B</i>(<i>x</i>, <i>y</i>, <i>z</i>) =<br>
(0, 1, 4, 7)<br>
<i>C</i>(<i>x</i>, <i>y</i>, <i>z</i>) =<br>
(1, 5)<br>
<i>D</i>(<i>x</i>, <i>y</i>, <i>z</i>) =<br>
(0, 1, 3, 5, 7)  <br>
 <br>
 <br>
 <br>Considering now the ROM as a memory. Specify the memory contents at addresses 1 and 4. <br>
 <br><b> 7.21 </b><br>
 <br>Derive the PLA programming table for the combinational circuit that squares a threebit <br>number. Minimize the number of product terms. (See  Fig.   7.12  for the equivalent ROM <br>implementation.)   <br>
 <br><b> 7.22 </b><br>
 <br>Derive the ROM programming table for the combinational circuit that squares a 4bit <br>number. Minimize the number of product terms. <br>
 <br><b> 7.23 </b><br>
 <br>List the PLA programming table for the BCDtoexcess3code converter whose Boolean <br>functions are simplified in Fig. 4.3.  <br>
<hr>
<A name=367></a><b>References    349</b><br>
 <br><b> 7.24 </b><br>
 <br>Repeat Problem 7.23, using a PAL. <br>
 <br><b> 7.25* </b> The following is a truth table of a threeinput, fouroutput combinational circuit: <br>
<i> <br></i><b>Inputs</b><i> </i><br>
<i> <br></i><b>Outputs</b><i> </i><br>
<i><b> <br>x  </b></i><br>
<i><b> <br>y  </b></i><br>
<i><b> <br>z  </b></i><br>
<i><b> <br>A  </b></i><br>
<i><b> <br>B  </b></i><br>
<i><b> <br>C  </b></i><br>
<i><b> <br>D  </b></i><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 <br>
 <br>
 <br>Tabulate the PAL programming table for the circuit, and mark the fuse map in a PAL <br>diagram similar to the one shown in  Fig.   7.17 .  <br>
 <br><b> 7.26 </b><br>
 <br>Using the registered macrocell of  Fig.   7.19 , show the fuse map for a sequential circuit with <br>two inputs  <i>x</i>  and  <i>y</i>  and one flipflop  <i>A</i>  described by the input equation <br>
 <br><i>DA </i>= <i>x </i>{ <i>y </i>{ <i>A</i> <br>
 <br><b> 7.27 </b><br>
  Modify  the  PAL  diagram  of   Fig.    7.16     by  including  three  clocked   <i>D</i> type  flipflops  between <br>the OR gates and the outputs, as in  Fig.   7.19 . The diagram should conform with the block <br>diagram of a sequential circuit. The modification will require three additional buffer�<br>inverter gates and six vertical lines for the flipflop outputs to be connected to the AND <br>array through programmable connections. Using the modified registered PAL diagram, <br>show the fuse map that will implement a threebit binary counter with an output carry. <br>
 <br><b> 7.28 </b><br>
 <br>Draw a PLA circuit to implement the functions <br>
 <br><i>F</i>1 = <i>A B </i>+ <i>AC </i>+ <i>A BC</i><br>
<i>F</i>2 = (<i>AC </i>+ <i>AB </i>+ <i>BC</i>)  <br>
 <br><b> 7.29 </b><br>
 <br>Develop the programming table for the PLA described in Problem 7.26. <br>
<b> <br>R E F E R E N C E S </b><br>
<b> </b><br>
<b> <br>1.  </b><br>
H amming,  R. W. 1950. Error Detecting and Error Correcting Codes.  <i>Bell Syst. Tech. J.</i> <br>29: 147�160. <br>
 <br>
 <br><b>2.</b> <br>
 K itson,   B.  1984.   <i>Programmable Array Logic Handbook</i> . Sunnyvale, CA: Advanced Micro <br>Devices.  <br>
 <br>
 <br><b>3.</b> <br>
 <br>L in,  S. and D. J. C ostello,   jr . 2004.  <i>Error Control Coding </i>. 2 nd  ed. Englewood Cliffs, NJ: <br>PrenticeHall.  <br>
 <br>
 <br><b>4.</b> <br>
 <br><i>Memory Components Handbook</i>. 1986. Santa Clara, CA: Intel. <br>
 <br>
 <br><b>5.</b> <br>
 <br>N elson, V. P., H. T. N agle,  J. D. I rwin,  and B. D. C arroll . 1995.  <i>Digital Logic Circuit <br>Analysis and Design</i>.  Upper Saddle River, NJ: Prentice Hall. <br>
<hr>
<A name=368></a><b>350    Chapter 7  Memory and Programmable Logic</b><br>
 <br>
 <br><b>6.</b> <br>
 <br><i>The Programmable Logic Data Book</i>, 2nd ed. 1994. San Jose, CA: Xilinx, Inc. <br>
 <br>
 <br><b>7.</b> <br>
 <br>T occi,  R. J. and N. S. W idmer . 2004.  <i>Digital Systems Principles and Applications</i>,  9th ed. <br>Upper Saddle River, NJ: Prentice Hall. <br>
 <br>
 <br><b>8.</b> <br>
 <br>T rimberger,  S. M. 1994.  <i>Field Programmable Gate Array Technology</i>.  Boston: Kluwer <br>Academic Publishers. <br>
 <br>
 <br><b>9.</b> <br>
 <br>W akerly,  J. F. 2006.  <i>Digital Design: Principles and Practices</i>,  4th ed. Upper Saddle River, <br>NJ: Prentice Hall. <br>
<b> <br>W E B   S E A R C H   T O P I C S </b><br>
 <br>
 <br>
   FPGA  <br>
 <br>
 <br>
  Gate  array  <br>
 <br>
 <br>
  Programmable  array  logic  <br>
 <br>
 <br>
 <br>Programmable logic data book  <br>
 <br>
 <br>
  RAM  <br>
 <br>
 <br>
 <br>ROM <br>
<hr>
<A name=369></a> <br>Chapter 8 <br>
<b> <br>Design at the Register Transfer Level </b> <br>
<b> <br>8 . 1       IN T R O D U C T I O N </b><br>
 <br>The behavior of many digital systems depends on the history of their inputs, and the <br>conditions that determine their future actions depend on the results of previous actions. <br>Such systems are said to have "memory." A digital system is a sequential logic system <br>constructed with flipflops and gates. Sequential circuits can be specified by means of <br>state tables as shown in  Chapter   5  . To specify a large digital system with a state table is <br>very difficult, because the number of states would be enormous. To overcome this dif-<br>ficulty, digital systems are designed via a modular approach. The system is partitioned <br>into subsystems, each of which performs some function. The modules are constructed <br>from such digital devices as registers, decoders, multiplexers, arithmetic elements, and <br>control logic. The various modules are interconnected with datapaths and control signals <br>to form a digital system. In this chapter, we will introduce a design methodology for <br>describing and designing large, complex digital systems. <br>
<b> <br>8 . 2       R E G I S T E R   T R A N S F E R   L E V E L   N O TAT I O N </b><br>
 <br>The modules of a digital system are best defined by a set of registers and the opera-<br>tions that are performed on the binary information stored in them. Examples of <br>register operations are  <i>shift</i>,    <i>count</i>,    <i>clear</i>,  and  <i>load</i> . Registers are assumed to be the <br>basic components of the digital system. The information flow and processing per-<br>formed on the data stored in the registers are referred to as  <i>register transfer opera-<br>tions</i> . We'll see subsequently how a hardware description language (HDL) includes <br>operators that correspond to the register transfer operations of a digital system. <br>
<b>351</b><br>
<hr>
<A name=370></a><b>352    Chapter 8  Design at the Register Transfer Level</b><br>
A digital system is represented at the  <i>register transfer level</i>  (RTL) when it is specified <br>by the following three components: <br>
 <br><b> 1. </b><br>
 <br>The set of registers in the system. <br>
 <br><b> 2. </b><br>
 <br>The operations that are performed on the data stored in the registers. <br>
 <br><b> 3. </b><br>
 <br>The control that supervises the sequence of operations in the system. <br>
 <br>A register is a connected group of flipflops that stores binary information and has the <br>capability of performing one or more elementary operations. A register can load new <br>information or shift the information to the right or the left. A counter is a register that <br>increments a number by a fixed value (e.g., 1). A flipflop is a onebit register that can <br>be set, cleared, or complemented. In fact, the flipflops and associated gates of any <br>sequential circuit can be called registers by this definition. <br>
 <br>The operations executed on the information stored in registers are elementary oper-<br>
ations that are performed in parallel on the bits of a data word during one clock cycle. <br>The data produced by the operation may replace the binary information that was in the <br>register before the operation executed. Alternatively, the result may be transferred to <br>another register (i.e., an operation on a register may leave its contents unchanged). The <br>digital circuits introduced in  Chapter   6   are registers that implement elementary opera-<br>tions. A counter with a parallel load is able to perform the incrementbyone and load <br>operations. A bidirectional shift register is able to perform the shiftright and shiftleft <br>operations by shifting its contents by one or more bits in a specified direction. <br>
 <br>The operations in a digital system are controlled by signals that sequence the opera-<br>
tions in a prescribed manner. Certain conditions that depend on results of previous <br>operations may determine the sequence of future operations. The outputs of the control <br>logic of a digital system are binary variables that initiate the various operations in the <br>system's registers. <br>
 <br>Information transfer from one register to another is designated in symbolic form by <br>
means of a replacement operator. The statement <br>
 <br><i>R2 </i>d <i>R1</i> <br>
 <br>denotes a transfer of the contents of register  <i>R1</i>  into register  <i>R2</i> --that is, a replacement <br>of the contents of register  <i>R2</i>  by the contents of register  <i>R1</i> . For example, an eightbit <br>register  <i>R</i> <i>2</i> holding the value 01011010 could have its contents replaced by  <i>R</i> <i>1</i> holding <br>the value 10100101. By definition, the contents of the source register  <i>R1</i>  do not change <br>after the transfer. They are merely copied to  <i>R1</i> . The arrow symbolizes the transfer and <br>its direction; it points from the register whose contents are being transferred and towards <br>the register that will receive the contents. A control signal would determine when the <br>operation actually executes. <br>
 <br>The controller in a digital system is a finite state machine (see Chapter 5) whose <br>
outputs are the control signals governing the register operations. In synchronous <br>machines, the operations are synchronized by the system clock. For example, register <br> <br><i>R</i> <i>2</i> might be synchronized to have its contents replaced at the positive edge of the clock. <br>
 <br>A statement that specifies a register transfer operation implies that a datapath (i.e., <br>
a set of circuit connections) is available from the outputs of the source register to the <br>
<hr>
<A name=371></a><b>Section 8.2  Register Transfer Level Notation    353</b><br>
inputs of the destination register and that the destination register has a parallel load <br>capability. Data can be transferred serially between registers, too, by repeatedly shifting <br>their contents along a single wire, one bit at a time. Normally, we want a register transfer <br>operation to occur, not with every clock cycle, but only under a predetermined condition. <br>A conditional statement governing a register transfer operation is symbolized with an <br>if�then statement such as <br>
 <br>If (<i>T1 </i>= 1) then (<i>R2 </i>d <i>R1</i>)   <br>
 where   <i>T1</i>  is a control signal generated in the control section. Note that the clock is not <br>included as a variable in the register transfer statements. It is assumed that all transfers <br>occur at a clockedge transition (i.e., a transition from 0 to 1 or from 1 to 0). Although <br>a control condition such as  <i>T1</i>  may become true before the clock transition, the actual <br>transfer does not occur until the clock transition does. The transfers are initiated and <br>synchronized by the action of the clock signal, but the actual transition of the outputs <br>(in a physical system) does not result in instantaneous transitions at the outputs of the <br>registers. Propagation delays depend on the physical characteristics of the transistors <br>implementing the flipflops of the register and the wires connecting devices. There is <br>always a delay, however small, between a cause and its effect in a physical system. <br>
 <br>A comma may be used to separate two or more operations that are executed at the <br>
same time (concurrently). Consider the statement <br>
 <br>If (<i>T3 </i>= 1) then (<i>R2 </i>d <i>R1</i>,  <i>R1 </i>d <i>R2</i>)   <br>
 <br>This statement specifies an operation that exchanges the contents of two registers; more-<br>over, the operation in both registers is triggered by the same clock edge, provided that <br> <br><i>T3 </i>= 1. This simultaneous (concurrent) operation is possible with registers that have <br>edgetriggered flipflops controlled by a common clock (synchronizing signal). Other <br>examples of register transfers are as follows: <br>
 <br><i>R1 </i>d <i>R1 </i>+ <i>R2</i>   <br>
Add contents of  <i>R2</i>  to  <i>R1</i>   ( <i>R1</i>  gets  <i>R1</i>  +  <i>R2</i> ) <br>
 <br><i>R3 </i>d <i>R3 </i>+ 1      <br>
Increment   <i>R3</i>  by 1 (count upwards) <br>
 <br><i>R4 </i>d shr <i>R4</i>      <br>
Shift  right   <i>R4</i> <br>
 <br><i>R5 </i>d 0      <br>
Clear   <i>R5</i>  to 0 <br>
 <br>In hardware, addition is done with a binary parallel adder, incrementing is done with a <br>counter, and the shift operation is implemented with a shift register. The type of opera-<br>tions most often encountered in digital systems can be classified into four categories: <br>
 <br><b> 1. </b><br>
 <br>Transfer operations, which transfer (i.e., copy) data from one register to another. <br>
 <br><b> 2. </b><br>
 <br>Arithmetic operations, which perform arithmetic (e.g., multiplication) on data in <br>registers.  <br>
 <br><b> 3. </b><br>
 <br>Logic operations, which perform bit manipulation (e.g., logical OR) of non numeric <br>data in registers. <br>
 <br><b> 4. </b><br>
 <br>Shift operations, which shift data between registers. <br>
 <br>The transfer operation does not change the information content of the data being moved <br>from the source register to the destination register unless the source and destination are <br>
<hr>
<A name=372></a><b>354    Chapter 8  Design at the Register Transfer Level</b><br>
the same. The other three operations change the information content during the trans-<br>fer. The register transfer notation and the symbols used to represent the various regis-<br>ter transfer operations are not standardized. In this text, we employ two types of <br>notation. The notation introduced in this section will be used informally to specify and <br>explain digital systems at the register transfer level. The next section introduces the <br>RTL symbols used in the Verilog HDL, which is standardized. <br>
<b> <br>8 . 3       R E G I S T E R   T R A N S F E R   L E V E L   I N   H D L </b><br>
 <br>Digital systems can be described at the register transfer level by means of a HDL. In the <br>Verilog HDL, descriptions of RTL operations use a combination of behavioral and data-<br>flow constructs and are employed to specify the register operations and the combina-<br>tional logic functions implemented by hardware. Register transfers are specified by <br>means of procedural assignment statements within an  <i>edgesensitive cyclic behavior.</i> <br>Combinational circuit functions are specified at the RTL level by means of continuous <br>assignment statements or by procedural assignment statements within a  <i>levelsensitive <br>cyclic behavior.</i> The symbol used to designate a register transfer is either an equals sign <br>(=) or an arrow (6 =); the symbol used to specify a combinational circuit function is an <br>equals sign. Synchronization with the clock is represented by associating with an  <b>always</b> <br>statement an event control expression in which sensitivity to the clock event is qualified <br>by  <b>posedge</b>  or  <b>negedge</b> .  The   <i>always</i>  keyword indicates that the associated block of state-<br>ments will be executed repeatedly, for the life of the simulation. The  @  operator and the <br>event control expression preceding the block of statements synchronize the execution <br>of the statements to the clock event. <br>
 <br>The following examples show the various ways to specify a register transfer operation <br>
in Verilog: <br>
 <br><b>(a) assign</b>  S = A + B; <br>
 <br>
// Continuous assignment for addition operation<br>
 <br><b>(b) always</b>   <b>@</b>  (A, B) <br>
 <br>
// Level-sensitive cyclic behavior<br>
    S = A + B; <br>
 <br>
 <br>
// Combinational logic for addition operation<br>
 <br><b>(c) always</b>   <b>@</b>  ( <b>negedge</b>  clock) <br>
// Edge-sensitive cyclic behavior<br>
    <b>begin</b> <br>      RA = RA + RB; <br>
 <br>
// Blocking procedural assignment for addition<br>
      RD = RA; <br>
// Register transfer operation<br>
    <b>end</b> <br> <br><b>(d) always</b>   <b>@</b>  ( <b>negedge</b>  clock) <br>
// Edge-sensitive cyclic behavior<br>
    <b>begin</b> <br>      RA &lt;= RA + RB; <br>
 <br>
// Nonblocking procedural assignment for addition<br>
      RD &lt;= RA; <br>
// Register transfer operation<br>
    <b>end</b> <br>
 <br>Continuous assignments (e.g.,  <b>assign</b>  S = A + B;) are used to represent and specify <br>
combinational logic circuits. In simulation, a continuous assignment statement executes <br>when the expression on the righthand side changes. The effect of execution is immediate. <br>
<hr>
<A name=373></a><b>Section 8.3  Register Transfer Level in HDL    355</b><br>
(The variable on the lefthand side is updated.) Similarly, a levelsensitive cyclic behav-<br>ior (e.g.,  <b>always</b>  @ (A, B)) executes during simulation when a change is detected by its <br>event control expression (sensitivity list). The effect of assignments made by the = oper-<br>ator is immediate. The continuous assignment statement ( <b>assign</b>  S = A + B) describes a <br>binary adder with inputs  <i>A</i>  and  <i>B</i>  and output  <i>S</i> . The target operand in a continuous <br>assignment statement ( <i>S</i>  in this case) cannot be a register data type, but must be a type <br>of net, for example,  <b>wire</b> . The procedural assignment made in the levelsensitive cyclic <br>behavior in the second example shows an alternative way of specifying a combinational <br>circuit for addition. Within the cyclic behavior, the mechanism of the sensitivity list <br>ensures that the output,  <i>S</i>,  will be updated whenever  <i>A</i>,  or  <i>B</i>,  or both change. <br>
 <br>There are two kinds of procedural assignments:  <i>blocking</i>  and  <i>nonblocking</i> .  The  two <br>
are distinguished by their symbols and by their operation.  <i>Blocking</i>  assignments use the <br>equals symbol (=) as the assignment operator, and  <i>nonblocking</i>  assignments use the left <br>arrow (6 =) as the operator. Blocking assignment statements are executed  <i>sequentially</i> <br>in the order that they are listed in a sequential block; when they execute, they have an <br>immediate effect on the contents of memory before the next statement can be executed. <br>Nonblocking assignments are made  <i>concurrently</i> . This feature is implemented by evalu-<br>ating the expression on the righthand side of each statement in the list of statements <br>before making the assignment to their lefthand sides. Consequently,  <i>there is no interac-<br>tion between the result of any assignment and the evaluation of an expression affecting <br>another assignment</i>. Also, the statements associated with an edgesensitive cyclic behav-<br>ior do not execute until the indicated edge condition occurs. Consider (c) in the example <br>given above. In the list of blocking procedural assignment, the first statement transfers the <br>sum ( <i>RA + RB</i> ) to  <i>RA</i>,  and the second statement transfers the new value of  <i>RA</i>  into  <i>RD</i> . <br>The value in  <i>RA</i>  after the clock event is the sum of the values in  <i>RA</i>  and  <i>RB</i>   immediately <br>before the clock event. At the completion of the operation, both  <i>RA</i>  and  <i>RD</i>  have the <br>same value. In the nonblocking procedural assignment ((d) above), the two assignments <br>are performed concurrently, so that  <i>RD</i>  receives the original value of  <i>RA</i> .  The  activity <br>in both examples is launched by the clock undergoing a falling edge transition. <br>
 <br>The registers in a system are clocked simultaneously (concurrently). The  <i>D</i> input  of <br>
each flipflop determines the value that will be assigned to its output, independently of <br>the input to any other flipflop. To ensure synchronous operations in RTL design, and <br>to ensure a match between an HDL model and the circuit synthesized from the model, <br>it is necessary that nonblocking procedural assignments be used for all variables that <br>are assigned a value within an edgesensitive cyclic behavior ( <b>always</b>  clocked). The non-<br>blocking assignment that appears in an edgesensitive cyclic behavior models the behav-<br>ior of the hardware of a synchronous sequential circuit accurately. In general, the <br>blocking assignment operator (=) is used in a procedural assignment statement only <br>when it is necessary to specify a sequential ordering of multiple assignment statements. <br>
<b> <br>HDL Operators </b><br>
 <br>The Verilog HDL operators and their symbols used in RTL design are listed in  Table  8.1 . <br>The arithmetic, logic, and shift operators describe register transfer operations. The <br>
<hr>
<A name=374></a><b>356    Chapter 8  Design at the Register Transfer Level</b><br>
<b> <br>Table 8.1 <br><i> <br>Verilog 2001 HDL Operators </b></i><br>
<b> <br>Operator Type </b><br>
<b> <br>Symbol  </b><br>
<b>Operation Performed </b><br>
 Arithmetic <br>
 <br>+ <br>
 addition <br>
 <br>
 <br>� <br>
 subtraction <br>
 <br>
 <br>* <br>
 multiplication <br>
 <br>
 <br>/ <br>
 division <br>
 <br>
 <br>% <br>
 modulus <br>
 <br>
 <br>** <br>
 exponentiation <br>
 <br>Bitwise or Reduction <br>
 <br>~ <br>
 negation  (complement) <br>
 <br>
 <br>&amp; <br>
 AND <br>
 <br>
 <br>| <br>
 OR <br>
 <br>
 <br>^ <br>
 exclusiveOR  (XOR) <br>
 Logical <br>
 <br>! <br>
 negation <br>
 <br>
 <br>&amp;&amp; <br>
 AND <br>
 <br>
 <br>|| <br>
 OR <br>
 Shift <br>
 <br>&gt;&gt; <br>
 <br>logical right shift <br>
 <br>
 <br>&lt;&lt; <br>
 <br>logical left shift <br>
 <br>
 <br>&gt;&gt;&gt; <br>
 <br>arithmetic right shift <br>
 <br>
 <br>&lt;&lt;&lt; <br>
 <br>arithmetic left shift <br>
 <br>
 <br>{ , } <br>
 concatenation <br>
 Relational <br>
 <br>&gt; <br>
 greater  than <br>
 <br>
 <br>&lt; <br>
 less  than <br>
 <br>
 <br>== <br>
 equality <br>
 <br>
 <br>!= <br>
 inequality <br>
 <br>
 <br>=== <br>
 case  equality <br>
 <br>
 <br>!== <br>
 case  inequality <br>
 <br>
 <br>&gt;= <br>
 <br>greater than or equal <br>
 <br>
 <br>&lt;= <br>
 <br>less than or equal <br>
logical and relational operators specify control conditions and have Boolean expres-<br>sions as their arguments. <br>
 <br>The operands of the arithmetic operators are numbers. The +, -, *, and / operators <br>
form the sum, difference, product, and quotient, respectively, of a pair of operands. <br>The exponentiation operator (**) was added to the language in 2001 and forms a <br>doubleprecision floatingpoint value from a base and exponent having a real, integer, <br>
<hr>
<A name=375></a><b>Section 8.3  Register Transfer Level in HDL    357</b><br>
or signed value. Negative numbers are represented in 2'scomplement form. The mod-<br>ulus operator produces the remainder from the division of two numbers. For example, <br>14 % 3 evaluates to 2. <br>
 <br>There are two types of binary operators for binary words: bitwise and reduction. The <br>
bitwise operators perform a bitbybit operation on two vector operands to form a vec-<br>tor result. They take each bit in one operand and perform the operation with the cor-<br>responding bit in the other operand. Negation (~) is a unary operator; it complements <br>the bits of a single vector operand to form a vector result. The reduction operators are <br>also unary, acting on a single operand and producing a scalar (onebit) result. They oper-<br>ate pairwise on the bits of a word, from right to left, and yield a onebit result. For <br>example, the reduction NOR (~|) results in 0 with operand 00101 and in 1 with operand <br>00000. The  result of applying the NOR operation on the first two bits is used with the <br>third bit, and so forth. Negation is not used as a reduction operator -- its operation on <br>a vector produces a vector. Truth tables for the bitwise operators acting on a pair of <br>scalar operands are the same as those listed in Table 4.9 in Section 4.12 for the corre-<br>sponding Verilog primitive (e.g., the  <b>and</b>  primitive and the  <b>&amp;</b>  bitwise operator have the <br>same truth table). The output of an AND gate with two scalar inputs is the same as the <br>result produced by operating on the two bits with the  <b>&amp;</b>   operator. <br>
 <br>The logical and relational operators are used to form Boolean expressions and can <br>
take variables or expressions as operands. ( <i>Note</i> : A variable is also an expression.) Used <br>basically for determining true or false conditions, the logical and relational operators <br>evaluate to 1 if the condition expressed is true and to 0 if the condition is false. If the <br>condition is ambiguous, they evaluate to x. An operand that is a variable evaluates to 0 <br>if the value of the variable is equal to zero and to 1 if the value is not equal to zero. For <br>example, if  <i>A</i> = 1010 and  <i>B</i> = 0000, then the expression  <i>A</i>  has the Boolean value 1 (the <br>number in question is not equal to 0) and the expression  <i>B</i>  has the Boolean value 0. <br>Results of other operations with these values are as follows: <br>
 <br>A &amp;&amp; B = 0 <br>
 <br>// Logical AND: <br>
 <br>(1010) &amp;&amp; (0000) = 0 <br>
 <br>A &amp; B = 0000 <br>
 <br>// Bitwise AND: <br>
 <br>(1010) &amp; (1010) = (0000) <br>
 <br>A || B = 1 <br>
 <br>// Logical OR: <br>
 <br>(1010) || (0000) = 1 <br>
 <br>A | B = 1010 <br>
 <br>// Bitwise OR: <br>
 <br>(1010) | (0000) = (1010) <br>
 <br>!A = 0 <br>
 <br>// Logical negation <br>
 <br>!(1010) = !(1) = 0 <br>
 <br>~A = 0101 <br>
 <br>// Bitwise negation <br>
 <br>~(1010) = (0101) <br>
 <br>!B = 1 <br>
 <br>// Logical negation <br>
 <br>!(0000) = !(0) = 1 <br>
 <br>~B = 1111 <br>
 <br>// Bitwise negation <br>
 <br>~(0000) = 1111 <br>
 <br>(A &gt; B) = 1 <br>
 <br>// is greater than <br>
 <br>
 <br>(A == B) = 0 <br>
 <br>// identity (equality) <br>
 <br>
 <br>The relational operators = = = and ! = = test for bitwise equality (identity) and inequal-<br>ity in Verilog's fourvalued logic system. For example, if  <i>A</i> = 0xx0 and  <i>B</i> = 0xx0, the test <br> <br><i>A</i> = = =  <i>B</i>  would evaluate to true, but the test  <i>A</i> = =  <i>B</i>  would evaluate to x. <br>
<hr>
<A name=376></a><b>358    Chapter 8  Design at the Register Transfer Level</b><br>
 <br>Verilog 2001 has logical and arithmetic shift operators. The logical shift operators shift <br>
a vector operand to the right or the left by a specified number of bits. The vacated bit <br>positions are filled with zeros. For example, if  <i>R</i>  = 11010, then the statement <br>
 <br>R = R &gt;&gt; 1;  <br>
 shifts   <i>R</i>  to the right one position. The value of  <i>R</i>  that results from the logical rightshift <br>operation (11010) &gt;&gt; 1 is 01101. In contrast, the arithmetic rightshift operator fills the <br>vacated cell (the most significant bit (MSB)) with its original contents when the word <br>is shifted to the right. The arithmetic leftshift operator fills the vacated cell with a 0 <br>when the word is shifted to the left. The arithmetic rightshift operator is used when the <br>sign extension of a number is important. If  <i>R</i>  = 11010, then the statement <br>
 <br>R &gt;&gt;&gt; 1;  <br>
 <br>produces the result  <i>R</i> = 11101; if  <i>R</i> = 01101, it produces the result  <i>R</i> = 00110. There is <br>no distinction between the logical leftshift and the arithmetic leftshift operators. <br>
 <br>The concatenation operator provides a mechanism for appending multiple oper-<br>
ands. It can be used to specify a shift, including the bits transferred into the vacant <br>positions. This aspect of its operation was shown in HDL Example 6.1 for the shift <br>register. <br>
 <br>Expressions are evaluated from left to right, and their operators associate from left <br>
to right (with the exception of the conditional operator) according to the precedence <br>shown in  Table   8.2  . For example, in the expression  <i>A + B � C</i> , the value of  <i>B</i>  is added <br>to  <i>A</i>,  and then  <i>C</i>  is subtracted from the result. In the expression  <i>A + B/C</i>,  the value of <br> <br><i>B</i>  is divided by  <i>C</i>,  and then the result is added to A because the division operator ( / ) <br>has a higher precedence than the addition operator (+). Use parentheses to establish <br>precedence. For example, the expression ( <i>A + B</i> )/ <i>C</i>  is not the same as the expression <br> <br><i>A + B/C</i>.   <br>
<b> <br>Loop Statements </b><br>
 <br>Verilog HDL has four types of loops that execute procedural statements repeatedly: <br> <br><i>repeat, forever, while</i>,  and  <i>for</i>. All looping statements must appear inside an  <b>initial</b>   or <br> <br><b>always</b>   block. <br>
 The  <b>repeat</b> loop executes the associated statements a specified number of times. The <br>
following is an example that was used previously: <br>
 <br><b>initial</b> <br>  <b>begin</b> <br>  clock = 1'b0;<br>
  <b>repeat</b>  (16)<br>    #5 clock = ~ clock;<br>
  <b>end</b> <br>
 <br>This code toggles the clock 16 times and produces eight clock cycles with a cycle time <br>of 10 time units. <br>
<hr>
<A name=377></a><b>Section 8.3  Register Transfer Level in HDL    359</b><br>
<b> <br>Table 8.2 <br><i> <br>Verilog Operator Precedence </b></i><br>
 <br>+ - ! ~ &amp; ~&amp; | ~ | ^ ~^ ^~ (unary) <br>
 <br>Highest precedence <br>
 ** <br>
 <br>* / % <br>
 <br>+ - (binary) <br>
 <br>
&lt;&lt; &gt;&gt; &lt;&lt;&lt; &gt;&gt;&gt; <br>
 <br>&lt; &lt; = &gt; &gt; = <br>
 <br>
== != === !== <br>
 &amp;  (binary) <br>
 <br>^ ^~  ~^ (binary) <br>
 |  (binary) <br>
 &amp;&amp; <br>
 || <br>
 <br>?: (conditional operator) <br>
 <br>{ } { { } } <br>
 <br>Lowest precedence <br>
 The   <b>forever</b>  loop causes unconditional, repetitive execution of a procedural statement <br>
or a block of procedural statements. For example, the following loop produces a con-<br>tinuous clock having a cycle time of 20 time units: <br>
 <br><b>initial</b> <br>  <b>begin</b> <br> <br>  clock = 1'b0;<br>
  <b>forever</b> <br>    #10 clock = ~ clock;<br>
  <b>end</b> <br>
 The   <b>while</b>  loop executes a statement or a block of statements repeatedly while an <br>
expression is true. If the expression is false to begin with, the statement is never exe-<br>cuted. The following example illustrates the use of the  <b>while</b>   loop:  <br>
 <br><b>integer</b>  count;<br>  <b>initial</b> <br>  <b>begin</b> <br>    count = 0;<br>
    <b>while</b>  (count &lt; 64)<br>    #5 count = count + 1;<br>
  <b>end</b> <br>
<hr>
<A name=378></a><b>360    Chapter 8  Design at the Register Transfer Level</b><br>
 <br>The value of count is incremented from 0 to 63. Each increment is delayed by five time <br>units, and the loop exits at the count of 64. <br>
 <br>In dealing with looping statements, it is sometimes convenient to use the  <b>integer</b>   data <br>
type to index the loop. Integers are declared with the keyword  <b>integer</b>,  as in the previous <br>example. Although it is possible to use a  <b>reg</b>  variable to index a loop, sometimes it is <br>more convenient to declare an integer variable, rather than a  <b>reg</b>,  for counting purposes. <br>Variables declared as data type  <b>reg</b>  are stored as unsigned numbers. Those declared as <br>data type  <b>integer</b>  are store as signed numbers in 2'scomplement format. The default <br>width of an integer is a minimum of 32 bits. <br>
 The   <b>for</b>  loop is a compact way to express the operations implied by a list of state-<br>
ments whose variables are indexed. The <b>for</b> loop contains three parts separated by two <br>semicolons: <br>
   �    An  initial  condition.  <br> <br>�   An expression to check for the terminating condition. <br> <br>�   An assignment to change the control variable. <br>
 <br>The following is an example of a  <b>for</b>   loop:  <br>
 <br><b>for</b>  (j = 0; j &lt; 8; j = j + 1)<br>  <b>begin</b> <br>  // procedural statements go here<br>
  <b>end</b> <br>
 The   <b>for</b>  loop statement repeats the execution of the procedural statements eight times. The <br>control variable is  <i>j</i>,  the initial condition is  <i>j</i> = 0, and the loop is repeated as long as  <i>j</i>  is less <br>than 8. After each execution of the loop statement, the value of  <i>j</i>  is incremented by 1. <br>
 <br>A description of a twotofourline decoder using a  <b>for</b>  loop is shown in HDL Exam-<br>
ple 8.1. Since output  <i>Y</i>  is evaluated in a procedural statement, it must be declared as <br>type  <b>reg</b> . The control variable for the loop is the  <b>integer</b>  <i>k</i> . When the loop is expanded <br>(unrolled), we get the following four conditions ( <i>IN</i>  and  <i>Y</i>  are in binary, and the index <br>for  <i>Y</i>  is in decimal): <br>
 <br>if <i>IN</i> = 00 then <i>Y</i>(0) = 1; else <i>Y</i>(0) = 0; <br> <br>if <i>IN</i> = 01 then <i>Y</i>(1) = 1; else <i>Y</i>(1) = 0; <br> <br>if <i>IN</i> = 10 then <i>Y</i>(2) = 1; else <i>Y</i>(2) = 0; <br> <br>if <i>IN</i> = 11 then <i>Y</i>(3) = 1; else <i>Y</i>(3) = 0;  <br>
<b> <br> <br>HDL Example 8.1 (Decoder) </b><br>
 <br>// Description of 2 x 4 decoder using a  <b>for</b>  loop statement<br> <br><b>module</b>  decoder (IN, Y);<br>  <b>input</b>   <br>
[1: 0] IN;   <br>
// Two binary inputs<br>
  <b>output</b>   <br>
[3: 0]   Y;   <br>
// Four binary outputs<br>
  <b>reg</b>  [3: <br>
0] <br>
 <br>
Y;<br>
  <b>integer</b> <br>
k;   <br>
// Control (index) variable for loop<br>
<hr>
<A name=379></a><b>Section 8.3  Register Transfer Level in HDL    361</b><br>
  <b>always</b>   <b>@</b>  (IN)<br>  <b>for</b>  (k = 0; k &lt;= 3; k = k + 1)<br>  <b>if</b>  (IN == k) Y[k] = 1;<br>  <b>else</b>  Y[k] = 0;<br> <br><b>endmodule</b> <br>
<b> <br>Logic Synthesis </b><br>
 <br>Logic synthesis is the automatic process by which a computerbased program (i.e., a <br>synthesis tool) transforms an HDL model of a logic circuit into an optimized netlist of <br>gates that perform the operations specified by the source code. There are various target <br>technologies that implement the synthesized design in hardware. The effective use of <br>an HDL description requires that designers adopt a vendorspecific style suitable for <br>the particular synthesis tools. The type of ICs that implement the design may be an <br>applicationspecific integrated circuit (ASIC), a programmable logic device (PLD), or <br>a fieldprogrammable gate array (FPGA). Logic synthesis is widely used in industry to <br>design and implement large circuits efficiently, correctly, and rapidly. <br>
 <br>Logic synthesis tools interpret the source code of the HDL and translate it into <br>
an optimized gate structure, accomplishing (correctly) all of the work that would be <br>done by manual methods using Karnaugh maps. Designs written in Verilog or a compa-<br>rable language for the purpose of logic synthesis tend to be at the register transfer level. <br>This is because the HDL constructs used in an RTL description can be converted into <br>a gatelevel description in a straightforward manner. The following examples discuss <br>how a logic synthesizer can interpret an HDL construct and convert it into a gate <br> structure. <br>
 <br>The continuous assignment ( <b>assign</b> ) statement is used to describe combinational <br>
circuits. In an HDL, it represents a Boolean equation for a logic circuit. A continuous <br>assignment with a Boolean expression for the righthand side of the assignment state-<br>ment is synthesized into the corresponding gate circuit implementing the expression. <br>An expression with an addition operator (+) is interpreted as a binary adder using <br>fulladder circuits. An expression with a subtraction operator (-) is converted into a <br>gatelevel subtractor consisting of full adders and exclusiveOR gates (Fig. 4.13). <br>A statement with a conditional operator such as  <br>
 <br><b>assign</b>  Y = S ? In_1 : In_0;  <br>
 <br>translates into a twotooneline multiplexer with control input  <i>S</i>  and data inputs  <i>In_1</i> <br>and  <i>In_0</i> .A statement with multiple conditional operators specifies a larger multiplexer. <br>
 <br>A cyclic behavior ( <b>always</b>  . . .) may imply a combinational or sequential circuit, <br>
depending on whether the event control expression is level sensitive or edge sensitive. <br>A synthesis tool will interpret as combinational logic a levelsensitive cyclic behavior <br>whose event control expression is sensitive to every variable that is referenced within <br>the behavior (e.g., by the variable's appearing in the righthand side of an assignment <br>
<hr>
<A name=380></a><b>362    Chapter 8  Design at the Register Transfer Level</b><br>
statement). The event control expression in a description of combinational logic may <br>not be sensitive to an edge of any signal. For example, <br>
 <br><b>always @</b>  (In_1  <b>or</b>  In_0  <b>or</b>  S) <br>
// Alternative: (In_1, In_0, S) <br>
  <b>if</b>  (S) Y = In_1; <br>  <b>else</b>  Y = In_0;  <br>
 <br>translates into a twotooneline multiplexer. As an alternative, the  <b>case</b>  statement may <br>be used to imply large multiplexers. The  <b>casex</b>  statement treats the logic values x and z <br>as don'tcares when they appear in either the case expression or a case item. <br>
 <br>An edgesensitive cyclic behavior (e.g.,  <b>always @</b>   ( <b>posedge</b> clock)) specifies a syn-<br>
chronous (clocked) sequential circuit. The implementation of the corresponding circuit <br>consists of  <i>D</i>  flipflops and the gates that implement the synchronous register transfer <br>operations specified by the statements associated with the event control expression. <br>Examples of such circuits are registers and counters. A sequential circuit description <br>with a  <b>case</b>  statement translates into a control circuit with  <i>D</i>  flipflops and gates that <br>form the inputs to the flipflops. Thus, each statement in an RTL description is inter-<br>preted by the synthesizer and assigned to a corresponding gate and flipflop circuit. For <br>synthesizable sequential circuits, the event control expression must be sensitive to the <br>positive or the negative edge of the clock (synchronizing signal), but not to both. <br>
 <br>A simplified flowchart of the process used by industry to design digital systems is <br>
shown in  Fig.   8.1 . The RTL description of the HDL design is simulated and checked for <br>proper operation. Its operational features must match those given in the specification <br>for the behavior of the circuit. The test bench provides the stimulus signals to the simu-<br>lator. If the result of the simulation is not satisfactory, the HDL description is corrected <br>and checked again. After the simulation run shows a valid design, the RTL description <br>is ready to be compiled by the logic synthesizer. All errors (syntax and functional) in <br>the description must be eliminated before synthesis. The synthesis tool generates a <br>netlist equivalent to a gatelevel description of the design as it is represented by the <br>model. If the model fails to express the functionality of the specification, the circuit will <br>fail to do so also. The gatelevel circuit is simulated with the same set of stimuli used to <br>check the RTL design. If any corrections are needed, the process is repeated until a <br>satisfactory simulation is achieved. The results of the two simulations are compared to <br>see if they match. If they do not, the designer must change the RTL description to correct <br>any errors in the design. Then the description is compiled again by the logic synthesizer <br>to generate a new gatelevel description. Once the designer is satisfied with the results <br>of all simulation tests, the design of the circuit is ready for physical implementation in a <br>technology. In practice, additional testing will be performed to verify that the timing <br>specifications of the circuit can be met in the chosen hardware technology. That issue is <br>not within the scope of this text. <br>
 <br>Logic synthesis provides several advantages to the designer. It takes less time to write <br>
an HDL description and synthesize a gatelevel realization than it does to develop the <br>circuit by manual entry from schematic diagrams. The ease of changing the description <br>facilitates exploration of design alternatives. It is faster, easier, less expensive, and less <br>risky to check the validity of the design by simulation than it is to produce a hardware <br>
<hr>
<A name=381></a><b>Section 8.4  Algorithmic State Machines (ASMs)    363</b><br>
Develop specification<br>
Develop/edit HDL<br>
description<br>
Simulate/verify HDL<br>
description<br>
<i>No</i><br>
Test bench<br>
<i>Correct?</i><br>
<i>Yes</i><br>
Develop<br>
Compare<br>
Synthesize<br>
<i>Yes Synthesis No</i><br>
(manually)<br>
simulation<br>
netlist<br>
<i>tools?</i><br>
gate-level<br>
results<br>
model<br>
Simulate netlist/model<br>
<i>Create production</i><br>
<i>Yes</i><br>
<i>No</i><br>
<i>Match?</i><br>
<i>masks for ICs</i><br>
<b> <br>FIGURE 8.1   <br> <br>A simplified flowchart for HDLbased modeling, verification, and synthesis  </b><br>
prototype for evaluation. A schematic and the database for fabricating the integrated <br>circuit can be generated automatically by synthesis tools. The HDL model can be com-<br>piled by different tools into different technologies (e.g., ASIC cells or FPGAs), provid-<br>ing multiple returns on the investment to create the model. <br>
<b> <br>8 . 4       A L G O R I T H M I C   S TAT E   M A C H I N E S   ( A S M s ) </b><br>
 <br>The binary information stored in a digital system can be classified as either data or <br>control information. Data are discrete elements of information (binary words) that are <br>manipulated by performing arithmetic, logic, shift, and other similar dataprocessing <br>
<hr>
<A name=382></a><b>364    Chapter 8  Design at the Register Transfer Level</b><br>
operations. These operations are implemented with digital hardware components such <br>as adders, decoders, multiplexers, counters, and shift registers. Control information pro-<br>vides command signals that coordinate and execute the various operations in the data <br>section of the machine in order to accomplish the desired dataprocessing tasks. <br>
 <br>The design of the logic of a digital system can be divided into two distinct efforts. One <br>
part is concerned with designing the digital circuits that perform the dataprocessing <br>operations. The other part is concerned with designing the control circuits that deter-<br>mine the sequence in which the various manipulations of data are performed. <br>
 <br>The relationship between the control logic and the dataprocessing operations in a <br>
digital system is shown in  Fig.   8.2  . The dataprocessing path, commonly referred to as <br>the  <i>datapath unit</i>,  manipulates data in registers according to the system's requirements. <br>The  <i>control unit</i>  issues a sequence of commands to the datapath unit. Note that an <br>internal feedback path from the datapath unit to the control unit provides status condi-<br>tions that the control unit uses together with the external (primary) inputs to determine <br>the sequence of control signals (outputs of the control unit) that direct the operation <br>of the datapath unit. We'll see later that understanding how to model this feedback <br>relationship with an HDL is very important. <br>
 <br>The control logic that generates the signals for sequencing the operations in the <br>
datapath unit is a finite state machine (FSM), i.e., a synchronous sequential circuit. The <br>control commands for the system are produced by the FSM as functions of the primary <br>inputs, the status signals, and the state of the machine. In a given state, the outputs of <br>the controller are the inputs to the datapath unit and determine the operations that it <br>will execute. Depending on status conditions and other external inputs, the FSM goes <br>to its next state to initiate other operations. The digital circuits that act as the control <br>logic provide a time sequence of signals for initiating the operations in the datapath and <br>also determine the next state of the control subsystem itself. <br>
<i>Input</i><br>
<i>data</i><br>
<i>Control</i><br>
<i>Input</i><br>
<i>signals</i><br>
<i>signals</i><br>
<i>(external)</i><br>
Control unit<br>
Datapath<br>
(FSM)<br>
unit<br>
<i>Status</i><br>
<i>signals</i><br>
<i>Output</i><br>
<i>data</i><br>
<b> <br>FIGURE 8.2   <br> <br>Control and datapath interaction  </b><br>
<hr>
<A name=383></a><b>Section 8.4  Algorithmic State Machines (ASMs)    365</b><br>
 <br>The control sequence and datapath tasks of a digital system are specified by means of <br>
a hardware algorithm. An algorithm consists of a finite number of procedural steps that <br>specify how to obtain a solution to a problem. A hardware algorithm is a procedure for <br>solving the problem with a given piece of equipment. The most challenging and creative <br>part of digital design is the formulation of hardware algorithms for achieving required <br>objectives. The goal is to implement the algorithms in silicon as an integrated circuit. <br>
 <br>A flowchart is a convenient way to specify the sequence of procedural steps and deci-<br>
sion paths for an algorithm. A flowchart for a hardware algorithm translates the verbal <br>instructions to an information diagram that enumerates the sequence of operations <br>together with the conditions necessary for their execution. An  <i>algorithmic state machine</i> <br>(ASM) chart is a flowchart that has been developed to specifically define algorithms for <br>execution on digital hardware. A  <i>state machine</i>  is another term for a sequential circuit, <br>which is the basic structure of a digital system. <br>
<b> <br>ASM Chart </b><br>
 <br>An ASM chart resembles a conventional flowchart, but is interpreted somewhat differ-<br>ently. A conventional flowchart describes the procedural steps and decision paths of an <br>algorithm in a sequential manner, without taking into consideration their time relation-<br>ship. The ASM chart describes the sequence of events, i.e., the ordering of events in time, <br>as well as the timing relationship between the states of a sequential controller and the <br>events that occur while going from one state to the next (i.e., the events that are syn-<br>chronous with changes in the state). The chart is adapted to specify accurately the con-<br>trol sequence and datapath operations in a digital system, taking into consideration the <br>constraints of digital hardware. <br>
 <br>An ASM chart is composed of three basic elements: the state box, the decision box, <br>
and the conditional box. The boxes themselves are connected by directed edges indicat-<br>ing the sequential precedence and evolution of the states as the machine operates. There <br>are various ways to attach information to an ASM chart. In one, a state in the control <br>sequence is indicated by a state box, as shown in  Fig.   8.3  (a). The shape of the state box <br>is a rectangle within which are written register operations or the names of output signals <br>that the control generates while being in the indicated state. The state is given a symbolic <br>name, which is placed within the upper left corner of the box. The binary code assigned <br>to the state is placed at the upper right corner. (The state symbol and code can be placed <br>
<i>Binary code</i><br>
0101<br>
<i>State name</i><br>
<i>S_ pause</i><br>
Moore-type<br>
<i>R</i><br>
0<br>
output signals, register operations<br>
<i>Start_OP_A</i><br>
(a)<br>
(b)<br>
<b> <br>FIGURE 8.3   <br> <br>ASM chart state box  </b><br>
<hr>
<A name=384></a><b>366    Chapter 8  Design at the Register Transfer Level</b><br>
in other places as well.)  Figure   8.3  (b) gives an example of a state box. The state has the <br>symbolic name  <i>S_pause</i>,  and the binary code assigned to it is 0101. Inside the box is writ-<br>ten the register operation   <i>R </i>d 0 , which indicates that register  <i>R</i>  is to be cleared to 0. The <br>name  <i>Start_OP_A</i>  inside the box indicates, for example, a Mooretype output signal that <br>is asserted while the machine is in state  <i>S_pause</i>  and that launches a certain operation <br>in the datapath unit. <br>
 <br>The style of state box shown in  Fig.   8.3  (b) is sometimes used in ASM charts, but it can <br>
lead to confusion about when the register operation   <i>R </i>d 0  is to execute. Although the <br>operation is written inside the state box, it actually occurs when the machine makes a <br>transition from  <i>S_pause</i>  to its next state. In fact, writing the register operation within the <br>state box is a way (albeit possibly confusing) to indicate that the controller must assert <br>a signal that will cause the register operation to occur when the machine changes state. <br>Later we'll introduce a chart and notation that are more suited to digital design and that <br>will eliminate any ambiguity about the register operations controlled by a state machine. <br>
 <br>The decision box of an ASM chart describes the effect of an input (i.e., a primary, or <br>
external, input or a status, or internal, signal) on the control subsystem. The box is dia-<br>mond shaped and has two or more exit paths, as shown in  Fig.   8.4  . The input condition <br>to be tested is written inside the box. One or the other exit path is taken, depending on <br>the evaluation of the condition. In the binary case, one path is taken if the condition is <br>true and another when the condition is false. When an input condition is assigned a <br>binary value, the two paths are indicated by 1 and 0, respectively. <br>
 <br>The state and decision boxes of an ASM chart are similar to those used in conven-<br>
tional flowcharts. The third element, the conditional box, is unique to the ASM chart. <br>The shape of the conditional box is shown in  Fig.   8.5  (a). Its rounded corners differenti-<br>ate it from the state box. The input path to the conditional box must come from one of <br>the exit paths of a decision box. The outputs listed inside the conditional box are gener-<br>ated as Mealytype signals during a given state; the register operations listed in the <br>conditional box are associated with a transition from the state.  Figure   8.5  (b) shows an <br>example with a conditional box. The control generates the output signal  <i>Start</i>  while in <br>state  <i>S_1</i>  and checks the status of input  <i>Flag</i> . If  <i>Flag</i> = 1, then  <i>R</i>  is cleared to 0; otherwise, <br> <br><i>R</i>  remains unchanged. In either case, the next state is  <i>S_2</i> . A register operation is <br>
1<br>
3<br>
Condition<br>
Exit path<br>
2<br>
Exit path<br>
Exit path<br>
<b> <br>FIGURE 8.4   <br> <br>ASM chart decision box  </b><br>
<hr>
<A name=385></a><b>Section 8.4  Algorithmic State Machines (ASMs)    367</b><br>
<i>Reset_b</i><br>
<i>Reset_b</i><br>
<i>Binary code</i><br>
001<br>
001<br>
<i>State name</i><br>
<i>S_1</i><br>
<i>S_1</i><br>
Moore-type output signals<br>
<i>Start</i><br>
<i>Start</i><br>
Unconditional register<br>operations<br>
0<br>
1<br>
0<br>
1<br>
<i>Flag</i><br>
<i>Flag</i><br>
Condition<br>
<i>R</i><br>
0<br>
<i>Flush_R</i><br>
Conditional<br>
010<br>
010<br>
(Mealy) outputs<br>
<i>S_2</i><br>
<i>S_2</i><br>
and register<br>
<i>F G</i><br>
<i>Load_F_G</i><br>
operations<br>
100<br>
100<br>
<i>S_3</i><br>
<i>S_3</i><br>
(a)<br>
(b)<br>
(c)<br>
<b> <br>FIGURE 8.5   <br> <br>ASM chart conditional box and examples  </b><br>
 <br>associated with  <i>S_2</i> . We again note that  <i>this style of chart can be a source of confusion</i>,  <br>because the state machine does not execute the indicated register operation   <i>R </i>d 0     when <br>it is in  <i>S_1</i>  or the operation   <i>F </i>d <i>G</i> when it is in  <i>S_2</i> . The notation actually indicates that <br>when the controller is in  <i>S_1</i>,  it must assert a Mealytype signal that will cause the reg-<br>ister operation   <i>R </i>d 0  to execute in the datapath unit1, subject to the condition that  <i>Flag</i> <br>= 0. Likewise, in state  <i>S_2</i>,  the controller must generate a Mooretype output signal that <br>causes the register operation   <i>F </i>d <i>G</i>  to execute in the datapath unit. The operations in <br>the datapath unit are synchronized to the clock edge that causes the state to move from <br> <br><i>S_1</i>  to  <i>S_2</i>  and from  <i>S_2</i>  to  <i>S_3</i>,  respectively. Thus,  <i>the control signal generated in a given <br>state affects the operation of a register in the datapath when the next clock transition <br>occurs.</i> The result of the operation is apparent in the next state. <br>
 <br>The ASM chart in  Fig.   8.5  (b) mixes descriptions of the datapath and the controller. <br>
An ASM chart for only the controller is shown in  Fig.   8.5  (c), in which the register oper-<br>ations are omitted. In their place are the control signals that must be generated by the <br>control unit to launch the operations of the datapath unit. This chart is useful for describ-<br>ing the controller, but it does not contain adequate information about the datapath. <br>(We'll address this issue later.)  <br>
1 If the path came from a state box the asserted signals would be moore type signals, dependent on only the <br>state, and should be listed within the box.<br>
<hr>
<A name=386></a><b>368    Chapter 8  Design at the Register Transfer Level</b><br>
<b> <br>ASM Block </b><br>
 <br>An ASM block is a structure consisting of one state box and all the decision and condi-<br>tional boxes connected to its exit path. An ASM block has one entrance and any number <br>of exit paths represented by the structure of the decision boxes. An ASM chart consists <br>of one or more interconnected blocks. An example of an ASM block is given in  Fig.   8.6  . <br>Associated with state  <i>S_0</i>  are two decision boxes and one conditional box. The diagram <br>distinguishes the block with dashed lines around the entire structure, but this is not usu-<br>ally done, since the ASM chart uniquely defines each block from its structure. A state <br>box without any decision or conditional boxes constitutes a simple block. <br>
 <br>Each block in the ASM chart describes the state of the system during one clockpulse <br>
interval (i.e., the interval between two successive active edges of the clock). The opera-<br>tions within the state and conditional boxes in  Fig.   8.6  (a) are initiated by a common <br>clock pulse when the state of the controller transitions from  <i>S_0</i>  to its next state. The <br>same clock pulse transfers the system controller to one of the next states,  <i>S_1,</i>  <i>S_2</i>,   or <br> <br><i>S_3</i>,  as dictated by the binary values of  <i>E</i>  and  <i>F</i> . The ASM chart for the controller alone <br>is shown in  Fig.   8.6  (b). The Mooretype signal  <i>incr_A</i>  is asserted unconditionally while <br>the machine is in  <i>S_0</i> ; the Mealytype signal  <i>Clear_R</i>  is generated conditionally when <br>the state is  <i>S_0</i>  and  <i>E</i>  is asserted. In general, the Mooretype outputs of the controller <br>are generated unconditionally and are indicated within a state box; the Mealytype <br>outputs are generated conditionally and are indicated in the conditional boxes con-<br>nected to the edges that leave a decision box. <br>
 <br>The ASM chart is similar to a state transition diagram. Each state block is equivalent <br>
to a state in a sequential circuit. The decision box is equivalent to the binary information <br>
<i>Reset_b</i><br>
<i>Reset_b</i><br>
001<br>
001<br>
<i>S_0</i><br>
<i>S_0</i><br>
<i>A A  1</i><br>
<i>incr_A</i><br>
1<br>
1<br>
<i>E</i><br>
<i>E</i><br>
1<br>
<i>R</i><br>
0<br>
1<br>
<i>Clear_B</i><br>
<i>F</i><br>
<i>F</i><br>
010<br>
011<br>
100<br>
010<br>
011<br>
100<br>
<i>S_1</i><br>
<i>S_2</i><br>
<i>S_3</i><br>
<i>S_1</i><br>
<i>S_2</i><br>
<i>S_3</i><br>
(a)<br>
(b)<br>
<b> <br>FIGURE 8.6   <br> <br>ASM blocks  </b><br>
<hr>
<A name=387></a><b>Section 8.4  Algorithmic State Machines (ASMs)    369</b><br>
001<br>
<i>EF</i><br>
 00<br>
<i>E</i><br>
 1<br>
010<br>
100<br>
<i>EF</i><br>
 01<br>
011<br>
<b> <br>FIGURE 8.7   <br> <br>State diagram equivalent to the ASM chart of  Fig.   8.6  </b><br>
written along the directed lines that connect two states in a state diagram. As a conse-<br>quence, it is sometimes convenient to convert the chart into a state diagram and then use <br>sequential circuit procedures to design the control logic. As an illustration, the ASM chart <br>of  Fig.   8.6   is drawn as a state diagram (outputs are omitted) in  Fig.   8.7 . The states are <br>symbolized by circles, with their binary values written inside. The directed lines indicate <br>the conditions that determine the next state. The unconditional and conditional opera-<br>tions that must be performed in the datapath unit are not indicated in the state diagram. <br>
<b> <br>Simplifications </b><br>
 <br>A binary decision box of an ASM chart can be simplified by labeling only the edge cor-<br>responding to the asserted decision variable and leaving the other edge without a label. <br>A further simplification is to omit the edges corresponding to the state transitions that <br>occur when a reset condition is asserted. Output signals that are not asserted are not shown <br>on the chart; the presence of the name of an output signal indicates that it is asserted. <br>
<b> <br>Timing Considerations </b><br>
 <br>The timing for all registers and flipflops in a digital system is controlled by a master<br>clock generator. The clock pulses are applied not only to the registers of the datapath, <br>but also to all the flipflops in the state machine implementing the control unit. Inputs <br>are also synchronized to the clock, because they are normally generated as outputs of <br>another circuit that uses the same clock signals. If the input signal changes at an arbitrary <br>time independently of the clock, we call it an asynchronous input. Asynchronous inputs <br>may cause a variety of problems. To simplify the design, we will assume that all inputs <br>are synchronized with the clock and change state in response to an edge transition. <br>
 <br>The major difference between a conventional flowchart and an ASM chart is in inter-<br>
preting the time relationship among the various operations. For example, if  Fig.   8.6   were <br>a conventional flowchart, then the operations listed would be considered to follow one <br>after another in sequence: First register  <i>A</i>  is incremented, and only then is  <i>E</i>   evaluated. <br>If  <i>E</i> = 1, then register  <i>R</i>  is cleared and control goes to state  <i>S_3</i> . Otherwise (if  <i>E</i> = 0), <br>the next step is to evaluate  <i>F</i>  and go to state  <i>S_1</i>  or  <i>S_2</i> . In contrast, an ASM chart con-<br>siders the entire block as one unit. All the register operations that are specified within <br>
<hr>
<A name=388></a><b>370    Chapter 8  Design at the Register Transfer Level</b><br>
<i>Positive edge of Clock</i><br>
<i>Clock</i><br>
<i>Present state</i><br>
<i>Next state</i><br>
(<i> S_0 </i>)<br>
(<i>S_1 or S_2 or S_3</i>)<br>
<b> <br>FIGURE 8.8   <br> <br>Transition between states  </b><br>
the block must occur in synchronism at the edge transition of the same clock pulse while <br>the system changes from  <i>S_0</i>  to the next state. This sequence of events is presented <br>pictorially in  Fig.   8.8  . In this illustration, we assume positiveedge triggering of all flip<br>flops. An asserted asynchronous reset signal ( <i>reset_b</i> ) transfers the control circuit into <br>state  <i>S_0</i> . While in state  <i>S_0</i>,  the control circuits check inputs  <i>E</i>   and   <i>F</i>  and generate <br>appropriate signals accordingly. If  <i>reset_b</i>  is not asserted, the following operations occur <br>simultaneously at the next positive edge of the clock: <br>
 <br><b> 1. </b><br>
  Register   <i>A</i>  is incremented. <br>
 <br><b> 2. </b><br>
  If   <i>E</i> = 1, register  <i>R</i>  is cleared. <br>
 <br><b> 3. </b><br>
 <br>Control transfers to the next state, as specified in  Fig.   8.7 . <br>
 <br>Note that the two operations in the datapath and the change of state in the control logic <br>occur at the same time. Note also that the ASM chart in  Fig.   8.6  (a) indicates the register <br>operations that must occur in the datapath unit, but does not indicate the control signal <br>that is to be formed by the control unit. Conversely, the chart in  Fig.   8.6  (b) indicates the <br>control signals, but not the datapath operations. We will now present an ASMD chart to <br>provide the clarity and complete information needed by logic designers. <br>
<b> <br>ASMD Chart </b><br>
 <br>Algorithmic state machine and datapath (ASMD) charts were developed to clarify the <br>information displayed by ASM charts and to provide an effective tool for designing a <br>control unit for a given datapath unit. An ASMD chart differs from an ASM chart in <br>three important ways: (1) An ASMD chart does not list register operations within a state <br>box, (2) the edges of an ASMD chart are annotated with register operations that are <br>concurrent with the state transition indicated by the edge, and (3) an ASMD chart <br>includes conditional boxes identifying the signals which control the register operations <br>that annotate the edges of the chart. Thus,  <i>an ASMD chart associates register operations <br>with state transitions rather than with states</i> ; it also associates register operations with the <br>signals that cause them. Consequently, an ASMD chart represents a partition of a com-<br>plex digital machine into its datapath and control units and clearly indicates the relation-<br>ship between them. There is no room for confusion about the timing of register <br>operations or about the signals that launch them. <br>
 <br>Designers form an ASMD chart in a threestep process that creates an annotated and <br>
completely specified ASM chart for the controller of a datapath unit. <br>
<hr>
<A name=389></a><b>Section 8.5  Design Example (ASMD Chart)    371</b><br>
 <br>The steps to form an ASMD chart are: <br>
 <br><b> 1. </b><br>
 <br>Form an ASM chart showing only the states of the controller and the input signals 2 <br>that cause state transitions, <br>
 <br><b> 2. </b><br>
 <br>Convert the ASM chart into an ASMD chart by annotating the edges of the ASM <br>chart to indicate the concurrent register operations of the datapath unit (i.e., reg-<br>ister operations that are concurrent with a state transition), and  <br>
 <br><b> 3. </b><br>
 <br>Modify the ASMD chart to identify the control signals that are generated by the <br>controller and that cause the indicated operations in the datapath unit. <br>
 <br>The ASMD chart produced by this process clearly and completely specifies the finite <br>state machine of the controller, identifies the registers operations of the datapath unit, <br>identifies signals reporting the status of the datapath to the controller, and links register <br>operations to the signals that control them. <br>
 <br>One important use of a state machine is to control register operations on a datapath <br>
in a sequential machine that has been partitioned into a controller and a datapath. An <br>ASMD chart links the ASM chart of the controller to the datapath it controls in a man-<br>ner that serves as a universal model representing all synchronous digital hardware <br>design. ASMD charts help clarify the design of a sequential machine by separating the <br>design of its datapath from the design of the controller, while maintaining a clear rela-<br>tionship between the two units. Register operations that occur concurrently with state <br>transitions are annotated on a path of the chart, rather than in state boxes or in condi-<br>tional boxes on the path, because these registers are not part of the controller. The <br>outputs generated by the controller are the signals that control the registers of the <br>datapath and cause the register operations annotated on the ASMD chart. <br>
<b> <br>8 . 5       D E S I G N   E X A M P L E   ( A S M D   C H A R T ) </b><br>
 <br>We will now present a simple example demonstrating the use of the ASMD chart and <br>the register transfer representation. We start from the initial specifications of a system <br>and proceed with the development of an appropriate ASMD chart from which the <br>digital hardware is then designed. <br>
 <br>The datapath unit is to consist of two  <i>JK</i>  flipflops  <i>E</i>  and  <i>F</i>,  and one fourbit binary <br>
counter  <i>A[3: 0]</i> .The individual flipflops in  <i>A</i>  are denoted by   <i>A</i>3,  <i>A</i>2,  <i>A</i>1, and <i>A</i>0, with <i>A</i>3 <br>holding the most significant bit of the count. A signal,  <i>Start</i>,  initiates the system's oper-<br>ation by clearing the counter  <i>A</i>  and flipflop  <i>F</i> . At each subsequent clock pulse, the <br>counter is incremented by 1 until the operations stop. Counter bits   <i>A</i>2     and     <i>A</i>3     determine <br>the sequence of operations: <br>
 <br>If  <i>A</i>2 = 0 ,  <i>E</i>  is cleared to 0 and the count continues.  <br> <br>If  <i>A</i>2 = 1 ,  <i>E</i>  is set to 1; then, if   <i>A</i>3 = 0 , the count continues, but if   <i>A</i>3 = 1 ,  <i>F</i>  is set to <br>1 on the next clock pulse and the system stops counting.  <br>
2 In general, the inputs to the control unit are external (primary) inputs and status signals that originate in <br>the datapath unit.<br>
<hr>
<A name=390></a><b>372    Chapter 8  Design at the Register Transfer Level</b><br>
  Then,  if   <i>Start</i>  = 0, the system remains in the initial state, but if  <i>Start</i>  = 1, the operation <br>cycle  repeats.   <br>
 <br>A block diagram of the system's architecture is shown in  Fig.   8.9  (a), with (1) the <br>
registers of the datapath unit, (2) the external (primary) input signals, (3) the status <br>signals fed back from the datapath unit to the control unit, and (4) the control signals <br>generated by the control unit and input to the datapath unit. Note that the names of the <br>control signals clearly indicate the operations that they cause to be executed in the <br>datapath unit. For example,  <i>clr_A_F</i>  clears registers  <i>A</i>  and  <i>F</i> . The name of the signal <br> <br><i>reset_b</i>  (alternatively,  <i>reset_bar</i> ) indicates that the reset action is active low. The internal <br>details of each unit are not shown. <br>
<b> <br>ASMD Chart </b><br>
 <br>An ASMD chart for the system is shown in  Fig.   8.9  (b) for asynchronous reset action and <br>in  Fig.   8.9  (c) for synchronous reset action. The chart shows the state transitions of the <br>controller and the datapath operations associated with those transitions. The chart is not <br>in its final form, for it does not identify the control signals generated by the controller. <br>The nonblocking Verilog operator (6=) is shown instead of the arrow   ( d )     for  register <br>transfer operations because we will ultimately use the ASMD chart to write a Verilog <br>description of the system. <br>
 <br>When the reset action is synchronous, the transition to the reset state is synchronous <br>
with the clock. This transition is shown for  <i>S_idle</i>  in the diagram, but  <i>all other synchro-<br>nous reset paths are omitted for clarity</i> .The system remains in the reset state,  <i>S_idle</i>,   until <br> <br><i>Start</i>  is asserted. When that happens (i.e.,  <i>Start</i> = 1), the state moves to  <i>S_1</i>.<i> At the next <br>clock edge</i>,  depending on the values of   <i>A</i>2     and     <i>A</i>3  (decoded in a priority order), the state <br>returns to  <i>S_1</i>  or goes to  <i>S_2</i> . From  <i>S_2</i>,  it moves unconditionally to  <i>S_idle</i>,  where it <br>awaits another assertion of  <i>Start</i> . <br>
 <br>The edges of the chart represent the state transitions that occur at the active (i.e., <br>
synchronizing) edge of the clock (e.g., the rising edge) and are annotated with the <br>register operations that are to occur in the datapath. With  <i>Start</i>  asserted in  <i>S_idle</i>,  <br>the state will transition to  <i>S_1</i>  and the registers  <i>A</i>  and  <i>F</i>  will be cleared. Note that, <br>on the one hand, if a register operation is annotated on the  <i>edge</i>  leaving a state box, <br>the operation occurs unconditionally and will be controlled by a Mooretype signal. <br>For example, register  <i>A</i>  is incremented at every clock edge that occurs while the <br>machine is in the state  <i>S_1</i> . On the other hand, the register operation setting register <br> <br><i>E</i>  annotates the edge leaving the  <i>decision box</i>   for     <i>A</i>2   .  The  signal  controlling  the <br>operation will be a Mealytype signal asserted when the system is in state  <i>S_1</i>   and <br> <i>A</i>2  has the value 1. Likewise, the control signal clearing  <i>A</i>  and  <i>F</i>  is asserted condition-<br>ally: The system is in state  <i>S_idle</i>  and  <i>Start</i>  is asserted. <br>
 <br>In addition to showing that the counter is incremented in state  <i>S_1</i>,  the annotated <br>
paths show that other operations occur conditionally with the same clock edge: <br>
   Either   <i>E</i>  is cleared and control stays in state  <i>S_1</i>  (<i>A</i>2 = 0)     or  <br> <br><i>E</i>  is set and control stays in state  <i>S_1</i>  (<i>A</i>2<i>A</i>3 = 10)     or  <br> <br><i>E</i>  is set and control goes to state  <i>S_2</i>  (<i>A</i>2<i>A</i>3 = 11). <br>
<hr>
<A name=391></a><b>Section 8.5  Design Example (ASMD Chart)    373</b><br>
Status signals<br>
<i>A</i>3<br>
<i>A</i>2<br>
<i>clr_E</i><br>
<i>Datapath</i><br>
<i>set_E</i><br>
<i>A</i><br>
<i>Controller</i><br>
<i>set_F</i><br>
<i>Start</i><br>
<i>E</i><br>
<i>clr_A_F<br>incr_A</i><br>
<i>F</i><br>
<i>reset_b</i><br>
<i>clock</i><br>
(a)<br>
Note: A3 denotes A[3],<br>A2 denotes A[2],<br>
 denotes nonblocking assignment<br>
<i>reset_b</i><br>
reset_b denotes active-low reset condition<br>
<i>S_idle</i><br>
<i>reset_b</i><br>
<i>S_idle</i><br>
<i>Start</i><br>
<i>A</i><br>
0<br>
<i>F</i><br>
0<br>
<i>reset_b</i><br>
1<br>
<i>S_idle</i><br>
<i>clr_A_F</i><br>
1<br>
<i>E</i><br>
0<br>
<i>A</i><br>
0<br>
<i>A</i><br>
0<br>
<i>F</i><br>
0<br>
<i>S_1</i><br>
<i>Start</i><br>
<i>F</i><br>
0<br>
<i>Start</i><br>
<i>clr_E</i><br>
<i>incr_A</i><br>
<i>E</i><br>
0<br>
1<br>
1<br>
<i>E</i><br>
0<br>
<i>S_1</i><br>
<i>A2</i><br>
<i>S_1</i><br>
<i>A</i><br>
<i> A  </i> 1<br>
<i>A</i><br>
<i> A </i><br>
1<br>
1<br>
<i>A</i><br>
<i> A </i><br>
1<br>
<i>E</i><br>
1<br>
<i>A2</i><br>
<i>A2</i><br>
<i>set_E</i><br>
<i>E</i><br>
1<br>
<i>E</i><br>
1<br>
1<br>
1<br>
<i>A3</i><br>
<i>A3</i><br>
<i>A3</i><br>
1<br>
1<br>
1<br>
<i>F</i><br>
1<br>
<i>F</i><br>
1<br>
<i>F</i><br>
1<br>
<i>S_2</i><br>
<i>S_2</i><br>
<i>S_2</i><br>
<i>set_F</i><br>
(b)<br>
(c)<br>
(d)<br>
<b> <br>FIGURE 8.9   <br> <br>(a) Block diagram for design example <br> <br>(b) ASMD chart for controller state transitions, asynchronous reset <br> <br>(c) ASMD chart for controller state transitions, synchronous reset <br> <br>(d) ASMD chart for a completely specified controller, asynchronous reset  </b><br>
<hr>
<A name=392></a><b>374    Chapter 8  Design at the Register Transfer Level</b><br>
 <br>When control is in state  <i>S_2</i>,  a Mooretype control signal must be asserted to set flipflop <br> <br><i>F</i>  to 1, and the state returns to  <i>S_idle</i>  at the next active edge of the clock.  <br>
 <br>The third and final step in creating the ASMD chart is to insert conditional boxes for <br>
the signals generated by the controller or to insert Mooretype signals in the state boxes, <br>as  shown  in   Fig.    8.9   (d).  The  signal   <i>clr_A_F</i>  is generated conditionally in state  <i>S_idle,</i> <br> <br><i>incr_A</i>  is generated unconditionally in  <i>S_1,</i>  <i>clr_E</i>  and  <i>set_E</i>  are generated conditionally <br>in  <i>S_1</i>,  and  <i>set_F</i>  is generated unconditionally in  <i>S_2</i>. The ASM chart has three states <br>and three blocks. The block associated with  <i>S_idle</i>  consists of the state box, one decision <br>box, and one conditional box. The block associated with  <i>S_2</i>  consists of only the state <br>box. In addition to  <i>clock</i>  and  <i>reset_b</i>,  the control logic has one external input,  <i>Start</i>,   and <br>two status inputs,   <i>A</i>2     and     <i>A</i>3.    <br>
 <br>In this example, we have shown how a verbal (text) description (specification) of a <br>
design is translated into an ASMD chart that completely describes the controller for the <br>datapath, indicating the control signals and their associated register operations. This <br>design example does not necessarily have a practical application, and in general, depend-<br>ing on the interpretation, the ASMD chart produced by the threestep design process <br>for the controller may be simplified and formulated differently. However, once the <br>ASMD chart is established, the procedure for designing the circuit is straightforward. <br> <br><i>In practice, designers use the ASMD chart to write Verilog models of the controller and <br>the datapath and then synthesize a circuit directly from the Verilog description</i> .  We  will <br>first design the system manually and then write the HDL description, keeping synthesis <br>as an optional step for those who have access to synthesis tools. <br>
<b> <br>Timing Sequence </b><br>
 <br>Every block in an ASMD chart specifies the signals which control the operations that <br>are to be initiated by one common clock pulse. The control signals specified within the <br>state and conditional boxes in the block are formed while the controller is in the indi-<br>cated state, and the annotated operations occur in the datapath unit when the state <br>makes a transition along an edge that exits the state. The change from one state to the <br>next is performed in the control logic. In order to appreciate the timing relationship <br>involved, we will list the stepbystep sequence of operations after each clock edge, <br>beginning with an assertion of the signal  <i>Start</i>  until the system returns to the reset (ini-<br>tial) state,  <i>S_idle</i> . <br>
 <br>Table   8.3   shows the binary values of the counter and the two flipflops after every <br>
clock pulse. The table also shows separately the status of   <i>A</i>2     and     <i>A</i>3 , as well as the pres-<br>ent state of the controller. We start with state  <i>S_1</i>  right after the input signal  <i>Start</i>   has <br>caused the counter and flipflop  <i>F</i>  to be cleared. We will assume that the machine had <br>been running before it entered  <i>S_idle</i>,  instead of entering it from a reset condition. <br>Therefore, the value of  <i>E</i>  is assumed to be 1, because  <i>E</i>  is set to 1 when the machine <br>enters  <i>S</i> _ <i>2</i>,  before moving to  <i>S_idle</i>  (as shown at the bottom of the table), and because <br> <br><i>E</i>  does not change during the transition from  <i>S_idle</i>  to  <i>S_1</i>. The system stays in state  <i>S_1</i> <br>during the next 13 clock pulses. Each pulse increments the counter and either clears or <br>sets  <i>E</i> . Note the relationship between the time at which   <i>A</i>2  becomes a 1 and the time at <br>
<hr>
<A name=393></a><b>Section 8.5  Design Example (ASMD Chart)    375</b><br>
<b> <br>Table 8.3 <br><i> <br>Sequence of Operations for Design Example </b></i><br>
<b> <br>Counter  </b><br>
<b>FlipFlops  </b><br>
<b> </b><br>
<b> </b><br>
<b> <br><i>A</i>3 </b><br>
<b> <br><i>A</i>2 </b><br>
<b> <br><i>A</i>1 </b><br>
<b> <br><i>A</i>0 </b><br>
<i><b> <br>E</i> </b><br>
<b> <br><i>F</i> </b><br>
<b> <br>Conditions  </b><br>
<b> <br>State  </b><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 <i>A</i>2 = 0,  <i>A</i>3 = 0    <br>
 <br><i>S_1</i> <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
  <br>
  <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
  <br>
  <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 <br>
 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 <i>A</i>2 = 1,  <i>A</i>3 = 0    <br>
 <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
  <br>
  <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
  <br>
  <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 <br>
 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 <i>A</i>2 = 0,  <i>A</i>3 = 1    <br>
 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
  <br>
  <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
  <br>
  <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 <br>
 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 <i>A</i>2 = 1,  <i>A</i>3 = 1    <br>
 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
  <br>
  <br><i>S_2</i> <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 <br>
 <br><i>S_idle</i> <br>
which  <i>E</i>  is set to 1. When   <i>A </i>= (<i>A</i>3  <i>A</i>2  <i>A</i>1  <i>A</i>0)  0011, the next (4th) clock pulse increments <br>the counter to 0100, but that same clock edge sees the value of   <i>A</i>2  as 0, so  <i>E</i>   remains <br>cleared. The next (5th) pulse changes the counter from 0100 to 0101, and because   <i>A</i>2 is <br>equal to 1  <i>before</i>  the clock pulse arrives,  <i>E</i>  is set to 1. Similarly,  <i>E</i>  is cleared to 0 not when <br>the count goes from 0111 to 1000, but when it goes from 1000 to 1001, which is when <br> <i>A</i>2  is 0 in the  <i>present</i>  value of the counter. <br>
 <br>When the count reaches 1100, both   <i>A</i>2     and     <i>A</i>3  are equal to 1. The next clock edge <br>
increments  <i>A</i>  by 1, sets  <i>E</i>  to 1, and transfers control to state  <i>S_2</i> . Control stays in  <i>S_2</i> <br>for only one clock period. The clock edge associated with the path leaving  <i>S</i> _ <i>2</i>  sets flip<br>flop  <i>F</i>  to 1 and transfers control to state  <i>S_idle</i> .The system stays in the initial state  <i>S_idle</i> <br>as long as  <i>Start</i>  is equal to 0. <br>
 <br>From an observation of  Table   8.3  , it may seem that the operations performed on  <i>E</i> <br>
are delayed by one clock pulse. This is the difference between an ASMD chart and a <br>conventional flowchart. If  Fig.   8.9 (d) were a conventional flowchart, we would assume <br>that  <i>A</i>  is first incremented and the incremented value would have been used to check <br>the status of   <i>A</i>2 . The operations that are performed in the digital hardware, as specified <br>by a block in the ASMD chart, occur during the same clock cycle and not in a sequence <br>of operations following each other in time, as is the usual interpretation in a conven-<br>tional flowchart. Thus, the value of   <i>A</i>2  to be considered in the decision box is taken <br>
<hr>
<A name=394></a><b>376    Chapter 8  Design at the Register Transfer Level</b><br>
from the value of the counter in the present state and before it is incremented. This is <br>because the decision box for  <i>E</i>  belongs with the same block as state  <i>S_1</i> .  The  digital <br>circuits in the control unit generate the signals for all the operations specified in the <br>present block  <i>prior to the arrival of the next clock pulse</i> . The next clock edge executes <br>all the operations in the registers and flipflops, including the flipflops in the controller <br>that determine the next state, using the present values of the output signals of the <br>controller. Thus, the signals that control the operations in the datapath unit are formed <br>in the controller in the clock cycle (control state)  <i>preceding</i>  the clock edge at which the <br>operations execute. <br>
<b> <br>Controller and Datapath Hardware Design </b><br>
 <br>The ASMD chart provides all the information needed to design the digital system -- the <br>datapath and the controller. The actual boundary between the hardware of the control-<br>ler and that of the datapath can be arbitrary, but we advocate, first, that the datapath <br>unit contain only the hardware associated with its operations and the logic required, <br>perhaps, to form status signals used by the controller, and, second, that the control unit <br>contain all of the logic required to generate the signals that control the operations of <br>the datapath unit. The requirements for the design of the datapath are indicated by the <br>control signals inside the state and conditional boxes of the ASMD chart and are spec-<br>ified by the annotations of the edges indicating datapath operations. The control logic <br>is determined from the decision boxes and the required state transitions. The hardware <br>configuration of the datapath and controller is shown in  Fig.   8.10  . <br>
 <br>Note that the input signals of the control unit are the external (primary) inputs ( <i>Start,</i> <br>
 <br><i>reset_b</i>,  and  <i>clock</i> ) and the status signals from the datapath (  <i>A</i>2     and     <i>A</i>3   ).  The  status <br>signals provide information about the present condition of the datapath. This informa-<br>tion, together with the primary inputs and information about the present state of the <br>machine, is used to form the output of the controller and the value of the next state. The <br>outputs of the controller are inputs to the datapath and determine which operations will <br>be executed when the clock undergoes a transition. Note, also, that the state of the con-<br>trol unit is not an output of the control unit. <br>
 <br>The control subsystem is shown in  Fig.   8.10   with only its inputs and outputs, with <br>
names matching those of the ASMD chart. The detailed design of the controller is con-<br>sidered subsequently. The datapath unit consists of a fourbit binary counter and two <br> <br><i>JK</i>  flipflops. The counter is similar to the one shown in Fig. 6.12, except that additional <br>internal gates are required for the synchronous clear operation. The counter is incre-<br>mented with every clock pulse when the controller state is  <i>S_1</i> . It is cleared only when <br>control is at state  <i>S_idle</i>  and  <i>Start</i>  is equal to 1. The logic for the signal  <i>clr_A_F</i>  will be <br>included in the controller and requires an AND gate to guarantee that both conditions <br>are present. Similarly, we can anticipate that the controller will use AND gates to form <br>signals  <i>set_E</i>  and  <i>clr_E</i> . Depending on whether the controller is in state  <i>S_1</i>  and whether <br> <i>A</i>2     is  asserted,   <i>set_F</i>  controls flipflop  <i>F</i>  and is asserted unconditionally during state  <i>S_2</i> . <br>Note that all flipflops and registers, including the flipflops in the control unit, use a <br>common clock. <br>
<hr>
<A name=395></a><b>Section 8.5  Design Example (ASMD Chart)    377</b><br>
<i>Design_Example</i><br>
<i>Controller</i><br>
<i>Start</i><br>
<i>Start</i><br>
<i>set_E<br>clr_E</i><br>
<i>set_F</i><br>
<i>clr_A_F</i><br>
<i>A</i>2<br>
<i>incr_A</i><br>
<i>A</i>3<br>
<i>clock</i><br>
<i>reset_b</i><br>
<i>reset_b</i><br>
<i>clock</i><br>
<i>Datapath</i><br>
<i>E</i><br>
<i>J</i><br>
<i>Q</i><br>
<i>C</i><br>
<i>K</i><br>
<i>F</i><br>
<i>J</i><br>
<i>Q</i><br>
<i>C</i><br>
4<i>-bit counter with<br>synchronous clear</i><br>
<i>A</i><br>
<i>K</i><br>
3 <i>A</i>2 <i>A</i>1 <i>A</i>0<br>
<i>A</i><br>
4<br>
 <br><b>FIGURE 8.10   <br> <br>Datapath and controller for design example  </b><br>
<b> <br>Register Transfer Representation </b><br>
 <br>A digital system is represented at the register transfer level by specifying the registers <br>in the system, the operations performed, and the control sequence. The register opera-<br>tions and control information can be specified with an ASMD chart. It is convenient to <br>separate the control logic from the register operations of the datapath. The ASMD chart <br>provides this separation and a clear sequence of steps to design a controller for a data-<br>path. The control information and register transfer operations can also be represented <br>separately, as shown in  Fig.   8.11 . The state diagram specifies the control sequence, and <br>the register operations are represented by the register transfer notation introduced in <br>
<hr>
<A name=396></a><b>378    Chapter 8  Design at the Register Transfer Level</b><br>
<i>A</i><br>
<i>Start</i><br>
0<br>
 <br>
2<br>
0<br>
<i>S_idle</i><br>
<i>S_1</i><br>
<i>S_2</i><br>
<i>Start</i><br>
1<br>
<i>A</i>2<i>A</i>3<br>
11<br>
<i>A</i>2<i>A</i>3<br>
10<br>
(a)<br>
<i>S_idle</i><br>
<i>S_1, clr_A_F</i>:<i> </i><br>
<i>A</i><br>
0<i>, F</i><br>
<i>0</i><br>
<i>S_1</i><br>
<i>S_1, incr_A</i>:<br>
<i>A</i><br>
<i>A  </i> 1<br>
<i>if (A</i>2<br>
1<i>) </i>then <i>set_E</i>:<br>
<i>E</i><br>
1<br>
<i>if (A</i>2<br>
0<i>) </i>then <i>clr_E</i>:<br>
<i>E</i><br>
0<br>
<i>S_2</i><br>
<i>S_idle, set_F</i>:<br>
<i>F</i><br>
1<br>
(b)<br>
 <br><b>FIGURE 8.11   <br> <br>Register transferlevel description of design example  </b><br>
Section 8.2. The state transition and the signal controlling the register operation are <br>shown with the operation. This representation is an alternative to the representation of <br>the system described in the ASMD chart of  Fig.   8.9  (d). Only the ASMD chart is really <br>needed, but the state diagram for the controller is an alternative representation that is <br>useful in manual design. The information for the state diagram is taken directly from <br>the ASMD chart. The state names are specified in each state box. The conditions that <br>cause a change of state are specified inside the diamondshaped decision boxes of the <br>ASMD chart and are used to annotate the state diagram. The directed lines between <br>states and the condition associated with each follow the same path as in the ASMD <br>chart. The register transfer operations for each of the three states are listed following <br>the name of the state. They are taken from the state boxes or the annotated edges of the <br>ASMD chart. <br>
<b> <br>State Table </b><br>
 <br>The state diagram can be converted into a state table from which the sequential circuit <br>of the controller can be designed. First, we must assign binary values to each state in the <br>ASMD chart. For  <i>n</i>  flipflops in the control sequential circuit, the ASMD chart can <br>accommodate up to   2<i>n</i>  states. A chart with 3 or 4 states requires a sequential circuit with <br>two flipflops. With 5 to 8 states, there is a need for three flipflops. Each combination <br>of flipflop values represents a binary number for one of the states. <br>
 A   <i>state table</i>  for a controller is a list of present states and inputs and their correspond-<br>
ing next states and outputs. In most cases, there are many don'tcare input conditions <br>
<hr>
<A name=397></a><b>Section 8.5  Design Example (ASMD Chart)    379</b><br>
<b> <br>Table 8.4 <br><i> <br>State Table for the Controller of  Fig.   8.10  </b></i><br>
<b> <br>Present </b><br>
<b> <br>Next </b><br>
<b> </b><br>
<b>State </b><br>
<b> <br>Inputs </b><br>
<b>State </b><br>
<b> <br>Outputs </b><br>
<b> <br>PresentState </b><br>
<b>Symbol </b><br>
<b> <br><i>G</i>1 </b><br>
<b> <br><i>G</i>0 </b><br>
<i><b> <br>Start  </b></i><br>
<b> <br><i>A</i>2 </b><br>
<b> <br><i>A</i>3 </b><br>
<b> <br><i>G</i>1 </b><br>
<b> <br><i>G</i>0 </b><br>
<i><b>   set_E </b></i><br>
<i><b>  clr_E </b></i><br>
<i><b>   set_F </b></i><br>
<i><b>   clr_A_F </b></i><br>
<i><b>   incr_A </b></i><br>
<i>  S_idle  </i><br>
 0 <br>
 0 <br>
 0 <br>
 X <br>
 X <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
<i>  S_idle  </i><br>
 0 <br>
 0 <br>
 1 <br>
 X <br>
 X <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
<i>  S_1  </i><br>
 0 <br>
 1 <br>
 X <br>
 0 <br>
 X <br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
<i>  S_1  </i><br>
 0 <br>
 1 <br>
 X <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
<i>  S_1  </i><br>
 0 <br>
 1 <br>
 X <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
<i>  S_2  </i><br>
 1 <br>
 1 <br>
 X <br>
 X <br>
 X <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
that must be included, so it is advisable to arrange the state table to take those conditions <br>into consideration. We assign the following binary values to the three states:  <i>S_idle</i> = 00, <br> <br><i>S_1</i> = 01, and  <i>S_2</i> = 11. Binary state 10 is not used and will be treated as a don'tcare <br>condition. The state table corresponding to the state diagram is shown in  Table   8.4  . Two <br>flipflops are needed, and they are labeled   <i>G</i>1     and     <i>G</i>0 . There are three inputs and five <br>outputs. The inputs are taken from the conditions in the decision boxes. The outputs <br>depend on the inputs and the present state of the control. Note that there is a row in the <br>table for each possible transition between states. Initial state 00 goes to state 01 or stays <br>in 00, depending on the value of input  <i>Start</i> . The other two inputs are marked with <br>don'tcare X's, as they do not determine the next state in this case. While the system is <br>in binary state 00 with  <i>Start</i> = 1, the control unit provides an output labeled  <i>clr_A_F</i>   to <br>initiate the required register operations. The transition from binary state 01 depends on <br>inputs     <i>A</i>2     and     <i>A</i>3 . The system goes to binary state 11 only if   <i>A</i>2<i>A</i>3 = 11;     otherwise,  it <br>remains in binary state 01. Finally, binary state 11 goes to 00 independently of the input <br>variables.   <br>
<b> <br>Control Logic </b><br>
 <br>The procedure for designing a sequential circuit starting from a state table was pre-<br>sented in  Chapter   5  . If this procedure is applied to  Table   8.4  , we need to use five<br>variable maps to simplify the input equations. This is because there are five variables <br>listed under the presentstate and input columns of the table. Instead of using maps <br>to simplify the input equations, we can obtain them directly from the state table by <br>inspection. To design the sequential circuit of the controller with  <i>D</i>  flipflops, it is <br>necessary to go over the nextstate columns in the state table and derive all the <br>conditions that must set each flipflop to 1. From  Table   8.4  , we note that the next<br>state column of   <i>G</i>1  has a single 1 in the fifth row. The  <i>D</i>  input of flipflop   <i>G</i>1     must <br>
<hr>
<A name=398></a><b>380    Chapter 8  Design at the Register Transfer Level</b><br>
be equal to 1 during present state  <i>S_1</i>  when both inputs   <i>A</i>2     and     <i>A</i>3  are equal to 1. <br>This condition is expressed with the  <i>D</i>  flipflop input equation <br>
 <br><i>DG</i>1 = <i>S</i>_1 <i>A</i>2<i>A</i>3 <br>
 <br>Similarly, the nextstate column of   <i>G</i>0  has four 1's, and the condition for setting this <br>flipflop is <br>
 <br><i>DG</i>0 = <i>Start S</i>_<i>idle </i>+ <i>S</i>_1   <br>
 <br>To derive the five output functions, we can exploit the fact that binary state 10 is not <br>used, which simplifies the equation for  <i>clr_A_F</i>  and enables us to obtain the following <br>simplified set of output equations: <br>
 <br><i>set</i>_<i>E </i>= <i>S</i>_1<i>A</i>2<br>
<i>clr</i>_<i>E </i>= <i>S</i>_1<i>A</i>2<br>
<i>set</i>_<i>F </i>= <i>S</i>_<i>2</i><br>
<i>clr</i>_<i>A</i>_<i>F </i>= <i>Start S</i>_<i>idle</i><br>
<i>incr</i>_<i>A </i>= <i>S</i>_<i>1</i> <br>
 <br>The logic diagram showing the internal detail of the controller of  Fig.   8.10   is drawn in <br> <br>Fig.   8.12  . Note that although we derived the output equations from  Table   8.4  , they can <br>also be obtained directly by inspection of  Fig.   8.9  (d). This simple example illustrates the <br>
<i>w</i>1<br>
<i>clr_A_F</i><br>
<i>G</i>0<br>
<i>Start</i><br>
<i>D</i><br>
<i>C</i><br>
<i>incr_A</i><br>
<i>w</i>2<br>
<i>set_E</i><br>
<i>G</i>1<br>
<i>set_F</i><br>
<i>A</i><br>
<i>D</i><br>
3<br>
<i>A</i>2<br>
<i>w</i>3<br>
<i>C</i><br>
<i>clr_E</i><br>
<i>clock</i><br>
<i>reset_b</i><br>
 <br><b>FIGURE 8.12   <br> <br>Logic diagram of the control unit for  Fig.   8.10  </b><br>
<hr>
<A name=399></a><b>Section 8.6  HDL Description of Design Example    381</b><br>
manual design of a controller for a datapath, using an ASMD chart as a starting point. <br>The fact that synthesis tools automatically execute these steps should be appreciated. <br>
<b> <br>8 . 6       H D L   D E S C R I P T I O N   O F   D E S I G N   E X A M P L E </b><br>
 <br>In previous chapters, we gave examples of HDL descriptions of combinational circuits, <br>sequential circuits, and various standard components such as multiplexers, counters, and <br>registers. We are now in a position to incorporate these components into the description <br>of a specific design. As mentioned previously, a design can be described either at the <br>structural or behavioral level. Behavioral descriptions may be classified as being either <br>at the register transfer level or at an abstract algorithmic level. Consequently, we now <br>consider three levels of design: structural description, RTL description, and algorithmic<br>based behavioral description. <br>
 The   <i>structural</i>  description is the lowest and most detailed level. The digital system is <br>
specified in terms of the physical components and their interconnection. The various <br>components may include gates, flipflops, and standard circuits such as multiplexers and <br>counters. The design is hierarchically decomposed into functional units, and each unit is <br>described by an HDL module. A toplevel module combines the entire system by instan-<br>tiating all the lower level modules. This style of description requires that the designer <br>have sufficient experience not only to understand the functionality of the system, but <br>also to implement it by selecting and connecting other functional elements. <br>
 The   <i>RTL</i>  description specifies the digital system in terms of the registers, the opera-<br>
tions performed, and the control that sequences the operations. This type of description <br>simplifies the design process because it consists of procedural statements that determine <br>the relationship between the various operations of the design without reference to any <br>specific structure. The RTL description implies a certain hardware configuration among <br>the registers, allowing the designer to create a design that can be synthesized automati-<br>cally, rather than manually, into standard digital components. <br>
 The   <i>algorithmicbased behavioral</i>  description is the most abstract level, describing <br>
the function of the design in a procedural, algorithmic form similar to a programming <br>language. It does not provide any detail on how the design is to be implemented with <br>hardware. The algorithmicbased behavioral description is most appropriate for simulat-<br>ing complex systems in order to verify design ideas and explore trade-offs. Descriptions <br>at this level are accessible to nontechnical users who understand programming lan-<br>guages. Some algorithms, however, might not be synthesizable. <br>
 <br>We will now illustrate the RTL and structural descriptions by using the design exam-<br>
ple of the previous section. The design example will serve as a model of coding style for <br>future examples and will exploit alternative syntax options supported by revisions to <br>the Verilog language. (An algorithmicbased description is illustrated in Section 8.9.) <br>
<b> <br>RTL Description </b><br>
 <br>The block diagram in  Fig.   8.10   describes the design example. An HDL description of <br>the design example can be written as a single RTL description in a Verilog module or <br>
<hr>
<A name=400></a><b>382    Chapter 8  Design at the Register Transfer Level</b><br>
as a toplevel module having instantiations of separate modules for the controller and <br>the datapath. The former option simply ignores the boundaries between the functional <br>units; the modules in the latter option establish the boundaries shown in  Fig.   8.9 (a) and <br> <br>Fig.  8.10 . We advocate the second option, because, in general, it distinguishes more <br>clearly between the controller and the datapath. This choice also allows one to easily <br>substitute alternative controllers for a given datapath (e.g., replace an RTL model by <br>a structural model). The RTL description of the design example is shown in HDL <br>Example 8.2. The description follows the ASMD chart of  Fig.   8.9 (d), which contains a <br>complete description of the controller, the datapath, and the interface between them <br>(i.e., the outputs of the controller and the status signals). Likewise, our description has <br>three modules:  <i>Design_Example_RTL,</i>   <i>Controller_RTL</i>,  and  <i>Datapath_RTL</i> .  The <br>descriptions of the controller and the datapath units are taken directly from  Fig.   8.9 (d). <br> <br><i>Design_Example_RTL</i>  declares the input and output ports of the module and instanti-<br>ates  <i>Controller_RTL</i>  and  <i>Datapath_RTL</i> .At this stage of the description, it is important <br>to remember to declare  <i>A</i>  as a vector. Failure to do so will produce  <i>port mismatch</i>   errors <br>when the descriptions are compiled together. Note that the status signals  <i>A[2]</i>  and  <i>A[3]</i>,  <br>but not  <i>A[0]</i>  and  <i>A[1]</i>,  are passed to the controller. The primary (external) inputs to <br>the controller are  <i>Start,</i>  <i>clock</i>  (to synchronize the system), and  <i>reset_b</i> .  The  activelow <br>input signal  <i>reset_b</i>  is needed to initialize the state of the controller to  <i>S_idle</i> .  Without <br>that signal, the controller could not be placed in a known initial state. <br>
 <br>The controller is described by three cyclic ( <b>always</b> ) behaviors. An edgesensitive <br>
behavior updates the state at the positive edge of the clock, depending on whether a <br>reset condition is asserted. Two levelsensitive behaviors describe the combinational <br>logic for the next state and the outputs of the controller, as specified by the ASMD <br>chart. Notice that the description includes default assignments to all of the outputs <br>(e.g.,     <i>set</i>_<i>E </i>= 0 ). This approach allows the code of the  <b>case</b>  logic to be simplified by <br>expressing only explicit assertions of the variables (i.e., values are assigned by excep-<br>tion). The approach also ensures that every path through the assignment logic assigns <br>a value to every variable. Thus, a synthesis tool will interpret the logic to be combina-<br>tional; failure to assign a value to every variable on every path of logic implies the <br>need for a transparent latch (memory) to implement the logic. Synthesis tools will <br>provide the latch, wasting silicon area. <br>
 <br>The three states of the controller are given symbolic names and are encoded into <br>
binary values. Only three of the possible twobit patterns are used, so the case statement <br>for the nextstate logic includes a  <b>default</b>  assignment to handle the possibility that one <br>of the three assigned codes is not detected. The alternative is to allow the hardware to <br>make an arbitrary assignment to the next state ( <i>next_state</i> =  <i>2 bx</i> ;). Also, the first state-<br>ment of the nextstate logic assigns  <i>next_state = S_idle</i>  to guarantee that the next state <br>is assigned in every thread of the logic. This is a precaution against accidentally forget-<br>ting to make an assignment to the next state in every thread of the logic, with the result <br>that the description implies the need for memory, which a synthesis tool will implement <br>with a transparent latch. <br>
 <br>The description of  <i>Datapath_RTL</i>  is written by testing for an assertion of each <br>
control signal from  <i>Controller_RTL</i> . The register transfer operations are displayed in <br>
<hr>
<A name=401></a><b>Section 8.6  HDL Description of Design Example    383</b><br>
the ASMD chart ( Fig.   8.9  (d)). Note that nonblocking assignments are used (with <br>symbol 6 =) for the register transfer operations. This ensures that the register opera-<br>tions and state transitions are concurrent, a feature that is especially crucial during <br>control state  <i>S_1</i> . In this state,  <i>A</i>  is incremented by 1 and the value of  <i>A2</i>   ( <i>A[2]</i>)   is <br>checked to determine the operation to execute at register  <i>E</i>  at the next clock. To <br>accomplish a valid synchronous design, it is necessary to ensure that  <i>A[2]</i>  is checked <br>before  <i>A</i>  is incremented. If blocking assignments were used, one would have to place <br>the two statements that check  <i>E</i>  first and the  <i>A</i>  statement that increments last. How-<br>ever, by using nonblocking assignments, we accomplish the required synchronization <br>without being concerned about the order in which the statements are listed. The <br>counter  <i>A</i>  in  <i>Datapath_RTL</i>  is cleared synchronously because  <i>clr_A_F</i>  is synchro-<br>nized to the clock. <br>
 <br>The cyclic behaviors of the controller and the datapath interact in a chain reaction: <br>
At the active edge of the clock, the state and datapath registers are updated. A change <br>in the state, a primary input, or a status input causes the levelsensitive behaviors of <br>the controller to update the value of the next state and the outputs. The updated values <br>are used at the next active edge of the clock to determine the state transition and the <br>updates of the datapath. <br>
 <br>Note that the manual method of design developed (1) a block diagram ( Fig.   8.9  (a)) <br>
showing the interface between the datapath and the controller, (2) an ASMD chart for <br>the system ( Fig.   8.9  (d)), (3) the logic equations for the inputs to the flipflops of the <br>controller, and (4) a circuit that implements the controller ( Fig.   8.12  ). In contrast, an <br>RTL model describes the state transitions of the controller and the operations of the <br>datapath as a step toward automatically synthesizing the circuit that implements them. <br>The descriptions of the datapath and controller are derived directly from the ASMD <br>chart  in  both  cases.     <br>
<b>   HDL  Example  8.2  </b><br>
 <br>// RTL description of design example (see  Fig.   8.11  )<br>
<b> <br>module  </b>Design_Example_RTL (A, E, F, Start, clock, reset_b);<br>  // Specify ports of the top-level module of the design<br>
  // See block diagram,  Fig.   8.10  <br>
<b>   output  </b>[3: 0] A;<br><b> <br> output </b><br>
<b> </b><br>
E, F;<br>
  <b>input  </b><br>
Start, clock, reset_b;<br>
  // Instantiate controller and datapath units<br>
  Controller_RTL M0 (set_E, clr_E, set_F, clr_A_F, incr_A, A[2], A[3], Start, clock, reset_b);<br>
  Datapath_RTL M1 (A, E, F, set_E, clr_E, set_F, clr_A_F, incr_A, clock);<br>
<b> <br>endmodule <br> <br>module  </b>Controller_RTL (set_E, clr_E, set_F, clr_A_F, incr_A, A2, A3, Start, clock, reset_b);<br><b> <br> output </b><br>
<b>reg </b><br>
 <br>set_E, clr_E, set_F, clr_A_F, incr_A;<br>
  <b>input  </b><br>
Start, A2, A3, clock, reset_b;<br>
<hr>
<A name=402></a><b>384    Chapter 8  Design at the Register Transfer Level</b><br>
<b> <br> reg </b><br>
<b> </b>[1: 0]  <br>
state, next_state;<br>
  <b>parameter   </b><br>
S_idle = 2'b00, S_1 = 2'b01, S_2 = 2'b11; <br>
// State codes<br>
<b> <br> always </b><br>
<b>  @ </b>(<b>posedge </b>clock,<b> negedge </b>reset_b)  <br>
// State transitions (edge sensitive)<br>
  <b>if  </b>(reset_b == 0) state &lt;= S_idle;<br>  <b>else  </b>state &lt;= next_state;<br> <br>// Code next-state logic directly from ASMD chart ( Fig.   8.9  d)<br>
<b> <br>always @ </b>(state, Start, A2, A3)<b> begin </b><br>
 <br>// Next-state logic (level sensitive)<br>
  next_state = S_idle;<br>
<b> <br> case </b><br>
<b> </b>(state)<br>
<b>    </b>S_idle:<b> </b><br>
<b> <br>if</b>  (Start) next_state = S_1;  <b>else</b>  next_state = S_idle;<br>
 <br>  <br>
S_1:<b>  </b><br>
<b> <br>if</b>  (A2 &amp; A3) next_state = S_2;  <b>else</b>  next_state = S_1;<br>
 <br>  <br>
S_2:<b>  </b><br>
next_state = S_idle;<br>
    <b>default : </b><br>
next_state = S_idle;<br>
<b> <br> endcase <br> <br>end <br></b> <br>// Code output logic directly from ASMD chart ( Fig.   8.9  d)<br>
<b> <br>always   @ </b>(state, Start, A2)<b> begin</b> <br>  set_E   =  0; <br>
// default assignments; assign by exception<br>
 <br> clr_E   = 0;<br>
  set_F    =  0;<br>
 <br> clr_A_F = 0;<br>
 <br> incr_A  = 0;<br>
<b> <br> case </b><br>
<b> </b>(state)<br>
 <br> S_idle: <br>
 <br>
 <br>
<b>if</b>  (Start) clr_A_F = 1;<br>
 <br> S_1: <br>
 <br>
 <br>
<b>begin</b>  incr_A = 1;  <b>if</b>  (A2) set_E = 1;  <b>else clr</b> _E = 1;  <b>end</b> <br>
  S_2:  <br>
set_F = 1;<br>
<b> <br> endcase <br> <br>end <br> <br>endmodule <br> <br>module  </b>Datapath_RTL (A, E, F, set_E, clr_E, set_F, clr_A_F, incr_A, clock);<br><b> <br> output </b><br>
<b>  reg</b>  [3: 0] A; <br>
// register for counter<br>
  <b>output reg</b>   <br>
E, F; <br>
// flags<br>
<b> <br> input </b><br>
<b>  </b><br>
set_E, clr_E, set_F, clr_A_F, incr_A, clock;<br>
  // Code register transfer operations directly from ASMD chart ( Fig.   8.9  (d))<br>
<b> <br> always @ </b>(<b>posedge </b>clock)<b> begin</b> <br><b> <br> if </b><br>
<b> </b>(set_E)  <br>
E &lt;= 1;<br>
  <b>if  </b>(clr_E)  <br>
E &lt;= 0;<br>
  <b>if  </b>(set_F)  <br>
F &lt;= 1;<br>
  <b>if  </b>(clr_A_F)  <br>
<b>begin</b>  A &lt;= 0; F &lt;= 0;  <b>end</b> <br>
  <b>if  </b>(incr_A)  <br>
A &lt;= A + 1;<br>
<b> <br> end <br> <br>endmodule  </b><br>
<hr>
<A name=403></a><b>Section 8.6  HDL Description of Design Example    385</b><br>
<b> <br>Testing the Design Description </b><br>
 <br>The sequence of operations for the design example was investigated in the previous <br>section.  Table   8.3   shows the values of  <i>E</i>  and  <i>F</i>  while register  <i>A</i>  is incremented. It is <br>instructive to devise a test that checks the circuit to verify the validity of the HDL <br>description. The test bench in HDL Example 8.3 provides such a module. (The procedure <br>for writing test benches is explained in Section 4.12.) The test module generates signals <br>for  <i>Start, clock</i>,  and  <i>reset_b</i>,  and checks the results obtained from registers  <i>A, E</i>,  and  <i>F</i> . <br>Initially, the  <i>reset_b</i>  signal is set to 0 to initialize the controller, and  <i>Start</i>  and  <i>clock</i>   are <br>set to 0. At time   <i>t </i>= 5   ,  the   <i>reset_b</i>  signal is deasserted by setting it to 1, the  <i>Start</i>   input <br>is asserted by setting it to 1, and the clock is then repeated for 16 cycles. The  <b>$monitor</b> <br>statement displays the values of  <i>A, E</i>,  and  <i>F</i>  every 10 ns. The output of the simulation is <br>listed in the example under the simulation log. Initially, at time   <i>t </i>= 0 , the values of the <br>registers are unknown, so they are marked with the symbol  <b>x</b> . The first positive clock <br>transition, at time = 10, clears  <i>A</i>  and  <i>F</i>,  but does not affect  <i>E</i>,  so  <i>E</i>  is unknown at this <br>time. The rest of the table is identical to  Table   8.3  . Note that since  <i>Start</i>  is still equal to <br>1 at time = 160, the last entry in the table shows that  <i>A</i>  and  <i>F</i>  are cleared to 0, and  <i>E</i> <br>does not change and remains at 1. This occurs during the second transition, from  <i>S_idle</i> <br>to  <i>S_1</i> . <br>
<b>   HDL  Example  8.3  </b><br>
 <br>// Test bench for design example<br>
 <br>'timescale 1 ns / 1 ps<br>
<b> <br>module  </b>t_Design_Example_RTL;<br><b> <br> reg </b><br>
<b>  </b><br>
Start, clock, reset_b;<br>
<b> <br> wire </b><br>
<b> </b>[3: 0] A;<br>
<b> <br> wire </b><br>
<b>  </b><br>
E, F;<br>
  // Instantiate design example<br>
  Design_Example_RTL M0 (A, E, F, Start, clock, reset_b);<br>
  // Describe stimulus waveforms<br>
<b> <br> initial </b><br>
<b> </b>#500  <b>$finish</b> ; // <br>
Stopwatch<br>
<b> <br> initial <br> <br> begin <br></b>    reset_b = 0;<br>
    Start = 0;<br>
    clock = 0;<br>
    #5 reset_b = 1; Start = 1;<br>
<b> <br>  </b><br>
<b>repeat </b><br>
<b> </b>(32)<br>
    <b>begin <br></b>    #5 clock = ~ clock; <br>
// Clock generator<br>
<b> <br>  </b><br>
<b>end </b><br>
<hr>
<A name=404></a><b>386    Chapter 8  Design at the Register Transfer Level</b><br>
<b> <br> end <br> <br> initial <br> <br> $monitor </b><br>
<b> </b>(&quot;A = %b E = %b F = %b time = %0d&quot;, A, E, F,  <b>$time</b> );<br>
 <br><b>endmodule <br></b> <br>Simulation log:<br>
 <br>A = xxxx  E = x F = x  time =  0<br>
 <br>A = 0000 E = x F = 0 time =  10<br>
 <br>A = 0001 E = 0 F = 0 time =  20<br>
 <br>A = 0010 E = 0 F = 0 time =  30<br>
 <br>A = 0011  E = 0 F = 0 time =  40<br>
 <br>A = 0100 E = 0 F = 0 time =  50<br>
 <br>A = 0101 E = 1 F = 0 time =  60<br>
 <br>A = 0110  E = 1 F = 0 time =  70<br>
 <br>A = 0111  E = 1 F = 0 time =  80<br>
 <br>A = 1000 E = 1 F = 0 time =  90<br>
 <br>A = 1001 E = 0 F = 0 time =  100<br>
 <br>A = 1010 E = 0 F = 0 time =  110<br>
 <br>A = 1011  E = 0 F = 0 time =  120<br>
 <br>A = 1100  E = 0 F = 0 time =  130<br>
 <br>A = 1101  E = 1 F = 0 time =  140<br>
 <br>A = 1101  E = 1 F = 1 time =  150<br>
 <br>A = 0000 E = 1 F = 0 time =  160  <br>
 <br>Waveforms produced by a simulation of  <i>Design_Example_RTL</i>  with the test bench <br>
are shown in  Fig.   8.13  . Numerical values are shown in hexadecimal format. The results <br>are annotated to call attention to the relationship between a control signal and the <br>operation that it causes to execute. For example, the controller asserts  <i>set_E</i>  for one <br>clock cycle  <i>before</i>  the clock edge at which  <i>E</i>  is set to 1. Likewise,  <i>set_F</i>  asserts during <br>the clock cycle before the edge at which  <i>F</i>  is set to 1. Also,  <i>clr_A_F</i>  is formed in the <br>cycle before  <i>A</i>  and  <i>F</i>  are cleared. A more thorough verification of  <i>Design_Example_<br>RTL</i>  would confirm that the machine recovers from a reset on the fly (i.e., a reset that <br>is asserted randomly after the machine is operating). Note that the signals in the out-<br>put of the simulation have been listed in groups showing (1)  <i>clock</i>  and  <i>reset_b</i>,  (2)  <i>Start</i> <br>and the status inputs, (3) the state, (4) the control signals, and (5) the datapath regis-<br>ters.  <i>It is strongly recommended that the state always be displayed</i>,  because this informa-<br>tion is essential for verifying that the machine is operating correctly and for debugging <br>its description when it is not. For the chosen binary state code,   <i>S</i>_<i>idle </i>= 002 = 0H,<br>
<i>S</i>_<i>1</i>= 012 = 1H, and <i>S</i>_<i>2 </i>= 112 = 3H. <br>
<b> <br>Structural Description </b><br>
 <br>The RTL description of a design consists of procedural statements that determine the <br>functional behavior of the digital circuit. This type of description can be compiled by <br>
<hr>
<A name=405></a><b>Section 8.6  HDL Description of Design Example    387</b><br>
0<br>
50<br>
100<br>
150<br>
Name<br>
<i>clock<br>reset_b</i><br>
<i>Start<br>A2<br>A3</i><br>
<i>state[1: 0]</i><br>
0<br>
1<br>
3<br>
0<br>
1<br>
<i>clr_A_F<br>set_E<br>clr_E<br>set_F<br>incr_A</i><br>
<i>A[3: 0]</i><br>
x<br>
0<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
a<br>
b<br>
c<br>
d<br>
0<br>
<i>E<br>F</i><br>
 <br><b>FIGURE 8.13   <br> <br>Simulation results for <i> Design_Example_RTL  </b></i><br>
HDL synthesis tools, from which it is possible to obtain the equivalent gatelevel circuit <br>of the design. It is also possible to describe the design by its structure rather than its <br>function. A structural description of a design consists of instantiations of components <br>that define the circuit elements and their interconnections. In this regard, a structural <br>description is equivalent to a schematic diagram or a block diagram of the circuit. Con-<br>temporary design practice relies heavily on RTL descriptions, but we will present a <br>structural description here to contrast the two approaches. <br>
 <br>For convenience, the circuit is again decomposed into two parts: the controller and <br>
the datapath. The block diagram of  Fig.   8.10   shows the highlevel partition between these <br>units, and  Fig.   8.12   provides additional underlying structural details of the controller. <br>The structure of the datapath is evident in  Fig.   8.10   and consists of the flipflops and the <br>fourbit counter with synchronous clear. The top level of the Verilog description replaces <br> <br><i>Design_Example_RTL,</i>  <i>Controller_RTL</i>,  and  <i>Datapath_RTL</i>   by   <i>Design_Example_STR,</i> <br> <br><i>Controller_STR</i>,  and  <i>Datapath_STR</i>,  respectively. The descriptions of  <i>Controller_STR</i> <br>and  <i>Datapath_STR</i>  will be structural. <br>
 <br>HDL Example 8.4 presents the structural description of the design example. It consists <br>
of a nested hierarchy of modules and gates describing (1) the toplevel module,  <i>Design_<br>Example_STR</i>,  (2) the modules describing the controller and the datapath, (3) the modules <br>describing the flipflops and counters, and (4) gates implementing the logic of the controller. <br>For simplicity, the counter and flipflops are described by RTL models. <br>
 <br>The toplevel module (see  Fig.   8.10  ) encapsulates the entire design by (1) instantiating <br>
the controller and the datapath modules, (2) declaring the primary (external) input signals, <br>
<hr>
<A name=406></a><b>388    Chapter 8  Design at the Register Transfer Level</b><br>
(3) declaring the output signals, (4) declaring the control signals generated by the controller <br>and connected to the datapath unit, and (5) declaring the status signals generated by the <br>datapath unit and connected to the controller. The port list is identical to the list used in the <br>RTL description. The outputs are declared as  <b>wire</b>  type here because they serve merely to <br>connect the outputs of the datapath module to the outputs of the toplevel module, with <br>their logic value being determined within the datapath module. <br>
 <br>The control module describes the circuit of  Fig.   8.12  . The outputs of the two flipflops <br>
 <br><i>G1</i>  and  <i>G0</i>  are declared as  <b>wire</b>  data type.  <i>G1</i>  and  <i>G0</i>  cannot be declared as  <b>reg</b>   data <br>type because they are outputs of an instantiated  <i>D</i>  flipflop.  <i>DG1</i>  and  <i>DG0</i>  are unde-<br>clared identifiers, i.e., implicit wires. The name of a variable is local to the module or <br>procedural block in which it is declared. Nets may not be declared within a procedural <br>block (e.g.,  <b>begin</b>  . . .  <b>end</b> ). The rule to remember is that a variable must be a declared <br>register type (e.g.,  <b>reg</b> ) if and only if its value is assigned by a procedural statement <br>(i.e., a blocking or nonblocking assignment statement within a procedural block in cyclic <br>or singlepass behavior or in the output of a sequential UDP). The instantiated gates <br>specify the combinational part of the circuit. There are two flipflop input equations and <br>three output equations. The outputs of the flipflops  <i>G1</i>  and  <i>G0</i>  and the input equations <br> <br><i>DG1</i>  and  <i>DG0</i>  replace output  <i>Q</i>  and input  <i>D</i>  in the instantiated flipflops. The  <i>D</i>   flip<br>flop is then described in the next module. The structure of the datapath unit has direct <br>inputs to the  <i>JK</i>  flipflops. Note the correspondence between the modules of the HDL <br>description and the structures in Figs. 8.9, 8.10, and 8.12. <br>
<b>   HDL  Example  8.4  </b><br>
 <br>// Structural description of design example (Figs. 8.9(a), 8.12)<br>
<b> <br>module  </b>Design_Example_STR<br><b>  </b>(<b>  output</b>   <br>
[3: 0]  <br>
A, <br>
// V 2001 port syntax<br>
<b> <br> output </b><br>
<b> </b><br>
E, F,<br>
  <b>input  </b><br>
Start, clock, reset_b<br>
 <br> );<br>
  Controller_STR M0 (clr_A_F, set_E, clr_E, set_F, incr_A, Start, A[2], A[3], clock, <br>
 reset_b <br>
);<br>
  Datapath_STR M1 (A, E, F, clr_A_F, set_E, clr_E, set_F, incr_A, clock);<br>
<b> <br>endmodule </b><br>
<b> <br>module  </b>Controller_STR<br> <br>(  <b>output</b>  clr_A_F, set_E, clr_E, set_F, incr_A,<br><b>    input  </b>Start, A2, A3, clock, reset_b<br> <br>);<br>
<b> <br> wire </b><br>
<b> </b><br>
G0, G1;<br>
<b> <br> parameter </b><br>
<b> </b><br>
S_idle = 2'b00, S_1 = 2'b01, S_2 = 2'b11;<br>
  <b>wire   </b><br>
w1, w2, w3;<br>
<hr>
<A name=407></a><b>Section 8.6  HDL Description of Design Example    389</b><br>
<b> <br> not </b><br>
<b> </b>(G0_b, G0);<br>
<b> <br> not </b><br>
<b> </b>(G1_b, G1);<br>
   <b>buf  </b>(incr_A, w2);<br>  <b>buf  </b>(set_F, G1);<br>  <b>not  </b>(A2_b, A2);<br>  <b>or  </b>(D_G0, w1, w2);<br>  <b>and  </b>(w1, Start, G0_b);<br>  <b>and  </b>(clr_A_F, G0_b, Start);<br>  <b>and  </b>(w2, G0, G1_b);<br>  <b>and  </b>(set_E, w2, A2);<br>  <b>and  </b>(clr_E, w2, A2_b);<br>  <b>and  </b>(D_G1, w3, w2);<br>  <b>and  </b>(w3, A2, A3);<br>  D_flip_flop_AR M0 (G0, D_G0, clock, reset_b);<br>
  D_flip_flop_AR M1 (G1, D_G1, clock, reset_b);<br>
<b> <br>endmodule </b><br>
 <br>// datapath unit<br>
<b> <br>module  </b>Datapath_STR<br> <br>(  <b>output</b>  [3: 0] <br>
A,<br>
<b> <br>  output </b><br>
<b> </b><br>
E, F,<br>
   <b>input  </b><br>
clr_A_F, set_E, clr_E, set_F, incr_A, clock<br>
 <br>);<br>
  JK_flip_flop_2 M0 (E, E_b, set_E, clr_E, clock);<br>
  JK_flip_flop_2 M1 (F, F_b, set_F, clr_A_F, clock);<br>
  Counter_4 <br>
M2 (A, incr_A, clr_A_F, clock);<br>
<b> <br>endmodule </b><br>
 <br>// Counter with synchronous clear<br>
<b> <br>module  </b>Counter_4 ( <b>output</b>   <b>reg</b>  [3: 0] A,  <b>input</b>  incr, clear, clock);<br><b> <br> always </b><br>
<b>  @ </b>(<b>posedge </b>clock) <br>
  <b>if  </b>(clear)  <br>
A &lt;= 0;  <b>else if</b>  (incr) A &lt;= A + 1;<br>
 <br><b>endmodule </b><br>
<b> <br>module  </b>D_flip_flop_AR (Q, D, CLK, RST);<br><b> <br> output </b><br>
<b>  </b><br>
Q;<br>
  <b>input  </b><br>
D, CLK, RST;<br>
  <b>reg   </b><br>
Q;<br>
<b> <br> always </b><br>
<b>  @ </b>(<b>posedge </b>CLK,<b> negedge </b>RST) <br>
<b> <br> if </b><br>
<b> </b>(RST == 0) Q &lt;= 1'b0;<br>
  <b>else  </b>Q &lt;= D;<br><b> <br>endmodule </b><br>
 <br>// Description of JK flip-flop<br>
<hr>
<A name=408></a><b>390    Chapter 8  Design at the Register Transfer Level</b><br>
<b> <br>module  </b>JK_flip_flop_2 (Q, Q_not, J, K, CLK);<br><b> <br> output </b><br>
<b>  </b><br>
Q, Q_not;<br>
  <b>input  </b><br>
J, K, CLK;<br>
  <b>reg   </b><br>
Q;<br>
  <b>assign  </b><br>
Q_not = ~Q;<br>
  <b>always   @ </b>(<b>posedge </b>CLK) <br>  <b>case  </b>({J, K})<br>    2'b00: <br>
Q &lt;= Q;<br>
    2'b01: <br>
Q &lt;= 1'b0;<br>
    2'b10: <br>
Q &lt;= 1'b1;<br>
    2'b11: <br>
Q &lt;= ~Q;<br>
<b> <br> endcase <br> <br>endmodule </b><br>
<b> <br>module </b>t_Design_Example_STR; <br><b> <br> reg </b><br>
<b> </b>Start, clock, reset_b;<br>
  <b>wire  </b>[3: 0] A;<br><b> <br> wire </b><br>
<b> </b><br>
E, F;<br>
  // Instantiate design example<br>
 <br>Design_Example_STR M0 (A, E, F, Start, clock, reset_b);<br>
 <br>// Describe stimulus waveforms<br>
<b> <br>initial  </b>#500  <b>$finish</b> ; // <br>
Stopwatch<br>
<b> <br>initial <br> <br> begin <br></b>  reset_b = 0;<br>
  Start = 0;<br>
  clock = 0;<br>
  #5 reset_b = 1; Start = 1;<br>
<b> <br> repeat </b><br>
<b> </b>(32)<br>
    <b>begin <br></b>    #5 clock = ~ clock; <br>
// Clock generator<br>
<b> <br>  </b><br>
<b>end </b><br>
<b> <br> end <br> <br>initial <br> <br> $monitor </b><br>
<b> </b>(&quot;A = %b E = %b F = %b time = %0d&quot;, A, E, F,  <b>$time</b> );<br>
<b> <br>endmodule  </b><br>
 <br>The structural description was tested with the test bench that verified the RTL descrip-<br>
tion to produce the results shown in  Fig.   8.13  .The only change necessary is the replacement <br>of the instantiation of the example from  <i>Design_Example_RTL</i>  by  <i>Design_Example_STR</i> . <br>The simulation results for  <i>Design_Example_STR</i>  matched those for  <i>Design_Example_<br>RTL</i> . However, a comparison of the two descriptions indicates that the RTL style is easier <br>
<hr>
<A name=409></a><b>Section 8.7  Sequential Binary Multiplier    391</b><br>
to write and will lead to results faster if synthesis tools are available to automatically <br>synthesize the registers, the combinational logic, and their interconnections. <br>
<b> <br>8 . 7       S E Q U E N T I A L   B I N A R Y   M U L T I P L I E R </b><br>
 <br>This section introduces a second design example. It presents a hardware algorithm for <br>binary multiplication, proposes the register configuration for its implementation, and <br>then shows how to use an ASMD chart to design its datapath and its controller. <br>
 <br>The system we will examine multiplies two unsigned binary numbers. The hardware <br>
developed in Section 4.7 to execute multiplication resulted in a combinational circuit <br>multiplier with many adders and AND gates, and requires large area of silicon as an <br>integrated circuit. In contrast, in this section, a more efficient hardware algorithm results <br>in a sequential multiplier that uses only one adder and a shift register. The savings in <br>hardware and silicon area come about from a tradeoff in the space (hardware)�time <br>domain. A parallel adder uses more hardware, but forms its result in one cycle of the <br>clock; a sequential adder uses less hardware, but takes multiple clock cycles to form its <br>result. <br>
 <br>The multiplication of two binary numbers is done with paper and pencil by successive <br>
(i.e., sequential) additions and shifting. The process is best illustrated with a numerical <br>example. Let us multiply the two binary numbers 10111 and 10011: <br>
                   23             10111   multiplican<br>
19             10011  multiplier<br>
10111<br>
10111<br>
 <br>
                                <br>
00000<br>
00000<br>
10111<br>
 437   110110101   product<br>
 <br>The process consists of successively adding and shifting copies of the multiplicand. <br>Successive bits of the multiplier are examined, least significant bit first. If the multi-<br>plier bit is 1, the multiplicand is copied down; otherwise, 0's are copied down. The <br>numbers copied in successive lines are shifted one position to the left from the previ-<br>ous number. Finally, the numbers are added and their sum forms the product. The <br>product obtained from the multiplication of two binary numbers of  <i>n</i>  bits each can <br>have up to 2 <i>n</i>  bits. It is apparent that the operations of addition and shifting are <br>executed by the algorithm. <br>
 <br>When the multiplication process is implemented with digital hardware, it is conve-<br>
nient to change the process slightly. First, we note that, in the context of synthesizing <br>a sequential machine, the addandshift algorithm for binary multiplication can be <br>executed in a single clock cycle or over multiple clock cycles. A choice to form the <br>
<hr>
<A name=410></a><b>392    Chapter 8  Design at the Register Transfer Level</b><br>
product in the time span of a single clock cycle will synthesize the circuit of a parallel <br>multiplier like the one discussed in Section 4.7. On the other hand, an RTL model of <br>the algorithm adds shifted copies of the multiplicand to an accumulated partial prod-<br>uct. The values of the multiplier, multiplicand, and partial product are stored in regis-<br>ters, and the operations of shifting and adding their contents are executed under the <br>control of a state machine. Among the many possibilities for distributing the effort of <br>multiplication over multiple clock cycles, we will consider that in which only one par-<br>tial product is formed and accumulated in a single cycle of the clock. (One alternative <br>would be to use additional hardware to form and accumulate two partial products in <br>a clock cycle, but this would require more logic gates and either faster circuits or a <br>slower clock.) Instead of providing digital circuits to store and add simultaneously as <br>many binary numbers as there are 1's in the multiplier, it is less expensive to provide <br>only the hardware needed to sum two binary numbers and accumulate the partial <br>products in a register. Second, instead of shifting the multiplicand to the left, the par-<br>tial product being formed is shifted to the right. This leaves the partial product and <br>the multiplicand in the required relative positions. Third, when the corresponding bit <br>of the multiplier is 0, there is no need to add all 0's to the partial product, since doing <br>so will not alter its resulting value. <br>
<b> <br>Register Configuration </b><br>
 <br>A block diagram for the sequential binary multiplier is shown in  Fig.   8.14  (a), and the <br>register configuration of the datapath is shown in  Fig.   8.14  (b). The multiplicand is <br>stored in register  <i>B</i>,  the multiplier is stored in register  <i>Q</i>,  and the partial product is <br>formed in register  <i>A</i>  and stored in  <i>A</i>  and  <i>Q</i> . A parallel adder adds the contents of <br>register  <i>B</i>  to register  <i>A</i> .  The   <i>C</i>  flipflop stores the carry after the addition. The counter <br> <br><i>P</i>  is initially set to hold a binary number equal to the number of bits in the multiplier. <br>This counter is decremented after the formation of each partial product. When the <br>content of the counter reaches zero, the product is formed in the double register  <i>A</i> <br>and  <i>Q</i>,  and the process stops. The control logic stays in an initial state until  <i>Start</i> <br>becomes 1. The system then performs the multiplication. The sum of  <i>A</i>  and  <i>B</i>   forms <br>the  <i>n</i>  most significant bits of the partial product, which is transferred to  <i>A</i> .  The  output <br>carry from the addition, whether 0 or 1, is transferred to  <i>C</i> . Both the partial product <br>in  <i>A</i>  and the multiplier in  <i>Q</i>  are shifted to the right. The least significant bit of  <i>A</i>   is <br>shifted into the most significant position of  <i>Q</i>,  the carry from  <i>C</i>  is shifted into the most <br>significant position of  <i>A</i>,  and 0 is shifted into  <i>C</i> . After the shiftright operation, one <br>bit of the partial product is transferred into  <i>Q</i>  while the multiplier bits in  <i>Q</i>  are shifted <br>one position to the right. In this manner, the least significant bit of register  <i>Q</i>,   desig-<br>nated by  <i>Q[0]</i>,  holds the bit of the multiplier that must be inspected next. The control <br>logic determines whether to add or not on the basis of this input bit. The control logic <br>also receives a signal,  <i>Zero</i>,  from a circuit that checks counter  <i>P</i>  for zero.  <i>Q[0]</i>   and <br> <br><i>Zero</i>  are status inputs for the control unit. The input signal  <i>Start</i>  is an external control <br>input. The outputs of the control logic launch the required operations in the registers <br>of the datapath unit. <br>
<hr>
<A name=411></a><b>Section 8.7  Sequential Binary Multiplier    393</b><br>
<i>Ready</i><br>
<i>Multiplicand</i><br>
<i>Multiplier</i><br>
<i>Datapath</i><br>
<i>A</i><br>
<i>Load_regs</i><br>
<i>Shift_regs</i><br>
<i>B</i><br>
<i>Start</i><br>
<i>Controller</i><br>
<i>Add_regs</i><br>
<i>Q</i><br>
<i>Decr_P</i><br>
<i>C</i><br>
<i>P</i><br>
<i>reset</i><br>
<i>clock</i><br>
<i>Product</i><br>
<i>Zero</i><br>
<i>Q</i>[<i>0</i>]<br>
(a)<br>
Register <i>B</i> (<i>Multiplicand</i>)<br>
Register <i>P</i> (<i>Counter</i>)<br>
1<br>
1<br>
0<br>
1<br>
0<br>
1<br>
1<br>
1<br>
1<br>
0<br>
0<br>
0<br>
7<br>
0<br>
8<br>
16 15<br>
8<br>
8<br>
7<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
1<br>
0<br>
1<br>
1<br>
1<br>
9<br>
<i>C</i><br>
Register <i>A</i> (<i>Sum</i>)<br>
Register <i>Q</i> (<i>Multiplier</i>)<br>
(b)<br>
 <br><b>FIGURE 8.14   <br> <br>(a) Block diagram and (b) datapath of a binary multiplier  </b><br>
 <br>The interface between the controller and the datapath consists of the status signals <br>
and the output signals of the controller. The control signals govern the synchronous <br>register operations of the datapath. Signal  <i>Load_regs</i>  loads the internal registers of the <br>datapath,  <i>Shift_regs</i>  causes the shift register to shift,  <i>Add_regs</i>  forms the sum of the <br>multiplicand and register  <i>A</i>,  and  <i>Decr_P</i>  decrements the counter. The controller also <br>forms output  <i>Ready</i>  to signal to the host environment that the machine is ready to mul-<br>tiply. The contents of the register holding the product vary during execution, so it is <br>useful to have a signal indicating that its contents are valid. Note, again, that the state <br>of the control is not an interface signal between the control unit and the datapath. Only <br>the signals needed to control the datapath are included in the interface. Putting the state <br>in the interface would require a decoder in the datapath, and would require a wider and <br>more active bus than the control signals alone. Not good. <br>
<hr>
<A name=412></a><b>394    Chapter 8  Design at the Register Transfer Level</b><br>
<b> <br>ASMD Chart </b><br>
 <br>The ASMD chart for the binary multiplier is shown in  Fig.   8.15  . The intermediate form <br>in  Fig.   8.15  (a) annotates the ASM chart of the controller with the register operations, <br>and the completed chart in  Fig.   8.15  (b) identifies the Moore and Mealy outputs of the <br>controller. Initially, the multiplicand is in  <i>B</i>  and the multiplier in  <i>Q</i> .As long as the circuit <br>is in the initial state and  <i>Start</i> = 0, no action occurs and the system remains in state  <i>S_idle</i> <br>with  <i>Ready</i>  asserted. The multiplication process is launched when  <i>Start</i> = 1. Then, (1) con-<br>trol goes to state  <i>S_add</i>,  (2) register  <i>A</i>  and carry flipflop  <i>C</i>  are cleared to 0, (3) registers <br>
<i>reset_b</i><br>
<i>S_idle</i><br>
<i>reset_b</i><br>
<i>Ready</i><br>
<i>A</i><br>
 0<br>
<i>C</i><br>
 0<br>
<i>B</i><br>
<i>Multiplicand</i><br>
<i>S_idle</i><br>
<i>Start</i><br>
<i>Q</i><br>
<i>Multiplier</i><br>
1<br>
<i>P</i><br>
<i>n</i><br>
<i>A</i><br>
 0<br>
<i>Load_regs</i><br>
<i>C</i><br>
 0<br>
<i>Start</i><br>
<i>B</i><br>
<i>Multiplicand</i><br>
<i>P</i><br>
<i> P </i>1<br>
1<br>
<i>Q</i><br>
<i>Multiplier</i><br>
<i>P</i><br>
<i>n</i><br>
<i>S_add<br>Decr_P</i><br>
<i>S_add</i><br>
{<i>C, A</i>}<br>
<i> A   B</i><br>
<i>P</i><br>
<i> P </i>1 <i>Decrement counter</i><br>
1<br>
<i>Q[0]</i><br>
{<i>C, A</i>}<br>
<i> A   B</i><br>
1<br>
<i>Q[0]</i><br>
<i>Add multiplicand </i><br>
<i>Add_regs</i><br>
<i>to shifted sum</i><br>
<i>S_shift<br>Shift_regs</i><br>
<i>S_shift</i><br>
{<i>C, A, Q</i>}<br>
 {<i>C, A, Q</i>}<br>
 1<br>
{<i>C, A, Q</i>}<br>
{<i>C, A, Q</i>}<br>
1<br>
<i>17-bit register shifts to the</i><br>
<i>Zero</i><br>
<i>Zero</i><br>
<i>right by one bit</i><br>
1<br>
1<br>
(a)<br>
(b)<br>
 <br><b>FIGURE 8.15   <br> <br>ASMD chart for binary multiplier  </b><br>
<hr>
<A name=413></a><b>Section 8.7  Sequential Binary Multiplier    395</b><br>
 <br><i>B</i>  and  <i>Q</i>  are loaded with the multiplicand and the multiplier, respectively, and (4) the <br>sequence counter  <i>P</i>  is set to a binary number  <i>n</i>,  equal to the number of bits in the mul-<br>tiplier. In state  <i>S_add</i>,  the multiplier bit in  <i>Q[0]</i>  is checked, and if it is equal to 1, the <br>multiplicand in  <i>B</i>  is added to the partial product in  <i>A</i> . The carry from the addition is <br>transferred to  <i>C</i> . The partial product in  <i>A</i>  and  <i>C</i>  is left unchanged if  <i>Q[0]</i> = 0. The coun-<br>ter  <i>P</i>  is decremented by 1 regardless of the value of  <i>Q[0]</i>,  so  <i>Decr_P</i>  is formed in state <br> <br><i>S_add</i>  as a Moore output of the controller. In both cases, the next state is  <i>S_shift</i> .  Reg-<br>isters  <i>C,</i>  <i>A</i>,  and  <i>Q</i>  are combined into one composite register  <i>CAQ</i>,  denoted by the <br>concatenation { <i>C, A, Q</i> }, and its contents are shifted once to the right to obtain a new <br>partial product. This shift operation is symbolized in the flowchart with the Verilog <br>logical rightshift operator, 77. It is equivalent to the following statement in register <br>transfer notation: <br>
   <br>Shift  right  <i>CAQ</i>, <i>C </i>d 0   <br>
 <br>In terms of individual register symbols, the shift operation can be described by the fol-<br>lowing register operations: <br>
 <i>A </i>d shr <i>A</i>, <i>An</i>-1 d <i>C<br>Q </i>d shr <i>Q</i>, <i>Qn</i>-1 d <i>A</i>0<br>
<i>C </i>d 0   <br>
 <br>Both registers  <i>A</i>  and  <i>Q</i>  are shifted right. The leftmost bit of  <i>A</i>,  designated by   <i>An</i>-1 , <br>receives the carry from  <i>C</i> .The leftmost bit of  <i>Q,</i>  <i>Qn</i>-1 , receives the bit from the rightmost <br>position of  <i>A</i>   in     <i>A</i>0   ,  and   <i>C</i>  is reset to 0. In essence, this is a long shift of the composite <br>register  <i>CAQ</i>  with 0 inserted into the serial input, which is at  <i>C</i> . <br>
 <br>The value in counter  <i>P</i>  is checked after the formation of each partial product. If the <br>
contents of  <i>P</i>  are different from zero, status bit  <i>Zero</i>  is set equal to 0 and the process is <br>repeated to form a new partial product. The process stops when the counter reaches 0 <br>and the controller's status input  <i>Zero</i>  is equal to 1. Note that the partial product formed <br>in  <i>A</i>  is shifted into  <i>Q</i>  one bit at a time and eventually replaces the multiplier. The final <br>product is available in  <i>A</i>  and  <i>Q</i>,  with  <i>A</i>  holding the most significant bits and  <i>Q</i>  the least <br>significant bits of the product. <br>
 <br>The previous numerical example is repeated in  Table   8.5   to clarify the multiplication <br>
process. The procedure follows the steps outlined in the ASMD chart. The data shown <br>in the table can be compared with simulation results. <br>
 <br>The type of registers needed for the data processor subsystem can be derived from the <br>
register operations listed in the ASMD chart. Register  <i>A</i>  is a shift register with parallel <br>load to accept the sum from the adder and must have a synchronous clear capability to <br>reset the register to 0. Register  <i>Q</i>  is a shift register. The counter  <i>P</i>  is a binary down coun-<br>ter with a facility to parallel load a binary constant. The  <i>C</i>  flipflop must be designed to <br>accept the input carry and have a synchronous clear. Registers  <i>B</i>   and   <i>Q</i>  need a parallel <br>load capability in order to receive the multiplicand and multiplier prior to the start of the <br>multiplication process. <br>
<hr>
<A name=414></a><b>396    Chapter 8  Design at the Register Transfer Level</b><br>
<b> <br>Table 8.5 <br><i> <br>Numerical Example For Binary Multiplier </b></i><br>
<b> <br>Multiplicand  <i>B</i>  = 10111 2  = 17 H  = 23 10 </b><br>
<b> <br>Multiplier  <i>Q</i>  = 10011 2  = 13 H  = 19 10 </b><br>
<i> </i><br>
<i><b> <br>C  </b></i><br>
<i><b> <br>A  </b></i><br>
<i><b> <br>Q  </b></i><br>
<i><b> <br>P  </b></i><br>
<i> <br></i>Multiplier in<i>   Q  </i><br>
 0 <br>
 00000 <br>
 10011 <br>
 101 <br>
<i>  Q  </i>0<i> </i>=<i> </i>1; add<i>   B  </i><br>
 <br>
  10111  <br>
  <br>
  <br>
 First  partial  product <br>
 0 <br>
 10111 <br>
  <br>
 100 <br>
 <br>Shift right  <i>CAQ</i>  <br>
 0 <br>
 01011 <br>
 11001 <br>
  <br>
<i>  Q  </i>0<i> </i>=<i> </i>1; add<i>   B  </i><br>
 <br>
  10111  <br>
  <br>
  <br>
 <br>Second partial product <br>
 <br>1 <br>
 <br>00010 <br>
  <br>
 011 <br>
 <br>Shift right  <i>CAQ</i>  <br>
 0 <br>
 10001 <br>
 01100 <br>
  <br>
<i>  Q  </i>0<i> </i>=<i> </i>0; shift right<i>   CAQ  </i><br>
 0 <br>
 01000 <br>
 10110 <br>
 010 <br>
<i>  Q  </i>0<i> </i>=<i> </i>0; shift right<i>   CAQ  </i><br>
 0 <br>
 00100 <br>
 01011 <br>
 001 <br>
<i>  Q  </i>0<i> </i>= 1; add<i>   B  </i><br>
 <br>
  10111  <br>
  <br>
  <br>
 Fifth  partial  product <br>
 0 <br>
 11011 <br>
  <br>
  <br>
<i> <br></i>Shift right<i>   CAQ  </i><br>
 0 <br>
 01101 <br>
 10101 <br>
 000 <br>
<i> <br></i>Final product in<i>   AQ   </i>=<i> </i>0110110101 2 = 1b5<i> </i>H<i> </i><br>
<b> <br>8 . 8       C O N T R O L   L O G I C </b><br>
 <br>The design of a digital system can be divided into two parts: the design of the regis-<br>ter transfers in the datapath unit and the design of the control logic of the control <br>unit. The control logic is a finite state machine; its Mealy and Mooretype outputs <br>control the operations of the datapath. The inputs to the control unit are the primary <br>(external) inputs and the internal status signals fed back from the datapath to the <br>controller. The design of the system can be synthesized from an RTL description <br>derived from the ASMD chart. Alternatively, a manual design must derive the logic <br>governing the inputs to the flipflops holding the state of the controller. The informa-<br>tion needed to form the state diagram of the controller is already contained in the <br>ASMD chart, since the rectangular blocks that designate state boxes are the states <br>of the sequential circuit. The diamondshaped blocks that designate decision boxes <br>determine the logical conditions for the next state transition in the state diagram and <br>assertions of the conditional outputs. <br>
 <br>As an example, the control state diagram for the binary multiplier developed in the <br>
previous section is shown in  Fig.   8.16  (a). The information for the diagram is taken directly <br>from the ASMD chart of  Fig.   8.15  . The three states  <i>S_idle</i>  through  <i>S_shift</i>  are taken from <br>the rectangular state boxes. The inputs  <i>Start</i>  and  <i>Zero</i>  are taken from the diamond<br>shaped decision boxes. The register transfer operations for each of the three states are <br>listed in  Fig.   8.16  (b) and are taken from the corresponding state and conditional boxes <br>in the ASMD chart. Establishing the state transitions is the initial focus, so the outputs <br>of the controller are not shown. <br>
<hr>
<A name=415></a><b>Section 8.8  Control Logic    397</b><br>
<i>Zero</i><br>
 1<br>
<i>Start</i><br>
 0<br>
<i>S_idle</i><br>
<i>S_add</i><br>
<i>S_shift</i><br>
<i>Start</i><br>
 1<br>
<i>Zero</i><br>
 0<br>
(a)<br>
State Transition<br>
Register Operations<br>
From<br>
To<br>
<i>S_idle</i><br>
Initial state<br>
<i>S_idle</i><br>
<i>S_add</i><br>
<i>A</i><br>
 0, <i>C</i><br>
 0, <i>P</i><br>
<i>dp_width</i><br>
<i>S_add</i><br>
<i>S_shift</i><br>
<i>P</i><br>
= <i>P</i><br>
 1<br>
if (<i>Q[0]</i>) then (<i>A</i><br>
<i>A</i><br>
<i>B</i>, <i>C</i><br>
<i>C</i>out)<br>
<i>S_shift</i><br>
shift right {<i>CAQ</i>}, <i>C</i> &lt;  0<br>
(b)<br>
 <br><b>FIGURE 8.16   <br> <br>Control specifications for binary multiplier  </b><br>
 <br>We must execute two steps when implementing the control logic: (1) establish the <br>
required sequence of states, and (2) provide signals to control the register operations. <br>The sequence of states is specified in the ASMD chart or the state diagram. The signals <br>for controlling the operations in the registers are specified in the register transfer state-<br>ments annotated on the ASMD chart or listed in tabular format. For the multiplier, these <br>signals are  <i>Load_regs</i>  (for parallel loading the registers in the datapath unit),  <i>Decr_P</i> <br>(for decrementing the counter),  <i>Add_regs</i>  (for adding the multiplicand and the partial <br>product), and  <i>Shift_regs</i>  (for shifting register  <i>CAQ</i> ). The block diagram of the control <br>unit is shown in  Fig.   8.14  (a). The inputs to the controller are  <i>Start, Q[0]</i>,  and  <i>Zero</i>,   and <br>the outputs are  <i>Ready,</i>  <i>Load_regs,</i>  <i>Decr_P,</i>  <i>Add_regs</i>,  and  <i>Shift_regs</i>,  as specified in the <br>ASMD chart. We note that  <i>Q[0]</i>  affects only the output of the controller, not its state <br>transitions. The machine transitions from  <i>S_add</i>  to  <i>S_shift</i>   unconditionally. <br>
 <br>An important step in the design is the assignment of coded binary values to the states. <br>
The simplest assignment is the sequence of binary numbers, as shown in  Table   8.6  . <br>Another assignment is the Gray code, according to which only one bit changes when <br>going from one number to the next. A state assignment often used in control design is <br>the  <i>onehot</i>  assignment. This assignment uses as many bits and flipflops as there are <br>states in the circuit. At any given time, only one bit is equal to 1 (the one that is hot) <br>
<hr>
<A name=416></a><b>398    Chapter 8  Design at the Register Transfer Level</b><br>
<b> <br>Table 8.6 <br><i> <br>State Assignment for Control </b></i><br>
<b> <br>State </b><br>
<b> <br>Binary </b><br>
<b> <br>Gray Code </b><br>
<b> <br>OneHot </b><br>
<i>  S_idle  </i><br>
 00 <br>
 00 <br>
 001 <br>
<i>  S_add  </i><br>
 01 <br>
 01 <br>
 010 <br>
<i>  S_shift  </i><br>
 10 <br>
 11 <br>
 100 <br>
while all others are kept at 0 (all cold). This type of assignment uses a flipflop for each <br>state. Indeed, onehot encoding uses more flipflops than other types of coding, but it <br>usually leads to simpler decoding logic for the next state and the output of the machine. <br>Because the decoding logic does not become more complex as states are added to the <br>machine, the speed at which the machine can operate is not limited by the time required <br>to decode the state. <br>
 <br>Since the controller is a sequential circuit, it can be designed manually by the sequential <br>
logic procedure outlined in  Chapter   5  . However, in most cases this method is difficult to <br>carry out manually because of the large number of states and inputs that a typical control <br>circuit may have. As a consequence, it is necessary to use specialized methods for control <br>logic design that may be considered as variations of the classical sequential logic method. <br>We will now present two such design procedures. One uses a sequence register and decoder, <br>and the other uses one flipflop per state. The method will be presented for a small circuit, <br>but it applies to larger circuits as well. Of course, the need for these methods is eliminated <br>if one has software that automatically synthesizes the circuit from an HDL description. <br>
<b> <br>Sequence Register and Decoder </b><br>
 <br>The sequenceregisteranddecoder (manual) method, as the name implies, uses a reg-<br>ister for the control states and a decoder to provide an output corresponding to each of <br>the states. (The decoder is not needed if a onehot code is used.) A register with  <i>n</i>   flip<br>flops can have up to 2 <i> n </i> states, and an  <i>n</i> to2 <i> n </i>line decoder has up to 2 <i> n </i> outputs. An  <i>n</i> bit <br>sequence register is essentially a circuit with  <i>n</i>  flipflops, together with the associated <br>gates that effect their state transitions. <br>
 <br>The ASMD chart and the state diagram for the controller of the binary multiplier <br>
have three states and two inputs. (There is no need to consider  <i>Q[0]</i> .) To implement the <br>design with a sequence register and decoder, we need two flipflops for the register and <br>a twotofourline decoder. The outputs of the decoder will form the Mooretype outputs <br>of the controller directly. The Mealytype outputs will be formed from the Moore outputs <br>and the inputs. <br>
 <br>The state table for the finite state machine of the controller is shown in  Table   8.7  . It <br>
is derived directly from the ASMD chart of  Fig.   8.15  (b) or the state diagram of <br> Fig.     8.16   (a).  We  designate  the  two  flipflops  as     <i>G</i>1     and     <i>G</i>0  and assign the binary states <br>00, 01, and 10 to  <i>S_idle,</i>  <i>S_add</i>,  and  <i>S_shift</i>,  respectively. Note that the input columns <br>have don'tcare entries whenever the input variable is not used to determine the next <br>
<hr>
<A name=417></a><b>Section 8.8  Control Logic    399</b><br>
<b> <br>Table 8.7 <br><i> <br>State Table for Control Circuit </b></i><br>
<b> <br>Present </b><br>
<b> <br>Next </b><br>
<b> </b><br>
<b>State </b><br>
<b> <br>Inputs </b><br>
<b>State </b><br>
<b> </b><br>
<b> </b><br>
<b> </b><br>
<b> </b><br>
<b> </b><br>
<b> <br>PresentState </b><br>
<b>Symbol </b><br>
<i> <br><b>G</i>1</b><i> </i><br>
<i> <br><b>G</i>0</b><i> </i><br>
<i><b> <br>Start  </b></i><br>
<i><b> <br>Q[0]  </b></i><br>
<i><b> <br>Zero  </b></i><br>
<i> <br><b>G</i>1</b><i> </i><br>
<i> <br><b>G</i>0</b><i> </i><br>
<i><b>  Ready </b></i><br>
<i><b>   Load_regs </b></i><br>
<i><b>   Decr_P </b></i><br>
<i><b>   Add_regs </b></i><br>
<i><b>   Shift_regs </b></i><br>
<i>  S_idle  </i><br>
 0 <br>
 0 <br>
 0 <br>
 X <br>
 X <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
<i>  S_idle  </i><br>
 0 <br>
 0 <br>
 1 <br>
 X <br>
 X <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
<i>  S_add  </i><br>
 0 <br>
 1 <br>
 X <br>
 0 <br>
 X <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
<i>  S_add  </i><br>
 0 <br>
 1 <br>
 X <br>
 1 <br>
 X <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
<i>  S_shift  </i><br>
 1 <br>
 0 <br>
 X <br>
 X <br>
 0 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
<i>  S_shift  </i><br>
 1 <br>
 0 <br>
 X <br>
 X <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
state. The outputs of the control circuit are designated by the names given in the ASMD <br>chart. The particular Mooretype output variable that is equal to 1 at any given time is <br>determined from the equivalent binary value of the present state. Those output variables <br>are shaded in  Table   8.7  . Thus, when the present state is   <i>G</i>1<i>G</i>0 = 00,     output   <i>Ready</i>   must <br>be equal to 1, while the other outputs remain at 0. Since the Mooretype outputs are a <br>function of only the present state, they can be generated with a decoder circuit having <br>the two inputs   <i>G</i>1     and     <i>G</i>0  and using three of the decoder outputs   <i>T</i>0     through     <i>T</i>2,     as <br>shown in  Fig.   8.17  (a), which does not include the wiring for the state feedback. <br>
 <br>The state machine of the controller can be designed from the state table by means of <br>
the classical procedure presented in  Chapter   5  . This example has a small number of states <br>and inputs, so we could use maps to simplify the Boolean functions. In most control logic <br>applications, the number of states and inputs is much larger. In general, the application of <br>the classical method requires an excessive amount of work to obtain the simplified input <br>equations for the flipflops and is prone to error. The design can be simplified if we take <br>into consideration the fact that the decoder outputs are available for use in the design. <br>Instead of using flipflop outputs as the presentstate conditions,  <i>we use the outputs of the <br>decoder to indicate the presentstate condition of the sequential circuit</i> . Moreover, instead of <br>using maps to simplify the flipflop equations, we can obtain them directly by inspection of <br>the state table. For example, from the nextstate conditions in the state table, we find that <br>the next state of   <i>G</i>1  is equal to 1 when the present state is  <i>S_add</i>  and is equal to 0 when the <br>present state is  <i>S_idle</i>  or  <i>S_shift</i> . These conditions can be specified by the equation <br>
 <br><i>DG</i>1 = <i>T</i>1 <br>
 where     <i>DG</i>1     is  the   <i>D</i>  input of flipflop   <i>G</i>1.     Similarly,  the   <i>D</i>  input of   <i>G</i>0     is <br>
 <br><i>DG</i>0 = <i>T</i>0 <i>Start </i>+ <i>T</i>2 <i>Zero </i> <br>
<hr>
<A name=418></a><i>Ready</i><br>
<i>G</i><br>
<i>D</i><br>
0<br>
(<i>S_Idle</i>) <i>T</i><br>
<i>Load_regs</i><br>
<i>0</i><br>
<i>Start</i><br>
0<br>
<i>C</i><br>
2<br>
 4<br>
<i>Decoder</i><br>
<i>Add_regs</i><br>
<i>Next State</i><br>
<i>Q[0]</i><br>
(<i>S_add) T</i><br>
<i>Logic</i><br>
<i>1</i><br>
<i>Decr_P</i><br>
<i>Shift_regs</i><br>
1<br>
(<i>S_shift</i>) <i>T2</i><br>
<i>Zero</i><br>
<i>D</i><br>
<i>G</i><br>
<i>T</i><br>
1<br>
<i>3</i><br>
<i>C</i><br>
<i>clock</i><br>
<i>reset_b</i><br>
(a)<br>
<i>Next State Logic</i><br>
<i>Ready</i><br>
<i>G</i><br>
<i>Start</i><br>
<i>D</i><br>
0<br>
(<i>S_idle</i>) <i>T</i><br>
<i>Load_regs</i><br>
<i>0</i><br>
<i>Q</i>[0]<br>
0<br>
<i>C</i><br>
<i>Add_regs</i><br>
(<i>S_add</i>) <i>T1</i><br>
<i>Decr_P</i><br>
2<br>
 4<i> Decoder</i><br>
<i>Shift_regs</i><br>
<i>Zero</i><br>
(<i>S_shift</i>) <i>T2</i><br>
1<br>
<i>D</i><br>
<i> T3</i><br>
<i>G</i>1<br>
<i>C</i><br>
<i>clock</i><br>
<i>reset_b</i><br>
(b)<br>
 <br><b>FIGURE 8.17   <br> <br>Logic diagram of control for binary multiplier using a sequence register and decoder  </b><br>
<b>400    </b><br>
<hr>
<A name=419></a><b>Section 8.8  Control Logic    401</b><br>
 <br>When deriving input equations by inspection from the state table, we cannot be sure <br>
that the Boolean functions have been simplified in the best possible way. (Synthesis tools <br>take care of this detail automatically.) In general, it is advisable to analyze the circuit to <br>ensure that the equations derived do indeed produce the required state transitions. <br>
 <br>The logic diagram of the control circuit is drawn in  Fig.   8.17  (b). It consists of a register <br>
with two flipflops   <i>G</i>1     and     <i>G</i>0     and  a  2  * 4 decoder. The outputs of the decoder are used to <br>generate the inputs to the nextstate logic as well as the control outputs. The outputs of the <br>controller should be connected to the datapath to activate the required register operations. <br>
<b> <br>OneHot Design (One FlipFlop per State) </b><br>
 <br>Another method of control logic design is the onehot assignment, which results in a <br>sequential circuit with one flipflop per state. Only one of the flipflops contains a 1 at <br>any time; all others are reset to 0. The single 1 propagates from one flipflop to another <br>under the control of decision logic. In such a configuration, each flipflop represents a <br>state that is present only when the control bit is transferred to it. <br>
 <br>This method uses the maximum number of flipflops for the sequential circuit. For <br>
example, a sequential circuit with 12 states requires a minimum of four flipflops. By <br>contrast, with the method of one flipflop per state, the circuit requires 12 flipflops, one <br>for each state. At first glance, it may seem that this method would increase system cost, <br>since more flipflops are used. But the method offers some advantages that may not be <br>apparent. One advantage is the simplicity with which the logic can be designed by <br>inspection of the ASMD chart or the state diagram. No state or excitation tables are <br>needed if  <i>D</i> type flipflops are employed. The onehot method offers a savings in design <br>effort, an increase in operational simplicity, and a possible decrease in the total number <br>of gates, since a decoder is not needed. <br>
 <br>The design procedure for a onehot state assignment will be demonstrated by obtaining <br>
the control circuit specified by the state diagram of  Fig.   8.16  (a). Since there are three states <br>in the state diagram, we choose three  <i>D</i>  flipflops and label their outputs   <i>G</i>0, <i>G</i>1,     and     <i>G</i>2,    <br> <br><i>corresponding to S_idle,</i>  <i>S_add</i>,  and  <i>S_shift</i>,  respectively. The input equations for setting <br>each flipflop to 1 are determined from the present state and the input conditions along <br>the corresponding directed lines going into the state. For example,   <i>DG</i>0 , the input to flip<br>flop     <i>G</i>0 , is set to 1 if the machine is in state   <i>G</i>0     and   <i>Start</i>  is not asserted, or if the machine <br>is in state   <i>G</i>2     and   <i>Zero</i>  is asserted. These conditions are specified by the input equation: <br>
 <br><i>DG</i>0 = <i>G</i>0 <i>Start </i>+ <i>G</i>2 <i>Zero</i> <br>
 <br>In fact, the condition for setting a flipflop to 1 is obtained directly from the state dia-<br>gram, from the condition specified in the directed lines going into the corresponding <br>flipflop state ANDed with the previous flipflop state. If there is more than one directed <br>line going into a state, all conditions must be ORed. Using this procedure for the other <br>three flipflops, we obtain the remaining input equations: <br>
 <br><i>DG</i>1 = <i>G</i>0 <i>Start </i>+ <i>G</i>2 <i>Zero<br>DG</i>2 = <i>G</i>1 <br>
<hr>
<A name=420></a><b>402    Chapter 8  Design at the Register Transfer Level</b><br>
<i>Ready</i><br>
<i>Start</i><br>
<i>D Set</i><br>
<i>Load_regs</i><br>
<i>G</i><br>
(<i>S_idle</i>)<br>
0<br>
<i>C</i><br>
<i>Q[0]</i><br>
<i>Add_regs</i><br>
<i>Zero</i><br>
<i>G</i><br>
<i>D</i><br>
1<br>
<i>Decr_P</i><br>
(<i>S_add</i>)<br>
<i>C</i><br>
<i>Rst</i><br>
<i>Shift_regs</i><br>
<i>D</i><br>
<i>(S_shift)</i><br>
<i>G</i>2<br>
<i>C</i><br>
<i>clock</i><br>
<i>Rst</i><br>
<i>reset_b</i><br>
 <br><b>FIGURE 8.18   <br> <br>Logic diagram for onehot state controller  </b><br>
 <br>The logic diagram of the onehot controller (with one flipflop per state) is shown in <br>
 Fig.   8.18   .  The  circuit  consists  of  three   <i>D</i>  flipflops labeled   <i>G</i>0     through     <i>G</i>2,     together  with  the <br>associated gates specified by the input equations. Initially, flipflop   <i>G</i>0  must be set to 1 and <br>all other flipflops must be reset to 0, so that the flipflop representing the initial state is <br>enabled. This can be done by using an asynchronous preset on flipflop   <i>G</i>0     and  an  asynchro-<br>nous clear for the other flipflops. Once started, the controller with one flipflop per state <br>will propagate from one state to the other in the proper manner. Only one flipflop will be <br>set to 1 with each clock edge; all others are reset to 0, because their  <i>D</i>  inputs are equal to 0. <br>
<b> <br>8 . 9       H D L   D E S C R I P T I O N   O F   B I N A R Y   M U L T I P L I E R </b><br>
 <br>A second example of an HDL description of an RTL design is given in HDL Example 8.5, <br>the binary multiplier designed in Section 8.7. For simplicity, the entire description is "flat-<br>tened" and encapsulated in one module. Comments will identify the controller and the <br>datapath. The first part of the description declares all of the inputs and outputs as specified <br>
<hr>
<A name=421></a><b>Section 8.9  HDL Description of Binary Multiplier    403</b><br>
in the block diagram of  Fig.   8.14  (a). The machine will be parameterized for a fivebit data-<br>path to enable a comparison between its simulation data and the result of the multiplication <br>with the numerical example listed in  Table   8.5  .The same model can be used for a datapath <br>having a different size merely by changing the value of the parameters. The second part of <br>the description declares all registers in the controller and the datapath, as well as the one<br>hot encoding of the states. The third part specifies implicit combinational logic (continuous <br>assignment statements) for the concatenated register  <i>CAQ</i>,  the  <i>Zero</i>  status signal, and the <br> <br><i>Ready</i>  output signal. The continuous assignments for  <i>Zero</i>  and  <i>Ready</i>  are accomplished by <br>assigning a Boolean expression to their  <b>wire</b>  declarations. The next section describes the <br>control unit, using a single edgesensitive cyclic behavior to describe the state transitions, <br>and a levelsensitive cyclic behavior to describe the combinational logic for the next state <br>and the outputs. Again, note that default assignments are made to  <i>next_state,</i>  <i>Load_regs,</i> <br> <br><i>Decr_P,</i>  <i>Add_regs</i>,  and  <i>Shift_regs</i> .The subsequent logic of the case statement assigns their <br>value by exception. The state transitions and the output logic are written directly from the <br>ASMD  chart  of   Fig.   8.15   (b). <br>
 <br>The datapath unit describes the register operations within a separate edgesensitive <br>
cyclic behavior.  3  (For clarity, separate cyclic behaviors are used; we do not mix the <br>description of the datapath with the description of the controller.) Each control input <br>is decoded and is used to specify the associated operations. The addition and subtraction <br>operations will be implemented in hardware by combinational logic. Signal  <i>Load_regs</i> <br>causes the counter and the other registers to be loaded with their initial values, etc. <br>Because the controller and datapath have been partitioned into separate units, the con-<br>trol signals completely specify the behavior of the datapath; explicit information about <br>the state of the controller is not needed and is not made available to the datapath unit. <br>
 <br>The nextstate logic of the controller includes a default case item to direct a synthesis <br>
tool to map any of the unused codes to  <i>S_idle</i> . The default case item and the default <br>assignments preceding the <b>case</b> statement ensure that the machine will recover if it <br>somehow enters an unused state. They also prevent unintentional synthesis of latches. <br>(Remember, a synthesis tool will synthesize latches when what was intended to be com-<br>binational logic in fact fails to completely specify the input�output function of the logic.) <br>
<b> <br>HDL Example 8.5 (Sequential Multiplier)  </b><br>
<b> <br>module  </b>Sequential_Binary_Multiplier (Product, Ready, Multiplicand, Multiplier, Start, <br>clock, reset_b);<br>
 <br>// Default configuration: five-bit datapath<br>
<b> <br> parameter </b><br>
<b> </b><br>
dp_width = 5; <br>
// Set to width of datapath<br>
<b> <br> output </b><br>
<b>  </b><br>
[2*dp_width -1: 0] <br>
Product;<br>
<b> <br> output </b><br>
<b> </b><br>
Ready;<br>
<b> <br> input </b><br>
<b> </b><br>
[dp_width -1: 0] <br>
Multiplicand, Multiplier;<br>
<b> <br> input </b><br>
<b>  </b><br>
Start, clock, reset_b;<br>
 <br>3 The width of the datapath here is  <i>dpwidth</i> . <br>
<hr>
<A name=422></a><b>404    Chapter 8  Design at the Register Transfer Level</b><br>
<b> <br> parameter </b><br>
<b>  </b><br>
BC_size = 3; <br>
// Size of bit counter<br>
<b> <br> parameter </b><br>
<b> </b><br>
S_idle = 3'b001, // one-hot code<br>
 <br>
S_add = 3'b010,<br>
 <br>
S_shift = 3'b100;<br>
<b> <br> reg </b><br>
<b> </b><br>
[2: 0] <br>
state, next_state;<br>
<b> <br> reg </b><br>
<b> </b><br>
[dp_width -1: 0] <br>
A, B, Q; <br>
// Sized for datapath<br>
<b> <br> reg </b><br>
<b>  </b><br>
C;<br>
<b> <br> reg </b><br>
<b> </b><br>
[BC_size -1: 0] <br>
P;<br>
<b> <br> reg </b><br>
<b> </b><br>
Load_regs, Decr_P, Add_regs, Shift_regs;<br>
 <br>// Miscellaneous combinational logic<br>
<b> <br> assign </b><br>
<b> </b><br>
Product = {A, Q};<br>
<b> <br> wire </b><br>
<b> </b><br>
Zero = (P == 0); <br>
// counter is zero<br>
 <br>
// Zero = ~|P; <br>
// alternative<br>
<b> <br> wire </b><br>
<b> </b><br>
Ready = (state == S_idle); // controller status<br>
 <br>// control unit<br>
<b> <br> always </b><br>
<b>  @</b>  ( <b>posedge</b>  clock,  <b>negedge</b>  reset_b)<br>
  <b>if  </b>(~reset_b) state &lt;= S_idle;  <b>else</b>  state &lt;= next_state;<br>
<b> <br> always </b><br>
<b>  @</b>  (state, Start, Q[0], Zero)  <b>begin</b> <br>
  next_state = S_idle;<br>
  Load_regs = 0;<br>
  Decr_P = 0;<br>
  Add_regs = 0;<br>
  Shift_regs = 0;<br>
<b> <br> case </b><br>
<b> </b>(state)<br>
 <br>  <br>
S_idle: <br>
 <br>
<b>begin</b>   <b>if</b>  (Start) next_state = S_add; Load_regs = 1;  <b>end</b> <br>
 <br>  <br>
S_add: <br>
 <br>
<b>begin</b>  next_state = S_shift; Decr_P = 1;  <b>if (</b> Q[0]) Add_regs = 1;  <b>end</b> <br>
 <br>  <br>
S_shift: <br>
 <br>
<b>begin</b>  Shift_regs = 1;  <b>if</b>  (Zero) next_state = S_idle;<br>
<b> </b><br>
<b> <br>else  </b>next_state = S_add;  <b>end</b> <br>
    <b>default : </b><br>
next_state = S_idle;<br>
<b> <br> endcase <br>   end <br></b> <br>// datapath unit<br>
<b> <br> always @</b>  ( <b>posedge</b>  clock)  <b>begin</b> <br>  <b>if  </b>(Load_regs)  <b>begin</b> <br>    P &lt;= dp_width;<br>
    A &lt;= 0;<br>
    C &lt;= 0;<br>
    B &lt;= Multiplicand;<br>
    Q &lt;= Multiplier;<br>
<b> <br> end <br> <br> if </b><br>
<b> </b>(Add_regs) {C, A} &lt;= A + B;<br>
<hr>
<A name=423></a><b>Section 8.9  HDL Description of Binary Multiplier    405</b><br>
  <b>if  </b>(Shift_regs) {C, A, Q} &lt;= {C, A, Q} &gt;&gt; 1;<br>  <b>if  </b>(Decr_P) P &lt;= P -1;<br>  <b>end <br> <br>endmodule  </b><br>
<b> <br>Testing the Multiplier </b><br>
 <br>HDL Example 8.6 shows a test bench for testing the multiplier. The inputs and outputs <br>are the same as those shown in the block diagram of  Fig.   8.14  (a). It is naive to conclude <br>that an HDL description of a system is correct on the basis of the output it generates <br>under the application of a few input signals. A more strategic approach to testing and <br>verification exploits the partition of the design into its datapath and control unit. This <br>partition supports separate verification of the controller and the datapath. A separate <br>test bench can be developed to verify that the datapath executes each operation and <br>generates status signals correctly. After the datapath unit is verified, the next step is to <br>verify that each control signal is formed correctly by the control unit. A separate test <br>bench can verify that the control unit exhibits the complete functionality specified by <br>the ASMD chart (i.e., that it makes the correct state transitions and asserts its outputs <br>in response to the external inputs and the status signals). <br>
 <br>A verified control unit and a verified datapath unit together do not guarantee that <br>
the system will operate correctly. The final step in the design process is to integrate <br>the verified models within a parent module and verify the functionality of the overall <br>machine. The interface between the controller and the datapath must be examined in <br>order to verify that the ports are connected correctly. For example, a mismatch in the <br>listed order of signals may not be detected by the compiler. After the datapath unit <br>and the control unit have been verified, a third test bench should verify the specified <br>functionality of the complete system. In practice, this requires writing a comprehensive <br>test plan identifying that functionality. For example, the test plan would identify the <br>need to verify that the sequential multiplier asserts the signal  <i>Ready</i>  in state  <i>S_idle</i>.  <br>The exercise to write a test plan is not academic: The quality and scope of the test plan <br>determine the worth of the verification effort. The test plan guides the development <br>of the test bench and increases the likelihood that the final design will match its <br>specification. <br>
 <br>Testing and verifying an HDL model usually requires access to more information <br>
than the inputs and outputs of the machine. Knowledge of the state of the control unit, <br>the control signals, the status signals, and the internal registers of the datapath might <br>all be necessary for debugging. Fortunately, Verilog provides a mechanism to hierarchi-<br>cally dereference identifiers so that any variable at any level of the design hierarchy <br>can be visible to the test bench. Procedural statements can display the information <br>required to support efforts to debug the machine. Simulators use this mechanism to <br>display waveforms of any variable in the design hierarchy. To use the mechanism, we <br>reference the variable by its hierarchical path name. For example, the register  <i>P</i>   within <br>
<hr>
<A name=424></a><b>406    Chapter 8  Design at the Register Transfer Level</b><br>
the datapath unit is not an output port of the multiplier, but it can be referenced as <br> <br><i>M0.P</i> . The hierarchical path name consists of the sequence of module identifiers or <br>block names, separated by periods and specifying the location of the variable in the <br>design hierarchy. We also note that simulators commonly have a graphical user interface <br>that displays all levels of the hierarchy of a design. <br>
 <br>The first test bench in HDL Example 8.6 uses the system task  <b>$strobe</b>  to display the <br>
result of the computations. This task is similar to the  <b>$display</b>  and  <b>$monitor</b>   tasks <br>explained in Section 4.12. The <b>$strobe</b> system task provides a synchronization mecha-<br>nism to ensure that data are displayed only after all assignments in a given time step are <br>executed. This is very useful in synchronous sequential circuits, where the time step <br>begins at a clock edge and multiple assignments may occur at the same time step of <br>simulation. When the system is synchronized to the positive edge of the clock, using <br> <br><b>$strobe</b>  after the <b><i>always  @   (  posedge </b>  clock) </i> statement ensures that the display shows <br>values of the signal after the clock pulse. <br>
 <br>The test bench module  <i>t_Sequential_Binary_Multiplier</i>  in HDL Example 8.6 instan-<br>
tiates the module  <i>Sequential Binary_Multiplier</i>  of HDL Example 8.5. Both modules <br>must be included as source files when simulating the multiplier with a Verilog HDL <br>simulator. The result of this simulation displays a simulation log with numbers identi-<br>cal to the ones in  Table   8.5  . The code includes a second test bench to exhaustively <br>multiply fivebit values of the multiplicand and the multiplier. Waveforms for a sample <br>of simulation results are shown in  Fig.   8.19  . The numerical values of  <i>Multiplicand,</i> <br> <br><i>Multiplier</i>,  and  <i>Product</i>  are displayed in decimal and hexadecimal formats. Insight can <br>be gained by studying the displayed waveforms of the control state, the control signals, <br>the status signals, and the register operations. Enhancements to the multiplier and its <br>test bench are considered in the problems at the end of this chapter. In this example, <br> <br>1910 * 2310 = 43710,     and     17H + 0bH = 02H     with  C  = 1. Note the need for the carry bit. <br>
<b>   HDL  Example  8.6  </b><br>
 <br>// Test bench for the binary multiplier<br>
<b> <br>module  </b>t_Sequential_Binary_Multiplier;<br><b> <br> parameter </b><br>
<b> </b><br>
dp_width = 5; <br>
// Set to width of datapath<br>
<b> <br> wire </b><br>
<b>  </b><br>
[2*dp_width -1: 0] <br>
Product; <br>
// Output from multiplier<br>
<b> <br> wire </b><br>
<b> </b><br>
Ready;<br>
<b> <br> reg </b><br>
<b>  </b><br>
[dp_width -1: 0] <br>
Multiplicand, Multiplier; // Inputs to multiplier<br>
<b> <br> reg </b><br>
<b>  </b><br>
Start, clock, reset_b;<br>
 <br>// Instantiate multiplier<br>
 <br>Sequential_Binary_Multiplier M0 (Product, Ready, Multiplicand, Multiplier, Start, clock, <br>
 reset_b);<br>
  // Generate stimulus waveforms<br>
<b> <br>initial  </b>#200  <b>$finish</b> ;<br> <br><b>initial <br> <br> begin <br></b>    Start = 0;<br>
<hr>
<A name=425></a><b>Section 8.9  HDL Description of Binary Multiplier    407</b><br>
<i>65885</i><br>
<i>65925</i><br>
<i>65965</i><br>
<i>66005</i><br>
<i>Name</i><br>
<i>clock<br>reset_b</i><br>
<i>Start</i><br>
<i>state[2: 0]</i><br>
<i>4</i><br>
<i>1</i><br>
<i>2</i><br>
<i>4</i><br>
<i>2</i><br>
<i>4</i><br>
<i>2</i><br>
<i>4</i><br>
<i>2</i><br>
<i>4</i><br>
<i>2</i><br>
<i>4</i><br>
<i>1</i><br>
<i>2</i><br>
<i>Load_regs</i><br>
<i>Decr_P</i><br>
<i>Add_regs</i><br>
<i>Shift_regs</i><br>
<i>P[2: 0]</i><br>
<i>0</i><br>
<i>5</i><br>
<i>4</i><br>
<i>3</i><br>
<i>2</i><br>
<i>1</i><br>
<i>0</i><br>
<i>5</i><br>
<i>Zero</i><br>
<i>B[4: 0]</i><br>
<i>16</i><br>
<i>17</i><br>
<i>18</i><br>
<i>A[4: 0]</i><br>
<i>0d</i><br>
<i>00</i><br>
<i>17</i><br>
<i>0b</i><br>
<i>02</i><br>
<i>11</i><br>
<i>08</i><br>
<i>04</i><br>
<i>1b</i><br>
<i>0d</i><br>
<i>00</i><br>
<i>C</i><br>
<i>Q[4: 0]</i><br>
<i>02</i><br>
<i>13</i><br>
<i>19</i><br>
<i>0c</i><br>
<i>16</i><br>
<i>0b</i><br>
<i>15</i><br>
<i>13</i><br>
<i>Multiplicand[4: 0]</i><br>
<i>16</i><br>
<i>17</i><br>
<i>18</i><br>
<i>Multiplicand[4: 0]</i><br>
<i>22</i><br>
<i>23</i><br>
<i>24</i><br>
<i>Multiplier[4: 0]</i><br>
<i>13</i><br>
<i>Multiplier[4: 0]</i><br>
<i>19</i><br>
<i>Product[9: 0]</i><br>
<i>1a2</i><br>
<i>013</i><br>
<i>2j3</i><br>
<i>179</i><br>
<i>059</i><br>
<i>22c</i><br>
<i>11b</i><br>
<i>08b</i><br>
<i>36b</i><br>
<i>1b5</i><br>
<i>013</i><br>
<i>Product[9: 0]</i><br>
<i>418</i><br>
<i>19</i><br>
<i>755</i><br>
<i>377</i><br>
<i>89</i><br>
<i>556</i><br>
<i>278</i><br>
<i>139</i><br>
<i>875</i><br>
<i>437</i><br>
<i>19</i><br>
<i>Ready</i><br>
 <br><b>FIGURE 8.19   <br> <br>Simulation waveforms for onehot state controller  </b><br>
<hr>
<A name=426></a><b>408    Chapter 8  Design at the Register Transfer Level</b><br>
    reset_b = 0;<br>
    #2 Start = 1; reset_b = 1;<br>
    Multiplicand = 5'b10111;    Multiplier = 5'b10011;<br>
    #10 Start = 0;<br>
<b> <br> end <br> <br> initial <br> <br> begin <br></b>    clock = 0;<br>
<b> <br>  </b><br>
<b>repeat </b><br>
<b> </b>(26) #5 clock = ~clock;<br>
<b> <br> end <br></b>  // Display results and compare with  Table   8.5  <br>
<b>   always   @</b>  ( <b>posedge</b>  clock)<br>  <b>$strobe  </b>(&quot;C=%b A=%b Q=%b P=%b time=%0d&quot;,M0.C,M0.A,M0.Q,M0.P,  <b>$time</b> );<br> <br><b>endmodule </b><br>
 <br>Simulation log:<br>
 <br>C=0 A=00000  Q=10011  P=101 time=5<br>
 <br>C=0 A=10111  Q=10011  P=100 time=15<br>
 <br>C=0 A=01011  Q=11001  P=100 time=25<br>
 <br>C=1 A=00010  Q=11001  P=011 time=35<br>
 <br>C=0 A=10001  Q=01100  P=011 time=45<br>
 <br>C=0 A=10001  Q=01100  P=010 time=55<br>
 <br>C=0 A=01000  Q=10110  P=010 time=65<br>
 <br>C=0 A=01000  Q=10110  P=001 time=75<br>
 <br>C=0 A=00100  Q=01011  P=001 time=85<br>
 <br>C=0 A=11011  Q=01011  P=000 time=95<br>
 <br>C=0 A=01101  Q=10101  P=000 time=105<br>
 <br>C=0 A=01101  Q=10101  P=000 time=115<br>
 <br>C=0 A=01101  Q=10101  P=000 time=125<br>
 <br>/* Test bench for exhaustive simulation<br>
<b> <br>module  </b>t_Sequential_Binary_Multiplier;<br><b> <br> parameter </b><br>
<b> </b><br>
dp_width = 5; <br>
// Width of datapath<br>
<b> <br> wire </b><br>
<b> </b><br>
[2 * dp_width -1: 0] <br>
Product;<br>
<b> <br> wire </b><br>
<b> </b><br>
Ready;<br>
<b> <br> reg </b><br>
<b>  </b><br>
[dp_width -1: 0] <br>
Multiplicand, Multiplier;<br>
<b> <br> reg </b><br>
<b>  </b><br>
Start, clock, reset_b;<br>
  Sequential_Binary_Multiplier M0 (Product, Ready, Multiplicand, Multiplier, Start, clock, <br>
  <br>
reset_b);<br>
<b> <br> initial </b><br>
<b> </b>#1030000  <b>$finish</b> ;<br>
  <b>initial   begin</b>  clock = 0; #5  <b>forever</b>  #5 clock = ~clock;  <b>end</b> <br>  <b>initial   fork</b> <br>  reset_b = 1;<br>
  #2 reset_b = 0;<br>
  #3 reset_b = 1;<br>
<b> <br> join </b><br>
<hr>
<A name=427></a><b>Section 8.9  HDL Description of Binary Multiplier    409</b><br>
<b> <br> initial </b><br>
<b>  begin</b>  #5 Start = 1;  <b>end</b> <br>
  <b>initial   begin</b> <br>    #5 Multiplicand = 0;<br>
 <br>  Multiplier = 0;<br>
<b> <br>  repeat </b><br>
<b> </b>(32) #10  <b>begin</b>  Multiplier = Multiplier + 1;<br>
    <b>repeat  </b>(32) @ (posedge M0.Ready) 5 Multiplicand = Multiplicand + 1;<br><b> <br> end <br> <br> end <br> <br>endmodule <br> <br></b>*/<b> </b><br>
<b> <br>Behavioral Description of a Parallel Multiplier </b><br>
 <br>Structural modeling implicitly specifies the functionality of a digital machine by prescrib-<br>ing an interconnection of gatelevel hardware units. In this form of modeling, a synthesis <br>tool performs Boolean optimization and translates the HDL description of a circuit into <br>a netlist of gates in a particular technology, e.g., CMOS. Hardware design at this level often <br>requires cleverness and accrued experience. It is the most tedious and detailed form of <br>modeling. In contrast, behavioral RTL modeling specifies functionality abstractly, in terms <br>of HDL operators. The RTL model does not specify a gatelevel implementation of the <br>registers or the logic to control the operations that manipulate their contents--those tasks <br>are accomplished by a synthesis tool. RTL modeling implicitly schedules operations by <br>explicitly assigning them to clock cycles. The most abstract form of behavioral modeling <br>describes only an algorithm, without any reference to a physical implementation, a set of <br>resources, or a schedule for their use. Thus, algorithmic modeling allows a designer to <br>explore tradeoffs in the space (hardware) and time domains, trading processing speed <br>for hardware complexity. <br>
 <br>HDL Example 8.7 presents an RTL model and an algorithmic model of a binary <br>
multiplier. Both use a levelsensitive cyclic behavior. The RTL model expresses the <br>functionality of a multiplier in a single statement. A synthesis tool will associate with <br>the multiplication operator a gatelevel circuit equivalent to that shown in Section 4.7. <br>In simulation, when either the multiplier or the multiplicand changes, the product will <br>be updated. The time required to form the product will depend on the propagation <br>delays of the gates available in the library of standard cells used by the synthesis tool. <br>The second model is an algorithmic description of the multiplier. A synthesis tool will <br>unroll the loop of the algorithm and infer the need for a gatelevel circuit equivalent to <br>that shown in Section 4.7. <br>
 <br>Be aware that a synthesis tool may not be able to synthesize a given algorithmic <br>
description, even though the associated HDL model will simulate and produce correct <br>results. One difficulty is that the sequence of operations implied by an algorithm might <br>not be physically realizable in a single clock cycle. It then becomes necessary to distrib-<br>ute the operations over multiple clock cycles. A tool for synthesizing RTL logic will not <br>be able to automatically accomplish the required distribution of effort, but a tool that <br>
<hr>
<A name=428></a><b>410    Chapter 8  Design at the Register Transfer Level</b><br>
<b>   HDL  Example  8.7  </b><br>
 <br>// Behavioral (RTL) description of a parallel multiplier (n = 8)<br>
<b> <br>module  </b>Mult (Product, Multiplicand, Multiplier);<br>  <b>input  </b>[7: <br>
0]  Multiplicand, <br>
Multiplier;<br>
  <b>output   reg</b>  [15: 0] Product;<br>  <b>always  </b>@ (Multiplicand, Multiplier)<br>    Product = Multiplicand * Multiplier;<br>
<b> <br>endmodule <br> <br>module  </b>Algorithmic_Binary_Multiplier #( <b>parameter</b>  dp_width = 5) (<br>  <b>output  </b>[2*dp_width -1: 0] Product,  <b>input</b>  [dp_width -1: 0] Multiplicand, Multiplier);<br><b> <br> reg </b><br>
<b> </b>[dp_width -1: 0] <br>
A, B, Q; <br>
// Sized for datapath<br>
<b> <br> reg </b><br>
<b> </b><br>
C;<br>
  <b>integer  </b><br>
k;<br>
  <b>assign  </b><br>
Product = {C, A, Q};<br>
<b> <br> always </b><br>
<b> </b>@ (Multiplier, Multiplicand) <b>begin</b><br>
      Q  =  Multiplier;<br>
      B  =  Multiplicand;<br>
      C  =  0;<br>
      A  =  0;<br>
<b>      for  </b>(k = 0; k &lt;= dp_width -1; k = k + 1)  <b>begin</b> <br>     <b>if  </b>(Q[0]) {C, A} = A + B;<br>     {C, A, Q} = {C, A, Q} &gt;&gt; 1;<br>
<b> <br> end <br> <br> end <br> <br>endmodule <br> <br>module  </b>t_Algorithmic_Binary_Multiplier;<br><b> <br> parameter </b><br>
<b> </b><br>
dp_width = 5; <br>
// Width of datapath<br>
<b> <br> wire </b><br>
<b> </b>[2 *  dp_width -1: 0] <br>
 <br>
Product; <br>
<b> <br> reg </b><br>
<b> </b>[dp_width -1: 0] <br>
Multiplicand, Multiplier;<br>
<b> <br> integer </b><br>
<b> </b><br>
<b> </b><br>
<b> </b><br>
<b> </b><br>
Exp_Value;<br>
  <b>reg  </b><br>
<b> </b><br>
<b> </b><br>
<b> </b><br>
Error; <br>
  Algorithmic_Binary_Multiplier M0 (Product, Multiplicand, Multiplier);<br>
  // Error detection<br>
<b> <br> initial </b><br>
<b>#</b>  1030000  <b>finish</b> ;<br>
  <b>always  </b>@ (Product) <b>begin<br></b>    Exp_Value = Multiplier * Multiplicand;<br>
    // Exp_Value = Multiplier * Multiplicand +1; // Inject error to confirm detection<br>
    Error = Exp_Value ^ Product;<br>
<b> <br> end <br></b> <br>// Generate multiplier and multiplicand exhaustively for 5 bit operands<br>
<b>   initial begin</b> <br>  #5 Multiplicand = 0;<br>
  Multiplier = 0;<br>
<hr>
<A name=429></a><b>Section 8.10  Design with Multiplexers    411</b><br>
<b> <br> repeat </b><br>
<b> </b>(32) #10  <b>begin</b>  Multiplier = Multiplier + 1;<br>
    <b>repeat  </b>(32) #5 Multiplicand = Multiplicand + 1;<br>  <b>end <br> <br> end <br> <br>endmodule  </b><br>
is designed to synthesize algorithms should be successful. In effect, a behavioral synthe-<br>sis tool would have to allocate the registers and adders to implement multiplication. If <br>only a single adder is to be shared by all of the operations that form a partial sum, the <br>activity must be distributed over multiple clock cycles and in the correct sequence, ulti-<br>mately leading to the sequential binary multiplier for which we have explicitly designed <br>the controller for its datapath. Behavioral synthesis tools require a different and more <br>sophisticated style of modeling and are not within the scope of this text. <br>
<b> <br>8 . 1 0       D E S I G N   W I T H   M U L T I P L E X E R S </b><br>
 <br>The registeranddecoder scheme for the design of a controller has three parts: the <br>flipflops that hold the binary state value, the decoder that generates the control outputs, <br>and the gates that determine the nextstate and output signals. In Section 4.11, it was <br>shown that a combinational circuit can be implemented with multiplexers instead of <br>individual gates. Replacing the gates with multiplexers results in a regular pattern of <br>three levels of components. The first level consists of multiplexers that determine the <br>next state of the register. The second level contains a register that holds the present <br>binary state. The third level has a decoder that asserts a unique output line for each <br>control state. These three components are predefined standard cells in many integrated <br>circuits. <br>
 <br>Consider, for example, the ASM chart of  Fig.   8.20  , consisting of four states and four <br>
control inputs. We are interested in only the control signals governing the state sequence. <br>These signals are independent of the register operations of the datapath, so the edges of <br>the graph are not annotated with datapath register operations, and the graph does not <br>identify the output signals of the controller. The binary assignment for each state is indi-<br>cated at the upper right corner of the state boxes. The decision boxes specify the state <br>transitions as a function of the four control inputs:  <i>w,</i>  <i>x,</i>  <i>y</i>,  and  <i>z</i> . The threelevel control <br>implementation, shown in  Fig.   8.21  , consists of two multiplexers, MUX1 and MUX2; <br>a register with two flipflops,   <i>G</i>1   and     <i>G</i>0;  and a decoder with four outputs--  <i>d</i>0, <i>d</i>1, <i>d</i>2,     and <br> <br><i>d</i>3,     corresponding  to   <i>S_0,</i>  <i>S_1,</i>  <i>S_2</i>,  and  <i>S_3</i>,  respectively. The outputs of the stateregister <br>flipflops are applied to the decoder inputs and also to the select inputs of the multiplexers. <br>In this way, the present state of the register is used to select one of the inputs from each <br>multiplexer. The outputs of the multiplexers are then applied to the  <i>D</i>  inputs of   <i>G</i>1 and <br> <br><i>G</i>0 . The purpose of each multiplexer is to produce an input to its corresponding flipflop <br>equal to the binary value of that bit of the nextstate vector. The inputs of the multiplexers <br>
<hr>
<A name=430></a><b>412    Chapter 8  Design at the Register Transfer Level</b><br>
00<br>
<i>S</i>_<i>0</i><br>
0<br>
<i>w</i><br>
1<br>
01<br>
<i>S_1</i><br>
0<br>
1<br>
<i>x</i><br>
11<br>
10<br>
<i>S_3</i><br>
<i>S_2</i><br>
0<br>
1<br>
1<br>
0<br>
<i>y</i><br>
<i>y</i><br>
0<br>
1<br>
1<br>
0<br>
<i>z</i><br>
<i>z</i><br>
 <br><b>FIGURE 8.20   <br> <br>Example of ASM chart with four control inputs  </b><br>
are determined from the decision boxes and state transitions given in the ASM chart. For <br>example, state 00 stays at 00 or goes to 01, depending on the value of input  <i>w</i> . Since the <br>next state of   <i>G</i>1  is 0 in either case, we place a signal equivalent to logic 0 in MUX1 input 0. <br>The next state of   <i>G</i>0  is 0 if  <i>w</i> = 0 and 1 if  <i>w</i> = 1. Since the next state of   <i>G</i>0     is  equal  to   <i>w</i>,  <br>we apply control input  <i>w</i>  to MUX2 input 0. This means that when the select inputs of the <br>multiplexers are equal to present state 00, the outputs of the multiplexers provide the <br>binary value that is transferred to the register at the next clock pulse. <br>
<hr>
<A name=431></a><b>Section 8.10  Design with Multiplexers    413</b><br>
<i>G</i>1<br>
0<br>
0<br>
<i>D</i><br>
1<br>
1<br>
<i>C</i><br>
MUX1<br>
<i>y</i><br>
2<br>
<i>y</i><br>
3<br>
<i>z</i><br>
<i>s</i>1<br>
<i>s</i>0<br>
<i>d</i>0<br>
<i>d</i>1<br>
2<br>
 4<br>
MUX select<br>
decoder<br>
<i>d</i>2<br>
<i>d</i>3<br>
<i>s</i>1<br>
<i>s</i>0<br>
<i>G</i>0<br>
<i>w</i><br>
0<br>
<i>D</i><br>
<i>x</i><br>
1<br>
<i>C</i><br>
<i>y</i><br>
MUX2<br>
2<br>
<i>z</i><br>
<i>y</i><br>
3<br>
<i>CLK</i><br>
 <br><b>FIGURE 8.21   <br> <br>Control implementation with multiplexers  </b><br>
 <br>To facilitate the evaluation of the multiplexer inputs, we prepare a table showing <br>
the input conditions for each possible state transition in the ASM chart. Table   8.8   gives <br>this information for the ASM chart of  Fig.   8.20  . There are two transitions from present <br>state 00 or 01 and three from present state 10 or 11. The sets of transitions are sepa-<br>rated by horizontal lines across the table. The input conditions listed in the table are <br>obtained from the decision boxes in the ASM chart. For example, from  Fig.   8.20  , we <br>note that present state 01 will go to next state 10 if   <i>x </i>= 1  or to next state 11 if   <i>x </i>= 0   . <br>In the table, we mark these input conditions as  <i>x</i>   and     <i>x </i>   ,  respectively.  The  two  columns <br>under "multiplexer inputs" in the table specify the input values that must be applied <br>to MUX1 and MUX2. The multiplexer input for each present state is determined from <br>the input conditions when the next state of the flipflop is equal to 1. Thus, after present <br>state 01, the next state of   <i>G</i>1  is always equal to 1 and the next state of   <i>G</i>0     is  equal  to <br>the complement of  <i>x</i> . Therefore, the input of MUX1 is made equal to 1 and that of <br>MUX2 to   <i>x </i> when the present state of the register is 01. As another example, after pres-<br>ent state 10, the next state of   <i>G</i>1  must be equal to 1 if the input conditions are   <i>yz </i> or <br> <br><i>yz</i> . When these two Boolean terms are ORed together and then simplified, we obtain <br>the single binary variable  <i>y</i>,  as indicated in the table. The next state of   <i>G</i>0  is equal to 1 <br>if the input conditions are   <i>yz </i>= 11 . If the next state of   <i>G</i>1  remains at 0 after a given <br>present state, we place a 0 in the multiplexer input, as shown in present state 00 for <br>
<hr>
<A name=432></a><b>414    Chapter 8  Design at the Register Transfer Level</b><br>
<b> <br>Table 8.8 <br><i> <br>Multiplexer Input Conditions </b></i><br>
<b> <br>Present </b><br>
<b> <br>Next </b><br>
<b> <br>Input </b><br>
<b>State </b><br>
<b>State </b><br>
<b>Condition </b><br>
<b> <br>Inputs </b><br>
<b> <br><i>G</i>1   <i>G</i>0 </b><br>
<b> <br><i>G</i>1   <i>G</i>0 </b><br>
<b> <br><i>s</i> </b><br>
<b> <br>MUX1 </b><br>
<b> <br>MUX2 </b><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
<i> <br>w  </i><br>
 <br>
<i> </i><br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
<i>  w  </i><br>
 0 <br>
<i>  w  </i><br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
<i>  x  </i><br>
 <br>
<i> </i><br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
<i> x  </i><br>
 1 <br>
<i> x  </i><br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
<i> y  </i><br>
 <br>
<i> </i><br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
<i> yz  </i><br>
 <br>
<i> </i><br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
<i>  yz  </i><br>
<i> yz </i>+ <i>yz </i>= <i>y    </i><br>
<i>  yz  </i><br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
<i> y z    </i><br>
<i> </i><br>
<i> </i><br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
<i> <br>y </i><br>
<i> </i><br>
<i> </i><br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
<i> y z  </i><br>
<i> y </i>+ <i>y z </i>= <i>y </i>+ <i>z  </i><br>
<i> y z </i>+ <i>y z </i>= <i>y  </i><br>
MUX1. If the next state of   <i>G</i>1  is always 1, we place a 1 in the multiplexer input, as <br>shown in present state 01 for MUX1. The other entries for MUX1 and MUX2 are <br>derived in a similar manner. The multiplexer inputs from the table are then used in the <br>control implementation of  Fig.   8.21 . Note that if the next state of a flipflop is a function <br>of two or more control variables, the multiplexer may require one or more gates in its <br>input. Otherwise, the multiplexer input is equal to the control variable, the complement <br>of the control variable, 0, or 1. <br>
<b> <br>Design Example: Count the Number of Ones in a Register </b><br>
 <br>We will demonstrate the multiplexer implementation of the logic for a control unit by <br>means of a design example--a system that is to count the number of 1's in a word of <br>data. The example will also demonstrate the formulation of the ASMD chart and the <br>implementation of the datapath subsystem. <br>
 <br>From among various alternatives, we will consider a ones counter consisting of two <br>
registers  <i>R1</i>  and  <i>R2</i>,  and a flipflop  <i>E</i> . (A more efficient implementation is considered <br>in the problems at the end of the chapter.) The system counts the number of 1's in the <br>number loaded into register  <i>R1</i>  and sets register  <i>R2</i>  to that number. For example, if the <br>binary number loaded into  <i>R1</i>  is 10111001, the circuit counts the five 1's in  <i>R1</i>  and sets <br>register  <i>R</i> 2 to the binary count 101. This is done by shifting each bit from register  <i>R1</i> <br>one at a time into flipflop  <i>E</i> . The value in  <i>E</i>  is checked by the control, and each time it <br>is equal to 1, register  <i>R2</i>  is incremented by 1. <br>
 <br>The block diagram of the datapath and controller are shown in  Fig.   8.22  (a). The <br>
datapath contains registers  <i>R1,</i>  <i>R2</i>,  and  <i>E</i>,  as well as logic to shift the leftmost bit of  <i>R1</i> <br>into  <i>E</i> . The unit also contains logic (a NOR gate to detect whether  <i>R1</i>  is 0, but that <br>
<hr>
<A name=433></a><i>Status</i><br>
<i>data</i><br>
<i>signals</i><br>
<i>E</i><br>
<i>Zero</i><br>
<i>Datapath</i><br>
<i>E</i><br>
<i>R1</i><br>
<i>...</i><br>
<i>Load_regs</i><br>
<i>Shift_left</i><br>
<i>Controller</i><br>
<i>Shift_left</i><br>
<i>Start</i><br>
<i>Incr_R2</i><br>
<i>R2</i><br>
<i>...</i><br>
<i>Ready</i><br>
<i>reset_b</i><br>
<i>clock</i><br>
<i>count</i><br>
(a)<br>
<i>reset_b</i><br>
<i>reset_b</i><br>
<i>S_idle</i><br>
<i>S_idle</i><br>
<i>Ready</i><br>
<i>Ready</i><br>
<i>R1</i><br>
<i> data</i><br>
<i>Start</i><br>
<i>R2</i><br>
<i> all </i>1<i>s</i><br>
<i>Start</i><br>
1<br>
1<br>
<i>R1</i><br>
<i> data</i><br>
<i>S</i>_<i>1</i><br>
<i>Load_regs</i><br>
<i>R2</i><br>
<i> all </i>1<i>s</i><br>
<i>R2</i><br>
<i> R2 </i><br>
1<br>
1<br>
<i>Zero</i><br>
<i>S_1<br>Incr_R2</i><br>
<i>R2</i><br>
<i> R2 </i><br>
1<br>
<i>S_2</i><br>
{<i>E, R1</i>}<br>
{<i>E</i>,<i> R1</i>}<br>
 1<br>
1<br>
<i>Zero</i><br>
<i>S_3</i><br>
<i>S_2</i><br>
<i>E</i><br>
<i>Shift_left</i><br>
{<i>E, R1</i>}<br>
{<i>E</i>,<i> R1</i>}<br>
 1<br>
1<br>
<i>S_3</i><br>
<i>E</i><br>
1<br>
(b)<br>
(c)<br>
 <br><b>FIGURE 8.22   <br> <br>Block diagram and ASMD chart for countofones circuit  </b><br>
<b>        415</b><br>
<hr>
<A name=434></a><b>416    Chapter 8  Design at the Register Transfer Level</b><br>
detail is omitted in the figure). The external input signal  <i>Start</i>  launches the operation <br>of the machine;  <i>Ready</i>  indicates the status of the machine to the external environment. <br>The controller has status input signals  <i>E</i>  and  <i>Zero</i>  from the datapath. These signals <br>indicate the contents of a register holding the MSB of the data word and the condition <br>that the data word is 0, respectively.  <i>E</i>  is the output of the flipflop.  <i>Zero</i>  is the output <br>of a circuit that checks the contents of register  <i>R1</i>  for all 0's. The circuit produces an <br>output  <i>Zero</i> = 1 when  <i>R1</i>  is equal to 0 (i.e., when  <i>R1</i>  is empty of 1's). <br>
 <br>A preliminary ASMD chart showing the state sequence and the register operations <br>
is  illustrated  in   Fig.    8.22   (b),  and  the  complete  ASMD  chart  in   Fig.    8.22   (c).  Asserting <br> <br><i>Start</i>  with the controller in  <i>S_idle</i>  transfers the state to  <i>S_1</i>,  concurrently loads reg-<br>ister  <i>R1</i>  with the binary data word, and fills the cells of  <i>R2</i>  with 1's. Note that incre-<br>menting a number with all 1's in a counter register produces a number with all 0's. <br>Thus, the first transition from  <i>S_1</i>  to  <i>S_2</i>  will clear  <i>R2</i> . Subsequent transitions will <br>have  <i>R2</i>  holding a count of the bits of data that have been processed. The content of <br> <br><i>R1</i>,  as indicated by  <i>Zero</i>,  will also be examined in  <i>S_1</i> . If  <i>R1</i>  is empty,  <i>Zero</i> = 1, and <br>the state returns to  <i>S_idle</i>,  where it asserts  <i>Ready</i> . In state  <i>S_1,</i>  <i>Incr_R2</i>  is asserted <br>to cause the datapath unit to increment  <i>R2</i>  at each clock pulse. If  <i>R1</i>  is not empty of <br>1's, then  <i>Zero</i> = 0, indicating that there are some 1's stored in the register. The num-<br>ber in  <i>R1</i>  is shifted and its leftmost bit is transferred into  <i>E</i> . This is done as many <br>times as necessary, until a 1 is transferred into  <i>E</i> . For every 1 detected in  <i>E</i>,   register <br> <br><i>R2</i>  is incremented and register  <i>R1</i>  is checked again for more 1's. The major loop is <br>repeated until all the 1's in  <i>R1</i>  are counted. Note that the state box of  <i>S_3</i>  has no <br>register operations, but the block associated with it contains the decision box for  <i>E</i> . <br>Note also that the serial input to shift register  <i>R1</i>  must be equal to 0 because we don't <br>want to shift external 1's into  <i>R1</i> . The register  <i>R1</i>   in   Fig.   8.22   (a)  is  a  shift  register. <br>Register  <i>R2</i>  is a counter with parallel load. The multiplexer input conditions for the <br>control are determined from  Table   8.9  . The input conditions are obtained from the <br>ASMD chart for each possible binary state transition. The four states are assigned <br>
<b> <br>Table 8.9 <br><i> <br>Multiplexer Input Conditions for Design Example </b></i><br>
<b> <br>Present </b><br>
<b> <br>Next </b><br>
<b> <br>Input </b><br>
<b> <br>Multiplexer </b><br>
<b>State </b><br>
<b>State </b><br>
<b>Conditions </b><br>
<b>Inputs </b><br>
<b> <br><i>G</i>1   <i>G</i>0 </b><br>
<b> <br><i>G</i>1   <i>G</i>0 </b><br>
<b> </b><br>
<b> <br>MUX1 </b><br>
<b> <br>MUX2 </b><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
<i> <br>Start  </i><br>
<i> </i><br>
<i> </i><br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
<i>  Start  </i><br>
 0 <br>
<i>  Start  </i><br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
<i>  Zero  </i><br>
<i>  </i><br>
<i>  </i><br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
<i> <br>Zero  </i><br>
<i> <br>Zero  </i><br>
 0 <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
<i> None </i><br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 1 <br>
 0 <br>
<i> <br>E  </i><br>
<i> </i><br>
 <br>
 1 <br>
 1 <br>
 0 <br>
 1 <br>
<i>  E  </i><br>
<i> <br>E  </i><br>
<i>  E  </i><br>
<hr>
<A name=435></a><b>Section 8.10  Design with Multiplexers    417</b><br>
0<br>
0<br>
<i>Zero</i><br>
1<br>
<i>G</i>1<br>
Mux_1<br>
<i>D</i><br>
1<br>
<i>Start</i><br>
2<br>
<i>Load_regs</i><br>
<i>C</i><br>
<i>E</i><br>
3<br>
<i>s</i>1<br>
<i>s</i>0<br>
0<br>
<i>Ready</i><br>
1<br>
<i>Incr_R2</i><br>
2<br>
 4 Decoder<br>
2<br>
<i>Shift_left</i><br>
3<br>
<i>s</i>1<br>
<i>s</i>0<br>
<i>Start</i><br>
0<br>
0<br>
1<br>
<i>G</i>0<br>
Mux_2<br>
<i>D</i><br>
1<br>
2<br>
<i>C</i><br>
<i>E</i><br>
3<br>
<i>clock</i><br>
<i>reset_b</i><br>
 <br><b>FIGURE 8.23   <br> <br>Control implementation for countofones circuit  </b><br>
binary values 00 through 11. The transition from present state 00 depends on  <i>Start</i> . <br>The transition from present state 01 depends on  <i>Zero</i>,  and the transition from pres-<br>ent state 11 on  <i>E</i> . Present state 10 goes to next state 11 unconditionally. The values <br>under MUX1 and MUX2 in the table are determined from the Boolean input condi-<br>tions for the next state of   <i>G</i>1     and     <i>G</i>0   ,  respectively. <br>
 <br>The control implementation of the design example is shown in  Fig.   8.23  . This is a <br>
threelevel implementation, with the multiplexers in the first level. The inputs to the <br>multiplexers are obtained from  Table   8.9  . The Verilog description in HDL Example 8.8 <br>instantiates structural models of the controller and the datapath. The listing of code <br>includes the lower level modules implementing their structures. Note that the datapath <br>unit does not have a reset signal to clear the registers, but the models for the flipflop, <br>shift register, and counter have an activelow reset. This illustrates the use of Verilog <br>data type  <b>supply1</b>  to hardwire those ports to logic value 1 in their instantiation within <br> <br><i>Datapath_STR</i> . Note also that the test bench uses hierarchical dereferencing to access <br>the state of the controller to make the debug and verification tasks easier, without hav-<br>ing to alter the module ports to provide access to the internal signals. Another detail to <br>observe is that the serial input to the shift register is hardwired to 0. The lower level <br>models  are  described  behaviorally  for  simplicity.       <br>
<hr>
<A name=436></a><b>418    Chapter 8  Design at the Register Transfer Level</b><br>
<b> <br>HDL Example 8.8 (Ones Counter)  </b><br>
<b> <br>module  </b>Count_Ones_STR_STR (count, Ready, data, Start, clock, reset_b);<br> <br>// Mux � decoder implementation of control logic<br>
 <br>// controller is structural<br>
 <br>// datapath is structural<br>
<b> <br> parameter </b><br>
<b> </b>R1_size = 8, R2_size = 4;<br>
<b> <br> output </b><br>
<b> </b><br>
[R2_size -1: 0] <br>
count;<br>
<b> <br> output </b><br>
<b> </b><br>
Ready;<br>
<b> <br> input </b><br>
<b>  </b>[R1_size -1: 0] <br>
data;<br>
<b> <br> input </b><br>
<b> </b><br>
Start, clock, reset_b;<br>
  <b>wire  </b><br>
Load_regs, Shift_left, Incr_R2, Zero, E;<br>
  Controller_STR M0 (Ready, Load_regs, Shift_left, Incr_R2, Start, E, Zero, clock, reset_b);<br>
  Datapath_STR  M1 (count, E, Zero, data, Load_regs, Shift_left, Incr_R2, clock);<br>
<b> <br>endmodule </b><br>
<b> <br>module  </b>Controller_STR (Ready, Load_regs, Shift_left, Incr_R2, Start, E, Zero, clock, <br> reset_b);<br>
<b> <br> output </b><br>
<b>  </b><br>
Ready;<br>
  <b>output  </b><br>
Load_regs, Shift_left, Incr_R2;<br>
  <b>input  </b><br>
Start;<br>
  <b>input  </b><br>
E, Zero;<br>
  <b>input  </b><br>
clock, reset_b;<br>
  <b>supply0  </b><br>
GND;<br>
  <b>supply1  </b><br>
PWR;<br>
  <b>parameter  </b><br>
S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11; // Binary code<br>
<b> <br> wire </b><br>
<b> </b><br>
Load_regs, Shift_left, Incr_R2;<br>
  <b>wire  </b><br>
G0, G0_b, D_in0, D_in1, G1, G1_b;<br>
  <b>wire  </b><br>
Zero_b = ~Zero;<br>
<b> <br> wire </b><br>
<b> </b><br>
E_b = ~E;<br>
  <b>wire  </b>[1: 0] <br>
select = {G1, G0};<br>
  <b>wire  </b>[0: 3] <br>
Decoder_out;<br>
  <b>assign  </b><br>
Ready = ~Decoder_out[0];<br>
  <b>assign   </b><br>
Incr_R2 = ~Decoder_out[1];<br>
  <b>assign   </b><br>
Shift_left = ~Decoder_out[2];<br>
  <b>and   </b><br>
(Load_regs, Ready, Start);<br>
  mux_4x1_beh <br>
Mux_1 <br>
(D_in1, GND, Zero_b, PWR, E_b, select);<br>
  mux_4x1_beh <br>
Mux_0 <br>
(D_in0, Start, GND, PWR, E, select);<br>
  D_flip_flop_AR_b <br>
M1 <br>
(G1, G1_b, D_in1, clock, reset_b);<br>
  D_flip_flop_AR_b <br>
M0 <br>
(G0, G0_b, D_in0, clock, reset_b);<br>
  decoder_2x4_df <br>
M2 <br>
(Decoder_out, G1, G0, GND);<br>
<b> <br>endmodule </b><br>
<hr>
<A name=437></a><b>Section 8.10  Design with Multiplexers    419</b><br>
<b> <br>module  </b>Datapath_STR (count, E, Zero, data, Load_regs, Shift_left, Incr_R2, clock);<br><b> <br> parameter </b><br>
<b> </b><br>
R1_size = 8, R2_size = 4;<br>
<b> <br> output </b><br>
<b> </b>[R2_size -1: 0]  count;<br>
<b> <br> output </b><br>
<b> </b><br>
E, Zero;<br>
<b> <br> input </b><br>
<b>  </b>[R1_size -1: 0] <br>
data;<br>
<b> <br> input </b><br>
<b> </b><br>
Load_regs, Shift_left, Incr_R2, clock;<br>
<b> <br> wire </b><br>
<b> </b><br>
[R1_size -1: 0] <br>
R1;<br>
<b> <br> wire </b><br>
<b> </b><br>
Zero;<br>
  <b>supply0  </b><br>
Gnd;<br>
  <b>supply1  </b><br>
Pwr;<br>
  <b>assign  </b>Zero = (R1 == 0); <br>
// implicit combinational logic<br>
  Shift_Reg <br>
M1 <br>
(R1, data, Gnd, Shift_left, Load_regs, clock, Pwr);<br>
  Counter <br>
M2 <br>
(count, Load_regs, Incr_R2, clock, Pwr);<br>
  D_flip_flop_AR <br>
M3 <br>
(E, w1, clock, Pwr);<br>
  and <br>
(w1, R1[R1_size - 1], Shift_left);<br>
<b> <br>endmodule </b><br>
<b> <br>module  </b>Shift_Reg (R1, data, SI_0, Shift_left, Load_regs, clock, reset_b);<br><b> <br> parameter </b><br>
<b>  </b>R1_size = 8;<br>
  <b>output  </b><br>
[R1_size -1: 0] <br>
R1;<br>
  <b>input  </b><br>
[R1_size -1: 0] <br>
data;<br>
<b> <br> input </b><br>
<b> </b><br>
SI_0, Shift_left, Load_regs;<br>
  <b>input  </b><br>
clock, reset_b;<br>
<b> <br> reg </b><br>
<b> </b><br>
[R1_size -1: 0] <br>
R1;<br>
<b> <br> always </b><br>
<b>  @</b>  ( <b>posedge</b>  clock,  <b>negedge</b>  reset_b)<br>
  <b>if  </b>(reset_b == 0) R1 &lt;= 0;<br>  <b>else   begin</b> <br>    <b>if  </b>(Load_regs) R1 &lt;= data;  <b>else</b> <br><b> <br>  if </b><br>
<b> </b>(Shift_left) R1 &lt;= {R1[R1_size -2: 0], SI_0};  <b>end</b> <br>
 <br><b>endmodule <br> <br>module  </b>Counter (R2, Load_regs, Incr_R2, clock, reset_b);<br><b> <br> parameter </b><br>
<b> </b><br>
R2_size = 4;<br>
<b> <br> output </b><br>
<b> </b><br>
[R2_size -1: 0] <br>
R2;<br>
<b> <br> input </b><br>
<b> </b><br>
Load_regs, Incr_R2;<br>
  <b>input   </b><br>
clock, reset_b;<br>
<b> <br> reg </b><br>
<b> </b><br>
[R2_size -1: 0] <br>
R2;<br>
<b> <br> always </b><br>
<b> </b>@ (<b>posedge</b> clock, <b>negedge</b> reset_b)<br>
  <b>if  </b>(reset_b == 0) R2 &lt;= 0;<br>  <b>else   if</b>  (Load_regs) R2 &lt;= {R2_size {1'b1}};  <br>
// Fill with 1<br>
    <b>else   if</b>  (Incr_R2 == 1) R2 &lt;= R2 + 1;<br> <br><b>endmodule <br> <br>module  </b>D_flip_flop_AR (Q, D, CLK, RST_b);<br><b> <br> output </b><br>
<b>  </b><br>
Q;<br>
  <b>input  </b><br>
D, CLK, RST_b;<br>
<hr>
<A name=438></a><b>420    Chapter 8  Design at the Register Transfer Level</b><br>
  <b>reg   </b><br>
Q;<br>
<b> <br> always </b><br>
<b>  @</b>  ( <b>posedge</b>  CLK,  <b>negedge</b>  RST_b)<br>
  <b>if  </b>(RST_b == 0) Q &lt;= 1'b0;<br>  <b>else  </b>Q &lt;= D;<br><b> <br>endmodule <br> <br>module  </b>D_flip_flop_AR_b (Q, Q_b, D, CLK, RST_b);<br><b> <br> output </b><br>
<b>  </b><br>
Q, Q_b;<br>
  <b>input  </b><br>
D, CLK, RST_b;<br>
  <b>reg   </b><br>
Q;<br>
  <b>assign  </b><br>
Q_b = ~Q;<br>
<b> <br> always </b><br>
<b>  @</b>  ( <b>posedge</b>  CLK,  <b>negedge</b>  RST_b)<br>
  <b>if  </b>(RST_b == 0) Q &lt;= 1'b0;<br>  <b>else  </b>Q &lt;= D; <br> <br><b>endmodule <br></b> <br>// Behavioral description of four-to-one line multiplexer<br>
 <br>// Verilog 2005 port syntax<br>
<b> <br>module  </b>mux_4x1_beh<br> <br>( <b>output reg</b>  m_out,<br><b> <br> input </b><br>
<b> </b><br>
in_0, in_1, in_2, in_3,<br>
  <b>input </b>[1: 0]  select<br> <br>);<br>
<b> <br> always </b><br>
<b> @</b> (in_0, in_1, in_2, in_3, select)  <br>
// Verilog 2005 syntax<br>
  <b>case  </b>(select)<br>    2'b00: <br>
m_out = in_0;<br>
    2'b01: <br>
m_out = in_1;<br>
    2'b10: <br>
m_out = in_2;<br>
    2'b11: <br>
m_out = in_3;<br>
<b> <br> endcase <br> <br> endmodule </b><br>
<b> <br></b>//<b> </b>Dataflow description of two-to-four-line decoder<br> <br>// See Fig. 4.19. Note: The figure uses symbol <i>E</i>, but the<br> <br>// Verilog model uses <i>enable</i> to indicate functionality clearly.<br><b> <br>module  </b>decoder_2x4_df (D, A, B, enable);<br><b> <br> output </b><br>
<b> </b><br>
[0: 3] <br>
D;<br>
<b> <br> input </b><br>
<b> </b><br>
A, B;<br>
  <b>input  </b><br>
enable;<br>
<b> <br> assign </b><br>
<b> </b><br>
D[0] = !(!A &amp;&amp; !B &amp;&amp; !enable),<br>
 <br>
D[1] = !(!A &amp;&amp; B &amp;&amp; !enable),<br>
 <br>
D[2] = !(A &amp;&amp; !B &amp;&amp; !enable),<br>
 <br>
D[3] = !(A &amp;&amp; B &amp;&amp; !enable);<br>
<b> <br> endmodule </b><br>
<b> <br>module  </b>t_Count_Ones;<br>
<hr>
<A name=439></a><b>Section 8.10  Design with Multiplexers    421</b><br>
<b> <br> parameter </b><br>
<b> </b>R1_size = 8, R2_size = 4;<br>
<b> <br> wire </b><br>
<b> </b><br>
[R2_size -1: 0] <br>
R2;<br>
<b> <br> wire </b><br>
<b> </b><br>
[R2_size -1: 0] <br>
count;<br>
<b> <br> wire </b><br>
<b> </b><br>
Ready;<br>
<b> <br> reg </b><br>
<b> </b><br>
[R1_size -1: 0] <br>
data;<br>
<b> <br> reg </b><br>
<b> </b><br>
Start, clock, reset_b;<br>
<b> <br> wire </b><br>
<b> </b><br>
[1: 0] <br>
state; <br>
// Use only for debug<br>
<b> <br> assign </b><br>
<b> </b>state = {M0.M0.G1, M0.M0.G0};<br>
  Count_Ones_STR_STR M0 (count, Ready, data, Start, clock, reset_b);<br>
<b> <br> initial </b><br>
<b> </b>#650  <b>$finish</b> ;<br>
  <b>initial   begin</b>  clock = 0; #5  <b>forever</b>  #5 clock = ~clock;  <b>end</b> <br>  <b>initial   fork</b> <br>  #1 reset_b = 1;<br>
  #3 reset_b = 0;<br>
  #4 reset_b = 1;<br>
  #27 reset_b = 0;<br>
  #29 reset_b = 1;<br>
  #355 reset_b = 0;<br>
  #365 reset_b = 1;<br>
  #4 data = 8'Hff;<br>
  #145 data = 8'haa;<br>
  # 25 Start = 1;<br>
  # 35 Start = 0;<br>
  #55 Start = 1;<br>
  #65 Start = 0;<br>
  #395 Start = 1;<br>
  #405 Start = 0;<br>
<b> <br> join <br> <br>endmodule  </b><br>
<b> <br>Testing the Ones Counter </b><br>
 <br>The test bench in HDL Example 8.8 was used to produce the simulation results in <br> Fig.   8.24   . Annotations  have  been  added  for  clarification.  In   Fig.    8.24   (a),   <i>reset_b</i>  is toggled <br>low at <i>t</i> = 3 to drive the controller into  <i>S_idle</i>,  but with  <i>Start</i>  not yet having an assigned <br>value. (The default is x.) Consequently, the controller enters an unknown state (the <br>shaded waveform) at the next clock, and its outputs are unknown.4 When  <i>reset_b</i>   is <br>asserted (low) again at  <i>t</i> = 27, the state enters  <i>S_idle</i> . Then, with  <i>Start</i> = 1 at the first clock <br>after  <i>reset_b</i>  is deasserted, (1) the controller enters  <i>S_1</i>,  (2)  <i>Load_regs</i>  causes  <i>R1</i>  to be <br>set to the value of  <i>data</i>,   namely,     8 Hff   ,  and  (3)   <i>R2</i>  is filled with 1's. At the next clock,  <i>R2</i> <br>
4 Remember, this simulation is in Verilog's fourvalued logic system. In actual hardware, the values will be 0 or 1. <br>Without a known applied value for the inputs, the next state and outputs will be undetermined, even after the reset <br>signal has been applied.<br>
<hr>
<A name=440></a><b>422    Chapter 8  Design at the Register Transfer Level</b><br>
<i>reset_b asserted (low), but</i><br>
<i>Machine begins</i><br>
<i>Start unknown</i><br>
<i>counting</i><br>
0<br>
30<br>
60<br>
90<br>
120<br>
Name<br>
<i>clock<br>reset_b</i><br>
<i>Start<br>Zero<br>E</i><br>
<i>state[1: 0]</i><br>
x<br>
0<br>
X<br>
0<br>
1<br>
2<br>
3<br>
1<br>
2<br>
3<br>
1<br>
2<br>
3<br>
1<br>
<i>state[1]<br>state[0]</i><br>
<i>Ready<br>Load_regs<br>Shift_left<br>Incr_R2</i><br>
<i>data[7: 0]</i><br>
ff<br>
<i>R1[7: 0]</i><br>
xx<br>
ff<br>
fe<br>
fc<br>
f8<br>
<i>E<br>R2[3: 0]</i><br>
x<br>
f<br>
0<br>
1<br>
2<br>
<i>count[3: 0]</i><br>
x<br>
f<br>
0<br>
1<br>
2<br>
<i>R</i>2<i> filled with 1s R</i>1<i> loaded with data</i><br>
(a)<br>
 <br><b>FIGURE 8.24   <br> <br>Simulation waveforms for countofones circuit  </b><br>
starts counting from 0.  <i>Shift_left</i>  is asserted while the controller is in state  <i>S_2</i>,   and <br> <br><i>incr_R2</i>  is asserted while the controller is in state  <i>S_1</i> . Notice that  <i>R2</i>  is incremented in <br>the next cycle after  <i>incr_R2</i>  is asserted. No output is asserted in state  <i>S_3</i> .  The  counting <br>sequence  continues  in   Fig.    8.24   (b)  until   <i>Zero</i>  is asserted, with  <i>E</i>  holding the last 1 of the <br>data word. The next clock produces  <i>count</i> = 8, and  <i>state</i>  returns to  <i>S_idle</i> .  (Additional <br>testing is addressed in the problems at the end of the chapter.)  <br>
<b> <br>8 . 1 1       R A C E  F R E E   D E S I G N   ( S O F T W A R E   R A C E </b><br>
<b>C O N D I T I O N S ) </b><br>
 <br>Once a circuit has been synthesized, either manually or with tools, it is necessary to <br>verify that the simulation results produced by the HDL behavioral model match those of <br>the netlist of the gates (standard cells) of the physical circuit. It is important to resolve any <br>
<hr>
<A name=441></a><b>Section 8.11  RaceFree Design (Software Race Conditions)    423</b><br>
<i>R1 is empty of</i><br>
<i>Machine returns to</i><br>
<i>Computations are</i><br>
<i>1s</i><br>
<i>S_idle</i><br>
<i>done</i><br>
120<br>
180<br>
240<br>
300<br>
Name<br>
<i>clock<br>reset_b</i><br>
<i>Start<br>Zero</i><br>
<i>E</i><br>
<i>state[1: 0]</i><br>
1<br>
2<br>
3<br>
1<br>
2<br>
3<br>
1<br>
2<br>
3<br>
1<br>
2<br>
3<br>
1<br>
2<br>
3<br>
1<br>
0<br>
<i>state[1]<br>state[0]</i><br>
<i>Ready<br>Load_regs<br>Shift_left<br>Incr_R2</i><br>
<i>data[7: 0]</i><br>
ff<br>
aa<br>
<i>R1[7: 0]</i><br>
f8<br>
f0<br>
e0<br>
c0<br>
80<br>
00<br>
<i>E<br>R2[3: 0]</i><br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
<i>count[3: 0]</i><br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
<i>R</i>2<i> holds number of 1s </i><br>
(b)<br>
 <br><b>Figure 8.24</b>   <b>(Continued)  </b><br>
mismatch, because the behavioral model was presumed to be correct. There are various <br>potential sources of mismatch between the results of a simulation, but we will consider <br>one that typically happens in HDLbased design methodology. Three realities contribute <br>to the potential problem: (1) a physical feedback path exists between a datapath unit and <br>a control unit whose inputs include status signals fed back from the datapath unit; <br>(2) blocked procedural assignments execute immediately, and behavioral models simu-<br>late with 0 propagation delays, effectively creating immediate changes in the outputs of <br>combinational logic when its inputs change (i.e., changes in the inputs and the outputs <br>are scheduled in the same time step of the simulation); and (3) the order in which a <br>simulator executes multiple blocked assignments to the same variable at a given time <br>step of the simulation is indeterminate (i.e., unpredictable). <br>
<hr>
<A name=442></a><b>424    Chapter 8  Design at the Register Transfer Level</b><br>
 <br>Now consider a sequential machine with an HDL model in which all assignments <br>
are made with the blocked assignment operator. At a clock pulse, the register opera-<br>tions in the datapath, the state transitions in the controller, the updates of the next <br>state and output logic of the controller, and the updates to the status signals in the <br>datapath are all scheduled to occur at the same time step of the simulation. Which <br>executes first? Suppose that when a clock pulse occurs, the state of the controller <br>changes before the register operations execute. The change in the state could change <br>the outputs of the control unit. The new values of the outputs would be used by the <br>datapath when it finally executes its assignments at that same clock pulse. The result <br>might not be the same as it would have been if the datapath had executed its assign-<br>ments before the control unit updated its state and outputs. Conversely, suppose that <br>when the clock pulse occurs, the datapath unit executes its operations and updates its <br>status signals first. The updated status signals could cause a change in the value of the <br>next state of the controller, which would be used to update the state. The result could <br>differ from that which would result if the state had been updated before the edge<br>sensitive operations in the datapath executed. In either case, the timing of register <br>transfer operations and state transitions in the different representations of the system <br>might not match.  <i>Failing to detect a mismatch can have disastrous consequences for <br>the user of the design. Finding the source of the mismatch can be very timeconsuming <br>and costly. It is better to  </i>avoid the mismatch<i>  by following a strict discipline in your <br>design</i> . Fortunately, there is a solution to this dilemma. <br>
 <br>A designer can eliminate the  <i>software race conditions</i>  just described by observing <br>
the rule of modeling combinational logic with blocked assignments and modeling <br>state transitions and edgesensitive register operations with nonblocking assign-<br>ments. A software race cannot happen if nonblocking operators are used as shown <br>in all of the examples in this text, because the sampling mechanism of the nonblock-<br>ing operator breaks the feedback path between a state transition or edgesensitive <br>datapath operation and the combinational logic that forms the next state or inputs <br>to the registers in the datapath unit. The mechanism does this because simulators <br>evaluate the expressions on the righthand side of their nonblocking assignment <br>statements before any blocked assignments are made. Thus, the nonblocking assign-<br>ments cannot be affected by the results of the blocked assignments. This matches the <br>hardware reality. Always use the blocking operator to model combinational logic, <br>and use the nonblocking operator to model edgesensitive register operations and <br>state transitions. <br>
 <br>It also might appear that the physical structure of a datapath and the controller <br>
together create a physical (i.e., hardware), race condition, because the status signals are <br>fed back to the controller and the outputs of the controller are fed forward to the <br>datapath. However, timing analysis can verify that a change in the output of the control-<br>ler will not propagate through the datapath logic and then through the input logic of <br>the controller in time to have an effect on the output of the controller until the next <br>clock pulse. The state cannot update until the next edge of the clock, even though the <br>status signals update the value of the next state. The flipflop cuts the feedback path <br>
<hr>
<A name=443></a><b>Section 8.12  LatchFree Design (Why Waste Silicon?)    425</b><br>
between clock cycles. In practice, timing analysis verifies that the circuit will operate at <br>the specified clock frequency, or it identifies signal paths whose propagation delays are <br>problematic. Remember, the design must implement the correct logic and operate at <br>the speed prescribed by the clock. <br>
<b> <br>8 . 1 2       L AT C H  F R E E   D E S I G N   ( W H Y   W A S T E </b><br>
<b>S I L I C O N ? ) </b><br>
 <br>Continuous assignments model combinational logic implicitly. A feedbackfree continu-<br>ous assignment will synthesize to combinational logic, and the input�output relationship <br>of the logic is automatically sensitive to all of the inputs of the circuit. In simulation, the <br>simulator monitors the righthand sides of all continuous assignments, detects a change <br>in any of the referenced variables, and updates the lefthand side of an affected assign-<br>ment statement. Unlike a continuous assignment, a cyclic behavior is not necessarily <br>completely sensitive to all of the variables that are referenced by its assignment state-<br>ments. If a levelsensitive cyclic behavior is used to describe combinational logic, it is <br>essential that the sensitivity list include every variable that is referenced on the righthand <br>side of an assignment statement in the behavior. If the list is incomplete, the logic <br>described by the behavior will be synthesized with latches at the outputs of the logic. This <br>implementation wastes silicon area and may have a mismatch between the simulation of <br>the behavioral model and the synthesized circuit. These difficulties can be avoided by <br>ensuring that the sensitivity list is complete, but, in large circuits, it is easy to fail to include <br>every referenced variable in the sensitivity list of a levelsensitive cyclic behavior. <br> <br>Consequently, Verilog 2001 included a new operator to reduce the risk of accidentally <br> synthesizing  latches. <br>
 <br>In Verilog 2001, the tokens @ and * can be combined as @* or @(*) and are used <br>
without a sensitivity list to indicate that execution of the associated statement is sensi-<br>tive to every variable that is referenced on the righthand side of an assignment state-<br>ment in the logic. In effect, the operator @* indicates that the logic is to be interpreted <br>
<b>   HDL  Example  8.9  </b><br>
 <br>The following level-sensitive cyclic behavior will synthesize a two-channel multiplexer:<br>
<b> <br>module  </b>mux_2_V2001 ( <b>output reg</b>  [31: 0] y,  <b>input</b>  [31: 0] a, b,  <b>input</b>  sel);<br><b> <br> always @*</b> <br>  y = sel ? a: b;<br>
<b> <br>endmodule  </b><br>
 <br>The cyclic behavior has an implicit sensitivity list consisting of  <i>a, b</i>,  and  <i>sel</i> .  <br>
<hr>
<A name=444></a><b>426    Chapter 8  Design at the Register Transfer Level</b><br>
and synthesized as levelsensitive combinational logic; the logic has an implicit  sensitivity <br>list composed of all of the variables that are referenced by the procedural assignments. <br>Using the @* operator will prevent accidental synthesis of latches. <br>
<b> <br>8 . 1 3       O T H E R   L A N G U A G E   F E AT U R E S </b><br>
 <br>The examples in this text have used only those features of the Verilog HDL that are <br>appropriate for an introductory course in logic design. Verilog 2001 contains features <br>that are very useful to designers, but which are not considered here. Among them are <br>multidimensional arrays, variable part selects, array bit and part selects, signed reg, net, <br>and port declarations, and local parameters. These enhancements are treated in more <br>advanced texts using Verilog 2001 and Verilog 2005. <br>
<b> <br>P R O B L E M S </b><br>
 <br>
Answers to problems marked with * appear at the end of the book. <br>
 <br><b> 8.1*  </b> Explain in words and write HDL statements for the operations specified by the following <br>
register transfer notation: <br>
    <br>
(a)       <i>R2 </i>d <i>R2 </i>+ 1, <i>R1 </i>d <i>R</i> <br>
   <br>
(b)       <i>R3 </i>d <i>R3 </i>- 1 <br>
   <br>
(c)    If     (<i>S</i>1 = 1)     then     (<i>R0 </i>d <i>R1</i>)     else  if     (<i>S</i>2 = 1)     then     (<i>R0 </i>d <i>R2</i>) <br>
 <br><b> 8.2 </b><br>
 <br>A logic circuit with activelow synchronous reset has two control inputs <i>x</i> and <i>y</i>. If  <i>x</i>  is 1 <br>and  <i>y</i>  is 0, register  <i>R</i>  is incremented by 1 and control goes to a second state. If  <i>x</i>  is 0 and  <i>y</i> <br>is 1, register  <i>R</i>  is cleared to zero and control goes from the initial state to a third state. <br>Otherwise, control stays in the initial state. Draw (1) a block diagram showing the control-<br>ler, datapath unit (with internal registers), and signals, and (2) the portion of an ASMD <br>chart starting from an initial state. <br>
 <br><b> 8.3 </b><br>
 <br>Draw the ASMD charts for the following state transitions: <br>
    <br>
(a)    If     <i>x </i>= 1,  control goes from state   <i>S</i>1     to  state     <i>S</i>2   ;  if   <i>x</i> = 0, generate a conditional opera-<br>
tion     <i>R </i>6 = <i>R </i>+ 2     and  go  from     <i>S</i>1 to  <i>S</i>2 . <br>
   <br>
(b)    If   <i>x</i> = 1, control goes from   <i>S</i>1 to  <i>S</i>2     and  then  to     <i>S</i>3;     if   <i>x</i> = 0, control goes from   <i>S</i>1 to  <i>S</i>3. <br>
   <br>
(c)    Start  from  state     <i>S</i>1;     then  if   <i>xy</i> = 11, go to   <i>S</i>2;     if   <i>xy</i> = 01 go to   <i>S</i>3;     and  if   <i>xy</i> = 10, go to   <i>S</i>1;    <br>
otherwise, go to   <i>S</i>3. <br>
 <br><b> 8.4 </b><br>
 <br>Show the eight exit paths in an ASM block emanating from the decision boxes that check <br>the eight possible binary values of three control variables  <i>x,</i>    <i>y</i>,  and  <i>z</i> .   <br>
 <br><b> 8.5 </b><br>
 <br>Explain how the ASM and ASMD charts differ from a conventional flowchart. Using <br> <br>Fig.  8.5   as an illustration, show the difference in interpretation. Explain the difference <br>between and ASM chart and an ASMD chart. In your own words, discuss the use and merit <br>of using an ASMD chart. <br>
 <br><b> 8.6 </b><br>
 <br>Construct a block diagram and an ASMD chart for a digital system that counts the number <br>of people in a room. The one door through which people enter the room has a photocell <br>that changes a signal <i>x</i> from 1 to 0 while the light is interrupted. They leave the room from <br>
<hr>
<A name=445></a><b>Problems    427</b><br>
a second door with a similar photocell that changes a signal <i>y</i> from 1 to 0 while the light <br>is interrupted. The datapath circuit consists of an up�down counter with a display that <br>shows how many people are in the room. <br>
 <br><b> 8.7*  </b> Draw a block diagram and an ASMD chart for a circuit with two eightbit registers  <i>RA</i> <br>
and  <i>RB</i>  that receive two unsigned binary numbers. The circuit performs the subtraction <br>operation <br>
 <br><i>RA </i>d <i>RA </i>- <i>RB</i> <br>
 <br>
 <br>
Use the method for subtraction described in Section 1.5, and set a borrow flipflop to 1 if <br>the answer is negative. Write and verify an HDL model of the circuit. <br>
 <br><b> 8.8*  </b> Design a digital circuit with three 16bit registers  <i>AR,</i>  <i>BR,</i>  and  <i>CR</i>  that perform the <br>
following operations: <br>
 <br>
(a)   Transfer two 16bit signed numbers (in 2'scomplement representation) to  <i>AR</i>  and  <i>BR</i> .  <br>
   <br>
(b)    If  the  number  in   <i>AR</i>  is negative, divide the number in  <i>AR</i>  by 2 and transfer the result <br>
to register  <i>CR</i> .  <br>
   <br>
(c)    If  the  number  in   <i>AR</i>  is positive but nonzero, multiply the number in  <i>BR</i>  by 2 and <br>
transfer the result to register  <i>CR</i> .  <br>
   <br>
(d)    If  the  number  in   <i>AR</i>  is zero, clear register  <i>CR</i>  to 0. <br>
 <br>
(e)   Write and verify a behavioral model of the circuit. <br>
 <br><b> 8.9*  </b> Design the controller whose state diagram is given by  Fig.   8.11  (a). Use one flipflop per <br>
state (a onehot assignment). Write, simulate, verify, and compare RTL and structural <br>models of the controller. <br>
 <br><b> 8.10 </b><br>
 <br>The state diagram of a control unit is shown in Fig.  P8.10 . It has four states and two <br>inputs <i>x</i> and  <i>y</i> . Draw the equivalent ASM chart. Write and verify a Verilog model of the <br>controller.   <br>
<i>x</i><br>
 0<br>
00<br>
<i>x</i><br>
 1<br>
<i>x</i><br>
 1<br>
<i>x</i><br>
 0<br>
01<br>
<i>y</i><br>
 1<br>
<i>y</i><br>
 0<br>
<i>x</i><br>
 0, <i>y </i> 0<br>
<i>x</i><br>
 0<br>
<i>x</i><br>
 1<br>
11<br>
10<br>
<i>y</i><br>
 1<br>
<i>y</i><br>
 0<br>
<i>x</i><br>
 1, <i>y </i> 1<br>
 <br><b>FIGURE P8.10   <br> <br>Control state diagram for Problems 8.10 and 8.11  </b><br>
 <br><b> 8.11* </b> Design the controller whose state diagram is shown in Fig. P8.10. Use  <i>D</i>   flipflops.   <br>
 <br><b> 8.12 </b><br>
 <br>Design the fourbit counter with synchronous clear specified in  Fig.   8.10  . Repeat for <br>asynchronous clear. <br>
<hr>
<A name=446></a><b>428    Chapter 8  Design at the Register Transfer Level</b><br>
 <br><b> 8.13 </b><br>
  Simulate   <i>Design_Example_STR</i>  (see HDL Example 8.4), and verify that its behavior <br>matches that of the RTL description. Obtain state information by displaying  <i>G0</i>  and  <i>G1</i> <br>as a concatenated vector for the state. <br>
 <br><b> 8.14 </b><br>
 <br>What, if any, are the consequences of the machine in  <i>Design_Example_RTL</i>  (see HDL <br>Example 8.2) entering an unused state?  <br>
 <br><b> 8.15 </b><br>
 <br><i>Simulate Design_Example_RTL</i>  in HDL Example 8.2, and verify that it recovers from an <br>unexpected reset condition during its operation, i.e., a "running reset" or a "reset onthefly." <br>
 <br><b> 8.16* </b> Develop a block diagram and an ASMD chart for a digital circuit that multiplies two binary <br>
numbers by the repeatedaddition method. For example, to multiply 5 * 4, the digital system <br>evaluates the product by adding the multiplicand four times: 5 + 5 + 5 + 5 = 20. Design the <br>circuit. Let the multiplicand be in register  <i>BR,</i>  the multiplier in register  <i>AR,</i>  and the product <br>in register  <i>PR</i> .An adder circuit adds the contents of  <i>BR</i>  to  <i>PR</i> .A zerodetection signal indi-<br>cates whether  <i>AR</i>  is 0. Write and verify a Verilog behavioral model of the circuit. <br>
 <br><b> 8.17* </b> Prove that the multiplication of two <i>n</i>bit numbers gives a product of length less than or <br>
equal to 2 <i>n</i>   bits.   <br>
 <br><b> 8.18* </b>  In   Fig.    8.14   ,  the   <i>Q</i>  register holds the multiplier and the  <i>B</i>  register holds the multiplicand. <br>
Assume that each number consists of 16 bits. <br>
 <br>
(a)   How many bits can be expected in the product, and where is it available?  <br>
 <br>
(b)   How many bits are in the  <i>P</i>  counter, and what is the binary number loaded into it <br>
initially?  <br>
 <br>
(c)   Design the circuit that checks for zero in the  <i>P</i>   counter.     <br>
 <br><b> 8.19 </b><br>
 <br>List the contents of registers  <i>C, A, Q</i>,  and  <i>P</i>  in a manner similar to  Table   8.5   during the <br>process of multiplying the two numbers 11011 (multiplicand) and 10111 (multiplier). <br>
 <br><b> 8.20* </b> Determine the time it takes to process the multiplication operation in the binary multi-<br>
plier described in Section 8.8. Assume that the  <i>Q</i>  register has <i>n</i> bits and the clock cycle is <br> <br><i>t</i>   ns.   <br>
 <br><b> 8.21 </b><br>
 <br>Design the control circuit of the binary multiplier specified by the state diagram of  Fig.  8.16  , <br>using multiplexers, a decoder, and a register. <br>
 <br><b> 8.22 </b><br>
 <br>Figure  P8.22  shows an alternative ASMD chart for a sequential binary multiplier. Write and <br>verify an RTL model of the system. Compare this design with that described by the ASMD <br>chart  in   Fig.    8.15   (b).  <br>
 <br><b> 8.23 </b><br>
 <br>Figure  P8.23  shows an alternative ASMD chart for a sequential binary multiplier. Write <br>and verify an RTL model of the system. Compare this design with that described by the <br>ASMD  chart  in   Fig.    8.15   (b).    <br>
 <br><b> 8.24 </b><br>
 <br>The HDL description of a sequential binary multiplier given in HDL Example 8.5 <br>encapsulates the descriptions of the controller and the datapath in a single Verilog <br>module. Write and verify a model that encapsulates the controller and datapath in <br>separate modules. <br>
 <br><b> 8.25 </b><br>
 <br>The sequential binary multiplier described by the ASMD chart in  Fig.   8.15   does not consider <br>whether the multiplicand or the shifted multiplier is 0. Therefore, it executes for a fixed <br>number of clock cycles, independently of the data. <br>
 <br>
(a)   Develop an ASMD chart for a more efficient multiplier that will terminate execution <br>
as soon as either word is found to be zero. <br>
<hr>
<A name=447></a><b>Problems    429</b><br>
<i>reset</i><br>
<i>S_idle</i><br>
<i>A</i><br>
 0<br>
<i>Ready</i><br>
<i>C</i><br>
 0<br>
<i>B</i><br>
<i>Multiplicand</i><br>
<i>Q</i><br>
<i>Multiplier</i><br>
<i>Start</i><br>
<i>P</i><br>
<i>m_size</i><br>
1<br>
<i>Load_regs</i><br>
<i>P</i><br>
<i> P  </i> 1<br>
<i>S_loaded</i><br>
<i>Decrement counter</i><br>
<i>Decr_P</i><br>
{<i>C, A</i>}<br>
<i> A   B</i><br>
1<br>
<i>Add multiplicand </i><br>
<i>Q[0]</i><br>
<i>to shifted sum</i><br>
<i>Add_regs</i><br>
<i>Shift_regs</i><br>
<i>S_sum</i><br>
<i>Shift_regs</i><br>
<i>S_shifted</i><br>
{<i>C, A, Q</i>}<br>
{<i>C, A, Q</i>}<br>
1<br>
17<i>-bit register shifts to the<br>right by one bit</i><br>
<i>Zero</i><br>
1<br>
 <br><b>FIGURE P8.22   <br> <br>ASMD chart for Problem 8.22  </b><br>
 <br>
(b)   Write an HDL description of the circuit. The controller and datapath are to be encap-<br>
sulated in separate Verilog modules. <br>
 <br>
(c)   Write a test plan and a test bench, and verify the circuit. <br>
 <br><b> 8.26 </b><br>
 <br>Modify the ASMD chart of the sequential binary multiplier shown in  Fig.   8.15   to add and <br>shift in the same clock cycle. Write and verify an RTL description of the system. <br>
 <br><b> 8.27 </b><br>
 <br>The second test bench given in HDL Example 8.6 generates a product for all possible <br>values of the multiplicand and multiplier. Verifying that each result is correct would not <br>be practical, so modify the test bench to include a statement that forms the expected <br>
<hr>
<A name=448></a><b>430    Chapter 8  Design at the Register Transfer Level</b><br>
<i>reset</i><br>
<i>S_idle</i><br>
<i>A</i><br>
 0<br>
<i>Ready</i><br>
<i>C</i><br>
 0<br>
<i>B</i><br>
<i>Multiplicand</i><br>
<i>Q</i><br>
<i>Multiplier</i><br>
<i>P</i><br>
<i>m_size</i><br>
<i>Start</i><br>
1<br>
<i>Load_regs</i><br>
<i> S_load<br>Load_regs</i><br>
<i>Decrement counter</i><br>
<i>P</i><br>
<i> P </i><br>
1<br>
<i> S_decr<br>decr_P</i><br>
1<br>
<i>Q[0]</i><br>
<i>Add_regs</i><br>
<i>Add multiplicand<br>to shifted sum</i><br>
<i> S_shift </i><br>
{<i>C, A</i>}<br>
<i> A   B</i><br>
<i>Shift_regs</i><br>
{<i>C, A, Q</i>}<br>
{<i>C, A, Q</i>}<br>
1<br>
17<i>-bit register shifts to the</i><br>
1<br>
<i>Zero</i><br>
<i>right by one bit</i><br>
 <br><b>FIGURE P8.23   <br> <br>ASMD chart for Problem 8.23  </b><br>
product. Write additional statements to compare the result produced by the RTL descrip-<br>tion with the expected result. Your simulation is to produce an error signal indicating the <br>result of the comparison. Repeat for the structural model of the multiplier. <br>
 <br><b> 8.28 </b><br>
 <br>Write the HDL structural description of the multiplier designed in Section 8.8. Use the <br>block diagram of  Fig.   8.14  (a) and the control circuit of  Fig.   8.18  . Simulate the design and <br>verify its functionality by using the test bench of HDL Example 8.6. <br>
 <br><b> 8.29 </b><br>
 <br>An incomplete ASMD chart for a finite state machine is shown in  Fig.   P8.29  . The register <br>operations are not specified, because we are interested only in designing the control logic. <br>
    <br>
(a)    Draw  the  equivalent  state  diagram.  <br>
 <br>
(b)   Design the control unit with one flipflop per state. <br>
 <br>
(c)   List the state table for the control unit. <br>
<hr>
<A name=449></a><b>Problems    431</b><br>
000<br>
<i>S_0</i><br>
0<br>
<i>x</i><br>
1<br>
0<br>
001<br>
<i>y</i><br>
<i>S_1</i><br>
1<br>
010<br>
<i>S_2</i><br>
0<br>
1<br>
<i>F</i><br>
100<br>
<i>S_4</i><br>
011<br>
0<br>
1<br>
<i>S_3</i><br>
<i>E</i><br>
110<br>
<i>S_6</i><br>
111<br>
101<br>
<i>S_7</i><br>
<i>S_5</i><br>
 <br><b>FIGURE P8.29   <br> <br>ASMD chart for Problem 8.29  </b><br>
 <br>
(d)   Design the control unit with three  <i>D</i>  flipflops, a decoder, and gates. <br>
 <br>
(e)   Derive a table showing the multiplexer input conditions for the control unit. <br>
 <br>
(f)   Design the control unit with three multiplexers, a register with three flipflops, and a <br>
3 * 8 decoder. <br>
 <br>
(g)   Using the results of (f), write and verify a structural model of the controller. <br>
   <br>
(h)    Write  and  verify  an  RTL  description  of  the  controller.      <br>
<hr>
<A name=450></a><b>432    Chapter 8  Design at the Register Transfer Level</b><br>
 <br><b> 8.30* </b> What is the value of  <i>E</i>  in each HDL block, assuming that  <i>RA</i> = 1? <br>
 <br> (a) <br>
 <br>RA = RA - 1;  <br>
 <br>(b)   RA &lt;= RA - 1; <br>
 <br>
 <br><b>if</b>  (RA == 0) E = 1;  <br>
 <br><b>if</b>  (RA == 0) E &lt;= 1; <br>
 <br>
 <br><b>else</b>  E = 0;  <br>
 <br><b>else</b>  E &lt;= 0;  <br>
 <br><b> 8.31* </b>  Using  the  Verilog  HDL  operators  listed  in   Table    8.2   ,  assume  that     <i>A </i>= 4 b0110, <br>
<i>B </i>= 4 b0010,     and     <i>C </i>= 4 b0000  and evaluate the result of the following operations: <br>
 <br>A * B; A + B; A - B; ~C; A &amp; B; A | B; A ^ B; &amp; A; ~|C; A || B; A &amp;&amp; C; |A; A &lt; B; A &gt; B; <br>A != B; <br>
 <br><b> 8.32 </b><br>
 <br>Consider the following always block: <br> <br><b>always @</b>  ( <b>posedge</b>  CLK) <br>
 <br><b>if</b>  (S1) R1 &lt;= R1 + R2; <br> <br><b>else if</b>  (S2) R1 &lt;= R1 + 1; <br> <br><b>else</b>  R1 &lt;= R1;  <br>
 <br>Using a fourbit counter with parallel load for  <i>R1</i>  (as in Fig. 6.15) and a fourbit adder, <br>draw a block diagram showing the connections of components and control signals for a <br>possible synthesis of the block. <br>
 <br>
<b>8.33  </b> The multilevel case statement is often translated by a logic synthesizer into hardware <br>
multiplexers. How would you translate the following  <b>case</b>  block into hardware (assume <br>registers of eight bits each)? <br>
 <br><b>case</b>  (state) <br>
 <br>S0: R4 = R0; <br>
 <br>S1: R4 = R1; <br>
 <br>S2: R4 = R2; <br>
 <br>S3: R4 = R3; <br>
 <br><b>endcase</b> <br>
 <br><b> 8.34 </b><br>
 <br>The design of a circuit that counts the number of ones in a register is carried out in Section <br>8.10. The block diagram for the circuit is shown in  Fig.   8.22  (a), a complete ASMD chart <br>for the circuit appears in  Fig.   8.22  (c), and structural HDL models of the datapath and <br>controller are given in HDL Example 8.8. Using the operations and signal names indi-<br>cated on the ASMD chart, <br>
    <br>
(a)    Write   <i>Datapath_BEH</i>,  an RTL description of the datapath unit of the ones counter. <br>
Write a test plan specifying the functionality that will be tested, and write a test bench <br>to implement the plan. Execute the test plan to verify the functionality of the datapath <br>unit, and produce annotated simulation results relating the test plan to the waveforms <br>produced in a simulation. <br>
   <br>
(b)    Write   <i>Controller_BEH</i>,  an RTL description of the control unit of the ones counter. <br>
Write a test plan specifying the functionality that will be tested, and write a test bench <br>to implement the plan. Execute the test plan to verify the functionality of the control <br>unit, and produce annotated simulation results relating the test plan to the waveforms <br>produced in a simulation. <br>
   <br>
(c)     <i>Write Count_Ones_BEH_BEH</i>,  a toplevel module encapsulating and integrating <br>
 <br><i>Controller_BEH</i>  and  <i>Datapath_BEH</i> . Write a test plan and a test bench, and verify <br>the description. Produce annotated simulation results relating the test plan to the <br>waveforms produced in a simulation. <br>
<hr>
<A name=451></a><b>Problems    433</b><br>
   <br>
(d)    Write   <i>Controller_BEH_1Hot</i>,  an RTL description of a onehot controller implement-<br>
ing the ASMD chart of  Fig.   8.22  (c). Write a test plan specifying the functionality that <br>will be tested, and write a test bench to implement the plan. Execute the test plan and <br>produce annotated simulation results relating the test plan to the waveforms produced <br>in a simulation. <br>
   <br>
(e)    Write   <i>Count_Ones_BEH_1_Hot</i>,  a toplevel module encapsulating the module  <i>Con-</i><br>
<i>troller_BEH_1_Hot</i>  and  <i>Datapath_BEH</i> . Write a test plan and a test bench, and verify <br>the description. Produce annotated simulation results relating the test plan to the <br>waveforms produced in a simulation. <br>
 <br><b> 8.35 </b><br>
 <br>The HDL description and test bench for a circuit that counts the number of ones in a <br>register are given in HDL Example 8.8. Modify the test bench and simulate the circuit to <br>verify that the system operates correctly for the following patterns of data:   8 hff, 8 h0f, <br>8 hf0, 8 h00, 8 haa, 8 h0a, 8 ha0, 8 h55, 8 h05, 8 h50, 8 ha5,     and     8 h5a . <br>
 <br><b> 8.36 </b><br>
 <br>The design of a circuit that counts the number of ones in a register is carried out in Section <br>8.10. The block diagram for the circuit is shown in  Fig.   8.22  (a), a complete ASMD chart <br>for this circuit appears in  Fig.   8.22  (c), and structural HDL models of the datapath and <br>controller are given in HDL Example 8.8. Using the operations and signal names indi-<br>cated on the ASMD chart, <br>
 <br>
(a)   Design the control logic, employing one flipflop per state (a onehot assignment). List <br>
the input equations for the four flipflops. <br>
   <br>
(b)    Write   <i>Controller_Gates_1_Hot</i>,  a gatelevel HDL structural description of the circuit, <br>
using the control designed in part (a) and the signals shown in the block diagram of <br> Fig.    8.22   (a).  <br>
 <br>
(c)   Write a test plan and a test bench, and then verify the controller. <br>
   <br>
(d)    Write   <i>Count_Ones_Gates_1_Hot_STR</i>,  a toplevel module encapsulating and integrating <br>
instantiations of  <i>Controller_Gates_1_Hot</i>  and  <i>Datapath_STR</i> . Write a test plan and a <br>test bench to verify the description. Produce annotated simulation results relating the <br>test plan to the waveforms produced in a simulation. <br>
 <br><b> 8.37 </b><br>
 <br>Compared with the circuit presented in HDL Example 8.8, a more efficient circuit that <br>counts the number of ones in a data word is described by the block diagram and the par-<br>tially completed ASMD chart in Fig. P8.37. This circuit accomplishes addition and shifting <br>in the same clock cycle and adds the LSB of the data register to the counter register at <br>every clock cycle. <br>
    <br>
(a)    Complete  the  ASMD  chart.  <br>
 <br>
(b)   Using the ASMD chart, write an RTL description of the circuit. A toplevel Verilog <br>
module,  <i>Count_of_ones_2_Beh</i>  is to instantiate separate modules for the datapath and <br>control units. <br>
 <br>
(c)   Design the control logic, using one flipflop per state (a onehot assignment). List the <br>
input equations for the flipflops. <br>
 <br>
(d)   Write the HDL structural description of the circuit, using the controller designed in <br>
part (c) and the block diagram of  Fig.   P8.37  (a). <br>
 <br>
(e)   Write a test bench to test the circuit. Simulate the circuit to verify the operation described <br>
in both the RTL and the structural programs. <br>
 <br><b> 8.38 </b><br>
 <br>The addition of two signed binary numbers in the signedmagnitude representation follows <br>the rules of ordinary arithmetic: If the two numbers have the same sign (both positive or <br>both negative), the two magnitudes are added and the sum has the common sign; if the <br>two numbers have opposite signs, the smaller magnitude is subtracted from the larger and <br>
<hr>
<A name=452></a><b>434    Chapter 8  Design at the Register Transfer Level</b><br>
<i>Status<br>signals</i><br>
<i>data</i><br>
<i>reset_b</i><br>
<i>R1</i>[0]<br>
<i>Zero</i><br>
<i>S_idle</i><br>
<i>Datapath</i><br>
<i>Ready</i><br>
<i>R1</i><br>
<i>...</i><br>
<i>R1</i><br>
<i> data</i><br>
<i>Start</i><br>
<i>R</i>2<br>
<i> 0</i><br>
<i>Controller</i><br>
<i>Add_shift</i><br>
<i>Start</i><br>
<i>R2</i><br>
<i>...</i><br>
1<br>
<i>S_running</i><br>
<i>Ready</i><br>
<i>R2</i><br>
<i> R2   R1[0]</i><br>
<i>R1</i><br>
<i> R1 </i><br>
 1<br>
1<br>
<i>reset_b</i><br>
<i>Zero</i><br>
<i>Clock</i><br>
<i>count</i><br>
(a)<br>
(b)<br>
 <br><b>FIGURE P8.37   <br> <br>(a) Alternative circuit for a ones counter <br> <br>(b) ASMD Chart for Problem 8.37  </b><br>
the result has the sign of the larger magnitude. Write an HDL behavioral description for <br>adding two 8bit signed numbers in signedmagnitude representation and verify. The left-<br>most bit of the number holds the sign and the other seven bits hold the magnitude. <br>
 <br><b> 8.39* </b> For the circuit designed in Problem 8.16, <br> <br>
(a)   Write and verify a structural HDL description of the circuit. The datapath and control-<br>
ler are to be described in separate units. <br>
 <br>
(b)   Write and verify an RTL description of the circuit. The datapath and controller are to <br>
be described in separate units. <br>
 <br><b> 8.40 </b><br>
 <br>Modify the block diagram of the sequential multiplier given in  Fig.   8.14  (a) and the ASMD <br>chart in  Fig.   8.15  (b) to describe a system that multiplies 32bit words, but with 8bit (byte-<br>wide) external datapaths. The machine is to assert  <i>Ready</i>  in the (initial) reset state. When <br> <br><i>Start</i>  is asserted, the machine is to fetch the data bytes from a single 8bit data bus in <br>consecutive clock cycles (multiplicand bytes first, followed by multiplier bytes, least sig-<br>nificant byte first) and store the data in datapath registers.  <i>Got_Data</i>  is to be asserted for <br>one cycle of the clock when the transfer is complete. When  <i>Run</i>  is asserted, the product is <br>to be formed sequentially.  <i>Done_Product</i>  is to be asserted for one clock cycle when the <br>multiplication is complete. When a signal  <i>Send_Data</i>  is asserted, each byte of the product <br>is to be placed on an 8bit output bus for one clock cycle, in sequence, beginning with the <br>least significant byte. The machine is to return to the initial state after the product has <br>been transmitted. Consider safeguards, such as not attempting to send or receive data <br>while the product is being formed. Consider also other features that might eliminate need-<br>less multiplication by 0. For example, do not continue to multiply if the shifted multiplier <br>is empty of 1's. <br>
<hr>
<A name=453></a><b>Problems    435</b><br>
{<i>P1, P0</i>}<br>
{0, 0}<br>
<i>S_idle</i><br>
1<br>
<i>rst</i><br>
<i>P1</i><br>
<i> Data</i><br>
<i>En</i><br>
<i>P0</i><br>
<i> P1</i><br>
<i>Data</i><br>
<i>P1[7: 0]</i><br>
<i>P0[7: 0]</i><br>
1<br>
8<br>
8<br>
8<br>
<i>P1</i><br>
<i> Data</i><br>
<i>S_1</i><br>
<i>P0</i><br>
<i> P1</i><br>
{<i>P1, P0</i>}<br>
{0, 0}<br>
<i>P1[7: 0]</i><br>
<i>P0[7: 0]</i><br>
<i>R</i>0[15: 0]<br>
<i>S_ full</i><br>
<i>P1</i><br>
<i> Data</i><br>
(a)<br>
<i>P0</i><br>
<i> P1</i><br>
<i>S_wait</i><br>
<i>Ld</i><br>
1<br>
1<br>
1<br>
<i>Ld</i><br>
<i>En</i><br>
<i>R0</i><br>
{<i>P1, P0</i>}<br>
(b)<br>
 <br><b>FIGURE P8.41   <br> <br>Twostage pipeline register: Datapath unit and ASMD chart  </b><br>
 <br><b> 8.41 </b><br>
 <br>The block diagram and partially completed ASMD chart in  Fig.   P8.41   describe the be-<br>havior of a twostage pipeline that acts as a 2:1 decimator with a parallel input and output. <br>Decimators are used in digital signal processors to move data from a datapath with a high <br>clock rate to a datapath with a lower clock rate, converting data from a parallel format <br>to a serial format in the process. In the datapath shown, entire words of data can be trans-<br>ferred into the pipeline at twice the rate at which the contents of the pipeline must be <br>dumped into a holding register or consumed by some processor. The contents of the <br>holding register  <i>R0</i>  can be shifted out serially, to accomplish an overall paralleltoserial <br>conversion of the data stream. The ASMD chart indicates that the machine has synchro-<br>nous reset to  <i>S_idle</i>,  where it waits until  <i>rst</i>  is deasserted and En is asserted. Note that <br>synchronous transitions which would occur from the other states to  <i>S_idle</i>  under the <br>action of  <i>rst</i>  are not shown. With  <i>En</i>  asserted, the machine transitions from  <i>S_idle</i>  to  <i>S_1</i>,  <br>accompanied by concurrent register operations that load the MSByte of the pipe with <br> <br><i>Data</i>  and move the content of  <i>P1</i>  to the LSByte ( <i>P0</i> ). At the next clock, the state goes to <br> <br><i>S_full</i>,  and now the pipe is full. If  <i>Ld</i>  is asserted at the next clock, the machine moves to <br> <br><i>S_1</i>  while dumping the pipe into a holding register  <i>R0</i> . If  <i>Ld</i>  is not asserted, the machine <br>
<hr>
<A name=454></a><b>436    Chapter 8  Design at the Register Transfer Level</b><br>
enters  <i>S_wait</i>  and remains there until  <i>Ld</i>  is asserted, at which time it dumps the pipe and <br>returns to  <i>S_1</i>  or to  <i>S_idle</i>,  depending on whether  <i>En</i>  is asserted, too. The data rate at   <i>R</i>0 <br>is onehalf the rate at which data are supplied to the unit from an external datapath. <br>
    <br>
(a)    Develop  the  complete  ASMD  chart.  <br>
   <br>
(b)    Using the ASMD chart developed in (a), write and verify an HDL model of the <br>
datapath.  <br>
 <br>
(c)   Write and verify a Verilog behavioral model of the control unit. <br>
 <br>
(d)   Encapsulate the datapath and controller in a toplevel module, and verify the integrated <br>
system. <br>
 <br><b> 8.42 </b><br>
 <br>The countofones circuit described in  Fig.   8.22   has a latency that is to be eliminated. It <br>arises because the status signal  <i>E</i>  is formed as the output of a flipflop into which the MSB <br>of  <i>R</i> 1 is shifted. Develop a design that eliminates the latency. <br>
<b> <br>R E F E R E N C E S </b><br>
 <br><b>  </b><br>
<b>1. </b><br>
 <br>A rnold,  M. G. 1999.  <i>Verilog Digital Computer Design</i> . Upper Saddle River, NJ: Prentice <br>Hall. <br>
 <br><b>  </b><br>
<b>2. </b><br>
 B hasker,   J.  1997.   <i>A Verilog HDL Primer</i> . Allentown, PA: Star Galaxy Press. <br>
 <br><b>  </b><br>
<b>3. </b><br>
 B hasker,   J.  1998.   <i>Verilog HDL Synthesis</i> . Allentown, PA: Star Galaxy Press. <br>
 <br><b>  </b><br>
<b>4. </b><br>
 <br>C iletti,  M. D. 2003.  <i>Modeling, Synthesis, and Rapid Prototyping with Verilog HDL</i> .  Upper <br>Saddle River, NJ: Prentice Hall. <br>
 <br><b>  </b><br>
<b>5. </b><br>
 <br>C iletti,  M. D. 2010.  <i>Advanced Digital Design with the Verilog HDL</i>.  Upper Saddle River, <br>NJ: Prentice Hall. <br>
 <br><b>  </b><br>
<b>6. </b><br>
 <br>C lare,  C. R. 1971.  <i>Designing Logic Systems Using State Machines</i> . New York: McGraw<br>Hill. <br>
 <br><b>  </b><br>
<b>7. </b><br>
 <br>H ayes,  J. P. 1993.  <i>Introduction to Digital Logic Design</i> . Reading, MA: AddisonWesley. <br>
 <br><b>  </b><br>
<b>8. </b><br>
 <br><i>IEEE Standard Hardware Description Language Based on the Verilog Hardware Description <br>Language</i>  (IEEE Std 13642005). 2005. New York: Institute of Electrical and Electronics <br>Engineers. <br>
 <br><b>  </b><br>
<b>9. </b><br>
 <br>M ano,  M. M. 1993.  <i>Computer System Architecture,</i>  3rd ed. Upper Saddle River, NJ: Prentice <br>Hall. <br>
 <br><b> 10. </b><br>
 <br>M ano,  M. M., and C. R. K ime . 2005.  <i>Logic and Computer Design Fundamentals,</i>  3rd ed. <br>Upper Saddle River, NJ: Prentice Hall. <br>
 <br><b> 11. </b><br>
 P alnitkar,   S.  2003.   <i>Verilog HDL: A Guide to Digital Design and Synthesis</i> .  Mountain  View, <br>CA: SunSoft Press (a Prentice Hall Title). <br>
 <br><b> 12. </b><br>
 <br>S mith,  D. J. 1996.  <i>HDL Chip Design. </i>Madison, AL: Doone Publications. <br>
 <br><b> 13. </b><br>
 <br>T homas,  D. E., and P. R. M oorby . 2002.  <i>The Verilog Hardware Description Language,</i> <br>5th ed. Boston: Kluwer Academic Publishers. <br>
 <br><b> 14. </b><br>
 <br>W inkler,  D., and F. P rosser . 1987.  <i>The Art of Digital Design,</i>  2nd ed. Englewood Cliffs, NJ: <br>PrenticeHall.  <br>
<hr>
<A name=455></a><b>Web Search Topics    437</b><br>
<b> <br>W E B   S E A R C H   T O P I C S </b><br>
   Algorithmic  state  machine  <br> <br>Algorithmic state machine chart  <br>  Asynchronous  circuit  <br>  Decimator  <br>  Digital  control  unit  <br>  Digital  datapath  unit  <br>  Mealy  machine  <br>  Moore  machine      <br>Race condition<br>
<hr>
<A name=456></a> <br>Chapter 9 <br>
<b> <br>Laboratory Experiments with <br>Standard ICs and FPGAs  </b><br>
<b> <br>9 . 1       IN T R O D U C T I O N   T O   E X P E R I M E N T S </b><br>
 <br>This chapter presents 17 laboratory experiments in digital circuits and logic design. The <br>experiments give the student using this book handson experience. The digital circuits <br>can be constructed by using standard integrated circuits (ICs) mounted on breadboards <br>that are easily assembled in the laboratory. The experiments are ordered according to <br>the material presented in the book. The last section consists of a number of supplements <br>with suggestions for using the Verilog HDL to simulate and verify the functionality of <br>the digital circuits  presented in the experiments. If an FPGA prototyping board is avail-<br>able, the experiments can be implemented in an FPGA as an alternative to standard ICs. <br>
 <br>A logic breadboard suitable for performing the experiments must have the following <br>
equipment: <br>
 <br><b> 1. </b><br>
 <br>Lightemitting diode (LED) indicator lamps. <br>
 <br><b> 2. </b><br>
 <br>Toggle switches to provide logic1 and logic0 signals. <br>
 <br><b> 3. </b><br>
 <br>Pulsers with push buttons and debounce circuits to generate single pulses. <br>
 <br><b> 4. </b><br>
 <br>A clockpulse generator with at least two frequencies: a low frequency of about <br>1 pulse per second to observe slow changes in digital signals and a higher frequency <br>for observing waveforms in an oscilloscope. <br>
 <br><b> 5. </b><br>
 <br>A power supply of 5 V. <br>
 <br><b> 6. </b><br>
 <br>Socket strips for mounting the ICs. <br>
 <br><b> 7. </b><br>
 <br>Solid hookup wires and a pair of wire strippers for cutting the wires. <br>
 <br>Digital logic trainers that include the required equipment are available from several <br>
manufacturers. A digital logic trainer contains LED lamps, toggle switches, pulsers, <br>
<b>438</b><br>
<hr>
<A name=457></a><b>Section 9.1  Introduction to Experiments    439</b><br>
a variable clock, a power supply, and IC socket strips. Some experiments may require <br>additional switches, lamps, or IC socket strips. Extended breadboards with more solder-<br>less sockets and plugin switches and lamps may be needed. <br>
 <br>Additional equipment required is a dualtrace oscilloscope (for Experiments 1, 2, 8, <br>
and 15), a logic probe to be used for debugging, and a number of ICs. The ICs required <br>for the experiments are of the TTL or CMOS series 7400. <br>
 <br>The integrated circuits to be used in the experiments can be classified as smallscale <br>
integration (SSI) or mediumscale integration (MSI) circuits. SSI circuits contain indi-<br>vidual gates or flipflops, and MSI circuits perform specific digital functions. The eight <br>SSI gate ICs  needed for the experiments--twoinput NAND, NOR, AND, OR, and <br>XOR gates, inverters, and threeinput and fourinput NAND gates--are shown in <br> <br>Fig.  9.1  . The pin assignments for the gates are indicated in the diagram. The pins are <br>numbered from 1 to 14. Pin number 14 is marked   <i>VCC</i>,  and pin number 7 is marked <i>GND</i> <br>(ground). These are the supply terminals, which must be connected to a power supply <br>of 5 V for proper operation of the circuit. Each IC is recognized by its identification <br>number; for example, the twoinput NAND gates are found inside the IC whose number <br>is 7400. <br>
 <br>Detailed descriptions of the MSI circuits can be found in data books published by <br>
the manufacturers. The best way to acquire experience with a commercial MSI circuit <br>is to study its description in a data book that provides complete information on the <br>internal, external, and electrical characteristics of integrated circuits. Various semicon-<br>ductor companies publish data books for the 7400 series. The MSI circuits that are <br>needed for the experiments are introduced and explained when they are used for the <br>first time. The operation of the circuit is explained by referring to similar circuits in <br>previous chapters. The information given in this chapter about the MSI circuits should <br>be sufficient for performing the experiments adequately. Nevertheless, reference to a <br>data book will always be preferable, as it gives more detailed description of the circuits. <br>
 <br>We will now demonstrate the method of presentation of MSI circuits adopted here. To <br>
illustrate, we introduce the ripple counter IC, type 7493. This IC is used in Experiment 1 <br>and in subsequent experiments to generate a sequence of binary numbers for verifying <br>the operation of combinational circuits. <br>
 <br>The information about the 7493 IC that is found in a data book is shown in Figs. 9.2(a) <br>
and (b). Part (a) shows a diagram of the internal logic circuit and its connection to <br>external pins. All inputs and outputs are given symbolic letters and assigned to pin <br>numbers. Part (b) shows the physical layout of the IC, together with its 14pin assign-<br>ment to signal names. Some of the pins are not used by the circuit and are marked as <br> <br><i>NC</i>  (no connection). The IC is inserted into a socket, and wires are connected to the <br>various pins through the socket terminals. When drawing schematic diagrams in this <br>chapter, we will show the IC in block diagram form, as in  Fig.   9.2  (c). The IC number <br>(here, 7493) is written inside the block. All input terminals are placed on the left of the <br>block and all output terminals on the right. The letter symbols of the signals, such as  <i>A,</i> <br> <br><i>R1</i>,  and  <i>QA</i>,  are written inside the block, and the corresponding pin numbers, such as <br>14, 2, and 12, are written along the external lines.   <i>VCC</i>,     and   <i>GND</i>  are the power terminals <br>connected to pins 5 and 10. The size of the block may vary to accommodate all input <br>
<hr>
<A name=458></a><i>VCC</i><br>
<i>VCC</i><br>
14<br>
13<br>
12<br>
11<br>
10<br>
9<br>
8<br>
14<br>
13<br>
12<br>
11<br>
10<br>
9<br>
8<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
<i>GND</i><br>
2-input NAND<br>
<i>GND</i><br>
2-input NOR<br>
7400<br>
7402<br>
<i>VCC</i><br>
<i>VCC</i><br>
14<br>
13<br>
12<br>
11<br>
10<br>
9<br>
8<br>
14<br>
13<br>
12<br>
11<br>
10<br>
9<br>
8<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
<i>GND</i><br>
Inverters<br>
<i>GND</i><br>
2-input AND<br>
7404<br>
7408<br>
<i>VCC</i><br>
<i>VCC</i><br>
14<br>
13<br>
12<br>
11<br>
10<br>
9<br>
8<br>
14<br>
13<br>
12<br>
11<br>
10<br>
9<br>
8<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
<i>GND</i><br>
3-input NAND<br>
<i>GND</i><br>
4-input NAND<br>
7410<br>
7420<br>
<i>VCC</i><br>
<i>VCC</i><br>
14<br>
13<br>
12<br>
11<br>
10<br>
9<br>
8<br>
14<br>
13<br>
12<br>
11<br>
10<br>
9<br>
8<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
<i>GND</i><br>
2-input OR<br>
<i>GND</i><br>
2-input XOR<br>
7432<br>
7486<br>
<b> <br>FIGURE 9.1   <br> <br>Digital gates in IC packages with identification numbers and pin assignments  </b><br>
<b>440    </b><br>
<hr>
<A name=459></a><b>Section 9.1  Introduction to Experiments    441</b><br>
12<br>
<i>J</i><br>
<i>Q</i><br>
<i>QA</i><br>
Input<i> A</i><br>
14<br>
<i>A</i><br>
<i>NC</i><br>
<i>QA</i><br>
<i>QD</i><br>
<i>GND</i><br>
<i>QB</i><br>
<i>QC</i><br>
<i>C</i><br>
14<br>
13<br>
12<br>
11<br>
10<br>
9<br>
8<br>
<i>K CLR</i><br>
7493<br>
9<br>
<i>J</i><br>
<i>Q</i><br>
<i>QB</i><br>
Input<i> B</i><br>
1<br>
<i>C</i><br>
<i>K CLR</i><br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
<i>B</i><br>
<i>R1</i><br>
<i>R2</i><br>
<i>NC</i><br>
<i>V</i>CC<br>
<i>NC</i><br>
<i>NC</i><br>
(b) Physical layout (<i>NC</i>: no connection)<br>
8<br>
<i>J</i><br>
<i>Q</i><br>
<i>QC</i><br>
<i>C</i><br>
5<br>
<i>K CLR</i><br>
14<br>
<i>VCC</i><br>
12<br>
<i>A</i><br>
<i>QA</i><br>
1<br>
9<br>
<i>B</i><br>
<i>QB</i><br>
11<br>
7493<br>
<i>J</i><br>
<i>Q</i><br>
2<br>
8<br>
<i>QD</i><br>
<i>R1</i><br>
<i>QC</i><br>
<i>C</i><br>
3<br>
11<br>
<i>R2</i><br>
<i>QD</i><br>
<i>K</i><br>
<i>GND</i><br>
<i>CLR</i><br>
2<br>
<i>R1</i><br>
10<br>
3<br>
<i>R2</i><br>
(a) Internal circuit diagram<br>
(c) Schematic diagram<br>
 <br><b> <br>FIGURE 9.2   <br> <br>IC type 7493 ripple counter  </b><br>
and output terminals. Inputs or outputs may sometimes be placed on the top or the <br>bottom of the block for convenience. <br>
 <br>The operation of the circuit is similar to the ripple counter shown in Fig. 6.8(a) with <br>
an asynchronous clear to each flipflop. When input  <i>R1</i>  or  <i>R2</i>  or both are equal to logic 0 <br>
<hr>
<A name=460></a><b>442    Chapter 9  Laboratory Experiments</b><br>
(ground), all asynchronous clears are equal to 1 and are disabled. To clear all four flip<br>flops to 0, the output of the NAND gate must be equal to 0. This is accomplished by <br>having both inputs  <i>R1</i>  and  <i>R2</i>  at logic 1 (about 5 V). Note that the  <i>J</i>  and  <i>K</i>  inputs show <br>no connections. It is characteristic of TTL circuits that an input terminal with no exter-<br>nal connections has the effect of producing a signal equivalent to logic 1. Note also that <br>output  <i>QA</i>  is not connected to input  <i>B</i>   internally.   <br>
 <br>The 7493 IC can operate as a threebit counter using input <i>B</i> and flipflops  <i>QB,</i>  <i>QC</i>,  <br>
and  <i>QD</i> . It can operate as a fourbit counter using input  <i>A</i>  if output  <i>QA</i>  is connected <br>to input  <i>B</i> . Therefore, to operate the circuit as a fourbit counter, it is necessary to have <br>an external connection between pin 12 and pin 1. The reset inputs,  <i>R1</i>  and  <i>R2</i>,  at pins 2 <br>and 3, respectively, must be grounded. Pins 5 and 10 must be connected to a 5V power <br>supply. The input pulses must be applied to input  <i>A</i>  at pin 14, and the four flipflop <br>outputs of the counter are taken from  <i>QA,</i>  <i>QB,</i>  <i>QC</i>,  and  <i>QD</i>  at pins 12, 9, 8, and 11, <br>respectively, with  <i>QA</i>  being the least significant bit. <br>
 <br>Figure   9.2  (c) demonstrates the way that all MSI circuits will be symbolized graph-<br>
ically in this chapter. Only a block diagram similar to the one shown in this figure <br>will be given for each IC. The letter symbols for the inputs and outputs in the IC block <br>diagram will be according to the symbols used in the data book. The operation of the <br>
<b> <br>Table 9.1 <br><i> <br>Integrated Circuits Required for the Experiments </b></i><br>
<b> <br>Graphic Symbol  </b><br>
<b> <br>IC Number  </b><br>
<b> <br>Description  </b><br>
<b> <br>In  Chapter   9  </b><br>
<b> <br>In  Chapter   10  </b><br>
  <br>
 Various  gates <br>
  Fig.    9.1    <br>
 Fig.  10.1 <br>
 7447 <br>
 BCDtosevensegment  decoder <br>
  Fig.    9.8    <br>
 -- <br>
 7474 <br>
 Dual   <i>D</i> type  flipflops <br>
  Fig.    9.13    <br>
 Fig.  10.9(b) <br>
 7476 <br>
 Dual   <i>JK</i> type  flipflops <br>
  Fig.    9.12    <br>
 Fig.  10.9(a) <br>
 7483 <br>
 Fourbit  binary  adder <br>
  Fig.    9.10    <br>
 Fig.  10.2 <br>
 7493 <br>
 Fourbit  ripple  counter <br>
  Fig.    9.2    <br>
 Fig.  10.13 <br>
 74151 <br>
 <br>8 * 1     multiplexer <br>
  Fig.    9.9    <br>
 Fig.  10.7(a) <br>
 74155 <br>
 <br>3 * 8     decoder <br>
  Fig.    9.7    <br>
 Fig.  10.6 <br>
 74157 <br>
 Quadruple     2 * 1     multiplexers <br>
  Fig.    9.17    <br>
 Fig.  10.7(b) <br>
 74161 <br>
 Fourbit  synchronous  counter <br>
  Fig.    9.15    <br>
 Fig.  10.14 <br>
 74189 <br>
 <br>16 * 4     randomaccess  memory <br>
  Fig.    9.18    <br>
 Fig.  10.15 <br>
 74194 <br>
 Bidirectional  shift  register <br>
  Fig.    9.19    <br>
 Fig.  10.12 <br>
 74195 <br>
 Fourbit  shift  register <br>
  Fig.    9.16    <br>
 Fig.  10.11 <br>
 7730 <br>
 Sevensegment  LED  display <br>
  Fig.    9.8    <br>
 -- <br>
 72555 <br>
 <br>Timer (same as 555) <br>
  Fig.    9.21    <br>
 -- <br>
<hr>
<A name=461></a><b>Section 9.2    Experiment 1: Binary and Decimal Numbers        443</b><br>
circuit will be explained with reference to logic diagrams from previous chapters. The <br>operation of the circuit will be specified by means of a truth table or a function table. <br>
 <br>Other possible graphic symbols for the ICs are presented in  Chapter   10  . These are <br>
standard graphic symbols approved by the Institute of Electrical and Electronics <br>Engineers and are given in IEEE Standard 911984. The standard graphic symbols for <br>SSI gates have rectangular shapes, as shown in Fig. 10.1. The standard graphic symbol <br>for the 7493 IC is shown in Fig. 10.13. This symbol can be substituted in place of the one <br>shown in  Fig.   9.2  (c). The standard graphic symbols of the other ICs that are needed to <br>run the experiments are presented in  Chapter   10  . They can be used to draw schematic <br>diagrams of the logic circuits if the standard symbols are preferred. <br>
 <br>Table   9.1   lists the ICs that are needed for the experiments, together with the numbers of <br>
the figures in which they are presented in this chapter. In addition, the table lists the numbers <br>of the figures in  Chapter   10   in which the equivalent standard graphic symbols are drawn. <br>
 <br>The next 18 sections present 18 hardware experiments requiring the use of digital <br>
inte grated circuits. Section 9.20 outlines HDL simulation experiments requiring a Verilog <br>HDL compiler and simulator. <br>
<b> <br>9 . 2       E X P E R I M E N T   1 :   B I N A R Y   A N D   D E C I M A L </b><br>
<b>N U M B E R S </b><br>
 <br>This experiment demonstrates the count sequence of binary numbers and the binary<br>coded decimal (BCD) representation. It serves as an introduction to the breadboard used <br>in the laboratory and acquaints the student with the cathoderay oscilloscope. Reference <br>material from the text that may be useful to know while performing the experiment can <br>be found in Section 1.2, on binary numbers, and Section 1.7, on BCD numbers. <br>
<b> <br>Binary Count </b><br>
 <br>IC type 7493 consists of four flipflops, as shown in  Fig.   9.2  . They can be connected to <br>count in binary or in BCD. Connect the IC to operate as a fourbit binary counter by <br>wiring the external terminals, as shown in  Fig.   9.3  .This is done by connecting a wire from <br>pin 12 (output  <i>QA</i> ) to pin 1 (input  <i>B</i> ). Input  <i>A</i>  at pin 14 is connected to a pulser that <br>provides single pulses. The two reset inputs,  <i>R1</i>  and  <i>R2</i>,  are connected to ground. The <br>four outputs go to four indicator lamps, with the loworder bit of the counter from  <i>QA</i> <br>connected to the rightmost indicator lamp. Do not forget to supply 5 V and ground to <br>the IC. All connections should be made with the power supply in the off position. <br>
 <br>Turn the power on and observe the four indicator lamps. The fourbit number in the <br>
output is incremented by 1 for every pulse generated in the pushbutton pulser. The <br>count goes to  binary 15 and then back to 0. Disconnect the input of the counter at pin <br>14 from the pulser, and connect it to a clock generator that produces a train of pulses at <br>a low frequency of about 1 pulse per second. This will provide an automatic binary count. <br>Note that the binary counter will be used in subsequent experiments to provide the <br>input binary signals for testing combinational circuits.  <b> </b><br>
<hr>
<A name=462></a><b>444    Chapter 9  Laboratory Experiments</b><br>
5<br>
14<br>
<i>VCC</i><br>
12<br>
<i>A</i><br>
<i>QA</i><br>
Push-button<br>
pulser or<br>
1<br>
9<br>
clock<br>
<i>B</i><br>
<i>QB</i><br>
7493<br>
8<br>
<i>QC</i><br>
2<br>
<i>R1</i><br>
11<br>
<i>QD</i><br>
3<br>
<i>R2</i><br>
Indicator<br>
<i>GND</i><br>
lamps<br>
10<br>
<b> <br>FIGURE 9.3   <br> <br>Binary counter  </b><br>
<b> <br>Oscilloscope Display </b><br>
 <br>Increase the frequency of the clock to 10 kHz or higher and connect its output to an oscil-<br>loscope. Observe the clock output on the oscilloscope and sketch its waveform. Using a <br>dualtrace oscilloscope, connect the output of  <i>QA</i>  to one channel and the output of the <br>clock to the second channel. Note that the output of  <i>QA</i>  is complemented every time the <br>clock pulse goes through a negative transition from 1 to 0. Note also that the clock fre-<br>quency at the output of the first flipflop is onehalf that of the input clock frequency. Each <br>flipflop in turn divides its incoming frequency by 2. The fourbit counter divides the <br>incoming frequency by 16 at output  <i>QD</i> . Obtain a timing diagram showing the relationship <br>of the clock to the four outputs of the counter. Make sure that you  include at least 16 clock <br>cycles. The way to proceed with a dualtrace oscilloscope is as follows: First,  observe the <br>clock pulses and  <i>QA</i>,  and record their timing waveforms. Then repeat by  observing and <br>recording the waveforms of  <i>QA</i>  together with  <i>QB</i>,  followed by the waveforms of  <i>QB</i>   with <br> <br><i>QC</i>  and then  <i>QC</i>  with  <i>QD</i> .Your final result should be a diagram showing the relationship <br>of the clock to the four outputs in one composite diagram having at least 16 clock cycles. <br>
<b> <br>BCD Count </b><br>
 <br>The BCD representation uses the binary numbers from 0000 to 1001 to represent the <br>coded decimal digits from 0 to 9. IC type 7493 can be operated as a BCD counter by <br>making the external connections shown in  Fig.   9.4  . Outputs  <i>QB</i>  and  <i>QD</i>  are connected <br>to the two reset inputs,  <i>R1</i>  and  <i>R2</i> . When both  <i>R1</i>  and  <i>R2</i>  are equal to 1, all four cells in <br>the counter clear to 0 irrespective of the input pulse. The counter starts from 0, and every <br>input pulse increments it by 1 until it reaches the count of 1001. The next pulse changes <br>the ouput to 1010, making  <i>QB</i>  and  <i>QD</i>  equal to 1. This momentary output cannot be <br>
<hr>
<A name=463></a><b>Section 9.2    Experiment 1: Binary and Decimal Numbers        445</b><br>
5<br>
14<br>
<i>VCC</i><br>
12<br>
Input<br>
<i>A</i><br>
<i>QA</i><br>
pulses<br>
1<br>
9<br>
<i>B</i><br>
<i>QB</i><br>
7493<br>
8<br>
<i>QC</i><br>
2 <i>R1</i><br>
11<br>
<i>QD</i><br>
3<br>
<i>R2</i><br>
<i>GND</i><br>
10<br>
<b> <br>FIGURE 9.4   <br> <br>BCD counter  </b><br>
sustained, because the four cells immedi ately clear to 0, with the result that the output <br>goes to 0000. Thus, the pulse after the count of 1001 changes the output to 0000, produc-<br>ing a BCD count. <br>
 <br>Connect the IC to operate as a BCD counter. Connect the input to a pulser and the <br>
four outputs to indicator lamps. Verify that the count goes from 0000 to 1001. <br>
 <br>Disconnect the input from the pulser and connect it to a clock generator. Observe the <br>
clock waveform and the four outputs on the oscilloscope. Obtain an accurate timing dia-<br>gram showing the relationship between the clock and the four outputs. Make sure to include <br>at least 10 clock cycles in the oscilloscope display and in the composite timing diagram. <br>
<b> <br>Output Pattern </b><br>
 <br>When the count pulses into the BCD counter are continuous, the counter keeps repeat-<br>ing the sequence from 0000 to 1001 and back to 0000. This means that each bit in the <br>four outputs produces a fixed pattern of 1's and 0's that is repeated every 10 pulses. These <br>patterns can be predicted from a list of the binary numbers from 0000 to 1001. The list <br>will show that output  <i>QA</i>,  being the least significant bit, produces a pattern of alternate <br>1's and 0's. Output  <i>QD</i>,  being the most significant bit, produces a pattern of eight 0's <br>followed by two 1's. Obtain the pattern for the other two outputs and then check all four <br>patterns on the oscilloscope. This is done with a dualtrace oscilloscope by displaying the <br>clock pulses in one channel and one of the output waveforms in the other channel. The <br>pattern of 1's and 0's for the corresponding output is obtained by observing the output <br>levels at the vertical positions where the pulses change from 1 to 0. <br>
<hr>
<A name=464></a><b>446    Chapter 9  Laboratory Experiments</b><br>
<b> <br>Other Counts </b><br>
 <br>IC type 7493 can be connected to count from 0 to a variety of final counts. This is done <br>by connecting one or two outputs to the reset inputs,  <i>R1</i>  and  <i>R2</i> .  Thus,  if  <i>R1</i> is connected <br>to  <i>QA</i>  instead of to  <i>QB</i>  in  Fig.   9.4  , the resulting count will be from 0000 to 1000, which <br>is 1 less than 1001 (  <i>QD </i>= 1     and     <i>QA </i>= 1   ). <br>
 <br>Utilizing your knowledge of how  <i>R1</i>  and  <i>R2</i>  affect the final count, connect the 7493 <br>
IC to count from 0000 to the following final counts: <br>
 <br>
(a)<b>  </b>  0101  <br>
 <br>
(b)    0111  <br>
   <br>
(c)    1011   <br>
 <br>Connect each circuit and verify its count sequence by applying pulses from the pulser <br>
and observing the output count in the indicator lamps. If the initial count starts with a <br>value greater than the final count, keep applying input pulses until the output clears to 0. <br>
<b> <br>9 . 3       E X P E R I M E N T   2 :   D I G I TA L   L O G I C   G AT E S </b><br>
 <br>In this experiment, you will investigate the logic behavior of various IC gates: <br>
 <br>7400 quadruple twoinput NAND gates  <br>
 <br>7402 quadruple twoinput NOR gates  <br>
  7404  hex  inverters  <br>
 <br>7408 quadruple twoinput AND gates  <br>
 <br>7432 quadruple twoinput OR gates  <br>
 <br>7486 quadruple twoinput XOR gates  <br>
 <br>The pin assignments to the various gates are shown in  Fig.   9.1 . "Quadruple" means <br>
that there are four gates within the package. The digital logic gates and their character-<br>istics are discussed in Section 2.8. A NAND implementation is discussed in Section 3.7. <br>
<b> <br>Truth Tables </b><br>
 <br>Use one gate from each IC listed and obtain the truth table of the gate. The truth table <br>is obtained by connecting the inputs of the gate to switches and the output to an indica-<br>tor lamp. Compare your results with the truth tables listed in Fig. 2.5. <br>
<b> <br>Waveforms </b><br>
 <br>For each gate listed, obtain the input�output waveform of the gate. The waveforms are <br>to be observed in the oscilloscope. Use the two loworder outputs of a binary counter <br>( Fig.   9.3  ) to provide the inputs to the gate. As an example, the circuit and waveforms <br>for the NAND gate are illustrated in  Fig.   9.5  . The oscilloscope display will repeat this <br>waveform, but you should record only the nonrepetitive portion. <br>
<hr>
<A name=465></a><b>Section 9.3  Experiment 2: Digital Logic Gates    447</b><br>
Input<br>
<i>QA</i><br>
0<br>
1<br>
0<br>
1<br>
<i>A</i><br>
<i>QA</i><br>
pulses<br>
<i>F</i><br>
<i>QB</i><br>
Fig. 9.3<br>
(counter)<br>
<i>QB</i><br>
0<br>
0<br>
1<br>
1<br>
<i>F</i><br>
1<br>
1<br>
1<br>
0<br>
<b> <br>FIGURE 9.5   <br> <br>Waveforms for NAND gate  </b><br>
<b> <br>Propagation Delay </b><br>
 <br>Connect the six inverters inside the 7404 IC in cascade. The output will be the same as <br>the input, except that it will be delayed by the time it takes the signal to propagate <br>through all six inverters. Apply clock pulses to the input of the first inverter. Using the <br>oscilloscope, determine the delay from the input to the output of the sixth inverter dur-<br>ing the upswing of the pulse and again during the downswing. This is done with a dual<br>trace oscilloscope by applying the input clock pulses to one of the channels and the <br>output of the sixth inverter to the second channel. Set the timebase knob to the lowest <br>timeperdivision setting. The rise or fall time of the two pulses should appear on the <br>screen. Divide the total delay by 6 to obtain an average propagation delay per inverter. <br>
<b> <br>Universal NAND Gate </b><br>
 <br>Using a single 7400 IC, connect a circuit that produces <br>
 <br>
(a)    an  inverter,  <br>
   <br>
(b)    a  twoinput  AND,  <br>
   <br>
(c)    a  twoinput  OR,  <br>
   <br>
(d)    a  twoinput  NOR,  <br>
   <br>
(e)    a  twoinput  XOR.  (See  Fig.  3.32.)   <br>
 <br>In each case, verify your circuit by checking its truth table. <br>
<b> <br>NAND Circuit </b><br>
 <br>Using a single 7400 IC, construct a circuit with NAND gates that implements the Boolean <br>function <br>
 <br><i>F </i>= <i>AB </i>+ <i>CD</i> <br>
 <br><b> 1. </b><br>
 <br>Draw the circuit diagram. <br>
 <br><b> 2. </b><br>
 <br>Obtain the truth table for  <i>F</i>  as a function of the four inputs. <br>
 <br><b> 3. </b><br>
 <br>Connect the circuit and verify the truth table. <br>
<hr>
<A name=466></a><b>448    Chapter 9  Laboratory Experiments</b><br>
 <br><b> 4. </b><br>
 <br>Record the patterns of 1's and 0's for  <i>F</i>  as inputs  <i>A,</i>  <i>B,</i>  <i>C</i>,  and  <i>D</i>  go from binary 0 <br>to  binary 15. <br>
 <br><b> 5. </b><br>
 <br>Connect the four outputs of the binary counter shown in  Fig.   9.3   to the four inputs <br>of the NAND circuit. Connect the input clock pulses from the counter to one <br>channel of a dualtrace oscilloscope and output <i>F</i> to the other channel. Observe <br>and record the 1's and 0's pattern of <i>F</i> after each clock pulse, and compare it with <br>the pattern recorded in step 4. <br>
<b> <br>9 . 4       E X P E R I M E N T   3 :   S I M P L I F I C AT I O N </b><br>
<b>O F   B O O L E A N   F U N C T I O N S </b><br>
 <br>This experiment demonstrates the relationship between a Boolean function and the <br>corresponding logic diagram. The Boolean functions are simplified by using the map <br>method, as discussed in  Chapter   3  .The logic diagrams are to be drawn with NAND gates, <br>as explained in Section 3.7. <br>
 <br>The gate ICs to be used for the logic diagrams must be those from  Fig.   9.1   which <br>
contain the following NAND gates: <br>
   7400  twoinput  NAND  <br>
 <br>7404 inverter (oneinput NAND)  <br>
  7410  threeinput  NAND  <br>
  7420  fourinput  NAND   <br>
 <br>If an input to a NAND gate is not used, it should not be left open, but instead should be <br>connected to another input that is used. For example, if the circuit needs an inverter and <br>there is an extra twoinput gate available in a 7400 IC, then both inputs of the gate are <br>to be con nected together to form a single input for an inverter. <br>
<b> <br>Logic Diagram </b><br>
 <br>This part of the experiment starts with a given logic diagram from which we proceed to <br>apply simplification procedures to reduce the number of gates and, possibly, the number <br>of ICs. The logic diagram shown in  Fig.   9.6   requires two ICs--a 7400 and a 7410. Note <br>that the inverters for inputs  <i>x,</i>  <i>y</i>,  and  <i>z</i>  are obtained from the remaining three gates in <br>the 7400 IC. If the inverters were taken from a 7404 IC, the circuit would have required <br>three ICs. Note also that, in drawing SSI circuits, the gates are not enclosed in blocks as <br>is done with MSI circuits. <br>
 <br>Assign pin numbers to all inputs and outputs of the gates, and connect the circuit with <br>
the  <i>x,</i>  <i>y</i>,  and  <i>z</i>  inputs going to three switches and the output  <i>F</i>  to an indicator lamp. Test <br>the circuit by obtaining its truth table. <br>
 <br>Obtain the Boolean function of the circuit and simplify it, using the map method. Con-<br>
struct the simplified circuit without disconnecting the original circuit. Test both circuits by <br>applying identical inputs to each and observing the separate outputs. Show that, for each <br>of the eight  possible input combinations, the two circuits have identical outputs. This will <br>prove that the simplified circuit behaves exactly like the original circuit. <br>
<hr>
<A name=467></a><b>Section 9.4    Experiment 3: Simplification of Boolean Functions         449</b><br>
<i>x</i><br>
<i>y</i><br>
<i>F</i><br>
<i>z</i><br>
<b> <br>FIGURE 9.6   <br> <br>Logic diagram for Experiment 3  </b><br>
<b> <br>Boolean Functions </b><br>
 <br>Consider two Boolean functions in sumofminterms form: <br>
<i>F</i><br>
  1(<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>) = (0, 1, 4, 5, 8, 9, 10, 12, 13)  <br>
<i>F</i>2(<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>) = (3, 5, 7, 8, 10, 11, 13, 15)<br>
 <br>Simplify these functions by means of maps. Obtain a composite logic diagram with four <br>inputs,  <i>A,</i>   <i>B,</i>   <i>C</i>,  and  <i>D</i>,  and two outputs,   <i>F</i>1     and     <i>F</i>2.  Implement the two functions <br>together, using a minimum number of NAND ICs. Do not duplicate the same gate if <br>the corresponding term is  needed for both functions. Use any extra gates in existing <br>ICs for inverters when possible. Connect the circuit and check its operation. The truth <br>table for   <i>F</i>1     and     <i>F</i>2  obtained from the circuit should conform with the minterms listed. <br>
<b> <br>Complement </b><br>
 <br>Plot the following Boolean function in a map: <br>
 <br><i>F </i>= <i>A D </i>+ <i>BD </i>+ <i>B C </i>+ <i>AB D</i> <br>
 <br>Combine the 1's in the map to obtain the simplified function for  <i>F</i>  in sumofproducts <br>form. Then combine the 0's in the map to obtain the simplified function for   <i>F </i>,     also  in <br>sumofproducts form. Implement both  <i>F</i>   and     <i>F </i>  with NAND gates, and connect the two <br>circuits to the same input switches, but to separate output indicator lamps. Obtain the <br>truth table of each circuit in the laboratory and show that they are the complements of <br>each  other.   <br>
<hr>
<A name=468></a><b>450    Chapter 9  Laboratory Experiments</b><br>
<b> <br>9 . 5       E X P E R I M E N T   4 :   C O M B I N AT I O N A L   C I R C U I T S </b><br>
 <br>In this experiment, you will design, construct, and test four combinational logic circuits. <br>The first two circuits are to be constructed with NAND gates, the third with XOR gates, <br>and the fourth with a decoder and NAND gates. Reference to a parity generator can be <br>found in Section 3.9. Implementation with a decoder is discussed in Section 4.9. <br>
<b> <br>Design Example </b><br>
 <br>Design a combinational circuit with four inputs-- <i>A,</i>  <i>B,</i>  <i>C</i>,  and  <i>D</i> --and one output,  <i>F</i> .   <i>F</i> <br>is to be equal to 1 when   <i>A </i>= 1,     provided  that     <i>B </i>= 0,     or  when     <i>B </i>= 1,     provided  that <br>either  <i>C</i>  or  <i>D</i>  is also equal to 1. Otherwise, the output is to be equal to 0. <br>
 <br><b> 1. </b><br>
 <br>Obtain the truth table of the circuit. <br>
 <br><b> 2. </b><br>
 <br>Simplify the output function. <br>
 <br><b> 3. </b><br>
 <br>Draw the logic diagram of the circuit, using NAND gates with a minimum number <br>of ICs. <br>
 <br><b> 4. </b><br>
 <br>Construct the circuit and test it for proper operation by verifying the given <br>conditions.    <br>
<b> <br>Majority Logic </b><br>
 <br>A majority logic is a digital circuit whose output is equal to 1 if the majority of the inputs <br>are 1's. The output is 0 otherwise. Design and test a threeinput majority circuit using <br>NAND gates with a minimum number of ICs. <br>
<b> <br>Parity Generator </b><br>
 <br>Design, construct, and test a circuit that generates an even parity bit from four message <br>bits. Use XOR gates. Adding one more XOR gate, expand the circuit so that it generates <br>an odd parity bit also. <br>
<b> <br>Decoder Implementation </b><br>
 <br>A combinational circuit has three inputs-- <i>x,</i>  <i>y</i>,  and  <i>z</i> --and  three  outputs--   <i>F</i>1, <i>F</i>2,     and <br> <br><i>F</i>3. The simplified Boolean functions for the circuit are <br>
 <br><i>F</i>1 = <i>xz </i>+ <i>x y z<br>F</i>2 = <i>x y </i>+ <i>xy z<br>F</i>3 = <i>xy </i>+ <i>x y z </i> <br>
 <br>Implement and test the combinational circuit, using a 74155 decoder IC and external <br>NAND gates. <br>
<hr>
<A name=469></a><b>Section 9.5  Experiment 4: Combinational Circuits    451</b><br>
 <br>The block diagram of the decoder and its truth table are shown in  Fig.   9.7  . The <br>
74155 can be connected as a dual   2 * 4  decoder or as a single   3 * 8     decoder.  When <br>a     3 * 8  decoder is desired, inputs  <i>C1</i>  and  <i>C2</i>,  as well as inputs  <i>G1</i>  and  <i>G2</i>,  must be <br>connected together, as shown in the block diagram. The function of the circuit is <br>similar to that illustrated in Fig. 4.18.  <i>G</i>  is the enable input and must be equal to 0 for <br>proper operation. The eight outputs are labeled with symbols given in the data book. <br>The 74155 uses NAND gates, with the result that the selected output goes to 0 while <br>all other outputs remain at 1. The implementation with the decoder is as shown in <br>Fig. 4.21, except that the OR gates must be replaced with external NAND gates when <br>the 74155 is used. <br>
16<br>
<i>VCC</i><br>
9<br>
1<br>
2<i>Y</i>0<br>
<i>C</i>1<br>
10<br>
2<i>Y</i>1<br>
15<br>
<i>C</i><br>
<i>C</i>2<br>
11<br>
2<i>Y</i>2<br>
3<br>
12<br>
<i>B</i><br>
<i>B</i><br>
2<i>Y</i>3<br>
74155<br>
7<br>
13<br>
1<i>Y</i>0<br>
<i>A</i><br>
<i>A</i><br>
6<br>
2<br>
1<i>Y</i>1<br>
<i>G1</i><br>
5<br>
1<i>Y</i>2<br>
14<br>
<i>G</i><br>
<i>G2</i><br>
4<br>
1<i>Y</i>3<br>
<i>GND</i><br>
8<br>
Truth table<br>
Inputs<br>
Outputs<br>
<i>G</i><br>
<i>C</i><br>
<i>B</i><br>
<i>A</i><br>
2<i>Y</i>0<br>
2<i>Y</i>1<br>
2<i>Y</i>2<br>
2<i>Y</i>3<br>
1<i>Y</i>0<br>
1<i>Y</i>1<br>
1<i>Y</i>2<br>
1<i>Y</i>3<br>
1<br>
X<br>
X<br>
X<br>
1<br>
1<br>
1<br>
1<br>
1<br>
1<br>
1<br>
1<br>
0<br>
0<br>
0<br>
0<br>
0<br>
1<br>
1<br>
1<br>
1<br>
1<br>
1<br>
1<br>
0<br>
0<br>
0<br>
1<br>
1<br>
0<br>
1<br>
1<br>
1<br>
1<br>
1<br>
1<br>
0<br>
0<br>
1<br>
0<br>
1<br>
1<br>
0<br>
1<br>
1<br>
1<br>
1<br>
1<br>
0<br>
0<br>
1<br>
1<br>
1<br>
1<br>
1<br>
0<br>
1<br>
1<br>
1<br>
1<br>
0<br>
1<br>
0<br>
0<br>
1<br>
1<br>
1<br>
1<br>
0<br>
1<br>
1<br>
1<br>
0<br>
1<br>
0<br>
1<br>
1<br>
1<br>
1<br>
1<br>
1<br>
0<br>
1<br>
1<br>
0<br>
1<br>
1<br>
0<br>
1<br>
1<br>
1<br>
1<br>
1<br>
1<br>
0<br>
1<br>
0<br>
1<br>
1<br>
1<br>
1<br>
1<br>
1<br>
1<br>
1<br>
1<br>
1<br>
0<br>
<b> <br>FIGURE 9.7   <br> <br>IC type 74155 connected as a   3 </b>* <b>8   decoder  </b><br>
<hr>
<A name=470></a><b>452    Chapter 9  Laboratory Experiments</b><br>
<b> <br>9 . 6       E X P E R I M E N T   5 :   C O D E   C O N V E R T E R S </b><br>
 <br>The conversion from one binary code to another is common in digital systems. In this <br>experiment, you will design and construct three combinationalcircuit converters. Code <br>conversion is discussed in Section 4.4. <br>
<b> <br>Gray Code to Binary </b><br>
 <br>Design a combinational circuit with four inputs and four outputs that converts a four<br>bit Gray code number (Table 1.6) into the equivalent fourbit binary number. Imple-<br>ment the circuit with exclusiveOR gates. (This can be done with one 7486 IC.) <br>Connect the circuit to four switches and four indicator lamps, and check for proper <br>operation.  <br>
<b> <br>9's Complementer </b><br>
 <br>Design a combinational circuit with four input lines that represent a decimal digit in <br>BCD and four output lines that generate the 9's complement of the input digit. Pro-<br>vide a fifth output that detects an error in the input BCD number. This output should <br>be equal to logic 1 when the four inputs have one of the unused combinations of the <br>BCD code. Use any of the gates listed in  Fig.   9.1  , but minimize the total number of <br>ICs used. <br>
<b> <br>SevenSegment Display </b><br>
 <br>A sevensegment indicator is used to display any one of the decimal digits 0 through 9. <br>Usually, the decimal digit is available in BCD. A BCDtosevensegment decoder accepts <br>a decimal digit in BCD and generates the corresponding sevensegment code, as is <br>shown pictorially in Problem 4.9. <br>
 <br>Figure   9.8   shows the connections necessary between the decoder and the display. The <br>
7447 IC is a BCDtosevensegment decoder/driver that has four inputs for the BCD <br>digit. Input  <i>D</i>  is the most significant and input <i>A</i> the least significant. The fourbit BCD <br>digit is converted to a sevensegment code with outputs  <i>a</i>  through  <i>g</i> . The outputs of the <br>7447 are applied to the inputs of the 7730 (or equivalent) sevensegment display. This <br>IC contains the seven lightemitting diode (LED) segments on top of the package. The <br>input at pin 14 is the common anode ( <i>CA</i> ) for all the LEDs. A   47@      resistor  to     <i>VCC</i> is <br>needed in order to supply the proper current to the selected LED segments. Other <br>equivalent sevensegment display ICs may have additional anode terminals and may <br>require different resistor values. <br>
 <br>Construct the circuit shown in  Fig.   9.8  . Apply the fourbit BCD digits through four <br>
 <br>switches, and observe the decimal display from 0 to 9. Inputs 1010 through 1111 have <br>no meaning in BCD. Depending on the decoder, these values may cause either a blank <br>or a meaningless pattern to be displayed. Observe and record the output patterns of the <br>six   unused  input  combinations.    <br>
<hr>
<A name=471></a><b>Section 9.7  Experiment 6: Design With Multiplexers    453</b><br>
<i>V</i><br>
 <br>
<i>CC</i><br>
5 V<br>
16<br>
47<br>
<i>VCC</i><br>
13<br>
1<br>
14<br>
<i>a</i><br>
<i>a</i><br>
<i>a</i><br>
<i>CA</i><br>
12<br>
13<br>
7<br>
<i>b</i><br>
<i>b</i><br>
<i>f</i><br>
<i>b</i><br>
<i>A</i><br>
11<br>
10<br>
<i>g</i><br>
1<br>
<i>c</i><br>
<i>c</i><br>
<i>B</i><br>
10<br>
 8<br>
<i>e</i><br>
<i>c</i><br>
2<br>
7447<br>
<i>d</i><br>
<i>d</i><br>
<i>C</i><br>
9<br>
7<br>
6<br>
<i>e</i><br>
<i>e</i><br>
<i>d</i><br>
<i>D</i><br>
15<br>
2<br>
<i>f</i><br>
<i>f</i><br>
7730<br>
14<br>
11<br>
<i>g</i><br>
<i>g</i><br>
<i>GND</i><br>
8<br>
<b> <br>FIGURE 9.8   <br> <br>BCDtosevensegment decoder (7447) and sevensegment display (7730)  </b><br>
<b> <br>9 . 7       E X P E R I M E N T   6 :   D E S I G N   W I T H   M U L T I P L E X E R S </b><br>
 <br>In this experiment, you will design a combinational circuit and implement it with multi-<br>plexers, as explained in Section 4.11. The multiplexer to be used is IC type 74151, shown <br>in  Fig.  9.9  . The internal construction of the 74151 is similar to the diagram shown in <br>Fig. 4.25, except that there are eight inputs instead of four. The eight inputs are desig-<br>nated  <i>D0</i>  through  <i>D7</i> .The three selection lines-- <i>C,</i>  <i>B</i>,  and  <i>A</i> --select the particular input <br>to be multiplexed and applied to the output. A strobe control  <i>S</i>  acts as an enable signal. <br>The function table specifies the value of output  <i>Y</i>  as a function of the selection lines. <br>Output  <i>W</i>  is the complement of  <i>Y</i> . For proper operation, the strobe input  <i>S</i>  must be <br>connected to ground. <br>
<b> <br>Design Specifications </b><br>
 <br>A small corporation has 10 shares of stock, and each share entitles its owner to one vote <br>at a stockholder's meeting. The 10 shares of stock are owned by four people as follows: <br>
   Mr.  W:  1  share  <br>
 <br>Mr. X: 2 shares  <br>
  Mr.  Y:  3  shares  <br>
  Mrs.  Z:  4  shares   <br>
<hr>
<A name=472></a><b>454    Chapter 9  Laboratory Experiments</b><br>
16<br>
8<br>
<i>V</i><br>
<i>GND</i><br>
<i>CC</i><br>
7<br>
Strobe<br>
<i>S</i><br>
4<br>
<i>D0</i><br>
3<br>
<i>D1</i><br>
2<br>
<i>D2</i><br>
5<br>
<i>Y</i><br>
1<br>
Output<i> Y</i><br>
<i>D3</i><br>
74151<br>
Data<br>
6<br>
15<br>
Inputs<br>
<i>W</i><br>
<i>W</i><br>
 <i>Y</i><br>
<i>D4</i><br>
14<br>
<i>D5</i><br>
13<br>
<i>D6</i><br>
12<br>
<i>D7</i><br>
<i>C</i><br>
<i>B</i><br>
<i>A</i><br>
9<br>
10<br>
11<br>
Select inputs<br>
Function table<br>
Strobe<br>
Select<br>
Output<br>
<i>S</i><br>
<i>C</i><br>
<i>B</i><br>
<i>A</i><br>
<i>Y</i><br>
1<br>
X<br>
X<br>
X<br>
0<br>
0<br>
0<br>
0<br>
0<br>
<i>D0</i><br>
0<br>
0<br>
0<br>
1<br>
<i>D1</i><br>
0<br>
0<br>
1<br>
0<br>
<i>D2</i><br>
0<br>
0<br>
1<br>
1<br>
<i>D3</i><br>
0<br>
1<br>
0<br>
0<br>
<i>D4</i><br>
0<br>
1<br>
0<br>
1<br>
<i>D5</i><br>
0<br>
1<br>
1<br>
0<br>
<i>D6</i><br>
0<br>
1<br>
1<br>
1<br>
<i>D7</i><br>
<b> <br>FIGURE 9.9   <br> <br>IC type 74151   38 </b>* <b>1   multiplexer  </b><br>
 <br>Each of these persons has a switch to close when voting yes and to open when voting <br>no for his or her shares. <br>
 <br>It is necessary to design a circuit that displays the total number of shares that vote yes for <br>
each measure. Use a sevensegment display and a decoder, as shown in  Fig.   9.8  , to display <br>the required number. If all shares vote no for a measure, the display should be blank. (Note <br>that binary input 15 into the 7447 blanks out all seven segments.) If 10 shares vote yes for a <br>measure, the display should show 0. Otherwise, the display shows a decimal number equal <br>to the number of shares that vote yes. Use four 74151 multiplexers to design the combina-<br>tional circuit that converts the inputs from the stock owners' switches into the BCD digit for <br>the 7447. Do not use 5 V for logic 1. Use the output of an inverter whose input is grounded. <br>
<hr>
<A name=473></a><b>Section 9.8  Experiment 7: Adders and Subtractors    455</b><br>
<b> <br>9 . 8       E X P E R I M E N T   7 :   A D D E R S   A N D   S U B T R A C T O R S </b><br>
 <br>In this experiment, you will construct and test various adder and subtractor circuits. The <br>subtractor circuit is then used to compare the relative magnitudes of two numbers. <br>Adders are discussed in Section 4.3. Subtraction with 2's complement is explained in <br>Section 1.6. A fourbit parallel adder�subtractor is shown in Fig. 4.13, and the compari-<br>son of two numbers is explained in Section 4.8. <br>
<b> <br>Half Adder </b><br>
 <br>Design, construct, and test a halfadder circuit using one XOR gate and two NAND gates. <br>
<b> <br>Full Adder </b><br>
 <br>Design, construct, and test a fulladder circuit using two ICs, 7486 and 7400. <br>
<b> <br>Parallel Adder </b><br>
 <br>IC type 7483 is a fourbit binary parallel adder. The pin assignment is shown in  Fig.   9.10  . <br>The 2 fourbit input binary numbers are  <i>A1</i>  through  <i>A4</i>  and  <i>B1</i>  through  <i>B4</i> . The  fourbit <br>sum is obtained from  <i>S1</i>  through  <i>S4</i> .   <i>C0</i>  is the input carry and  <i>C4</i>  the output carry. <br>
 <br>Test the fourbit binary adder 7483 by connecting the power supply and ground ter-<br>
minals. Then connect the four  <i>A</i>  inputs to a fixed binary number, such as 1001, and the <br> <br><i>B</i>  inputs and the input carry to five toggle switches. The five outputs are applied to <br>
5<br>
<i>V</i><br>
16<br>
<i>CC</i><br>
14<br>
<i>B4</i><br>
<i>C4</i><br>
1<br>
<i>A4</i><br>
15<br>
4<br>
<i>S4</i><br>
<i>B3</i><br>
3<br>
2<br>
<i>A3</i><br>
<i>S3</i><br>
7<br>
<i>B2</i><br>
7483<br>
6<br>
8<br>
<i>S2</i><br>
<i>A2</i><br>
11<br>
9<br>
<i>B1</i><br>
<i>S1</i><br>
10<br>
<i>A1</i><br>
13<br>
<i>C0</i><br>
<i>GND</i><br>
12<br>
<b> <br>FIGURE 9.10   <br> <br>IC type 7483 fourbit binary adder  </b><br>
<hr>
<A name=474></a><b>456    Chapter 9  Laboratory Experiments</b><br>
indicator lamps. Perform the addition of a few binary numbers and check that the output <br>sum and output carry give the proper values. Show that when the input carry is equal <br>to 1, it adds 1 to the output sum. <br>
<b> <br>Adder�Subtractor </b><br>
 <br>Two binary numbers can be subtracted by taking the 2's complement of the subtrahend <br>and adding it to the minuend. The 2's complement can be obtained by taking the 1's <br>complement and adding 1. To perform   <i>A </i>- <i>B</i>,  we complement the four bits of  <i>B</i>,  add them <br>to the four bits of  <i>A,</i>  and add 1 through the input carry. This is done as shown in  Fig.  9.11 . <br>The four XOR gates complement the bits of  <i>B</i>  when the mode select   <i>M </i>= 1     (because <br> <i>x </i>{ 1 = <i>x </i>  and leave the bits of  <i>B</i>  unchanged when   <i>M </i>= 0     (because     <i>x </i>{ 0 = <i>x</i>   ).  Thus, <br>when the mode select  <i>M</i>  is equal to 1, the input carry  <i>C0</i>  is equal to 1 and the sum output <br>is  <i>A</i>  plus the 2's complement of  <i>B</i> .  When   <i>M</i>  is equal to 0, the input carry is equal to 0 and <br>the sum generates   <i>A </i>+ <i>B</i>.  <br>
 <br>Connect the adder�subtractor circuit and test it for proper operation. Connect the <br>
four  <i>A</i>  inputs to a fixed binary number 1001 and the  <i>B</i>  inputs to switches. Perform <br>
5<br>
<i>VCC</i><br>
1<br>
14<br>
<i>A4</i><br>
<i>C4</i><br>
Output carry<br>
3<br>
Data input<br>
<i>A3</i><br>
<i>A</i><br>
8<br>
<i>A2</i><br>
10<br>
<i>A1</i><br>
15<br>
<i>S4</i><br>
16<br>
2<br>
<i>B4</i><br>
<i>S3</i><br>
Data output<br>
7483<br>
6<br>
<i>S</i><br>
<i>S2</i><br>
4<br>
<i>B3</i><br>
9<br>
Data input<br>
<i>S1</i><br>
<i>B</i><br>
7<br>
<i>B2</i><br>
11<br>
<i>B1 C</i>0 <i>GND</i><br>
13<br>
12<br>
Mode select <i>M</i><br>
<i>M</i><br>
0 for add<br>
<i>M</i><br>
1 for subtract<br>
<b> <br>FIGURE 9.11   <br> <br>Fourbit adder�subtractor  </b><br>
<hr>
<A name=475></a><b>Section 9.9  Experiment 8: FlipFlops    457</b><br>
the following operations and record the values of the output sum and the output <br>carry  <i>C4</i> : <br>
9 + 5<br>
9 - 5<br>
 <br>9 + 9<br>
9 - 9  <br>
9 + 15<br>
9 - 15<br>
 <br>Show that during addition, the output carry is equal to 1 when the sum exceeds 15. <br>Also, show that when   <i>A </i>� <i>B</i>,  the subtraction operation gives the correct answer, <br> <i>A </i>- <i>B</i>,  and the output carry  <i>C4</i>  is equal to 1, but when   <i>A</i> 6 <i>B</i>,     the  subtraction  gives <br>the 2's complement of   <i>B </i>- <i>A</i>  and the output carry is equal to 0. <br>
<b> <br>Magnitude Comparator </b><br>
 <br>The comparison of two numbers is an operation that determines whether one number is <br>greater than, equal to, or less than the other number. Two numbers,  <i>A</i>  and  <i>B</i>,  can be com-<br>pared by first subtracting   <i>A </i>- <i>B</i>  as is done in  Fig.   9.11 . If the output in  <i>S</i>  is equal to zero, <br>then     <i>A </i>= <i>B</i>. The output carry from  <i>C4</i>  determines the relative magnitudes of the num-<br>bers: When     <i>C4 </i>= 1, <i>A </i>� <i>B</i>;     when     <i>C4 </i>= 0, <i>A</i> 6 <i>B</i>;     and  when     <i>C4 </i>= 1     and     <i>S</i><br>
0, <i>A </i>7 <i>B</i>.    <br>
 <br>It is necessary to supplement the subtractor circuit of  Fig.   9.11   to provide the com-<br>
parison logic. This is done with a combinational circuit that has five inputs-- <i>S1</i>   through <br> <br><i>S4</i>  and  <i>C4</i> --and three outputs, designated by  <i>x,</i>    <i>y</i>,  and  <i>z</i>,  so that <br>
 <i>x </i>= 1<br>
if <i>A </i>= <i>B</i><br>
(<i>S </i>= 0000)<br>
<i>y </i>= 1<br>
if <i>A </i>6 <i>B</i><br>
(<i>C4 </i>= 0)<br>
<i>z </i>= 1<br>
if <i>A </i>7 <i>B</i><br>
(<i>C4 </i>= 1 and <i>S</i><br>
0000)   <br>
 <br>The combinational circuit can be implemented with the 7404 and 7408 ICs. <br>
 <br>Construct the comparator circuit and test its operation. Use at least two sets of num-<br>
bers for  <i>A</i>  and  <i>B</i>  to check each of the outputs  <i>x,</i>    <i>y</i>,  and  <i>z</i> .   <br>
<b> <br>9 . 9       E X P E R I M E N T   8 :   F L I P  F L O P S </b><br>
 <br>In this experiment, you will construct, test, and investigate the operation of various <br>latches and flipflops. The internal construction of latches and flipflops can be found in <br>Sections 5.3 and 5.4. <br>
<b> <br><i>SR</i>  Latch </b><br>
 <br>Construct an  <i>SR</i>  latch with two crosscoupled NAND gates. Connect the two inputs to <br> <br>switches and the two outputs to indicator lamps. Set the two switches to logic 1, and then <br>momentarily turn each switch separately to the logic0 position and back to 1. Obtain <br>the function table of the circuit. <br>
<b> <br><i>D</i>  Latch </b><br>
 <br>Construct a  <i>D</i>  latch with four NAND gates (only one 7400 IC) and verify its function table. <br>
<hr>
<A name=476></a><b>458    Chapter 9  Laboratory Experiments</b><br>
<b> <br>Master�Slave FlipFlop </b><br>
 <br>Connect a master�slave  <i>D</i>  flipflop using two  <i>D</i>  latches and an inverter. Connect the <br> <br><i>D</i>  input to a switch and the clock input to a pulser. Connect the output of the master <br>latch to one indicator lamp and the output of the slave latch to another indicator <br>lamp. Set the value of the input to the complement value of the output. Press the push <br>button in the pulser and then release it to produce a single pulse. Observe that the <br>master changes when the pulse goes positive and the slave follows the change when <br>the pulse goes negative. Press the push button again a few times while observing the <br>two indicator lamps. Explain the transfer sequence from input to master and from <br>master to slave. <br>
 <br>Disconnect the clock input from the pulser and connect it to a clock generator. Con-<br>
nect the complement output of the flipflop to the  <i>D</i>  input. This causes the flipflop to <br>be complemented with each clock pulse. Using a dualtrace oscilloscope, observe the <br>waveforms of the clock and the master and slave outputs. Verify that the delay between <br>the master and the slave outputs is equal to the positive half of the clock cycle. Obtain <br>a timing diagram showing the relationship between the clock waveform and the master <br>and slave outputs. <br>
2<br>
7<br>
4<br>
<i>PR</i><br>
15<br>
9<br>
<i>PR</i><br>
11<br>
<i>J</i><br>
<i>Q</i><br>
<i>J</i><br>
<i>Q</i><br>
1<br>
6<br>
<i>V</i><br>
<i>CK</i><br>
<i>CK</i><br>
<i>CC</i><br>
 pin 5<br>
<i>GND</i><br>
 pin 13<br>
16<br>
14<br>
12<br>
10<br>
<i>K</i><br>
<i>Q</i><br>
<i>K</i><br>
<i>Q</i><br>
<i>CLR</i><br>
<i>CLR</i><br>
3<br>
8<br>
Function table<br>
Inputs<br>
Outputs<br>
Preset<br>
Clear<br>
Clock<br>
<i>J</i><br>
<i>K</i><br>
<i>Q</i><br>
<i>Q</i><br>
0<br>
1<br>
X<br>
X<br>
X<br>
1<br>
0<br>
1<br>
0<br>
X<br>
X<br>
X<br>
0<br>
1<br>
0<br>
0<br>
X<br>
X<br>
X<br>
1<br>
1<br>
1<br>
1<br>
0<br>
0<br>
No change<br>
1<br>
1<br>
0<br>
1<br>
0<br>
1<br>
1<br>
1<br>
1<br>
0<br>
1<br>
0<br>
1<br>
1<br>
1<br>
1<br>
Toggle<br>
<b> <br>FIGURE 9.12   <br> <br>IC type 7476 dual  <i>JK</i>  master�slave flipflops  </b><br>
<hr>
<A name=477></a><b>Section 9.9  Experiment 8: FlipFlops    459</b><br>
<b> <br>EdgeTriggered FlipFlop </b><br>
 <br>Construct a  <i>D</i> type positiveedgetriggered flipflop using six NAND gates. Connect the <br>clock input to a pulser, the  <i>D</i>  input to a toggle switch, and the output  <i>Q</i>  to an indicator <br>lamp. Set the value of  <i>D</i>  to the complement of  <i>Q</i> . Show that the flipflop output changes <br>only in response to a positive transition of the clock pulse. Verify that the output does <br>not change when the clock input is logic 1, when the clock goes through a negative <br>transition, or when the clock input is logic 0. Continue changing the  <i>D</i>  input to corre-<br>spond to the complement of the  <i>Q</i>  output at all times. <br>
 <br>Disconnect the input from the pulser and connect it to the clock generator. Connect <br>
the complement output   <i>Q </i>     to  the   <i>D</i>  input. This causes the output to be complemented <br>with each positive transition of the clock pulse. Using a dualtrace oscilloscope, observe <br>and record the timing relationship between the input clock and the output  <i>Q</i> . Show that <br>the output changes in response to a positive edge transition. <br>
<b> <br>IC FlipFlops </b><br>
 <br>IC type 7476 consists of two  <i>JK</i>  master�slave flipflops with preset and clear. The pin <br>assignment for each flipflop is shown in  Fig.   9.12  .The function table specifies the circuit's <br>operation. The first three entries in the table specify the operation of the asynchronous <br>
4<br>
10<br>
<i>PR</i><br>
2<br>
5<br>
<i>PR</i><br>
12<br>
9<br>
<i>D</i><br>
<i>Q</i><br>
<i>D</i><br>
<i>Q</i><br>
3<br>
11<br>
<i>VCC </i> pin 14<br>
<i>CK</i><br>
<i>CK</i><br>
<i>GND</i><br>
 pin 7<br>
6<br>
8<br>
<i>Q</i><br>
<i>Q</i><br>
<i>CLR</i><br>
<i>CLR</i><br>
1<br>
13<br>
Function table<br>
Inputs<br>
Outputs<br>
Preset<br>
Clear<br>
Clock<br>
<i>D</i><br>
<i>Q</i><br>
<i>Q</i><br>
0<br>
1<br>
X<br>
X<br>
1<br>
0<br>
1<br>
0<br>
X<br>
X<br>
0<br>
1<br>
0<br>
0<br>
X<br>
X<br>
1<br>
1<br>
1<br>
1<br>
0<br>
0<br>
1<br>
1<br>
1<br>
1<br>
1<br>
0<br>
1<br>
1<br>
0<br>
X<br>
No change<br>
<b> <br>FIGURE 9.13   <br> <br>IC type 7474 dual  <i>D</i>  positiveedgetriggered flipflops  </b><br>
<hr>
<A name=478></a><b>460    Chapter 9  Laboratory Experiments</b><br>
preset and clear inputs. These inputs behave like a NAND  <i>SR</i>  latch and are independent <br>of the clock or the  <i>J</i>  and  <i>K</i>  inputs. (The X's indicate don'tcare conditions.) The last four <br>entries in the function table specify the operation of the clock with both the preset and <br>clear inputs maintained at logic 1. The clock value is shown as a single pulse. The positive <br>transition of the pulse changes the master flipflop, and the negative transition changes <br>the slave flipflop as well as the output of the circuit. With   <i>J </i>= <i>K </i>= 0,     the  output  does <br>not change. The flipflop toggles, or is complemented, when   <i>J </i>= <i>K </i>= 1.     Investigate  the <br>operation of one 7476 flipflop and verify its function table. <br>
 <br>IC type 7474 consists of two  <i>D</i>  positiveedgetriggered flipflops with preset and <br>
clear. The pin assignment is shown in  Fig.   9.13  . The function table specifies the preset <br>and clear operations and the clock's operation. The clock is shown with an upward <br>arrow to indicate that it is a positiveedgetriggered flipflop. Investigate the operation <br>of one of the flipflops and verify its function table. <br>
<b> <br>9 . 1 0       E X P E R I M E N T   9 :   S E Q U E N T I A L   C I R C U I T S </b><br>
 <br>In this experiment, you will design, construct, and test three synchronous sequential circuits. <br>Use IC type 7476 ( Fig.   9.12  ) or 7474 ( Fig.   9.13  ). Choose any type of gate that will minimize <br>the total number of ICs. The design of synchronous sequential circuits is covered in Section 5.7. <br>
<b> <br>Up�Down Counter with Enable </b><br>
 <br>Design, construct, and test a twobit counter that counts up or down. An enable input <i>E</i> <br>determines whether the counter is on or off. If   <i>E </i>= 0,  the counter is disabled and remains <br>at its present count even though clock pulses are applied to the flipflops. If   <i>E </i>= 1, the <br>counter is enabled and a second input,  <i>x,</i>  determines the direction of the count. If   <i>x </i>= 1, <br>the circuit counts upward with the sequence 00, 01, 10, 11, and the count repeats. If   <i>x </i>= 0, <br>the circuit counts downward with the sequence 11, 10, 01, 00, and the count repeats. Do <br>not use  <i>E</i>  to disable the clock. Design the sequential circuit with  <i>E</i>  and  <i>x</i>  as inputs. <br>
<b> <br>State Diagram </b><br>
 <br>Design, construct, and test a sequential circuit whose state diagram is shown in  Fig.   9.14  . <br>Designate the two flipflops as  <i>A</i>  and  <i>B</i>,  the input as  <i>x</i>,  and the output as  <i>y</i> . <br>
 <br>Connect the output of the least significant flipflop  <i>B</i>  to the input  <i>x</i>,  and predict the <br>
sequence of states and output that will occur with the application of clock pulses. Verify <br>the state transition and output by testing the circuit. <br>
<b> <br>Design of Counter </b><br>
 <br>Design, construct, and test a counter that goes through the following sequence of binary <br>states: 0, 1, 2, 3, 6, 7, 10, 11, 12, 13, 14, 15, and back to 0 to repeat. Note that binary states <br>4, 5, 8, and 9 are not used. The counter must be selfstarting; that is, if the circuit starts <br>from any one of the four invalid states, the count pulses must transfer the circuit to one <br>of the valid states to continue the count correctly. <br>
<hr>
<A name=479></a><b>Section 9.11  Experiment 10: Counters    461</b><br>
1/1<br>
00<br>
0/0<br>
0/1<br>
0/1<br>
01<br>
10<br>
1/0<br>
1/0<br>
1/1<br>
11<br>
0/0<br>
<b> <br>FIGURE 9.14   <br> <br>State diagram for Experiment 9  </b><br>
 <br>Check the circuit's operation for the required count sequence. Verify that the counter <br>
is selfstarting. This is done by initializing the circuit to each unused state by means of <br>the preset and clear inputs and then applying pulses to see whether the counter reaches <br>one of the valid states. <br>
<b> <br>9 . 1 1       E X P E R I M E N T   1 0 :   C O U N T E R S </b><br>
 <br>In this experiment, you will construct and test various ripple and synchronous counter <br>circuits. Ripple counters are discussed in Section 6.3 and synchronous counters are cov-<br>ered in Section 6.4. <br>
<b> <br>Ripple Counter </b><br>
 <br>Construct a fourbit binary ripple counter using two 7476 ICs ( Fig.   9.12  ). Connect all <br>asynchronous clear and preset inputs to logic 1. Connect the countpulse input to a <br>pulser and check the counter for proper operation. <br>
 <br>Modify the counter so that it will count downward instead of upward. Check that <br>
each input pulse decrements the counter by 1. <br>
<b> <br>Synchronous Counter </b><br>
 <br>Construct a synchronous fourbit binary counter and check its operation. Use two 7476 <br>ICs and one 7408 IC. <br>
<b> <br>Decimal Counter </b><br>
 <br>Design a synchronous BCD counter that counts from 0000 to 1001. Use two 7476 ICs <br>and one 7408 IC. Test the counter for the proper sequence. Determine whether the <br>counter is selfstarting. This is done by initializing the counter to each of the six unused <br>states by means of the preset and clear inputs. The application of pulses will transfer the <br>counter to one of the valid states if the counter is selfstarting. <br>
<hr>
<A name=480></a><b>462    Chapter 9  Laboratory Experiments</b><br>
<b> <br>Binary Counter with Parallel Load </b><br>
 <br>IC type 74161 is a fourbit synchronous binary counter with parallel load and asyn-<br>chronous clear. The internal logic is similar to that of the circuit shown in Fig. 6.14. <br>The pin assignments to the inputs and outputs are shown in  Fig.   9.15  . When the load <br>signal is enabled, the four data inputs are transferred into four internal flipflops,  <i>QA</i> <br>through  <i>QD</i>,  with  <i>QD</i>  being the most significant bit. There are two countenable <br>inputs called  <i>P</i>  and  <i>T</i> . Both must be equal to 1 for the counter to operate. The function <br>table is similar to Table 6.6, with one exception: The load input in the 74161 is enabled <br>when equal to 0. To load the input data, the clear input must be equal to 1 and the <br>load input must be equal to 0. The two count inputs have don'tcare conditions and <br>may be equal to either 1 or 0. The internal flipflops trigger on the positive transition <br>of the clock pulse. The circuit functions as a counter when the load input is equal to <br>1 and both count inputs  <i>P</i>  and  <i>T</i>  are equal to 1. If either  <i>P</i>  or  <i>T</i>  goes to 0, the output <br>
16<br>
<i>VCC</i><br>
3<br>
14<br>
<i>A</i><br>
<i>QA</i><br>
4<br>
13<br>
<i>B</i><br>
Data<br>
<i>QB</i><br>
Data<br>
5<br>
inputs<br>
outputs<br>
<i>C</i><br>
12<br>
<i>QC</i><br>
6<br>
<i>D</i><br>
11<br>
<i>QD</i><br>
9<br>
Load<br>
<i>L</i><br>
74161<br>
7<br>
15<br>
<i>P</i><br>
<i>COUT</i><br>
Carry out<br>
10<br>
Count<br>
<i>T</i><br>
2<br>
Clock<br>
<i>CK</i><br>
1<br>
Clear<br>
<i>CLR</i><br>
<i>GND</i><br>
8<br>
Function table<br>
Clear<br>
Clock<br>
Load<br>
Count<br>
Function<br>
0<br>
X<br>
X<br>
X<br>
Clear outputs to 0<br>
1<br>
0<br>
X<br>
Load input data<br>
1<br>
1<br>
1<br>
Count to next binary value<br>
1<br>
1<br>
0<br>
No change in output<br>
<b> <br>FIGURE 9.15   <br> <br>IC type 74161 binary counter with parallel load  </b><br>
<hr>
<A name=481></a><b>Section 9.12  Experiment 11: Shift Registers    463</b><br>
does not change. The carryout output is equal to 1 when all four data outputs are <br>equal to 1. Perform an experiment to verify the operation of the 74161 IC according <br>to the function table. <br>
 <br>Show how the 74161 IC, together with a twoinput NAND gate, can be made to oper-<br>
ate as a synchronous BCD counter that counts from 0000 to 1001. Do not use the clear <br>input. Use the NAND gate to detect the count of 1001, which then causes all 0's to be <br>loaded into the counter. <br>
<b> <br>9 . 1 2       E X P E R I M E N T   1 1 :   S H I F T   R E G I S T E R S </b><br>
 <br>In this experiment, you will investigate the operation of shift registers. The IC to be <br>used is the 74195 shift register with parallel load. Shift registers are explained in <br>Section 6.2. <br>
<b> <br>IC Shift Register </b><br>
 <br>IC type 74195 is a fourbit shift register with parallel load and asynchronous clear. The <br>pin assignments to the inputs and outputs are shown in  Fig.   9.16  . The single control line <br>labeled     <i>SH</i>&gt;<i>LD</i>  (shift/load) determines the synchronous operation of the register. When <br> <br><i>SH</i>&gt;<i>LD </i>= 0,  the control input is in the load mode and the four data inputs are trans-<br>ferred into the four internal flipflops,  <i>QA</i>  through  <i>QD</i> .  When     <i>SH</i>&gt;<i>LD </i>= 1,     the  control <br>input is in the shift mode and the information in the register is shifted right from  <i>QA</i> <br>toward  <i>QD</i> . The serial input into  <i>QA</i>  during the shift is determined from the  <i>J</i>   and     <i>K</i> <br>inputs. The two inputs behave like the  <i>J</i>  and the complement of  <i>K</i>  of a  <i>JK</i>   flipflop. When <br>both  <i>J</i>   and     <i>K</i>  are equal to 0, flipflop  <i>QA</i>  is cleared to 0 after the shift. If both inputs are <br>equal to 1,  <i>QA</i>  is set to 1 after the shift. The other two conditions for the  <i>J</i>   and     <i>K</i>     inputs <br>provide a complement or no change in the output of flipflop  <i>QA</i>  after the shift.  <br>
 <br>The function table for the 74195 shows the mode of operation of the register. When <br>
the clear input goes to 0, the four flipflops clear to 0 asynchronously--that is, without <br>the need of a clock. Synchronous operations are affected by a positive transition of the <br>clock. To load the input data,  <i>SH/LD</i>  must be equal to 0 and a positive clockpulse <br>transition must occur. To shift right,  <i>SH/LD</i>  must be equal to 1. The  <i>J</i>   and     <i>K</i>     inputs  must <br>be connected together to form the serial input. <br>
 <br>Perform an experiment that will verify the operation of the 74195 IC. Show that it <br>
performs all the operations listed in the function table. Include in your function table <br>the two conditions for   <i>JK </i>= 01     and  10.  <br>
<b> <br>Ring Counter </b><br>
 <br>A ring counter is a circular shift register with the signal from the serial output  <i>QD</i>   going <br>into the serial input. Connect the  <i>J</i>   and     <i>K</i>  input together to form the serial input. Use <br>the load condition to preset the ring counter to an initial value of 1000. Rotate the single <br>bit with the shift condition and check the state of the register after each clock pulse. <br>
<hr>
<A name=482></a><b>464    Chapter 9  Laboratory Experiments</b><br>
16<br>
<i>V</i><br>
1<br>
<i>CC</i><br>
Clear<br>
<i>CLR</i><br>
10<br>
Clock<br>
<i>CK</i><br>
9<br>
15<br>
Shift/load<br>
<i>SH/LD</i><br>
<i>QA</i><br>
2<br>
14<br>
<i>J</i><br>
<i>QB</i><br>
Serial<br>
Data<br>
3<br>
13<br>
inputs<br>
outputs<br>
<i>K</i><br>
74195<br>
<i>QC</i><br>
4<br>
12<br>
<i>A</i><br>
<i>QD</i><br>
5<br>
11<br>
<i>B</i><br>
<i>QD</i><br>
Complement of <i>QD</i><br>
Data<br>
inputs<br>
6<br>
<i>C</i><br>
7<br>
<i>D</i><br>
<i>GND</i><br>
8<br>
Function table<br>
Shift/<br>
Serial<br>
Clear<br>
load<br>
Clock<br>
<i>J</i><br>
<i>K</i><br>
input<br>
Function<br>
0<br>
X<br>
X<br>
X<br>
X<br>
X<br>
Asynchronous clear<br>
1<br>
X<br>
0<br>
X<br>
X<br>
X<br>
No change in output<br>
1<br>
0<br>
X<br>
X<br>
X<br>
Load input data<br>
1<br>
1<br>
0<br>
0<br>
0<br>
Shift from <i>QA</i> toward <i>QD</i>, <i>QA</i><br>
 0<br>
1<br>
1<br>
1<br>
1<br>
1<br>
Shift from <i>QA</i> toward <i>QD</i>, <i>QA</i><br>
 1<br>
<b> <br>FIGURE 9.16   <br> <br>IC type 74195 shift register with parallel load  </b><br>
 <br>A switchtail ring counter uses the complement output of  <i>QD</i>  for the serial input. <br>
Preset the switchtail ring counter to 0000 and predict the sequence of states that <br>will result from shifting. Verify your prediction by observing the state sequence after <br>each shift. <br>
<b> <br>Feedback Shift Register </b><br>
 <br>A feedback shift register is a shift register whose serial input is connected to some func-<br>tion of selected register outputs. Connect a feedback shift register whose serial input is <br>
<hr>
<A name=483></a><b>Section 9.12  Experiment 11: Shift Registers    465</b><br>
the exclusiveOR of outputs  <i>QC</i>  and  <i>QD</i> . Predict the sequence of states of the register, <br>starting from state 1000. Verify your prediction by observing the state sequence after <br>each clock pulse. <br>
<b> <br>Bidirectional Shift Register </b><br>
 <br>The 74195 IC can shift only right from  <i>QA</i>  toward  <i>QD</i> . It is possible to convert the <br>register to a bidirectional shift register by using the load mode to obtain a shiftleft <br>operation (from  <i>QD</i>  toward  <i>QA</i> ). This is accomplished by connecting the output of <br>each flipflop to the input of the flipflop on its left and using the load mode of the <br> <br><i>SH/LD</i>  input as a shiftleft control. Input  <i>D</i>  becomes the serial input for the shift<br>left operation. <br>
 <br>Connect the 74195 as a bidirectional shift register (without parallel load). Con-<br>
nect the serial input for shift right to a toggle switch. Construct the shift left as a <br>ring counter by connecting the serial output  <i>QA</i>  to the serial input  <i>D</i> . Clear the <br>register and then check its operation by shifting a single 1 from the serial input <br>switch. Shift right three more times and insert 0's from the serial input switch. Then <br>rotate left with the shiftleft (load) control. The single 1 should remain visible while <br>shifting.  <br>
<b> <br>Bidirectional Shift Register with Parallel Load </b><br>
 <br>The 74195 IC can be converted to a bidirectional shift register with parallel load in con-<br>junction with a multiplexer circuit. We will use IC type 74157 for this purpose. The 74157 <br>is a quadruple twotooneline multiplexer whose internal logic is shown in Fig. 4.26. The <br>pin assignments to the inputs and outputs of the 74157 are shown in  Fig.   9.17 . Note that <br>the enable input is called a strobe in the 74157. <br>
 <br>Construct a bidirectional shift register with parallel load using the 74195 register <br>
and the 74157 multiplexer. The circuit should be able to perform the following opera-<br>tions: <br>
 <br><b> 1. </b><br>
  Asynchronous  clear  <br>
 <br><b> 2. </b><br>
  Shift  right  <br>
 <br><b> 3. </b><br>
  Shift  left  <br>
 <br><b> 4. </b><br>
  Parallel  load  <br>
 <br><b> 5. </b><br>
  Synchronous  clear    <br>
 <br>Derive a table for the five operations as a function of the clear, clock, and  <i>SH/LD</i>   inputs <br>of the 74195 and the strobe and select inputs of the 74157. Connect the circuit and verify <br>your function table. Use the parallelload condition to provide an initial value to the <br>register, and connect the serial outputs to the serial inputs of both shifts in order not to <br>lose the binary information while shifting. <br>
<hr>
<A name=484></a><b>466    Chapter 9  Laboratory Experiments</b><br>
16<br>
<i>V</i><br>
2<br>
<i>CC</i><br>
<i>A1</i><br>
5<br>
Data<br>
<i>A2</i><br>
inputs<br>
11<br>
<i>A</i><br>
<i>A3</i><br>
4<br>
14<br>
<i>Y1</i><br>
<i>A4</i><br>
7<br>
<i>Y2</i><br>
Data<br>
9<br>
outputs<br>
3<br>
<i>Y3</i><br>
<i>B1</i><br>
12<br>
6<br>
74157<br>
<i>Y4</i><br>
Data<br>
<i>B2</i><br>
inputs<br>
10<br>
<i>B</i><br>
<i>B3</i><br>
13<br>
<i>B4</i><br>
1<br>
Select<br>
<i>SEL</i><br>
15<br>
Strobe<br>
<i>STB</i><br>
<i>GND</i><br>
8<br>
Function table<br>
Strobe<br>
Select<br>
Data outputs <i>Y</i><br>
1<br>
X<br>
All 0's<br>
0<br>
0<br>
Select data inputs <i>A</i><br>
0<br>
1<br>
Select data inputs <i>B</i><br>
<b> <br>FIGURE 9.17   <br> <br>IC type 74157 quadruple   2 </b>* <b>1   multiplexers  </b><br>
<b> <br>9 . 1 3       E X P E R I M E N T   1 2 :   S E R I A L   A D D I T I O N </b><br>
 <br>In this experiment, you will construct and test a serial adder�subtractor circuit. Serial <br>addition of two binary numbers can be done by means of shift registers and a full adder, <br>as explained in Section 6.2. <br>
<b> <br>Serial Adder </b><br>
 <br>Starting from the diagram of Fig. 6.6, design and construct a fourbit serial adder using <br>the following ICs: 74195 (two), 7408, 7486, and 7476. Provide a facility for register  <i>B</i>   to <br>accept parallel data from four toggle switches, and connect its serial input to ground so <br>that 0's are  shifted into register  <i>B</i>  during the addition. Provide a toggle switch to clear <br>
<hr>
<A name=485></a><b>Section 9.14  Experiment 13: Memory Unit    467</b><br>
the registers and the flipflop. Another switch will be needed to specify whether register <br> <br><i>B</i>  is to accept parallel data or is to be shifted during the addition. <br>
<b> <br>Testing the Adder </b><br>
 <br>To test your serial adder, perform the binary addition   5 + 6 + 15 = 26.     This  is  done  by <br>first clearing the registers and the carry flipflop. Parallel load the binary value 0101 into <br>register  <i>B</i> .Apply four pulses to add  <i>B</i>  to  <i>A</i>  serially, and check that the result in  <i>A</i>  is 0101. <br>(Note that clock pulses for the 7476 must be as shown in  Fig.   9.12  .) Parallel load 0110 <br>into  <i>B</i>  and add it to  <i>A</i>  serially. Check that  <i>A</i>  has the proper sum. Parallel load 1111 into <br> <br><i>B</i>  and add to  <i>A</i> . Check that the value in  <i>A</i>  is 1010 and that the carry flipflop is set. <br>
 <br>Clear the registers and flipflop and try a few other numbers to verify that your serial <br>
adder is functioning properly. <br>
<b> <br>Serial Adder�Subtractor </b><br>
 <br>If we follow the procedure used in Section 6.2 for the design of a serial subtractor (that <br>subtracts     <i>A </i>- <i>B</i> ), we will find that the output difference is the same as the output sum, but <br>that the input to the <i>J</i> and <i>K</i> of the borrow flipflop needs the complement of  <i>QD</i>   (available <br>in the 74195). Using the other two XOR gates from the 7486, convert the serial adder to a <br>serial adder�subtractor with a mode control  <i>M</i> . When     <i>M </i>= 0,     the  circuit  adds     <i>A </i>+ <i>B</i>.    When <br> <br><i>M </i>= 1,     the  circuit  subtracts     <i>A </i>- <i>B</i>  and the flipflop holds the borrow instead of the carry. <br>
 <br>Test the adder part of the circuit by repeating the operations recommended to ensure <br>
that the modification did not change the operation. Test the serial subtractor part by <br>performing the subtraction   15  - 4 - 5 - 13 = -7.  Binary 15 can be transferred to reg-<br>ister <i>A</i> by first clearing it to 0 and adding 15 from B. Check the intermediate results <br>during the subtraction. Note that   -7  will appear as the 2's complement of 7 with a bor-<br>row of 1 in the flipflop. <br>
<b> <br>9 . 1 4       E X P E R I M E N T   1 3 :   M E M O R Y   U N I T </b><br>
 <br>In this experiment, you will investigate the behavior of a randomaccess memory (RAM) <br>unit and its storage capability. The RAM will be used to simulate a readonly memory <br>(ROM). The ROM simulator will then be used to implement combinational circuits, as <br>explained in Section 7.5. The memory unit is discussed in Sections 7.2 and 7.3. <br>
<b> <br>IC RAM </b><br>
 <br>IC type 74189 is a   16 * 4  RAM. The internal logic is similar to the circuit shown in Fig. 7.6 <br>for a   4 * 4  RAM. The pin assignments to the inputs and outputs are shown in  Fig.   9.18  . <br>The four address inputs select 1 of 16 words in the memory. The least significant bit of the <br>address is  <i>A</i>  and the most significant is   <i>A</i>3.     The  chip  select  ( <i>CS</i> ) input must be equal to 0 <br>to enable the memory. If  <i>CS</i>  is equal to 1, the memory is disabled and all four outputs are <br>in a highimpedance state. The write enable ( <i>WE</i> ) input determines the type of operation, <br>as indicated in the function table. The write operation is performed when   <i>WE </i>= 0. This <br>
<hr>
<A name=486></a><b>468    Chapter 9  Laboratory Experiments</b><br>
16<br>
<i>V</i><br>
4<br>
<i>CC</i><br>
5<br>
<i>D1</i><br>
<i>S1</i><br>
6<br>
7<br>
Data<br>
<i>D2</i><br>
<i>S2</i><br>
Data<br>
inputs<br>
10<br>
9<br>
outputs<br>
<i>D3</i><br>
<i>S3</i><br>
12<br>
11<br>
<i>D4</i><br>
<i>S4</i><br>
1<br>
<i>A</i>0<br>
15<br>
74189<br>
Address<br>
<i>A</i>1<br>
inputs<br>
14<br>
<i>A</i>2<br>
13<br>
<i>A</i>3<br>
2<br>
Chip select<br>
<i>CS</i><br>
3<br>
Write enable<br>
<i>WE</i><br>
<i>GND</i><br>
8<br>
Function table<br>
<i>CS</i><br>
<i>WE</i><br>
Operation<br>
Data outputs<br>
0<br>
0<br>
Write<br>
High impedance<br>
0<br>
1<br>
Read<br>
Complement of selected word<br>
1<br>
X<br>
Disable<br>
High impedance<br>
<b> <br>FIGURE 9.18   <br> <br>IC type 74189   16 </b>* <b>4   RAM  </b><br>
operation is a transfer of the binary number from the data inputs into the selected word <br>in memory. The read operation is performed when   <i>WE </i>= 1.     This  operation  transfers  the <br>complemented value stored in the selected word into the output data lines. The memory <br>has threestate outputs to facilitate memory expansion. <br>
<b> <br>Testing the RAM </b><br>
 <br>Since the outputs of the 74189 produce the complemented values, we need to insert four <br>inverters to change the outputs to their normal value. The RAM can be tested after <br>making the following connections: Connect the address inputs to a binary counter using <br>the 7493 IC (shown in  Fig.   9.3  ). Connect the four data inputs to toggle switches and the <br>
<hr>
<A name=487></a><b>Section 9.15  Experiment 14: Lamp Handball    469</b><br>
data outputs to four 7404 inverters. Provide four indicator lamps for the address and <br>four more for the outputs of the inverters. Connect input  <i>CS</i>  to ground and  <i>WE</i>  to a <br>toggle switch (or a pulser that provides a negative pulse). Store a few words into the <br>memory, and then read them to verify that the write and read operations are functioning <br>properly. You must be careful when using the  <i>WE</i>  switch. Always leave the  <i>WE</i>  input in <br>the read mode, unless you want to write into memory. The proper way to write is first to <br>set the address in the counter and the inputs in the four toggle switches. Then, store the <br>word in memory, flip the  <i>WE</i>  switch to the write position and return it to the read posi-<br>tion. Be careful not to change the address or the inputs when  <i>WE</i>  is in the write mode. <br>
<b> <br>ROM Simulator </b><br>
 <br>A ROM simulator is obtained from a RAM operated in the read mode only. The pattern <br>of 1's and 0's is first entered into the simulating RAM by placing the unit momentarily <br>in the write mode. Simulation is achieved by placing the unit in the read mode and tak-<br>ing the address lines as inputs to the ROM. The ROM can then be used to implement <br>any combinational circuit. <br>
 <br>Implement a combinational circuit using the ROM simulator that converts a fourbit <br>
bi nary number to its equivalent Gray code as defined in Table 1.6. This is done as follows: <br>Obtain the truth table of the code converter. Store the truth table into the 74189 mem-<br>ory by setting the  address inputs to the binary value and the data inputs to the corre-<br>sponding Gray code value. After all 16 entries of the table are written into memory, the <br>ROM simulator is set by permanently connecting the  <i>WE</i>  line to logic 1. Check the code <br>converter by applying the inputs to the  address lines and verifying the correct outputs <br>in the data output lines. <br>
<b> <br>Memory Expansion </b><br>
 <br>Expand the memory unit to a   32 * 4  RAM using two 74189 ICs. Use the  <i>CS</i>  inputs to <br>select between the two ICs. Note that since the data outputs are threestated, you can <br>tie pairs of terminals together to obtain a logic OR operation between the two ICs. Test <br>your circuit by using it as a ROM simulator that adds a threebit number to a twobit <br>number to produce a fourbit sum. For example, if the input of the ROM is 10110, then <br>the output is calculated to be   101 + 10 = 0111.  (The first three bits of the input repre-<br>sent 5, the last two bits represent 2, and the output sum is binary 7.) Use the counter to <br>provide four bits of the address and a switch for the fifth bit of the address. <br>
<b> <br>9 . 1 5       E X P E R I M E N T   1 4 :   L A M P   H A N D B A L L </b><br>
 <br>In this experiment, you will construct an electronic game of handball, using a single light <br>to simulate the moving ball. The experiment demonstrates the application of a bidirec-<br>tional shift register with parallel load. It also shows the operation of the asynchronous <br>inputs of flipflops. We will first introduce an IC that is needed for the experiment and <br>then present the logic diagram of the simulated lamp handball game. <br>
<hr>
<A name=488></a><b>470    Chapter 9  Laboratory Experiments</b><br>
<b> <br>IC Type 74194 </b><br>
 <br>This is a fourbit bidirectional shift register with parallel load. The internal logic is sim-<br>ilar to that shown in Fig. 6.7. The pin assignments to the inputs and outputs are shown <br>in  Fig.   9.19  . The two modecontrol inputs determine the type of operation, as specified <br>in the function table. <br>
<b> <br>Logic Diagram </b><br>
 <br>The logic diagram of the electronic lamp handball game is shown in  Fig.   9.20  . It consists <br>of two 74194 ICs, a dual  <i>D</i>  flipflop 7474 IC, and three gate ICs: the 7400, 7404, and <br>7408. The ball is simulated by a moving light that is shifted left or right through the <br>
Serial input<br>
for shift right<br>
2<br>
16<br>
<i>SIR VCC</i><br>
3<br>
15<br>
<i>A</i><br>
<i>QA</i><br>
4<br>
14<br>
<i>B</i><br>
<i>QB</i><br>
Data<br>
Parallel data<br>
5<br>
13<br>
outputs<br>
inputs<br>
<i>C</i><br>
<i>QC</i><br>
6<br>
12<br>
<i>D</i><br>
<i>QD</i><br>
74194<br>
10<br>
<i>S1</i><br>
Mode control<br>
9<br>
inputs<br>
<i>S0</i><br>
11<br>
Clock<br>
<i>CK</i><br>
1<br>
Clear<br>
<i>CLR</i><br>
<i>SIL GND</i><br>
7<br>
8<br>
Serial input<br>
for shift left<br>
Function table<br>
Mode<br>
Clear<br>
Clock<br>
<i>S</i>1<br>
<i>S</i>0<br>
Function<br>
0<br>
X<br>
X<br>
X<br>
Clear outputs to 0<br>
1<br>
0<br>
0<br>
No change in output<br>
1<br>
0<br>
1<br>
Shift right in the direction from<br><i>QA</i> to <i>QD</i>. <i>SIR</i> to <i>QA</i><br>
1<br>
1<br>
0<br>
Shift left in the direction from<br><i>QD</i> to <i>QA</i>. <i>SIL</i> to <i>QD</i><br>
1<br>
1<br>
1<br>
Parallel-load input data<br>
<b> <br>FIGURE 9.19   <br> <br>IC type 74194 bidirectional shift register with parallel load  </b><br>
<hr>
<A name=489></a>Indicator lamps<br>
<i>QA</i><br>
<i>QB</i><br>
<i>QC</i><br>
<i>QD</i><br>
<i>QA</i><br>
<i>QB</i><br>
<i>QC</i><br>
<i>QD</i><br>
<i>SIL</i><br>
<i>SIR</i><br>
<i>SIR</i><br>
74194<br>
74194<br>
<i>SIL</i><br>
<i>CLR</i><br>
<i>CLR</i><br>
<i>CK</i><br>
<i>A</i><br>
<i>B</i><br>
<i>C</i><br>
<i>D</i><br>
<i>S1</i><br>
<i>S0</i><br>
<i>S1</i><br>
<i>S0</i><br>
<i>A</i><br>
<i>B</i><br>
<i>C</i><br>
<i>D CK</i><br>
<i>CLK</i><br>
<i>PR</i><br>
<i>PR</i><br>
<i>D</i><br>
<i>Q</i><br>
<i>Q</i><br>
<i>D</i><br>
<i>CK</i><br>
<i>CK</i><br>
Pulser<br>
<i>Q</i><br>
<i>Q</i><br>
<i>CLR</i><br>
<i>CLR</i><br>
Reset<br>
Start<br>
<b> <br>FIGURE 9.20   <br> <br>Lamp handball logic diagram  </b><br>
<b>        471</b><br>
<hr>
<A name=490></a><b>472    Chapter 9  Laboratory Experiments</b><br>
bidirectional shift  register. The rate at which the light moves is determined by the fre-<br>quency of the clock. The  circuit is first initialized with the  <i>reset</i>  switch. The  <i>start</i>   switch <br>starts the game by placing the ball (an indicator lamp) at the extreme right. The player <br>must press the pulser push button to start the ball moving to the left. The single light <br>shifts to the left until it reaches the leftmost position (the wall), at which time the ball <br>returns to the player by reversing the direction of shift of the moving light. When the <br>light is again at the rightmost position, the player must press the pulser again to reverse <br>the direction of shift. If the player presses the pulser too soon or too late, the ball dis-<br>appears and the light goes off. The game can be restarted by turning the start switch <br>on and then off. The start switch must be open (logic 1) during the game. <br>
<b> <br>Circuit Analysis </b><br>
 <br>Prior to connecting the circuit, analyze the logic diagram to ensure that you understand <br>how the circuit operates. In particular, try to answer the following questions: <br>
 <br><b> 1. </b><br>
 <br>What is the function of the reset switch?  <br>
 <br><b> 2. </b><br>
 <br>How does the light in the rightmost position come on when the start switch is <br> <br>grounded? Why is it necessary to place the start switch in the logic1 position <br>before the game starts?  <br>
 <br><b> 3. </b><br>
 <br>What happens to the two modecontrol inputs,  <i>S1</i>  and  <i>S0</i>,  once the ball is set in <br>motion?  <br>
 <br><b> 4. </b><br>
 <br>What happens to the modecontrol inputs and to the ball if the pulser is pressed <br>while the ball is moving to the left? What happens if the ball is moving to the right, <br>but has not yet reached the rightmost position?  <br>
 <br><b> 5. </b><br>
 <br>If the ball has returned to the rightmost position, but the pulser has not yet been <br>pressed, what is the state of the modecontrol inputs if the pulser is pressed? What <br>happens if it is not pressed?  <br>
<b> <br>Playing the Game </b><br>
 <br>Wire the circuit of  Fig.   9.20  .Test the circuit for proper operation by playing the game. Note <br>that the pulser must provide a positiveedge transition and that both the reset and start <br> <br>switches must be open (i.e., must be in the logic1 state) during the game. Start with a low <br>clock rate, and increase the clock frequency to make the handball game more challenging. <br>
<b> <br>Counting the Number of Losses </b><br>
 <br>Design a circuit that keeps score of the number of times the player loses while playing <br>the game. Use a BCDtosevensegment decoder and a sevensegment display, as in <br> <br>Fig.  9.8  , to display the count from 0 through 9. Counting is done with either the 7493 as <br>a ripple  decimal counter or the 74161 and a NAND gate as a synchronous decimal <br>counter. The display should show 0 when the circuit is reset. Every time the ball disap-<br>pears and the light goes off, the display should increase by 1. If the light stays on during <br>the play, the number in the display should not change. The final design should be an <br>
<hr>
<A name=491></a><b>Section 9.16  Experiment 15: ClockPulse Generator    473</b><br>
automatic scoring circuit, with the decimal display incremented automatically each time <br>the player loses when the light  disappears. <br>
<b> <br>Lamp PingPongTM </b><br>
 <br>Modify the circuit of  Fig.   9.20   so as to obtain a lamp PingPong game. Two players can <br>participate in this game, with each player having his or her own pulser. The player with <br>the right pulser returns the ball when it is in the extreme right position, and the player <br>with the left pulser returns the ball when it is in the extreme left position. The only mod-<br>ification required for the PingPong game is a second pulser and a change of a few wires. <br>
 <br>With a second start circuit, the game can be made to start by either one of the two <br>
players (i.e., either one serves). This addition is optional. <br>
<b> <br>9 . 1 6       E X P E R I M E N T   1 5 :   C L O C K  P U L S E   G E N E R AT O R </b><br>
 <br>In this experiment, you will use an IC timer unit and connect it to produce clock pulses <br>at a given frequency. The circuit requires the connection of two external resistors and <br>two external capacitors. The cathoderay oscilloscope is used to observe the waveforms <br>and measure the frequency of the pulses. <br>
<b> <br>IC Timer </b><br>
 <br>IC type 72555 (or 555) is a precision timer circuit whose internal logic is shown in  Fig.   9.21 . <br>(The  resistors,     <i>RA</i>     and     <i>RB</i>,  and the two capacitors are not part of the IC.) The circuit con-<br>sists of two voltage comparators, a flipflop, and an internal transistor. The voltage division <br>from     <i>VCC </i>= 5 V  through the three internal resistors to ground produces   2     and     1 of  <i>V</i><br>
3<br>
3<br>
<i>CC</i> <br>
(3.3 V and 1.7 V, respectively) into the fixed inputs of the comparators. When the threshold <br>input at pin 6 goes above 3.3 V, the upper comparator resets the flipflop and the output <br>goes low to about 0 V. When the trigger input at pin 2 goes below 1.7 V, the lower com-<br>parator sets the flipflop and the output goes high to about 5 V. When the output is low, <br> <br><i>Q </i>  is high and the base�emitter junction of the transistor is forward biased. When the <br>output is high,   <i>Q </i>  is low and the transistor is cut off. (See Section 10.3.) The timer circuit <br>is capable of producing accurate time delays controlled by an external  <i>RC</i>  circuit. In this <br>experiment, the IC timer will be operated in the astable mode to produce clock pulses. <br>
<b> <br>Circuit Operation </b><br>
 <br>Figure   9.21   shows the external connections for astable operation of the circuit. Capacitor <br> <br><i>C</i>  charges through resistors   <i>RA</i>     and     <i>RB</i>  when the transistor is cut off and discharges through <br> <br><i>RB</i>  when the transistor is forward biased and conducting. When the charging voltage across <br>capacitor  <i>C</i>  reaches 3.3 V, the threshold input at pin 6 causes the flipflop to reset and the <br>transistor turns on. When the discharging voltage reaches 1.7 V, the trigger input at pin 2 <br>causes the flipflop to set and the transistor turns off. Thus, the output continually alternates <br>
<hr>
<A name=492></a><b>474    Chapter 9  Laboratory Experiments</b><br>
5 V<br>
0.01 f<br>
<i>VCC </i>8<br>
5<br>
Reset 4<br>
<i>RA</i><br>
6<br>
Threshold<br>
Compare<br>
<i>R</i><br>
<i>Q</i><br>
3<br>
<i>S</i><br>
<i>Q</i><br>
Output<br>
Compare<br>
2<br>
Trigger<br>
7<br>
Discharge<br>
72555 Timer<br>
<i>RB</i><br>
<i>GND </i>1<br>
<i>C</i><br>
<b> <br>FIGURE 9.21   <br> <br>IC type 72555 timer connected as a clockpulse generator  </b><br>
between two voltage levels at the output of the flipflop. The output remains high for a <br>duration equal to the charge time. This duration is determined from the equation <br>
 <br><i>tH </i>= 0.693(<i>RA </i>+ <i>RB</i>)<i>C</i> <br>
 <br>The output remains low for a duration equal to the discharge time. This duration is <br>determined from the equation <br>
 <br><i>tL </i>= 0.693<i>RBC</i> <br>
<b> <br>ClockPulse Generator </b><br>
 <br>Starting with a capacitor  <i>C</i>  of 0.001 F calculate values for   <i>RA</i>     and     <i>RB</i>     to  produce  clock <br> <br>pulses, as shown in  Fig.   9.22  . The pulse width is 1 s in the low level and repeats at a <br>
<hr>
<A name=493></a><b>Section 9.17    Experiment 16: Parallel Adder and Accumulator        475</b><br>
1 <i>S</i><br>
10 <i>S</i><br>
<b> <br>FIGURE 9.22   <br> <br>Output waveform for clock generator  </b><br>
frequency rate of 100 kHz (every 10 s). Connect the circuit and check the output in the <br>oscilloscope. <br>
 <br>Observe the output across the capacitor  <i>C,</i>  and record its two levels to verify that <br>
they are between the trigger and threshold values.  <br>
 <br>Observe the waveform in the collector of the transistor at pin 7 and record all perti-<br>
nent information. Explain the waveform by analyzing the circuit's action. <br>
 <br>Connect a variable resistor (potentiometer) in series with   <i>RA</i>  to produce a variable <br>
frequency pulse generator. The lowlevel duration remains at 1 s The frequency should <br>range from 20 to 100 kHz. <br>
 <br>Change the lowlevel pulses to highlevel pulses with a 7404 inverter. This will pro-<br>
duce positive pulses of 1 s with a variablefrequency range. <br>
<b> <br>9 . 1 7       E X P E R I M E N T   1 6 :   PA R A L L E L   A D D E R </b><br>
<b>A N D   A C C U M U L AT O R </b><br>
 <br>In this experiment, you will construct a fourbit parallel adder whose sum can be loaded <br>into a register. The numbers to be added will be stored in a RAM. A set of bi nary <br> <br>numbers will be selected from memory and their sum will be accumulated in the  register. <br>
<b> <br>Block Diagram </b><br>
 <br>Use the RAM circuit from the memory experiment of Section 9.14, a fourbit parallel <br>adder, a fourbit shift register with parallel load, a carry flipflop, and a multiplexer to <br>construct the circuit. The block diagram and the ICs to be used are shown in  Fig.   9.23  . <br>Information can be written into RAM from data in four switches or from the fourbit <br>data available in the outputs of the register. The selection is done by means of a multi-<br>plexer. The data in RAM can be added to the contents of the register and the sum <br>transferred back to the register. <br>
<b> <br>Control of Register </b><br>
 <br>Provide toggle switches to control the 74194 register and the 7476 carry flipflop as follows: <br>
 <br>
(a)<b>  </b> A LOAD condition transfers the sum to the register and the output carry to the <br>
flipflop upon the application of a clock pulse. <br>
<hr>
<A name=494></a><b>476    Chapter 9  Laboratory Experiments</b><br>
Address<br>
Count<br>
RAM<br>
MUX<br>
Select<br>
counter<br>
(pulser)<br>
(74189)<br>
(74157)<br>
(switch)<br>
(7493)<br>
4 switches<br>
Inverters<br>
(7404)<br>
Output carry<br>
4-bit adder<br>
(7483)<br>
Sum<br>
Carry<br>
Register<br>
(7476)<br>
(74194)<br>
<b> <br>FIGURE 9.23   <br> <br>Block diagram of a parallel adder for Experiment 16  </b><br>
 <br>
(b)<b>  </b> A SHIFT condition shifts the register right with the carry from the carry flip<br>
flop transferred into the leftmost position of the register upon the application <br>of a clock pulse. The value in the carry flipflop should not change during the <br>shift.  <br>
 <br>
(c)<b>  </b> A NOCHANGE condition leaves the contents of the register and flipflop <br>
unchanged even when clock pulses are applied. <br>
<b> <br>Carry Circuit </b><br>
 <br>To conform with the preceding specifications, it is necessary to provide a circuit between <br>the output carry from the adder and the  <i>J</i>  and  <i>K</i>  inputs of the 7476 flipflop so that the <br>output carry is transferred into the flipflop (whether it is equal to 0 or 1) only when the <br>LOAD condition is activated and a pulse is applied to the clock input of the flipflop. <br>The carry flipflop should not change if the LOAD condition is disabled or the SHIFT <br>condition is enabled. <br>
<hr>
<A name=495></a><b>Section 9.17    Experiment 16: Parallel Adder and Accumulator        477</b><br>
<b> <br>Detailed Circuit </b><br>
 <br>Draw a detailed diagram showing all the wiring between the ICs. Connect the circuit, <br>and provide indicator lamps for the outputs of the register and carry flipflop and for <br>the address and output data of the RAM. <br>
<b> <br>Checking the Circuit </b><br>
 <br>Store the numbers 0110, 1110, 1101, 0101, and 0011 in RAM and then add them to the <br>register one at a time. Start with a cleared register and flipflop. Predict the values in <br>the output of the register and carry after each addition in the following sum, and verify <br>your results: <br>
   <br>0110 + 1110 + 1101 + 0101 + 0011    <br>
<b> <br>Circuit Operation </b><br>
 <br>Clear the register and the carry flipflop to zero, and store the following fourbit num-<br>bers in RAM in the indicated addresses: <br>
<b>  Address  </b><br>
<b>  Content  </b><br>
   0 <br>
 0110 <br>
   3 <br>
 1110 <br>
   6 <br>
 1101 <br>
   9 <br>
 0101 <br>
 12 <br>
 0011 <br>
 <br>Now perform the following four operations: <br>
 <br><b> 1. </b><br>
 <br>Add the contents of address 0 to the contents of the register, using the LOAD <br>condition.  <br>
 <br><b> 2. </b><br>
 <br>Store the sum from the register into RAM at address 1. <br>
 <br><b> 3. </b><br>
 <br>Shift right the contents of the register and carry with the SHIFT condition. <br>
 <br><b> 4. </b><br>
 <br>Store the shifted contents of the register at address 2 of RAM. <br>
 <br>Check that the contents of the first three locations in RAM are as follows: <br>
<b>  Address  </b><br>
<b>  Contents  </b><br>
 0 <br>
 0110 <br>
 1 <br>
 0110 <br>
 2 <br>
 0011 <br>
 <br>Repeat the foregoing four operations for each of the other four binary numbers <br>
stored in RAM. Use addresses 4, 7, 10, and 13 to store the sum from the register in step 2. <br>
<hr>
<A name=496></a><b>478    Chapter 9  Laboratory Experiments</b><br>
Use addresses 5, 8, 11, and 14 to store the shifted value from the register in step 4. Predict <br>what the contents of RAM at addresses 0 through 14 would be, and check to verify your <br>results.   <br>
<b> <br>9 . 1 8       E X P E R I M E N T   1 7 :   B I N A R Y   M U L T I P L I E R </b><br>
 <br>In this experiment, you will design and construct a circuit that multiplies 2 fourbit <br>unsigned numbers to produce an eightbit product. An algorithm for multiplying two <br>binary numbers is  presented in Section 8.7. The algorithm implemented in this experi-<br>ment differs from the one described in Figs. 8.14 and 8.15, by treating only a fourbit <br>datapath and by incrementing, instead of decrementing, a bit  counter. <br>
<b> <br>Block Diagram </b><br>
 <br>The ASMD chart and block diagram of the binary multiplier with those ICs recom-<br>mended to be used are shown in  Fig.   9.24  (a) and (b). The multiplicand,  <i>B</i>,  is available <br>from four  switches instead of a register. The multiplier,  <i>Q</i>,  is obtained from another set <br>of four switches. The product is displayed with eight indicator lamps. Counter  <i>P</i>   is <br>initialized to 0 and then incremented after each partial product is formed. When the <br>counter reaches the count of four, output <i>Done</i> becomes 1 and the multiplication <br>operation terminates. <br>
<b> <br>Control of Registers </b><br>
 <br>The ASMD chart for the binary multiplier in  Fig.   9.24  (a) shows that the three registers <br>and the carry flipflop of the datapath unit are controlled with signals  <i>Load_regs, <br>Incr_P, Add_regs</i>,  and  <i>Shift_regs</i> . The external input signals of the control unit are <br> <br><i>clock,</i>  <i>reset_b</i>  (activelow), and  <i>Start</i> ; another input to the control unit is the internal <br>status signal,  <i>Done</i>,  which is formed by the datapath unit to indicate that the counter <br>has reached a count of four, corresponding to the number of bits in the multiplier. <br> <br><i>Load_regs</i>  clears the product register ( <i>A</i> ) and the carry flipflop ( <i>C</i> ), loads the mul-<br>tiplicand into register  <i>B</i>,  loads the multiplier into register  <i>Q</i>,  and clears the bit coun-<br>ter.  <i>Incr_P</i>  increments the bit counter concurrently with the accumulation of a partial <br>product.  <i>Add_regs</i>  adds the multiplicand to  <i>A</i>,  if the least significant bit of the shifted <br> multiplier  (Q <i>[0]</i> ) is 1. Flipflop  <i>C</i>  accommodates a carry that results from the addition. <br>The  concatenated register  <i>CAQ</i>  is updated by storing the result of shifting its contents <br>one bit to the right.  <i>Shift_regs</i>  shifts  <i>CAQ</i>  one bit to the right, which also clears flip<br>flop  <i>C</i> . <br>
 <br>The state diagram for the control unit is shown in  Fig.   9.24  (c). Note that it does not <br>
show the register operations of the datapath unit or the output signals that control <br>them. That information is apparent in  Fig.   9.24  (d). Note that  <i>Incr_P</i>   and   <i>Shift_regs</i>   are <br>generated unconditionally in states  <i>S_add</i>  and  <i>S_shift</i>,  respectively.  <i>Load_regs</i>   is <br>
<hr>
<A name=497></a><b>Section 9.18  Experiment 17: Binary Multiplier    479</b><br>
 <br>generated under the condition that  <i>Start</i>  is asserted conditionally while the state is in <br> <br><i>S_idle</i> ;   <i>Add_regs</i>  is asserted conditionally in  <i>S_add</i>  if  <i>Q[0]</i>  = 1. <br>
<b> <br>Multiplication Example </b><br>
 <br>Before connecting the circuit, make sure that you understand the operation of the <br>multiplier. To do this, construct a table similar to Table 8.5, but with   <i>B </i>= 1111     for the <br>multiplicand and   <i>Q </i>= 1011     for the multiplier. Along with each comment listed on <br>the left side of the table, specify the state. <br>
<b> <br>Datapath Design </b><br>
 <br>Draw a detailed diagram of the datapath part of the multiplier, showing all IC pin con-<br>nections. Generate the four control signals with switches, and use them to provide the <br>required control operations for the various registers. Connect the circuit and check that <br>each component is functioning properly. With the control signals at 0, set the multipli-<br>cand switches to 1111 and the multiplier switches to 1011. Assert the control signals <br>manually by means of the control switches, as specified by the state diagram of <br> <br>Fig.  9.24  (c). Apply a single pulse while in each control state, and observe the outputs of <br>registers  <i>A</i>  and  <i>Q</i>  and the values in  <i>C</i>   and     <i>P</i>.  Compare these outputs with the numbers <br>in your numerical example to verify that the circuit is functioning properly. Note that IC <br>type 74161 has master�slave flipflops. To operate it manually, it is necessary that the <br>single clock pulse be a negative pulse. <br>
<b> <br>Design of Control </b><br>
 <br>Design the control circuit specified by the state diagram. You can use any method of <br>control implementation discussed in Section 8.8. <br>
 <br>Choose the method that minimizes the number of ICs. Verify the operation of the <br>
control circuit prior to its connection to the datapath unit. <br>
<b> <br>Checking the Multiplier </b><br>
 <br>Connect the outputs of the control circuit to the datapath unit, and verify the total circuit <br>operation by repeating the steps of multiplying 1111 by 1011. The single clock pulses <br>should now sequence the control states as well. (Remove the manual switches.) The start <br>signal ( <i>Start</i> ) can be generated with a switch that is on while the control is in state   <i>S</i>_<i>idle</i>.    <br>
 <br>Generate the start signal ( <i>Start</i> ) with a pulser or any other short pulse, and operate the <br>
multiplier with continuous clock pulses from a clock generator. Pressing the pulser for <br> <br><i>Start</i>  should initiate the multiplication operation, and upon its completion, the product <br>should be displayed in the  <i>A</i>  and  <i>Q</i>  registers. Note that the multiplication will be repeated <br>as long as signal  <i>Start</i>  is enabled. Make sure that  <i>Start</i>  goes back to 0. Then set the switches <br>to two other fourbit  numbers and press  <i>Start</i>  again. The new product should appear at the <br>outputs. Repeat the multiplication of a few numbers to verify the operation of the circuit. <br>
<hr>
<A name=498></a><b>480    Chapter 9  Laboratory Experiments</b><br>
<i>reset</i><br>
<i>S_idle</i><br>
<i>Ready</i><br>
<i>A</i><br>
 0<br>
<i>C</i><br>
 0<br>
<i>B</i><br>
<i>Multiplicand</i><br>
<i>Start</i><br>
<i>Q</i><br>
<i>Multiplier</i><br>
1<br>
<i>P</i><br>
 0<br>
<i>Load_regs</i><br>
<i>S_add<br>Incr_P</i><br>
<i>P</i><br>
<i> P </i>1<br>
1<br>
<i>{C, A} </i><br>
<i> A   B</i><br>
<i>Q[0]</i><br>
<i>Add_regs</i><br>
<i>S_shift<br>Shift_regs</i><br>
<i>{C, A, Q} </i><br>
<i> {C, A, Q} </i><br>
1<br>
<i>Done</i><br>
1<br>
(a) ASMD chart<br>
<b> <br></b> <br><b>FIGURE 9.24   <br> <br>ASMD chart, block diagram of the datapath, control state diagram, and register <br>operations of the binary multiplier circuit  </b><br>
<b> <br>9 . 1 9       V E R I L O G   H D L   S I M U L AT I O N   E X P E R I M E N T S </b><br>
<b>A N D   R A P I D   P R O T O T Y P I N G   W I T H   F P G A S </b><br>
 <br>Field programmable gate arrays (FPGAs) are used by industry to implement logic when <br>the system is complex, the timetomarket is short, the performance (e.g., speed) of an <br>FPGA is acceptable, and the volume of potential sales does not warrant the investment <br>in a standard cellbased ASIC. Circuits can be rapidly prototyped into an FPGA using an <br>
<hr>
<A name=499></a><b>Section 9.19  Verilog HDL Simulation Experiments    481</b><br>
Multiplicand <i>B</i><br>
(4 switches)<br>
<i>Done</i><br>
 1 on count of 4<br>
Counter <i>P</i><br>
(74161)<br>
<i>C</i>out<br>
Parallel adder<br>
(7483)<br>
Multiplier <i>Q</i><br>
(4 switches)<br>
<i>C</i><br>
Register <i>A</i><br>
Register <i>Q</i><br>
(7474)<br>
(74194)<br>
(74194)<br>
<i>Q</i>0<br>
(b) Datapath block program<br>
<i>Done</i><br>
 1<br>
<i>Start</i><br>
 0<br>
<i>S_idle</i><br>
<i>S_add</i><br>
<i>S_shift</i><br>
<i>Start</i><br>
 1<br>
<i>Done</i><br>
 0<br>
(c) Control state diagram<br>
State Transition<br>
Register Operations<br>
Control signal<br>
From<br>
To<br>
<i>S_idle</i><br>
Initial state reached by reset action<br>
<i>S_idle</i><br>
<i>S_add</i><br>
<i>A</i><br>
 0, <i>C</i><br>
 0, <i>P</i><br>
 0<br>
<i>Load_regs</i><br>
<i>S_add</i><br>
<i>S_shift</i><br>
<i>P</i><br>
= <i>P</i><br>
 1<br>
<i>Incr_P</i><br>
if (<i>Q[0]</i>) then (<i>A</i><br>
<i>A</i><br>
<i>B</i>, <i>C</i><br>
<i>C</i><br>
<i>Add_regs</i><br>
out)<br>
<i>S_shift</i><br>
shift right {<i>CAQ</i>}, <i>C</i> &lt;  0<br>
<i>Shift_regs</i><br>
(d) Register operations<br>
<b>FIGURE 9.24 <br>(<i>Continued </i>) </b><br>
<hr>
<A name=500></a><b>482    Chapter 9  Laboratory Experiments</b><br>
HDL. Once the HDL model is verified, the description is synthesized and mapped into <br>the FPGA. FPGA vendors provide software tools for synthesizing the HDL description <br>of a circuit into an optimized gatelevel description and mapping (fitting) the resulting <br>netlist into the resources of their FPGA. This process avoids the detailed assembly of ICs <br>that is required by composing a circuit on a breadboard, and the process involves sig-<br>nificantly less risk of failure, because it is easier and faster to edit an HDL description <br>than to rewire a breadboard. <br>
 <br>Most of the hardware experiments outlined in this chapter can be supplemented by <br>
a corresponding software procedure using the Verilog hardware description language <br>(HDL). A Verilog compiler and simulator are necessary for these supplements. The <br>supplemental experiments have two levels of engagement. In the first, the circuits that <br>are specified in the handson  laboratory experiments can be described, simulated, and <br>verified using Verilog and a simulator. In the second, if a suitable FPGA prototyping <br>board is available (e.g., see www.digilentinc.com), the hardware experiments can be <br>done by synthesizing the Verilog descriptions and implementing the circuits in an FPGA. <br>Where appropriate, the identity of the individual (structural) hardware units (e.g., a 4bit <br>counter) can be preserved by encapsulating them in separate Verilog modules whose <br>internal detail is described behaviorally or by a mixture of behavioral and structural <br>models. <br>
 <br>Prototyping a circuit with an FPGA requires synthesizing a Verilog description to <br>
produce a bit stream that can be downloaded to configure the internal resources <br>(e.g., CLBS of a  Xilinx FPGA) and connectivity of the FPGA. Three details require <br>attention: (1) The pins of the prototyping board are connected to the pins of the FPGA, <br>and the hardware implementation of the synthesized circuit requires that its input and <br>output signals be associated with the pins of the prototyping board (this association is <br>made using the synthesis tool  provided by the vendor of the FPGA (such tools are avail-<br>able free)), (2) FPGA prototyping boards have a clock generator, but it will be necessary, <br>in some cases, to implement a clock divider (in Verilog) to obtain an internal clock <br>whose frequency is suitable for the experiment, and (3) inputs to an FPGAbased circuit <br>can be made using switches and pushbuttons located on the prototyping board, but it <br>might be necessary to implement a pulser circuit in software to control and observe the <br>activity of a counter or a state machine (see the supplement to  Experiment 1). <br>
<b> <br>Supplement to Experiment 1 (Section 9.2) </b><br>
 <br>The functionality of the counters specified in Experiment 1 can be described in Verilog <br>and synthesized for implementation in an FPGA. Note that the circuit shown in  Fig.   9.3  <br>uses a pushbutton pulser or a clock to cause the count to increment in a circuit built <br>with standard ICs. A software pulser circuit can be developed to work with a switch on <br>the prototyping board of an FPGA so that the operation of the counters can be verified <br>by visual inspection. <br>
 <br>The software pulser has the ASM chart shown in  Fig.   9.25  , where the external input <br>
( <i>Pushed</i> ) is obtained from a mechanical switch or pushbutton. This circuit asserts  <i>Start</i> <br>for one cycle of the clock and then waits for the switch to be opened (or the pushbutton <br>
<hr>
<A name=501></a><b>Section 9.19  Verilog HDL Simulation Experiments    483</b><br>
<i>reset_b</i><br>
<i>S_idle</i><br>
<i>pushed</i><br>
1<br>
<i>S_ pulse<br>Start</i><br>
<i>A</i>2<br>
<i>S_wait</i><br>
1<br>
<i>Pushed</i><br>
<b> <br>FIGURE 9.25   <br> <br>Pulser circuit for FPGA implementation of Experiment 1  </b><br>
to be released) to ensure that each action of the switch or pushbutton will produce only <br>one pulse of  <i>Start</i> . If the counter, or a state machine, is in the reset state ( <i>S_idle</i> )  when <br>the switch is closed, the pulse will launch the  activity of the counter or state machine. It <br>will be necessary to open the switch (or release the pushbutton) before  <i>Start</i>  can be <br>reasserted. Using the software pulser will allow each value of the count to be observed. <br>If necessary, a simple synchronizer circuit can be used with  <i>Pushed</i> .  <br>
<b> <br>Supplement to Experiment 2 (Section 9.3) </b><br>
 <br>The various logic gates and their propagation delays were introduced in the hardware <br>experiment. In Section 3.10, a simple circuit with gate delays was investigated. As an <br>introduction to the laboratory Verilog program, compile the circuit described in HDL <br>Example 3.3 and then run the simulator to verify the waveforms shown in Fig. 3.38. <br>
 <br>Assign the following delays to the exclusiveOR circuit shown in Fig. 3.32(a): 10 ns <br>
for an inverter, 20 ns for an AND gate, and 30 ns for an OR gate. The input of the circuit <br>goes from   <i>xy </i>= 00 to  <i>xy </i>= 01.    <br>
 <br>
(a)<b>  </b> Determine the signals at the output of each gate from   <i>t </i>= 0     to     <i>t </i>= 50  ns.     <br>
 <br>
(b)<b>  </b> Write the HDL description of the circuit including the delays. <br>
<hr>
<A name=502></a><b>484    Chapter 9  Laboratory Experiments</b><br>
 <br>
(c)<b>  </b> Write a stimulus module (similar to HDL Example 3.3) and simulate the circuit <br>
to  verify the answer in part (a). <br>
 <br>
(d)<b>  </b> Implement the circuit with an FPGA and test its operation. <br>
<b> <br>Supplement to Experiment 4 (Section 9.5) </b><br>
 <br>The operation of a combinational circuit is verified by checking the output and compar-<br>ing it with the truth table for the circuit. HDL Example 4.10 (Section 4.12) demonstrates <br>the procedure for obtaining the truth table of a combinational circuit by simulating it. <br>
 <br>
(a)<b>  </b> In order to get acquainted with this procedure, compile and simulate HDL <br>
Example 4.10 and check the output truth table. <br>
 <br>
(b)<b>  </b> In Experiment 4, you designed a majority logic circuit. Write the HDL gatelevel <br>
description of the majority logic circuit together with a stimulus for displaying the <br>truth table. Compile and simulate the circuit and check the output response. <br>
 <br>
(c)<b>  </b> Implement the majority logic circuit units in an FPGA and test its operation. <br>
<b> <br>Supplement to Experiment 5 (Section 9.6) </b><br>
 <br>This experiment deals with code conversion. A BCDtoexcess3 converter was designed <br>in Section 4.4. Use the result of the design to check it with an HDL simulator. <br>
 <br>
(a)<b>  </b> Write an HDL gatelevel description of the circuit shown in Fig. 4.4. <br>
 <br>
(b)<b>  </b> Write a dataflow description using the Boolean expressions listed in Fig. 4.3. <br>
 <br>
(c)<b>  </b> Write an HDL behavioral description of a BCDtoexcess3 converter. <br>
 <br>
(d)<b>  </b> Write a test bench to simulate and test the BCDtoexcess3 converter circuit in <br>
order to verify the truth table. Check all three circuits. <br>
 <br>
(e)<b>  </b> Implement the behavioral description with an FPGA and test the operation of the <br>
circuit.    <br>
<b> <br>Supplement to Experiment 7 (Section 9.8) </b><br>
 <br>A fourbit adder�subtractor is developed in this experiment. An adder�subtractor cir-<br>cuit is also developed in Section 4.5. <br>
 <br>
(a)<b>  </b> Write the HDL behavioral description of the 7483 fourbit adder. <br>
 <br>
(b)<b>  </b> Write a behavioral description of the adder�subtractor circuit shown in  Fig.   9.11 . <br>
 <br>
(c)<b>  </b> Write the HDL hierarchical description of the fourbit adder�subtractor shown in <br>
Fig. 4.13 (including V). This can be done by instantiating a modified version of the <br>fourbit adder described in HDL Example 4.2 (Section 4.12). <br>
 <br>
(d)<b>  </b> Write an HDL test bench to simulate and test the circuits of part (c). Check and <br>
verify the values that cause an overflow with   <i>V </i>= 1. <br>
 <br>
(e)<b>  </b> Implement the circuit of part (c) with an FPGA and test its operation. <br>
<hr>
<A name=503></a><b>Section 9.19  Verilog HDL Simulation Experiments    485</b><br>
<b> <br>Supplement to Experiment 8 (Section 9.9) </b><br>
 <br>The edgetriggered  <i>D</i>  flipflop 7474 is shown in  Fig.   9.13  . The flipflop has asynchronous <br>preset and clear inputs. <br>
 <br>
(a)<b>  </b> Write an HDL behavioral description of the 7474  <i>D</i>  flipflop, using only the  <i>Q</i> <br>
output. (Note that when   <i>Preset </i>= 0,   <i>Q</i>  goes to 1, and when   <i>Preset </i>= 1     and <br> <br><i>Clear </i>= 0,  <i>Q</i>  goes to 0. Thus,  <i>Preset</i>  takes precedence over  <i>Clear</i> .)  <br>
 <br>
(b)<b>  </b> Write an HDL behavioral description of the 7474  <i>D</i>  flipflop, using both outputs. <br>
Label the second output  <i>Q_not,</i>  and note that this is not always the complement <br>of Q. (When   <i>Preset </i>= <i>Clear </i>= 0,     both   <i>Q</i>  and  <i>Q_not</i>   go  to  1.)    <br>
<b> <br>Supplement to Experiment 9 (Section 9.10) </b><br>
 <br>In this hardware experiment, you are asked to design and test a sequential circuit whose <br>state diagram is given by  Fig.   9.14  . This is a Mealy model sequential circuit similar to the <br>one  described in HDL Example 5.5 (Section 5.6). <br>
 <br>
(a)<b>  </b> Write the HDL description of the state diagram of  Fig.   9.14  . <br>
 <br>
(b)<b>  </b> Write the HDL structural description of the sequential circuit obtained from the <br>
design. (This is similar to HDL Example 5.7 in Section 5.6.)  <br>
 <br>
(c)<b>  </b> Figure   9.24  (c) (Section 9.18) shows a control state diagram. Write the HDL descrip-<br>
tion of the state diagram, using the onehot binary assignment (see Table 5.9 in <br>Section 5.7) and four outputs--  <i>T</i>0, <i>T</i>1, <i>T</i>2,     and     <i>T</i>3 . <br>
 <br>
(d)<b>  </b> Write a behavioral model of the datapath unit, and verify that the interconnected <br>
control unit and datapath unit operate correctly. <br>
 <br>
(e)<b>  </b> Implement the integrated circuit with an FPGA and test its operation. <br>
<b> <br>Supplement to Experiment 10 (Section 9.11) </b><br>
 <br>The synchronous counter with parallel load IC type 74161 is shown in  Fig.   9.15  . This <br>circuit is similar to the one described in HDL Example 6.3 (Section 6.6), with two excep-<br>tions: The load input is enabled when equal to 0, and there are two inputs ( <i>P</i>  and  <i>T</i> )  that <br>control the count. Write the HDL description of the 74161 IC. Implement the counter <br>with an FPGA and test its operation. <br>
<b> <br>Supplement to Experiment 11 (Section 9.12) </b><br>
 <br>A bidirectional shift register with parallel load is designed in this experiment by using <br>the 74195 and 74157 IC types. <br>
 <br>
(a)<b>  </b> Write the HDL description of the 74195 shift register. Assume that inputs  <i>J</i>   and     <i>K</i> <br>
are connected together to form the serial input. <br>
 <br>
(b)<b>  </b> Write the HDL description of the 74157 multiplexer. <br>
<hr>
<A name=504></a><b>486    Chapter 9  Laboratory Experiments</b><br>
 <br>
(c)<b>  </b> Obtain the HDL description of the fourbit bidirectional shift register that has <br>
been designed in this experiment. (1) Write the structural description by instanti-<br>ating the two ICs and specifying their interconnection, and (2) write the behav-<br>ioral description of the circuit, using the function table that is derived in this design <br>experiment.  <br>
 <br>
(d)<b>  </b> Implement the circuit with an FPGA and test its operation. <br>
<b> <br>Supplement to Experiment 13 (Section 9.14) </b><br>
 <br>This experiment investigates the operation of a randomaccess memory (RAM). The <br>way a memory is described in HDL is explained in Section 7.2 in conjunction with HDL <br>Example 7.1. <br>
 <br>
(a)<b>  </b> Write the HDL description of IC type 74189 RAM, shown in  Fig.   9.18  . <br>
 <br>
(b)<b>  </b> Test the operation of the memory by writing a stimulus program that stores bi-<br>
nary 3 in address 0 and binary 1 in address 14. Then read the stored numbers from <br>the two addresses to check whether the numbers were stored correctly. <br>
 <br>
(c)<b>  </b> Implement the RAM with an FPGA and test its operation. <br>
<b> <br>Supplement to Experiment 14 (Section 9.15) </b><br>
 <br>
(a)<b>  </b> Write the HDL behavioral description of the 74194 bidirectional shift register with <br>
parallel  load  shown  in   Fig.    9.19   .  <br>
 <br>
(b)<b>  </b> Implement the shift register with an FPGA and test its operation. <br>
<b> <br>Supplement to Experiment 16 (Section 9.17) </b><br>
 <br>A parallel adder with an accumulator register and a memory unit is shown in the block <br>diagram of  Fig.   9.23  . Write the structural description of the circuit specified by the <br>block  diagram. The HDL structural description of this circuit can be obtained by <br>instantiating the various components. An example of a structural description of a <br>design can be found in HDL Example 8.4 in Section 8.6. First, it is necessary to write <br>the behavioral description of each component. Use counter 74161 instead of 7493, and <br>substitute the  <i>D</i>  flipflop 7474 instead of the  <i>JK</i>  flipflop 7476. The block diagram of <br>the various components can be found from the list in  Table   9.1 . Write a test bench for <br>each model, and then write a test bench to verify the entire design. Implement the <br>circuit with an FPGA and test its operation. <br>
<b> <br>Supplement to Experiment 17 (Section 9.18) </b><br>
 <br>The block diagram of a fourbit binary multiplier is shown in  Fig.   9.24  . The multiplier <br>can be described in one of two ways: (1) by using the register transfer level statements <br>listed in part (b) of the figure or (2) by using the block diagram shown in part (a) of the <br>
<hr>
<A name=505></a><b>Section 9.19  Verilog HDL Simulation Experiments    487</b><br>
figure. The description of the multiplier in terms of the register transfer level (RTL) <br>format is carried out in HDL Example 8.5 (Section 8.7). <br>
 <br>
(a)<b>  </b> Use the integrated circuit components specified in the block diagram to write the <br>
HDL structural description of the binary multiplier. The structural description is <br>obtained by using the module description of each component and then instantiating <br>all the components to show how they are interconnected. (See Section 8.5 for an <br>example.) The HDL descriptions of the components may be available from the <br>solutions to previous experiments. The 7483 is described with a solution to <br>Experiment 7(a), the 7474 with Experiment 8(a), the 74161 with Experiment 10, <br>and the 74194 with Experiment 14. The description of the control is available from <br>a solution to Experiment 9(c). Be sure to verify each structural unit before <br>attempting to verify the multiplier. <br>
 <br>
(b)<b>  </b> Implement the binary multiplier with an FPGA. Use the pulser described in the <br>
supplement  to  Experiment  1.           <br>
<hr>
<A name=506></a> <br>Chapter 10 <br>
<b> <br>Standard Graphic Symbols </b> <br>
<b> <br>1 0 . 1       R E C TA N G U L A R  S H A P E   S Y M B O L S </b><br>
 <br>Digital components such as gates, decoders, multiplexers, and registers are available <br>commercially in integrated circuits and are classified as SSI or MSI circuits. Standard <br>graphic symbols have been developed for these and other components so that the user <br>can recognize each function from the unique graphic symbol assigned to it. This stan-<br>dard, known as ANSI/IEEE Std. 911984, has been approved by industry, government, <br>and professional organizations and is consistent with international standards. <br>
 <br>The standard uses a rectangularshape outline to represent each particular logic func-<br>
tion. Within the outline, there is a general qualifying symbol denoting the logical operation <br>performed by the unit. For example, the general qualifying symbol for a multiplexer is <br>MUX. The size of the outline is arbitrary and can be either a square or a rectangular shape <br>with an arbitrary length�width ratio. Input lines are placed on the left and output lines are <br>placed on the right. If the direction of signal flow is reversed, it must be indicated by arrows. <br>
 <br>The rectangularshape graphic symbols for SSI gates are shown in  Fig.   10.1  . The <br>
qualifying symbol for the AND gate is the ampersand (&amp;). The OR gate has the qualify-<br>ing symbol that designates greater than or equal to 1, indicating that at least one input <br>must be active for the output to be active. The symbol for the buffer gate is 1, showing <br>that only one input is present. The exclusiveOR symbol designates the fact that only <br>one input must be active for the output to be active. The inclusion of the logic negation <br>small circle in the output converts the gates to their complement values. Although the <br>rectangularshape symbols for the gates are recommended, the standard also recognizes <br>the distinctiveshape symbols for the gates shown in Fig. 2.5. <br>
 <br>An example of an MSI standard graphic symbol is the fourbit parallel adder shown <br>
in  Fig.   10.2  . The qualifying symbol for an adder is the Greek letter  . The preferred <br>
<b>488</b><br>
<hr>
<A name=507></a><b>Section 10.1  RectangularShape Symbols    489</b><br>
&amp;<br>
1<br>
1<br>
1<br>
AND<br>
OR<br>
Buffer<br>
XOR<br>
&amp;<br>
1<br>
1<br>
1<br>
NAND<br>
NOR<br>
Inverter<br>
XNOR<br>
 <br><b>FIGURE 10.1   <br> <br>Rectangularshape graphic symbols for gates  </b><br>
10<br>
<i>A</i>1<br>
0<br>
8<br>
<i>A</i>2<br>
3<br>
<i>P</i><br>
9<br>
<i>A</i>3<br>
<i>S</i>1<br>
0<br>
1<br>
6<br>
<i>A</i>4<br>
3<br>
<i>S</i>2<br>
11<br>
2<br>
<i>B</i>1<br>
0<br>
<i>S</i>3<br>
7<br>
15<br>
<i>B</i>2<br>
3<br>
<i>S</i>4<br>
4<br>
<i>Q</i><br>
<i>B</i>3<br>
16<br>
<i>B</i>4<br>
3<br>
13<br>
14<br>
<i>CI</i><br>
<i>CI</i><br>
<i>CO</i><br>
<i>CO</i><br>
 <br><b>FIGURE 10.2   <br> <br>Standard graphic symbol for a fourbit parallel adder, IC type 7483  </b><br>
letters for the arithmetic operands are  <i>P</i>  and  <i>Q</i> . The bitgrouping symbols in the two <br>types of inputs and the sum  output are the decimal equivalents of the weights of the <br>bits to the power of 2. Thus, the input labeled 3 corresponds to the value of 2 3 = 8. The <br>input carry is designated by  <i>CI</i>  and the output carry by  <i>CO</i> . When the digital compo-<br>nent represented by the outline is also a commercial integrated circuit, it is customary <br>to write the IC pin number along each input and output. Thus, IC type 7483 is a fourbit <br>adder with lookahead carry. It is enclosed in a package with 16 pins. The pin numbers <br>
<hr>
<A name=508></a><b>490    Chapter 10  Standard Graphic Symbols</b><br>
for the nine inputs and five outputs are shown in  Fig.   10.2  . The other two pins are for <br>the power supply. <br>
 <br>Before introducing the graphic symbols of other components, it is necessary to review <br>
some terminology. As mentioned in Section 2.8, a positivelogic system defines the more <br>positive of two signal levels (designated by  <i>H</i> ) as logic 1 and the more negative signal <br>level (designated by  <i>L</i> ) as logic 0. Negative logic assumes the opposite assignment. <br>A third alternative is to employ a mixedlogic convention, where the signals are consid-<br>ered entirely in terms of their  <i>H</i>  and  <i>L</i>  values. At any point in the circuit, the user is <br>allowed to define the logic polarity by assigning logic 1 to either the  <i>H</i>  or  <i>L</i>   signal.  The <br>mixedlogic notation uses a small rightangletriangle graphic symbol to designate a <br>negativelogic polarity at any input or output terminal. (See Fig. 2.10(f).) <br>
 <br>Integratedcircuit manufacturers specify the operation of integrated circuits in terms of <br>
 <br><i>H</i>  and  <i>L</i>  signals. When an input or output is considered in terms of positive logic, it is defined <br>as  <i>active high</i> . When it is considered in terms of negative logic, it is defined as  <i>active low</i> .  <br> <br>Activelow inputs or outputs are recognized by the presence of the smalltriangle polarity <br>indicator symbol. When positive logic is used exclusively throughout the entire system, the <br>smalltriangle polarity symbol is equivalent to the small circle that designates negation. In <br>this book, we have assumed positive logic throughout and employed the small circle when <br>drawing logic diagrams. When an input or output line does not include the small circle, we <br>define it to be active if it is logic 1. An input or output that includes the smallcircle symbol <br>is considered active if it is in the logic0 state. However, we will use the smalltriangle <br>polarity symbol to indicate activelow assignment in all drawings that represent standard <br>diagrams. This will conform with integratedcircuit data books, where the polarity symbol <br>is usually employed. Note that the bottom four gates in  Fig.  10.1   could have been drawn <br>with a small triangle in the output lines instead of a small circle. <br>
 <br>Another example of a graphic symbol for an MSI circuit is shown in  Fig.   10.3  . This <br>
is a 2to4line decoder representing onehalf of IC type 74155. Inputs are on the left <br>and outputs on the right. The identifying symbol  <i>X/Y</i>  indicates that the circuit converts <br>from code  <i>X</i>  to code  <i>Y</i> . Data inputs  <i>A</i>   and   <i>B</i>  are assigned binary weights 1 and 2 <br>equivalent to 2 0  and 2 1 , respectively. The outputs are assigned numbers from 0 to 3, <br>corresponding to outputs  <i>D</i> 0  through  <i>D</i> 3 , respectively. The decoder has one activelow <br>input  <i>E</i> 1  and one activehigh input  <i>E</i> 2 . These two inputs go through an internal AND <br>
<i>X</i>/<i>Y</i><br>
13<br>
<i>A</i><br>
1<br>
7<br>
3<br>
0<br>
<i>D</i>0<br>
<i>B</i><br>
2<br>
6<br>
1<br>
<i>D</i>1<br>
5<br>
2<br>
2<br>
<i>D</i>2<br>
<i>E</i>1<br>
4<br>
1<br>
&amp;<br>
<i>EN</i><br>
3<br>
<i>D</i>3<br>
<i>E</i>2<br>
 <br><b>FIGURE 10.3   <br> <br>Standard graphic symbol for a 2to4line decoder (onehalf of IC type 74155)  </b><br>
<hr>
<A name=509></a><b>Section 10.2  Qualifying Symbols    491</b><br>
gate to enable the decoder. The output of the AND gate is labeled  <i>EN</i>  (enable) and is <br>activated when  <i>E</i> 1  is at a lowlevel state and  <i>E</i> 2  at a highlevel state. <br>
<b> <br>1 0 . 2       Q U A L I F Y I N G   S Y M B O L S </b><br>
 <br>The IEEE standard graphic symbols for logic functions provide a list of qualifying symbols <br>to be used in conjunction with the outline. A qualifying symbol is added to the basic outline <br>to designate the overall logic characteristics of the element or the physical characteristics <br>of an input or output.  Table   10.1   lists some of the general qualifying symbols specified in <br>the standard. A general qualifying symbol defines the basic function performed by the <br>device represented in the diagram. It is placed near the top center position of the rectan-<br>gularshape outline. The general qualifying symbols for the gates, decoder, and adder were <br>shown in previous diagrams. The other symbols are selfexplanatory and will be used later <br>in diagrams representing the corresponding digital elements. <br>
 <br>Some of the qualifying symbols associated with inputs and outputs are shown in <br>
 <br>Fig.  10.4  . Symbols associated with inputs are placed on the left side of the column <br>labeled  <i>symbol</i> . Symbols associated with outputs are placed on the right side of the <br>column. The activelow input or output symbol is the polarity indicator. As mentioned <br>
<b> <br>Table 10.1 <br><i> <br>General Qualifying Symbols </b></i><br>
<b> <br>Symbol  </b><br>
<b> <br>Description  </b><br>
 <br>&amp; <br>
 <br>AND gate or function <br>
  � 1 <br>
 <br>OR gate or function <br>
 <br>1 <br>
 <br>Buffer gate or inverter <br>
 <br>= 1 <br>
 <br>ExclusiveOR gate or function <br>
 <br>2k <br>
 <br>Even function or even parity <br>element <br>
 2k  + 1 <br>
 <br>Odd function or odd parity element <br>
 <br>X/Y <br>
 <br>Coder, decoder, or code converter <br>
 MUX <br>
 Multiplexer <br>
 DMUX <br>
 Demultiplexer <br>
 a  <br>
 Adder <br>
 q  <br>
 Multiplier <br>
 COMP <br>
 Magnitude  comparator <br>
 ALU <br>
 Arithmetic  logic  unit <br>
 SRG <br>
 Shift  register <br>
 CTR <br>
 Counter <br>
 RCTR <br>
 Ripple  counter <br>
 ROM <br>
 Readonly  memory <br>
 RAM <br>
 Randomaccess  memory <br>
<hr>
<A name=510></a><b>492    Chapter 10  Standard Graphic Symbols</b><br>
Symbol<br>
Description<br>
Active-low input or output<br>
Logic negation input or output<br>
Dynamic indicator input<br>
Three-state output<br>
Open-collector output<br>
Output with special amplification<br>
<i>EN</i><br>
Enable input<br>
<i>D</i><br>
Data input to a storage element<br>
<i>J, K, R, S, </i>or<i> T </i><br>
Flip-flop inputs<br>
<br>
Shift right<br>
<br>
Shift left<br>
Countup<br>
Countdown<br>
<i>CT</i><br>
 15<br>
Contents of register equals binary 15<br>
 <br><b>FIGURE 10.4   <br> <br>Qualifying symbols associated with inputs and outputs  </b><br>
<hr>
<A name=511></a><b>Section 10.3  Dependency Notation    493</b><br>
previously, it is equivalent to the logic negation when positive logic is assumed. The <br>dynamic input is associated with the clock input in flipflop circuits. It indicates that the <br>input is active on a transition from a lowtohighlevel signal. The threestate output has <br>a third highimpedance state, which has no logic significance. When the circuit is enabled, <br>the output is in the normal 0 or 1 logic state, but when the circuit is disabled, the three<br>state output is in a highimpedance state. This state is equivalent to an open circuit. <br>
 <br>The opencollector output has one state that exhibits a highimpedance condition. An <br>
 <br>externally connected resistor is sometimes required in order to produce the proper logic <br>level. The diamondshape symbol may have a bar on top (for high type) or on the bottom <br>(for low type). The high or low type specifies the logic level when the output is not in <br>the  highimpedance state. For example, TTLtype integrated circuits have special outputs <br>called opencollector outputs. These outputs are recognized by a diamondshape symbol <br>with a bar under it. This indicates that the output can be either in a highimpedance state <br>or in a lowlevel state. When used as part of a distribution function, two or more open<br>collector NAND gates when connected to a common resistor perform a positivelogic <br>AND function or a negativelogic OR function. <br>
 <br>The output with special amplification is used in gates that provide special driving <br>
capabilities. Such gates are employed in components such as clock drivers or busoriented <br>transmitters. The  <i>EN</i>  symbol designates an enable input. It has the effect of enabling all <br>outputs when it is active. When the input marked with  <i>EN</i>  is inactive, all outputs are <br>disabled. The symbols for flipflop inputs have the usual meaning. The  <i>D</i>  input is also <br>associated with other storage elements such as memory input. <br>
 <br>The symbols for shift right and shift left are arrows pointing to the right or the left, <br>
respectively. The symbols for countup and countdown counters are the plus and minus <br>symbols, respectively. An output designated by <i>CT</i>  = 15 will be active when the contents <br>of the register reach the binary count of 15. When nonstandard information is shown <br>inside the outline, it is enclosed in square brackets [like this]. <br>
<b> <br>1 0 . 3       D E P E N D E N C Y   N O TAT I O N </b><br>
 <br>The most important aspect of the standard logic symbols is the dependency notation. <br>Dependency notation is used to provide the means of denoting the relationship between <br>different inputs or outputs without actually showing all the elements and interconnections <br>between them. We will first demonstrate the dependency notation with an example of the <br>AND dependency and then define all the other symbols associated with this notation. <br>
 <br>The AND dependency is represented with the letter  <i>G</i>  followed by a number. Any <br>
input or output in a diagram that is labeled with the number associated with  <i>G</i>  is consid-<br>ered to be ANDed with it. For example, if one input in the diagram has the label  <i>G</i> 1  and <br>another input is labeled with the number 1, then the two inputs labeled  <i>G</i> 1 and 1 are <br>considered to be ANDed together internally. <br>
 <br>An example of AND dependency is shown in  Fig.   10.5  . In (a), we have a portion of <br>
a  graphic symbol with two AND dependency labels,  <i>G</i> 1 and  <i>G</i> 2. There are two inputs <br>labeled with the number 1 and one input labeled with the number 2. The equivalent <br>
<hr>
<A name=512></a><b>494    Chapter 10  Standard Graphic Symbols</b><br>
<i>X</i><br>
<i>Y</i><br>
&amp;<br>
<i>X</i><br>
<i>G</i>1<br>
<i>A</i><br>
<i>Y</i><br>
<i>G</i>2<br>
&amp;<br>
<i>A</i><br>
1<br>
<i>B</i><br>
<i>B</i><br>
1<br>
<i>C</i><br>
2<br>
&amp;<br>
(a) Block with <i>G</i>1 and <i>G</i>2<br>
<i>C</i><br>
(b) Equivalent interpretation<br>
 <br><b>FIGURE 10.5   <br> <br>Example of <i> G</i>  (AND) dependency  </b><br>
interpretation is shown in part (b) of the figure. Input  <i>X</i>  associated with  <i>G</i> 1 is considered <br>to be ANDed with inputs  <i>A</i>  and  <i>B</i>,  which are labeled with a 1. Similarly, input  <i>Y</i>   is <br>ANDed with input  <i>C</i>  to conform with the dependency between  <i>G</i> 2 and 2. <br>
 <br>The standard defines 10 other dependencies. Each dependency is denoted by a letter <br>
symbol (except  <i>EN</i> ). The letter appears at the input or output and is followed by a <br>number. Each input or output affected by that dependency is labeled with that same <br>number. The 11 dependencies and their corresponding letter designation are as follows: <br>
<i>  G  </i><br>
 <br>Denotes an AND (gate) relationship <br>
<i>  V  </i><br>
 <br>Denotes an OR relationship <br>
<i>  N  </i><br>
 <br>Denotes a negate (exclusive-OR) relationship <br>
<i>  EN  </i><br>
 Specifi es an enable action <br>
<i>  C  </i><br>
 Identifi es a control dependency <br>
<i>  S  </i><br>
 Specifi es a setting action <br>
<i>  R  </i><br>
 Specifi es a resetting action <br>
<i>  M  </i><br>
 Identifi es a mode dependency <br>
<i>  A  </i><br>
 Identifi es an address dependency <br>
<hr>
<A name=513></a><b>Section 10.4  Symbols for Combinational Elements    495</b><br>
<i>  Z  </i><br>
 <br>Indicates an internal interconnection <br>
<i>  X  </i><br>
 <br>Indicates a controlled transmission <br>
 The   <i>V</i>  and  <i>N</i>  dependencies are used to denote the Boolean relationships of OR and <br>
exclusiveOR similar to the  <i>G</i>  that denotes the Boolean AND. The  <i>EN</i>  dependency is <br>similar to the qualifying symbol  <i>EN</i>  except that a number follows it (for example,  <i>EN</i>  2). <br>Only the outputs marked with that number are disabled when the input associated with <br> <br><i>EN</i>  is active. <br>
 <br>The control dependency  <i>C</i>  is used to identify a clock input in a sequential element <br>
and to indicate which input is controlled by it. The set  <i>S</i>  and reset  <i>R</i>  dependencies are <br>used to specify internal logic states of an  <i>SR</i>  flipflop. The  <i>C,</i>  <i>S</i>,  and  <i>R</i>   dependencies <br>are explained in Section 10.5 in conjunction with the flipflop circuit. The mode  <i>M</i> <br>dependency is used to identify inputs that select the mode of operation of the unit. The <br>mode dependency is presented in Section 10.6 in conjunction with registers and coun-<br>ters. The address  <i>A</i>  dependency is used to identify the address input of a memory. It is <br>introduced in Section 10.8 in conjunction with the memory unit. <br>
 The   <i>Z</i>  dependency is used to indicate interconnections inside the unit. It signifies the <br>
existence of internal logic connections between inputs, outputs, internal inputs, and inter-<br>nal outputs, in any combination. The  <i>X</i>  dependency is used to indicate the controlled <br>transmission path in a CMOS transmission gate. <br>
<b> <br>1 0 . 4       S Y M B O L S   F O R   C O M B I N AT I O N A L   E L E M E N T S </b><br>
 <br>The examples in this section and the rest of this chapter illustrate the use of the standard <br>in representing various digital components with graphic symbols. The examples demon-<br>strate actual commercial integrated circuits with the pin numbers included in the inputs <br>and outputs. Most of the ICs presented in this chapter are included with the suggested <br>experiments  outlined  in   Chapter    9   . <br>
 <br>The graphic symbols for the adder and decoder were shown in Section 10.2. IC type <br>
74155 can be connected as a 3 * 8 decoder, as shown in  Fig.   10.6  . (The truth table of this <br>decoder is shown in Fig. 9.7.) There are two  <i>C</i>  and two  <i>G</i>  inputs in the IC. Each pair must <br>be con nected together as shown in the diagram. The enable input is active when in the <br>lowlevel state. The outputs are all active low. The inputs are assigned binary weights 1, 2, <br>and 4, equivalent to 2 0 ,  2 1 , and 2 2 , respectively. The outputs are assigned numbers from 0 <br>to 7. The sum of the weights of the inputs determines the output that is active. Thus, if the <br>two input lines with weights 1 and 4 are activated, the total weight is 1 + 4 = 5 and output <br>5 is activated. Of course, the  <i>EN</i>  input must be activated for any output to be active. <br>
 <br>The decoder is a special case of a more general component referred to as a  <i>coder</i> . <br>
A coder is a device that receives an input binary code on a number of inputs and produces <br>a different binary code on a number of outputs. Instead of using the qualifying symbol <br> <br><i>X/Y</i>,  the coder can be specified by the code name. For example, the 3to8line decoder <br>of  Fig.   10.6   can be symbolized with the name  <i>BIN/OCT</i>  since the circuit converts a 3bit <br>binary number into 8 octal values, 0 through 7. <br>
<hr>
<A name=514></a><b>496    Chapter 10  Standard Graphic Symbols</b><br>
<i>X</i>/<i>Y</i><br>
9<br>
0<br>
<i>D</i>0<br>
13<br>
10<br>
<i>A</i><br>
1<br>
1<br>
<i>D</i>1<br>
3<br>
11<br>
<i>B</i><br>
2<br>
2<br>
<i>D</i>2<br>
1<br>
12<br>
<i>C</i><br>
4<br>
3<br>
<i>D</i>3<br>
15<br>
7<br>
4<br>
<i>D</i>4<br>
2<br>
6<br>
<i>G</i><br>
<i>D</i>5<br>
<i>EN</i><br>
5<br>
14<br>
5<br>
6<br>
<i>D</i>6<br>
4<br>
7<br>
<i>D7</i><br>
 <br><b>FIGURE 10.6   <br> <br>IC type 74155 connected as a 3 </b>* <b>8 decoder  </b><br>
 <br>Before showing the graphic symbol for the multiplexer, it is necessary to show a <br>
variation of the AND dependency. The AND dependency is sometimes represented by <br>a shorthand notation like   <i>G </i>0 . This symbol stands for eight AND dependency symbols <br>
7<br>
from 0 to 7 as follows: <br>
 <br><i>G</i>0, <i>G</i>1, <i>G</i>2, <i>G</i>3, <i>G</i>4, <i>G</i>5, <i>G</i>6, <i>G</i>7   <br>
 <br>At any given time, only one out of the eight AND gates can be active. The active AND <br>gate is determined from the inputs associated with the  <i>G</i>  symbol. These inputs are <br>marked with weights equal to the powers of 2. For the eight AND gates just listed, <br>the weights are 0, 1, and 2, corresponding to the numbers 2 0 ,  2 1 , and 2 2 ,  respectively. <br>The AND gate that is active at any given time is determined from the sum of the <br>weights of the active inputs. Thus, if inputs 0 and 2 are active, then the AND gate that <br>is active has the number 2 0 + 2 2 = 5. This makes  <i>G</i> 5 active and the other seven AND <br>gates inactive. <br>
 <br>The standard graphic symbol for a 8 * 1 multiplexer is shown in  Fig.   10.7  (a). The <br>
qualifying symbol MUX identifies the device as a multiplexer. The symbols inside the <br>block are part of the standard notation, but the symbols marked outside are user<br>defined symbols. The function table of the 741551 IC can be found in Fig. 9.9. The AND <br>dependency is marked with   <i>G </i>0  and is associated with the inputs enclosed in brackets. <br>
7<br>
These inputs have weights of 0, 1, and 2. They are actually what we have called the <br>selection inputs. The eight data inputs are marked with numbers from 0 to 7. The net <br>weight of the active inputs associated with the  <i>G</i>  symbol specifies the number in the <br>data input that is active. For example, if selection inputs  <i>CBA</i> = 110, then inputs 1 and <br>2 associated with  <i>G</i>  are active. This gives a numerical value for the AND dependency <br>of 2 2 + 2 1 = 6, which makes  <i>G</i>  6 active. Since  <i>G</i>  6 is ANDed with data input number 6, <br>it makes this input active. Thus, the output will be equal to data input  <i>D</i> 6  provided that <br>the enable input is active. <br>
<hr>
<A name=515></a><b>Section 10.5  Symbols for FlipFlops    497</b><br>
15<br>
Strobe<br>
<i>EN</i><br>
MUX<br>
1<br>
7<br>
Select<br>
<i>G</i>1<br>
<i>S</i><br>
<i>EN</i><br>
11<br>
<i>A</i><br>
0<br>
10<br>
0<br>
<i>B</i><br>
<i>G</i><br>
MUX<br>
7<br>
2<br>
9<br>
<i>A</i>1<br>
1<br>
4<br>
<i>C</i><br>
2<br>
<i>Y</i>1<br>
3<br>
<i>B</i>1<br>
1<br>
4<br>
<i>D</i>0<br>
0<br>
5<br>
<i>Y</i><br>
5<br>
3<br>
<i>A</i>2<br>
7<br>
<i>D</i>1<br>
1<br>
6<br>
<i>Y</i>2<br>
6<br>
<i>W</i><br>
2<br>
<i>B</i>2<br>
<i>D</i>2<br>
2<br>
1<br>
<i>D</i>3<br>
3<br>
11<br>
15<br>
<i>A</i>3<br>
9<br>
<i>D</i>4<br>
4<br>
<i>Y</i>3<br>
10<br>
14<br>
<i>B</i>3<br>
<i>D</i>5<br>
5<br>
13<br>
<i>D</i>6<br>
6<br>
14<br>
12<br>
<i>A</i>4<br>
12<br>
<i>D</i>7<br>
7<br>
<i>Y</i>4<br>
13<br>
<i>B</i>4<br>
(a) IC type 74151 8   1 MUX<br>
(b) IC type 74157 quadruple 2   1 MUX<br>
 <br><b>FIGURE 10.7   <br> <br>Graphic symbols for multiplexers  </b><br>
 <br>Figure 10.7(b) represents the quadruple 2 * 1 multiplexer IC type 74157 whose func-<br>
tion table is listed in Fig. 9.17. The enable and selection inputs are common to all four <br>multiplexers. This is indicated in the standard notation by the indented box at the top <br>of the diagram, which represents a  <i>common control block</i> . The inputs to a common <br>control block control all lower sections of the diagram. The common enable input  <i>EN</i> <br>is active when in the lowlevel state. The AND dependency,  <i>G</i> 1, determines which input <br>is active in each multiplexer section. When  <i>G</i> 1  = 0, the  <i>A</i>  inputs marked with   1     are  active. <br>When  <i>G</i> 1  = 1, the  <i>B</i>  inputs marked with 1 are active. The active inputs are applied to <br>the corresponding outputs if  <i>EN</i>  is active. Note that the input symbols   1     and  1  are <br>marked in the upper section only instead of repeating them in each section. <br>
<b> <br>1 0 . 5       S Y M B O L S   F O R   F L I P  F L O P S </b><br>
 <br>The standard graphic symbols for different types of flipflops are shown in  Fig.   10.8  . <br>A flipflop is represented by a rectangularshaped block with inputs on the left and <br>outputs on the right. One output designates the normal state of the flipflop and the <br>
<hr>
<A name=516></a><b>498    Chapter 10  Standard Graphic Symbols</b><br>
1<i>D</i><br>
1<i>D</i><br>
<i>C</i>1<br>
<i>C</i>1<br>
<i>D </i>latch<br>
Positive-edge-triggered<br>
<i>D</i> flip-flop<br>
1<i>J</i><br>
1<i>J</i><br>
<i>C</i>1<br>
<i>C</i>1<br>
1<i>K</i><br>
1<i>K</i><br>
Positive-edge-triggered<br>
Negative-edge-triggered<br>
<i>JK</i> flip-flop<br>
<i>JK</i> flip-flop<br>
1<i>J</i><br>
1<i>D</i><br>
<i>C</i>1<br>
<i>C</i>1<br>
1<i>K</i><br>
Master-slave <i>JK</i> flip-flop<br>
Master-slave <i>D</i> flip-flop<br>
 <br><b>FIGURE 10.8   <br> <br>Standard graphic symbols for flipflops  </b><br>
other output with a  smallcircle negation symbol (or polarity indicator) designates the <br>complement output. The graphic symbols distinguish between three types of flipflops: <br>the  <i>D</i>  latch, whose internal construction is shown in Fig. 6.5; the master�slave flipflop, <br>shown in Fig. 6.9; and the edgetriggered flipflop, introduced in Fig. 6.12. The graphic <br>symbol for the  <i>D</i>  latch or  <i>D</i>  flipflop has inputs  <i>D</i>  and  <i>C</i>  indicated inside the block. The <br>graphic symbol for the  <i>JK</i>  flipflop has inputs  <i>J,</i>  <i>K,</i>  and  <i>C</i>  inside. The notation  <i>C</i> 1,  1 <i>D,</i> <br>1 <i>J</i>,  and 1 <i>K</i>  are examples of control dependency. The input in  <i>C</i> 1 controls input 1 <i>D</i>  in a <br> <br><i>D</i>  flipflop and inputs 1 <i>J</i>  and 1 <i>K</i>  in a  <i>JK</i>   flipflop. <br>
 The   <i>D</i>  latch has no other symbols besides the 1 <i>D</i>  and  <i>C</i> 1 inputs. The edgetriggered <br>
flipflop has an arrowheadshaped symbol in front of the control dependency  <i>C</i> 1  to <br>designate a  dynamic input. The dynamic indicator symbol denotes that the flipflop <br>responds to the positiveedge transition of the input clock pulses. A small circle outside <br>the block along the  dynamic indicator designates a negativeedge transition for trigger-<br>ing the flipflop. The  master�slave is considered to be a pulsetriggered flipflop and is <br>
<hr>
<A name=517></a><b>Section 10.6  Symbols for Registers    499</b><br>
2<br>
S<br>
4<br>
4<br>
15<br>
<i>S</i><br>
1<i>J</i><br>
3<br>
5<br>
1<br>
<i>C</i>1<br>
<i>C</i>1<br>
2<br>
6<br>
16<br>
14<br>
1<i>D</i><br>
1<i>K</i><br>
1<br>
3<br>
<i>R</i><br>
<i>R</i><br>
(a) One-half 7476 <i>JK</i> flip-flop<br>
(b) One-half 7474 <i>D</i> flip-flop<br>
 <br><b>FIGURE 10.9   <br> <br>IC flipflops with direct set and reset  </b><br>
indicated as such with an upsidedown  <i>L</i>  symbol in front of the outputs. This is to show <br>that the output signal changes on the falling edge of the pulse. Note that the master�<br>slave flipflop is drawn without the dynamic indicator. <br>
 <br>Flipflops available in integratedcircuit packages provide special inputs for setting <br>
and  resetting the flipflop asynchronously. These inputs are usually called direct set and <br>direct reset. They affect the output on the negative level of the signal without the need <br>of a clock. The graphic symbol of a master�slave  <i>JK</i>  flipflop with direct set and reset is <br>shown  in   Fig.    10.9   (a).  The  notations   <i>C</i> 1,  1 <i>J</i>,  and 1 <i>K</i>  represent control dependency, show-<br>ing that the clock input at  <i>C</i> 1 controls inputs 1 <i>J</i>  and 1 <i>K</i> .   <i>S</i>  and  <i>R</i>  have no 1 in front of <br>the letters and, therefore, they are not controlled by the clock at  <i>C</i> 1.  The   <i>S</i>  and  <i>R</i>   inputs <br>have a small circle along the input lines to indicate that they are active when in the <br>logic0 level. The function table for the 7476 flipflop is shown in Fig. 9.12. <br>
 <br>The graphic symbol for a positiveedgetriggered  <i>D</i>  flipflop with direct set and reset <br>
is shown in  Fig.   10.9  (b). The positiveedge transition of the clock at input  <i>C</i> 1  controls <br>input 1 <i>D</i> .  The   <i>S</i>  and  <i>R</i>  inputs are independent of the clock. This is IC type 7474, whose <br>function table is listed in Fig. 9.13. <br>
<b> <br>1 0 . 6       S Y M B O L S   F O R   R E G I S T E R S </b><br>
 <br>The standard graphic symbol for a register is equivalent to the symbol used for a group <br>of flipflops with a common clock input.  Fig.   10.10   shows the standard graphic symbol <br>of IC type 74175, consisting of four  <i>D</i>  flipflops with common clock and clear inputs. <br>The clock input  <i>C</i> 1 and the clear input  <i>R</i>  appear in the common control block. The <br>inputs to the common control block are connected to each of the elements in the lower <br>sections of the diagram. The notation  <i>C</i> 1 is the control dependency that controls all the <br>1 <i>D</i>  inputs. Thus, each flipflop is triggered by the common clock input. The dynamic <br>input symbol associated with  <i>C</i> 1 indicates that the flipflops are triggered on the positive <br>edge of the input clock. The common  <i>R</i>  input resets all flipflops when its input is at a <br>lowlevel state. The 1 <i>D</i>  symbol is placed only once in the upper section instead of <br>
<hr>
<A name=518></a><b>500    Chapter 10  Standard Graphic Symbols</b><br>
1<br>
Clear<br>
<i>R</i><br>
9<br>
Clock<br>
<i>C</i>1<br>
2<br>
<i>Q</i><br>
4<br>
1<i>D</i><br>
3<br>
<i>Q</i><br>
7<br>
5<br>
6<br>
10<br>
12<br>
11<br>
15<br>
13<br>
14<br>
 <br><b>FIGURE 10.10   <br> <br>Graphic symbol for IC type 74175 quad flip-flop  </b><br>
repeating it in each section. The complement outputs of the flipflops in this diagram <br>are marked with the polarity symbol rather than the negation symbol. <br>
 <br>The standard graphic symbol for a shift register with parallel load is shown in <br>
 <br>Fig.  10.11  . This is IC type 74195, whose function table can be found in Fig. 9.16. The <br>qualifying symbol for a shift register is  <i>SRG</i>  followed by a number that designates the <br>number of stages. Thus,  <i>SRG</i> 4 denotes a fourbit shift register. The common control <br>block has two mode dependencies,  <i>M</i> 1 and  <i>M</i> 2, for the shift and load operations, respec-<br>tively. Note that the IC has a single input labeled  <i>SH</i> / <i>LD</i>  (shift/load), which is split into <br>two lines to show the two modes.  <i>M</i> 1 is active when the  <i>SH</i> / <i>LD</i>  input is high and  <i>M</i> 2  is <br>active when the  <i>SH</i> / <i>LD</i>  input is low.  <i>M</i> 2 is recognized as active low from the polarity <br>indicator along its input line. Note the convention in this symbology: We must recognize <br>that a single input actually exists in pin 9, but it is split into two parts in order to assign <br>to it the two modes,  <i>M</i> 1 and  <i>M</i> 2. The control dependency  <i>C</i> 3 is for the clock input. The <br>dynamic symbol along the  <i>C</i> 3 input indicates that the flipflops trigger on the positive <br>edge of the clock. The symbol /1 S following  <i>C</i> 3 indicates that the register shifts to the <br>right or in the downward direction when mode  <i>M</i> 1 is active. <br>
 <br>The four sections below the common control block represent the four flipflops. Flip<br>
flop  <i>QA</i>  has three inputs: Two are associated with the serial (shift) operation and one <br>
<hr>
<A name=519></a><b>Section 10.6  Symbols for Registers    501</b><br>
<i>SRG</i>4<br>
1<br>
Clear<br>
<i>R</i><br>
9<br>
<i>SH</i>/<i>LD</i><br>
<i>M</i>1 [SHIFT]<br>
<i>M</i>2 [LOAD]<br>
10<br>
Clock<br>
<i>C</i>3/1<br>
2<br>
<i>J</i><br>
1, 3<i>J</i><br>
3<br>
15<br>
<i>QA</i><br>
<i>K</i><br>
1, 3<i>K</i><br>
4<br>
<i>A</i><br>
2, 3<i>D</i><br>
5<br>
14<br>
<i>B</i><br>
2, 3<i>D</i><br>
<i>QB</i><br>
6<br>
13<br>
<i>C</i><br>
<i>QC</i><br>
12<br>
<i>QD</i><br>
7<br>
11<br>
<i>D</i><br>
<i>QD</i><br>
 <br><b>FIGURE 10.11   <br> <br>Graphic symbol for a shift register with parallel load, IC type 74195  </b><br>
with the  parallel (load) operation. The serial input label 1, 3 <i>J</i>  indicates that the  <i>J</i>   input <br>of flipflop  <i>QA</i>  is active when  <i>M</i> 1 (shift) is active and  <i>C</i> 3 goes through a positive clock <br>transition. The other serial input with label 1, 3 <i>K</i>  has a polarity symbol in its input line <br>corresponding to the complement of input  <i>K</i>  in a  <i>JK</i>  flipflop. The third input of  <i>QA</i> <br>and the inputs of the other flipflops are for the parallel input data. Each input is denoted <br>by the label 2, 3 <i>D</i> . The 2 is for  <i>M</i> 2 (load), and 3 is for the clock  <i>C</i> 3. If the input in pin <br>number 9 is in the low level,  <i>M</i> 1 is active, and a positive transition of the clock at  <i>C</i> 3 <br>causes a parallel transfer from the four inputs,  <i>A</i>  through  <i>D</i>,  into the four flipflops,  <i>QA</i> <br>through  <i>QD</i> . Note that the parallel input is labeled only in the first and second sections. <br>It is assumed to be in the other two sections below. <br>
 <br>Figure   10.12   shows the graphic symbol for the bidirectional shift register with paral-<br>
lel load, IC type 74194. The function table for this IC is listed in Fig. 9.19. The common <br>control block shows an  <i>R</i>  input for resetting all flipflops to 0 asynchronously. The mode <br>select has two inputs and the mode dependency  <i>M</i>  may take binary values from 0 to 3. <br>This is indicated by the symbol   <i>M </i>0,      which  stands  for   <i>M</i> 0,   <i>M</i> 1,   <i>M</i> 2,   <i>M</i> 3, and is similar <br>
3<br>
to the notation for the  <i>G</i>  dependency in multiplexers. The symbol associated with the <br>clock is <br>
 <br><i>C</i>4&gt;1 S &gt;2 d  <br>
 <br><i>C</i> 4 is the control dependency for the clock. The /1 S symbol indicates that the register <br>shifts right (down in this case) when the mode is  <i>M</i> 1  ( <i>S</i> 1  <i>S</i> 0 = 10). The /2 d symbol <br>
<hr>
<A name=520></a><b>502    Chapter 10  Standard Graphic Symbols</b><br>
<i>SRG</i>4<br>
1<br>
Clear<br>
<i>R</i><br>
9<br>
<i>S</i>0<br>
0<br>
10<br>
<i>M </i>03<br>
<i>S</i>1<br>
1<br>
11<br>
Clock<br>
<i>C</i>4/1<br>
/2<br>
2<br>
Serial input<br>
1, 4<i>D</i><br>
15<br>
<i>QA</i><br>
3<br>
<i>A</i><br>
3, 4<i>D</i><br>
4<br>
14<br>
<i>B</i><br>
3, 4<i>D</i><br>
<i>QB</i><br>
5<br>
13<br>
<i>C</i><br>
3, 4<i>D</i><br>
<i>QC</i><br>
6<br>
<i>D</i><br>
3, 4<i>D</i><br>
12<br>
7<br>
<i>QD</i><br>
Serial input<br>
2, 4<i>D</i><br>
 <br><b>FIGURE 10.12   <br> <br>Graphic symbol for a bidirectional shift register with parallel load, IC type 74194  </b><br>
indicates that the register shifts left (up in this case) when the mode is  <i>M</i>  2   ( <i>S</i> 1  <i>S</i> 0 = 10). <br>The right and left directions are obtained when the page is turned 90 degrees counter-<br>clockwise.  <br>
 <br>The sections below the common control block represent the four flipflops. The first <br>
flipflop has a serial input for shift right, denoted by 1, 4 <i>D</i>  (mode  <i>M</i> 1, clock  <i>C</i> 4, <br>input  <i>D</i> ). The last flipflop has a serial input for shift left, denoted by 2, 4 <i>D</i>  (mode  <i>M</i> 2, <br>clock  <i>C</i> 4, input  <i>D</i> ). All four flipflops have a parallel input denoted by the label 3, 4 <i>D</i> <br>(mode  <i>M</i> 3, clock  <i>C</i> 4, input  <i>D</i> ).  Thus,   <i>M</i> 3  ( <i>S</i> 1  <i>S</i> 0 = 11) is for parallel load. The remaining <br>mode  <i>M</i> 0  ( <i>S</i> 1  <i>S</i> 0 = 00) has no effect on the outputs because it is not included in the <br>input labels. <br>
<b> <br>1 0 . 7       S Y M B O L S   F O R   C O U N T E R S </b><br>
 <br>The standard graphic symbol of a binary ripple counter is shown in  Fig.   10.13  . The <br>qualifying symbol for a ripple counter is  <i>RCTR</i> . The designation  <i>DIV</i> 2 stands for the <br>divideby2 circuit that is obtained from the single flipflop  <i>QA</i> .  The   <i>DIV</i> 8  designation <br>is for the divideby8 counter obtained from the other three flipflops. The diagram <br>represents IC type 7493, whose internal circuit diagram is shown in Fig. 9.2. The com-<br>mon control block has an internal AND gate, with inputs  <i>R</i> 1 and  <i>R</i> 2. When both of <br>these inputs are equal to 1, the content of the  counter goes to zero. This is indicated by <br>
<hr>
<A name=521></a><b>Section 10.7  Symbols for Counters    503</b><br>
<i>RCTR</i><br>
2<br>
<i>R</i>1<br>
3<br>
&amp;<br>
<i>CT</i><br>
 0<br>
<i>R</i>2<br>
14<br>
12<br>
<i>A</i><br>
<i>DIV</i>2<br>
<i>QA</i><br>
<i>DIV</i>8<br>
1<br>
9<br>
<i>B</i><br>
0<br>
<i>QB</i><br>
8<br>
<i>CT</i><br>
<i>QC</i><br>
11<br>
2<br>
<i>QD</i><br>
 <br><b>FIGURE 10.13   <br> <br>Graphic symbol for ripple counter, IC type 7493  </b><br>
the symbol  <i>CT</i> = 0. Since the count input does not go to the clock inputs of all flipflops, <br>it has no  <i>C</i> 1 label and, instead, the symbol + is used to indicate a countup operation. <br>The dynamic symbol next to the + together with the polarity symbol along the input <br>line signify that the count is affected with a negativeedge transition of the input signal. <br>The bit grouping from 0 to 2 in the output represents values for the weights to the <br>power of 2. Thus, 0 represents the value of 2 0 = 1 and 2 represents the value 2 2 = 4.  <br>
 <br>The standard graphic symbol for the fourbit counter with parallel load, IC type 74161, <br>
is shown in  Fig.   10.14  . The qualifying symbol for a synchronous counter is  <i>CTR</i>   followed <br>by the symbol  <i>DIV</i> 16 (divide by 16), which gives the cycle length of the counter. There <br>is a single load input at pin 9 that is split into the two modes,  <i>M</i> 1 and  <i>M</i> 2.   <i>M</i> 1 is active <br>when the load input at pin 9 is low and  <i>M</i> 2 is active when the load input at pin 9 is high. <br> <br><i>M</i> 1 is recognized as active low from the polarity indicator along its input line. The count<br>enable inputs use the  <i>G</i>  dependencies.  <i>G</i> 3 is associated with the  <i>T</i>  input and  <i>G</i> 4  with <br>the  <i>P</i>  input of the count enable. The label associated with the clock is  <br>
 <br><i>C</i>5&gt;2, 3, 4 +  <br>
 <br>This means that the circuit counts up (the + symbol) when  <i>M</i> 2,   <i>G</i> 3, and  <i>G</i> 4 are active <br>(load = 1,  <i>ENT</i> = 1, and  <i>ENP</i> = 1) and the clock in  <i>C</i> 5 goes through a positive transition. <br>This condition is specified in the function table of the 74161 listed in Fig. 9.15. The paral-<br>lel inputs have the label 1, 5 <i>D,</i>  meaning that the  <i>D</i>  inputs are active when  <i>M</i> 1 is active <br>(load = 0) and the clock goes through a positive transition. The output carry is designated <br>by the label <br>
 <br>3<i>CT </i>= 15   <br>
 <br>This is interpreted to mean that the output carry is active (equal to 1) if  <i>G</i> 3 is active <br>( <i>ENT</i> = 1) and the content ( <i>CT</i> ) of the counter is 15 (binary 1111). Note that the outputs <br>
<hr>
<A name=522></a><b>504    Chapter 10  Standard Graphic Symbols</b><br>
<i>CTR DIV</i>16<br>
1<br>
Clear<br>
<i>CT</i><br>
 0<br>
9<br>
Load<br>
<i>M</i>1<br>
<i>M</i>2<br>
15<br>
3<i>CT</i><br>
 15<br>
Output carry<br>
10<br>
<i>ENT</i><br>
<i>G</i>3<br>
7<br>
<i>ENP</i><br>
<i>G</i>4<br>
2<br>
Clock<br>
<i>C</i>5/2, 3, 4 <br>
3<br>
14<br>
<i>A</i><br>
1, 5<i>D</i><br>
[1]<br>
<i>QA</i><br>
4<br>
13<br>
<i>B</i><br>
[2]<br>
<i>QB</i><br>
5<br>
12<br>
<i>C</i><br>
[4]<br>
<i>QC</i><br>
6<br>
11<br>
<i>D</i><br>
[8]<br>
<i>QD</i><br>
 <br><b>FIGURE 10.14   <br> <br>Graphic Symbol for 4Bit Binary Counter with Parallel Load, IC Type 74161  </b><br>
have an in verted  <i>L</i>  symbol, indicating that all the flipflops are of the master�slave type. <br>The polarity symbol in the  <i>C</i> 5 input designates an inverted pulse for the input clock. <br>This means that the master is triggered on the negative transition of the clock pulse and <br>the slave changes state on the positive transition. Thus, the output changes on the posi-<br>tive transition of the clock pulse. It should be noted that IC type 74LS161 (lowpower <br>Schottky version) has positiveedge triggered flipflops. <br>
<b> <br>1 0 . 8       S Y M B O L   F O R   R A M </b><br>
 <br>The standard graphic symbol for the randomaccess memory (RAM) 74189 is shown <br>in   Fig.    10.15   .  The  numbers  16  * 4 that follow the qualifying symbol RAM designate <br>the number of words and the number of bits per word. The common control block is <br>shown with four address lines and two control inputs. Each bit of the word is shown in <br>a separate section with an input and output data line. The address dependency  <i>A</i>   is <br>used to identify the address inputs of the memory. Data inputs and outputs affected <br>by the address are labeled with the letter  <i>A</i> . The bit grouping from 0 through 3 provides <br>the binary address that ranges from  <i>A</i> 0 through  <i>A</i> 15. The inverted triangle signifies <br>threestate outputs. The polarity symbol specifies the inversion of the outputs. <br>
 <br>The operation of the memory is specified by means of the dependency notation. The <br>
RAM graphic symbol uses four dependencies: A (address),  <i>G</i>  (AND),  <i>EN</i>  (enable), and <br> <br><i>C</i>  (control). Input  <i>G</i> 1 is to be considered ANDed with 1 <i>EN</i>  and 1 <i>C</i> 2 because  <i>G</i> 1 has a <br>1 after the letter  <i>G</i>  and the other two have a 1 in their label. The  <i>EN</i>  dependency is used <br>
<hr>
<A name=523></a><b>Problems    505</b><br>
RAM 16   4<br>
1<br>
<i>A</i>0<br>
0<br>
15<br>
<i>A</i>1<br>
0<br>
14<br>
<i>A </i>15<br>
<i>A</i>2<br>
13<br>
<i>A</i>3<br>
2<br>
2<br>
<i>CS</i><br>
<i>G</i>1<br>
3<br>
<i>WE</i><br>
1<i>EN</i> [READ]<br>
1<i>C</i>2 [WRITE]<br>
4<br>
5<br>
<i>D</i>1<br>
<i>A, </i>2<i>D</i><br>
<i>A</i><br>
<i>S</i>1<br>
6<br>
7<br>
<i>D</i>2<br>
<i>S</i>2<br>
10<br>
9<br>
<i>D</i>3<br>
<i>S</i>3<br>
12<br>
11<br>
<i>D</i>4<br>
<i>S</i>4<br>
<b> <br>FIGURE 10.15   <br> <br>Graphic symbol for 16�4 RAM, IC type 74189  </b><br>
to identify an enable input that controls the data outputs. The dependency  <i>C</i> 2  controls <br>the  inputs as indicated by the 2 <i>D</i>  label. Thus, for a write operation, we have the  <i>G</i> 1  and <br>1 <i>C</i> 2 dependency ( <i>CS</i> = 0), the  <i>C</i> 2 and 2 <i>D</i>  dependency ( <i>WE</i> = 0), and the A dependency, <br>which specifies the binary address in the four address inputs. For a read operation, we <br>have the  <i>G</i> 1 and 1 <i>EN</i>  dependencies ( <i>CS</i> = 0,  <i>WE</i> = 1) and the A dependency for the <br>outputs. The interpretation of these dependencies results in the operation of the memory <br>as listed in the function table of the 74189 RAM (see Web Search Topics). <br>
<b> <br>P R O B L E M S </b><br>
 <br><b> 10.1 </b><br>
 <br>Figure 9.1 shows various smallscale integration circuits with pin assignment. Using this <br>information, draw the rectangularshaped graphic symbols for the 7400, 7404, and 7486 ICs. <br>
 <br><b> 10.2 </b><br>
 <br>Define the following in your own words: <br>
    <br>
(a)    Positive  and  negative  logic.   <br>
  (b)    Active  high  and  active  low.  <br>
   <br>
(c)    Polarity  indicator.   <br>
  (d)    Dynamic  indicator.  <br>
   <br>
(e)    Dependency  notation.     <br>
 <br><b> 10.3 </b><br>
 <br>Show an example of a graphic symbol that has the three Boolean dependencies-- <i>G,</i>  <i>V</i>,  <br>and  <i>N</i> . Draw the equivalent interpretation. <br>
 <br><b> 10.4 </b><br>
 <br>Draw the graphic symbol of a BCDtodecimal decoder. This is similar to a decoder with <br>4 inputs and 10 outputs. <br>
<hr>
<A name=524></a><b>506    Chapter 10  Standard Graphic Symbols</b><br>
 <br><b> 10.5 </b><br>
 <br>Draw the graphic symbol for a binarytooctal decoder with three enable inputs,  <i>E</i> 1,   <i>E</i> 2, <br>and  <i>E</i> 3. The circuit is enabled if  <i>E</i> 1   = 1,  <i>E</i> 2 = 0, and  <i>E</i> 3 = 0 (assuming positive logic). <br>
 <br><b> 10.6 </b><br>
 <br>Draw the graphic symbol of dual 4to1line multiplexers with common selection inputs <br>and a separate enable input for each multiplexer. <br>
 <br><b> 10.7 </b><br>
 <br>Draw the graphic symbol for the following flipflops: <br>
    <br>
(a)    Negativeedgetriggered   <i>D</i>   flipflop.   <br>
  (b)    Master�slave   <i>RS</i>   flipflop.  <br>
   <br>
(c)    Positiveedgetriggered   <i>T</i>   flipflop.     <br>
 <br><b> 10.8 </b><br>
 <br>Explain the function of the common control block when used with the standard graphic <br>symbols. <br>
 <br><b> 10.9 </b><br>
 <br>Draw the graphic symbol of a fourbit register with parallel load using the label  <i>M</i> 1  for <br>the load input and  <i>C</i> 2 for the clock. <br>
 <br><b> 10.10 </b><br>
 <br>Explain all the symbols used in the standard graphic diagram of  Fig.   10.12  . <br>
 <br><b> 10.11 </b><br>
 <br>Draw the graphic symbol of an up�down synchronous binary counter with mode input <br>(for up or down) and countenable input with  <i>G</i>  dependency. Show the output carries <br>for the up count and the down count. <br>
 <br><b> 10.12 </b><br>
 <br>Draw the graphic symbol of a 256 * 1 RAM. Include the symbol for threestate outputs. <br>
<b> <br>R E F E R E N C E S </b><br>
 <br><b> 1. </b><br>
 <br><i>IEEE Standard Graphic Symbols for Logic Functions</i>  (ANSI/IEEE Std. 911984). 1984. <br>New York: Institute of Electrical and Electronics Engineers. <br>
 <br><b> 2. </b><br>
 K ampel,   I.  1985.  A   <i>Practical Introduction to the New Logic Symbols</i> . Boston: Butterworth. <br>
 <br><b> 3. </b><br>
 M ann,   F.  A.  1984.   <i>Explanation of New Logic Symbols</i> . Dallas: Texas Instruments. <br>
 <br><b> 4. </b><br>
 <br><i>The TTL Data Book,</i>   Volume  1.  1985.  Dallas:  Texas  Instruments.     <br>
<b>W E B   S E A R C H   T O P I C S</b><br>
Bidirectional shift register<br>
74161 flip-flop<br>
Three-state inverter<br>
74194 shift register<br>
Three-state buffer<br>
74175 quad flip-flops<br>
Universal shift register<br>
74195 shift register<br>
7483 adder<br>
7494 counter<br>
74151 multiplexer<br>
74161 counter<br>
74155 decoder<br>
74LS161 flip-flop<br>
74157 multiplexer<br>
74189 RAM<br>
7476 flip-flop<br>
BCD-to-decimal decoder<br>
7474 flip-flop<br>
Random access memory<br>
<hr>
<A name=525></a> <br>Appendix <br>
<b> <br>Semiconductors and CMOS <br>Integrated Circuits </b><br>
 <br>Semiconductors are formed by doping a thin slice of a pure silicon crystal with a small <br>amount of a dopant that fits relatively easily into the crystalline structure of the silicon. <br>Dopants are differentiated on the basis of whether they have either three valence elec-<br>trons or five valence electrons. A silicon crystalline structure is such that each silicon <br>atom shares its four valence electrons with its four nearest neighbors, thereby completing <br>its valence structure. The atoms of a dopant with five valence electrons, referred to as a <br><i>n</i>type dopant, fit in the physical structure of the crystal, but their fifth electrons are held <br>only loosely by their parent atoms in the bonded structure. Consequently, an applied <br>electric field can cause such electrons to flow as a current. On the other hand, a dopant <br>atom with only three valence electrons, a <i>p</i>type dopant, has a vacant valence site. Under <br>the influence of an applied electric field, an electron from a neighboring silicon atom in <br>the bonded structure can jump from its host and fill a vacant dopant site, leaving behind <br>a vacancy at its host. This migration, visualized as a leapfrogging of electrons from hole <br>to hole, establishes a current. <br>
 <br>Current is due to the movement of electrons, which are negative charge carriers. Cur-<br>
rent is measured, however, in the opposite direction of flow, by convention--since the <br>days of Benjamin Franklin. (Think of current as being the motion of an equivalent <br>positive charge moving in the opposite direction of an electron, whose charge is nega-<br>tive). Holes move in the direction of current, although the underlying physical movement <br>of electrons is in the opposite direction. Thermal agitation causes both types of charge <br>carriers to be present in a semiconductor. If the majority carrier is a hole, the device is <br>said to be a <i>p</i>type device; if the majority carrier is an electron, the device is said to be <br>an <i>n</i>type device. Bipolar transistors rely on both types of carriers. Metaloxide silicon <br>semiconductors rely on a majority carrier, either an electron or a hole, but not both. The <br>type and relative amount of dopant determine the type of a semiconductor material. <br>
<b>507</b><br>
<hr>
<A name=526></a><b>508    Appendix  Semiconductors and CMOS Integrated Circuits</b><br>
gate ( )<br>
gate ( )<br>
drain ( )<br>
source<br>
drain ( )<br>
source<br>
<i>p</i><br>
<i>p</i><br>
<i>n</i><br>
<i>n</i><br>
<i>n</i>-type substrate<br>
<i>p</i>-type substrate<br>
(a) <i>p</i>-channel<br>
(b) <i>n</i>-channel<br>
<b> <br>FIGURE A.1   <br> <br>Basic structure of MOS transistor  </b><br>
 <br>The basic structure of a metaloxide semiconductor (MOS) transistor is shown in <br>
 Fig.   A.1   .  The  <i>p</i>channel MOS transistor consists of a lightly doped substrate of <i>n</i>type <br>silicon material. Two regions are heavily doped with <i>p</i>type impurities by a diffusion pro-<br>cess to form the  <i>source</i>  and  <i>drain</i> . The source terminal supplies charge carriers to an <br>external circuit; the drain terminal removes charge carriers from the circuit. The region <br>between the two <i>p</i>type sections serves as the  <i>channel</i> . In its simplest form, the gate is a <br>metal plate separated from the channel by an insulted dielectric of silicon dioxide. <br>A negative voltage (with respect to the substrate) at the gate terminal causes an induced <br>electric field in the channel that attracts <i>p</i>type carriers (holes) from the substrate. As <br>the magnitude of the negative voltage increases, the region below the gate accumulates <br>more positive carriers, the conductivity increases, and current can flow from source to <br>drain, provided that a voltage difference is maintained between these two terminals. <br>
 <br>There are four basic types of MOS structures. The channel can be  <i>p</i>  or  <i>n</i>  type, depend-<br>
ing on whether the majority carriers are holes or electrons. The mode of operation can <br>be enhancement or depletion, depending on the state of the channel region at zero gate <br>voltage. If the channel is initially doped lightly with  <i>p</i> type impurity (in which case it is <br>called a  <i>diffused channel</i> ), a conducting channel exists at zero gate voltage and the <br>device is said to operate in the  <i>depletion</i>  mode. In this mode, current flows unless the <br>channel is depleted by an applied gate field. If the region beneath the gate is left initially <br>uncharged, a channel must be induced by the gate field before current can flow. Thus, <br>the channel current is enhanced by the gate voltage, and such a device is said to operate <br>in the  <i>enhancement</i>   mode. <br>
 <br><b>The source is the terminal through which the majority carriers enter the device.</b>   If <br>
the majority carrier is a hole (<i>p</i>type channel), the source terminal supplies current to <br>the circuit; if the majority carrier is an electron (<i>n</i>type channel), the source removes <br>current from the circuit. The drain is the terminal through which the majority carriers <br>leave the device. In a  <i>p</i> channel MOS, the source terminal is connected to the substrate <br>and a negative voltage is applied to the drain terminal. When the gate voltage is above <br>a threshold voltage   <i>VT</i>     (about     -2 V  ), no current flows in the channel and the drainto<br>source path is like an open circuit. When the gate voltage is sufficiently negative below <br> <br><i>VT</i>,  a channel is formed and  <i>p</i> type carriers flow from source to drain.  <i>p</i> type carriers are <br>positive and correspond to a positive current flow from source to drain. <br>
<hr>
<A name=527></a><b>Appendix  Semiconductors and CMOS Integrated Circuits    509</b><br>
drain<br>
<i>D</i><br>
drain<br>
<i>D</i><br>
gate<br>
substrate<br>
<i>G</i><br>
gate<br>
substrate<br>
<i>G</i><br>
source<br>
<i>S</i><br>
source<br>
<i>S</i><br>
(a) <i>p</i>-channel<br>
(b) <i>n</i>-channel<br>
 <br><b>FIGURE A.2   <br> <br>Symbols for MOS transistors  </b><br>
 <br>In the  <i>n</i> channel MOS, the source terminal is connected to the substrate and a <br>
positive voltage is applied to the drain terminal. When the gate voltage is below the <br>threshold voltage   <i>VT</i>  (about 2 V), no current flows in the channel. When the gate volt-<br>age is sufficiently positive above   <i>VT</i>  to form the channel,  <i>n</i> type carriers flow from <br>source to drain.  <i>n</i> type carriers are negative and correspond to a positive current flow <br>from drain to source. The threshold voltage may vary from 1 to 4 V, depending on the <br>particular process used. <br>
 <br>The graphic symbols for the MOS transistors are shown in  Fig.  A.2  . The symbol for <br>
the enhancement type is the one with the brokenline connection between source and <br>drain. In this symbol, the substrate can be identified and is shown connected to the <br>source. An alternative symbol omits the substrate, and instead an arrow is placed in the <br>source terminal to show the direction of  <i>positive</i>  current flow (from source to drain in <br>the  <i>p</i> channel MOS and from drain to source in the  <i>n</i> channel  MOS). <br>
 <br>Because of the symmetrical construction of source and drain, the MOS transistor can <br>
be operated as a bilateral device. Although normally operated so that carriers flow from <br>source to drain, there are circumstances when it is convenient to allow carriers to flow <br>from drain to source. <br>
 <br>One advantage of the MOS device is that it can be used not only as a transistor, but <br>
as a resistor as well. A resistor is obtained from the MOS by permanently biasing the <br>gate terminal for conduction. The ratio of the source�drain voltage to the channel <br>current then determines the value of the resistance. Different resistor values may be <br>constructed during manufacturing by fixing the channel length and width of the MOS <br>device. <br>
 <br>Three logic circuits using MOS devices are shown in  Fig. A.3  . For an  <i>n</i> channel  MOS, <br>
the supply voltage   <i>VDD</i>  is positive (about 5 V), to allow positive current flow from drain <br>to source. The two voltage levels are a function of the threshold voltage   <i>VT</i>.     The  low  level <br>is anywhere from zero to   <i>VT</i>,  and the high level ranges from   <i>VT</i> to  <i>VDD</i>.     The   <i>n</i> channel <br>gates usually employ positive logic. The  <i>p</i> channel MOS circuits use a negative voltage <br>for     <i>VDD</i>,  to allow positive current flow from source to drain. The two voltage levels are <br>both negative above and below the negative threshold voltage   <i>VT</i>.      <i>p</i> channel gates usu-<br>ally employ negative logic. <br>
 <br>The inverter circuit shown in  Fig.  A.3  (a) uses two MOS devices.  <i>Q1</i>  acts as the load <br>
resistor and  <i>Q2</i>  as the active device. The loadresistor MOS has its gate connected to   <i>VDD</i>,    <br>
<hr>
<A name=528></a><b>510    Appendix  Semiconductors and CMOS Integrated Circuits</b><br>
<i>VDD</i><br>
<i>VDD</i><br>
<i>VDD</i><br>
<i>Y</i><br>
 (<i>AB</i>)<br>
<i>Q</i>1<br>
<i>A</i><br>
<i>Y</i><br>
 (<i>A</i><br>
<i> B</i>)<br>
<i>Y</i><br>
<i>A</i><br>
<i>A</i><br>
<i>B</i><br>
<i>A</i><br>
<i>Q</i>2<br>
<i>B</i><br>
(a) Inverter<br>
(b) NAND gate<br>
(c) NOR gate<br>
 <br><b>FIGURE A.3   <br> <br><i>n</i> channel MOS logic circuits  </b><br>
thus maintaining it in the conduction state. When the input voltage is low (below   <i>VT</i> ),  <i>Q2</i> <br>turns off. Since  <i>Q1</i>  is always on, the output voltage is about   <i>VDD</i>.     When  the  input  voltage <br>is high (above  <i>VT</i> ),  <i>Q2</i>  turns on. Current flows from   <i>VDD</i>  through the load resistor  <i>Q1</i>   and <br>into  <i>Q2</i> . The geometry of the two MOS devices must be such that the resistance of  <i>Q2,</i> <br>when conducting, is much less than the resistance of  <i>Q1</i>  to maintain the output  <i>Y</i>  at a <br>voltage below   <i>VT</i>.  <br>
 <br>The NAND gate shown in  Fig. A.3  (b) uses transistors in series. Inputs  <i>A</i>  and  <i>B</i>   must <br>
both be high for all transistors to conduct and cause the output to go low. If either input <br>is low, the corresponding transistor is turned off and the output is high. Again, the series <br>resistance formed by the two active MOS devices must be much less than the resistance <br>of the loadresistor MOS. The NOR gate shown in  Fig. A.3  (c) uses transistors in parallel. <br>If either input is high, the corresponding transistor conducts and the output is low. If all <br>inputs are low, all active transistors are off and the output is high. <br>
<b> <br>A . 1     C O M P L E M E N TA R Y  M O S  </b><br>
 <br>Complementary MOS (CMOS) circuits take advantage of the fact that both  <i>n</i> channel <br>and  <i>p</i> channel devices can be fabricated on the same substrate. CMOS circuits consist <br>of both types of MOS devices, interconnected to form logic functions. The basic cir-<br>cuit is the inverter, which consists of one  <i>p</i> channel transistor and one  <i>n</i> channel <br>transistor, as shown in  Fig.  A.4  (a). The source terminal of the  <i>p</i> channel device is at <br> <br><i>VDD</i>,  and the source terminal of the  <i>n</i> channel device is at ground. The value of   <i>VDD</i> <br>
<hr>
<A name=529></a><b>Section A.1  Complementary MOS    511</b><br>
<i>VDD</i><br>
<i>VDD</i><br>
<i>Y</i><br>
 (<i>AB</i>)<br>
<i>p</i><br>
<i>A</i><br>
<i>A</i><br>
<i>Y</i><br>
<i>A</i><br>
<i>n</i><br>
<i>B</i><br>
(a) Inverter<br>
(b) NAND gate<br>
<i>VDD</i><br>
<i>A</i><br>
<i>B</i><br>
<i>Y</i><br>
 (<i>A</i><br>
<i> B</i>)<br>
(c) NOR gate<br>
 <br><b>FIGURE A.4   <br> <br>CMOS logic circuits  </b><br>
<hr>
<A name=530></a><b>512    Appendix  Semiconductors and CMOS Integrated Circuits</b><br>
may be anywhere from   +3 to  +18 V. The two voltage levels are 0 V for the low level <br>and     <i>VDD</i>  for the high level (typically, 5 V). <br>
 <br>To understand the operation of the inverter, we must review the behavior of the MOS <br>
transistor from the previous section: <br>
 <br><b> 1. </b><br>
  The   <i>n</i> channel MOS conducts when its gatetosource voltage is positive. <br>
 <br><b> 2. </b><br>
  The   <i>p</i> channel MOS conducts when its gatetosource voltage is negative. <br>
 <br><b> 3. </b><br>
 <br>Either type of device is turned off if its gatetosource voltage is zero. <br>
 <br>Now consider the operation of the inverter. When the input is low, both gates are at <br>
zero potential. The input is at   -<i>VDD</i>  relative to the source of the  <i>p</i> channel device and <br>at 0 V relative to the source of the  <i>n</i> channel device. The result is that the  <i>p</i> channel <br>device is turned on and the  <i>n</i> channel device is turned off. Under these conditions, there <br>is a lowimpedance path from   <i>VDD</i>  to the output and a very high impedance path from <br>output to ground. Therefore, the output voltage approaches the high level   <i>VDD</i>     under <br>normal loading conditions. When the input is high, both gates are at   <i>VDD</i>     and  the  situa-<br>tion is reversed: The  <i>p</i> channel device is off and the  <i>n</i> channel device is on. The result is <br>that the output approaches the low level of 0 V. <br>
 <br>Two other CMOS basic gates are shown in  Fig. A.4  . A twoinput NAND gate consists <br>
of two  <i>p</i> type units in parallel and two  <i>n</i> type units in series, as shown in  Fig.  A.4  (b). If <br>all inputs are high, both  <i>p</i> channel transistors turn off and both  <i>n</i> channel  transistors <br>turn on. The output has a low impedance to ground and produces a low state. If any input <br>is low, the associated  <i>n</i> channel transistor is turned off and the associated  <i>p</i> channel <br>transistor is turned on. The output is coupled to   <i>VDD</i>  and goes to the high state. Multiple<br>input NAND gates may be formed by placing equal numbers of  <i>p</i> type and  <i>n</i> type <br>transistors in parallel and series, respectively, in an arrangement similar to that shown <br>in   Fig.    A.4   (b).  <br>
 <br>A twoinput NOR gate consists of two  <i>n</i> type units in parallel and two  <i>p</i> type  units  in <br>
series, as shown in  Fig.  A.4  (c). When all inputs are low, both  <i>p</i> channel units are on and <br>both  <i>n</i> channel units are off. The output is coupled to   <i>VDD</i>  and goes to the high state. If any <br>input is high, the associated  <i>p</i> channel transistor is turned off and the associated  <i>n</i> channel <br>transistor turns on, connecting the output to ground and causing a lowlevel output. <br>
 <br>MOS transistors can be considered to be electronic switches that either conduct <br>
or are open. As an example, the CMOS inverter can be visualized as consisting of two <br>switches as shown in  Fig. A.5  (a). Applying a low voltage to the input causes the upper <br>switch ( <i>p</i> ) to close, supplying a high voltage to the output. Applying a high voltage <br>to the input causes the lower switch ( <i>n</i> ) to close, connecting the output to ground. <br>Thus, the output   <i>V</i>out  is the complement of the input   <i>V</i>in.     Commercial  applications <br>often use other graphic symbols for MOS transistors to emphasize the logical behav-<br>ior of the switches. The arrows showing the direction of current flow are omitted. <br>Instead, the gate input of the  <i>p</i> channel transistor is drawn with an inversion bubble <br>on the gate terminal to show that it is enabled with a low voltage. The inverter circuit <br>is redrawn with these symbols in  Fig.  A.5  (b). A logic 0 in the input causes the upper <br>transistor to conduct, making the output logic 1. A logic 1 in the input enables the <br>lower transistor, making the output logic 0. <br>
<hr>
<A name=531></a><b>Section A.1  Complementary MOS    513</b><br>
<i>VDD </i> 5 V<br>
<i>VDD</i><br>
<i>V</i>in<br>
<i>V</i>out<br>
<i>A</i><br>
<i>Y</i><br>
(a) Switch model<br>
(b) Logical model<br>
 <br><b>FIGURE A.5   <br> <br>CMOS inverter  </b><br>
<b> <br>CMOS Characteristics </b><br>
 <br>When a CMOS logic circuit is in a static state, its power dissipation is very low. This is <br>because at least one transistor is always off in the path between the power supply and <br>ground when the state of the circuit is not changing. As a result, a typical CMOS gate <br>has static power dissipation on the order of 0.01 mW. However, when the circuit is <br>changing state at the rate of 1 MHz, the power dissipation increases to about 1 mW, and <br>at 10 MHz it is about 5 mW. <br>
 <br>CMOS logic is usually specified for a single powersupply operation over a voltage <br>
range from 3 to 18 V with a typical   <i>VDD</i>  value of 5 V. Operating CMOS at a larger power<br>supply voltage reduces the propagation delay time and improves the noise margin, but <br>the power dissipation is increased. The propagation delay time with   <i>VDD </i>= 5  V     ranges <br>from 5 to 20 ns, depending on the type of CMOS used. The noise margin is usually about <br>40% of the power supply voltage. The fanout of CMOS gates is about 30 when they are <br>operated at a frequency of 1 MHz. The fanout decreases with an increase in the <br> <br>frequency of operation of the gates. <br>
 <br>There are several series of the CMOS digital logic family. The 74C series are pin and <br>
function compatible with TTL devices having the same number. For example, CMOS <br>IC type 74C04 has six inverters with the same pin configuration as TTL type 7404. The <br>highspeed CMOS 74HC series is an improvement over the 74C series, with a tenfold <br>increase in switching speed. The 74HCT series is electrically compatible with TTL ICs. <br>This means that circuits in this series can be connected to inputs and outputs of TTL ICs <br>without the need of addi tional interfacing circuits. Newer versions of CMOS are the <br>highspeed series 74VHC and its TTLcompatible version 74VHCT. <br>
 <br>The CMOS fabrication process is simpler than that of TTL and provides a greater <br>
packing density. Thus, more circuits can be placed on a given area of silicon at a reduced <br>cost per function. This property, together with the low power dissipation of CMOS cir-<br>cuits, good noise immunity, and reasonable propagation delay, makes CMOS the most <br>popular standard as a digital logic family. <br>
<hr>
<A name=532></a><b>514    Appendix  Semiconductors and CMOS Integrated Circuits</b><br>
<b> <br>A . 2     C M O S   T R A N S M I S S I O N   G AT E   C I R C U I T S </b><br>
 <br>A special CMOS circuit that is not available in the other digital logic families is the <br> <br><i>transmission gate</i> . The transmission gate is essentially an electronic switch that is con-<br>trolled by an input logic level. It is used to simplify the construction of various digital <br>components when fabricated with CMOS technology. <br>
 <br>Figure A.6(a) shows the basic circuit of the transmission gate. Whereas a CMOS <br>
in verter consists of a  <i>p</i> channel transistor connected in series with an  <i>n</i> channel  transis-<br>tor, a transmission gate is formed by one  <i>n</i> channel and one  <i>p</i> channel MOS transistor <br>connected in parallel. <br>
 The   <i>n</i> channel substrate is connected to ground and the  <i>p</i> channel substrate is con-<br>
nected to   <i>VDD</i>.     When  the   <i>N</i>  gate is at   <i>VDD</i>     and  the   <i>P</i>  gate is at ground, both transistors <br>conduct and there is a closed path between input  <i>X</i>  and output  <i>Y</i> . When the  <i>N</i>  gate is <br>at ground and the  <i>P</i>  gate is at   <i>VDD</i>,  both transistors are off and there is an open circuit <br>between  <i>X</i>  and  <i>Y</i> . Figure A.4(b) shows the block diagram of the transmission gate. Note <br>that the terminal of the  <i>p</i> channel gate is marked with the negation symbol. Figure A.4(c) <br>demonstrates the behavior of the switch in terms of positivelogic assignment with   <i>VDD</i> <br>equivalent to logic 1 and ground equivalent to logic 0. <br>
 <br>The transmission gate is usually connected to an inverter, as shown in  Fig.  A.7 . This <br>
type of arrangement is referred to as a  <i>bilateral switch</i> . The control input  <i>C</i>   is  connected <br>directly to the  <i>n</i> channel gate and its inverse to the  <i>p</i> channel  gate.  When     <i>C </i>= 1,     the <br>
<i>N</i><br>
<i>N</i><br>
<i>X</i><br>
<i>Y</i><br>
<i>X</i><br>
<i>TG</i><br>
<i>Y</i><br>
<i>VDD</i><br>
<i>P</i><br>
<i>P</i><br>
(a)<br>
(b)<br>
Closed switch<br>
Open switch<br>
<i>X</i><br>
<i>Y</i><br>
<i>X</i><br>
<i>Y</i><br>
<i>N</i><br>
 1<br>
<i>N</i><br>
 0<br>
<i>P</i><br>
 0<br>
<i>P</i><br>
 1<br>
(c)<br>
 <br><b>FIGURE A.6   <br> <br>Transmission gate (TG)  </b><br>
<hr>
<A name=533></a><b>Section A.2  CMOS Transmission Gate Circuits    515</b><br>
<i>C</i><br>
<i>X</i><br>
<i>TG</i><br>
<i>Y</i><br>
 <br><b>FIGURE A.7   <br> <br>Bilateral switch  </b><br>
switch is closed, producing a path between  <i>X</i>  and  <i>Y</i> .  When     <i>C </i>= 0,  the switch is open, <br>disconnecting the path between  <i>X</i>  and  <i>Y</i> .   <br>
 <br>Various circuits can be constructed that use the transmission gate. To demonstrate its <br>
usefulness as a component in the CMOS family, we will show three examples. <br>
 <br>The exclusiveOR gate can be constructed with two transmission gates and two <br>
inverters, as shown in  Fig. A.8  . Input A controls the paths in the transmission gates and <br>input  <i>B</i>  is connected to output  <i>Y</i>  through the gates. When input  <i>A</i>  is equal to 0, transmis-<br>sion gate  <i>TG1</i>  is closed and output  <i>Y</i>  is equal to input  <i>B</i> . When input A is equal to 1, <br> <br><i>TG2</i>  is closed and output  <i>Y</i>  is equal to the complement of input  <i>B</i> . This results in the <br>exclusiveOR  truth  table,  as  indicated  in   Fig.    A.8   .  <br>
 <br>Another circuit that can be constructed with transmission gates is the multiplexer. <br>
A  fourtooneline multiplexer implemented with transmission gates is shown in <br> Fig.   A.9   .  The   <i>TG</i>  circuit provides a transmission path between its horizontal input and <br>
<i>A</i><br>
<i>B</i><br>
<i>TG1</i><br>
<i>A</i><br>
<i>B</i><br>
<i>TG1</i><br>
<i>TG2</i><br>
<i>Y</i><br>
0<br>
0<br>
close<br>
open<br>
0<br>
<i>Y</i><br>
0<br>
1<br>
close<br>
open<br>
1<br>
1<br>
1<br>
open<br>
close<br>
1<br>
1<br>
0<br>
open<br>
close<br>
0<br>
<i>TG2</i><br>
 <br><b>FIGURE A.8   <br> <br>ExclusiveOR constructed with transmission gates  </b><br>
<hr>
<A name=534></a><b>516    Appendix  Semiconductors and CMOS Integrated Circuits</b><br>
<i>S</i>0<br>
<i>S</i>1<br>
<i>I</i><br>
<i>TG</i><br>
0<br>
(<i>S</i><br>
 <br>
0<br>
0)<br>
<i>TG</i><br>
(<i>S</i><br>
 <br>
1<br>
0)<br>
<i>TG</i><br>
<i>I</i>1<br>
(<i>S</i><br>
 <br>
0<br>
1)<br>
<i>Y</i><br>
<i>TG</i><br>
<i>I</i>2<br>
(<i>S</i><br>
 <br>
0<br>
0)<br>
<i>TG</i><br>
(<i>S</i><br>
 <br>
1<br>
1)<br>
<i>TG</i><br>
<i>I</i>3<br>
(<i>S</i><br>
 <br>
0<br>
1)<br>
 <br><b>FIGURE A.9   <br> <br>Multiplexer with transmission gates  </b><br>
output lines when the two vertical control inputs have the value of 1 in the uncircled ter-<br>minal and 0 in the circled terminal. With an opposite polarity in the control inputs, the path <br>disconnects and the circuit behaves like an open switch. The two selection inputs,   <i>S</i>1   and     <i>S</i>0,    <br>control the transmission path in the  <i>TG</i>  circuits. Inside each box is marked the condition <br>for the transmission gate switch to be closed. Thus, if   <i>S</i>0 = 0     and     <i>S</i>1 = 0,     there  is  a  closed <br>path from input   <i>I</i>0     to  output   <i>Y</i>  through the two  <i>TG</i> s  marked  with     <i>S</i>0 = 0     and     <i>S</i>1 = 0. The <br>other three inputs are disconnected from the output by one of the other  <i>TG</i>   circuits. <br>
<hr>
<A name=535></a><b>Section A.3  SwitchLevel Modeling With HDL    517</b><br>
<i>C</i><br>
<i>D</i><br>
<i>TG</i><br>
<i>Q</i><br>
<i>TG</i><br>
<i>Q</i><br>
<b> <br>FIGURE A.10   <br> <br>Gated  <i>D</i>  latch with transmission gates  </b><br>
 <br>The levelsensitive  <i>D</i>  flipflop commonly referred to as the gated  <i>D</i>  latch can be <br>
constructed with transmission gates, as shown in  Fig.  A.10  . The  <i>C</i>  input controls two <br>transmission gates  <i>TG</i> .  When     <i>C </i>= 1,     the   <i>TG</i>  connected to input  <i>D</i>  has a closed path <br>and the one connected to output  <i>Q</i>  has an open path. This configuration produces an <br>equivalent circuit from input  <i>D</i>  through two inverters to output  <i>Q</i> . Thus, the output fol-<br>lows the data input as long as  <i>C</i>  remains active. When  <i>C</i>  switches to 0, the first  <i>TG</i>   dis-<br>connects input  <i>D</i>  from the circuit and the second  <i>TG</i>  produces a closed path between <br>the two inverters at the output. Thus, the value that was present at input  <i>D</i>  at the time <br>that  <i>C</i>  went from 1 to 0 is retained at the  <i>Q</i>   output.  <br>
 <br>A master�slave  <i>D</i>  flipflop can be constructed with two circuits of the type shown in <br>
 <br>Fig. A.10  . The first circuit is the master and the second is the slave. Thus, a master�slave <br> <br><i>D</i>  flipflop can be constructed with four transmission gates and six inverters. <br>
<b> <br>A . 3     S W I T C H  L E V E L   M O D E L I N G   W I T H   H D L </b><br>
 <br>CMOS is the dominant digital logic family used with integrated circuits. By definition, <br>CMOS is a complementary connection of an NMOS and a PMOS transistor. MOS <br>transistors can be considered to be electronic switches that either conduct or are open. <br>By specifying the connections among MOS switches, the designer can describe a digital <br>circuit constructed with CMOS. This type of description is called  <i>switchlevel modeling</i> <br>in Verilog HDL. <br>
 <br>The two types of MOS switches are specified in Verilog HDL with the keywords  <b>nmos</b> <br>
and  <b>pmos</b> . They are instantiated by specifying the three terminals of the transistor, as <br>shown  in   Fig.    A.2   : <br>
 <br><b>nmos</b>  (drain, source, gate); <br> <br><b>pmos</b>  (drain, source, gate);  <br>
 <br>Switches are considered to be primitives, so the use of an instance name is optional. <br>
<hr>
<A name=536></a><b>518    Appendix  Semiconductors and CMOS Integrated Circuits</b><br>
 <br>The connections to a power source   (<i>VDD</i>)  and to ground must be specified when MOS <br>
circuits are designed. Power and ground are defined with the keywords  <b>supply1</b>   and <br> <br><b>supply0</b> . They are specified, for example, with the following statements: <br>
 <br><b>supply1</b>  PWR; <br>
 <br><b>supply0</b>  GRD;  <br>
 <br>Sources of type  <b>supply1</b>  are equivalent to   <i>VDD</i>  and have a value of logic 1. Sources of <br>type  <b>supply0</b>  are equivalent to ground connection and have a value of logic 0. <br>
 <br>The description of the CMOS inverter of  Fig. A.4  (a) is shown in HDL Example A.1. <br>
The input, the output, and the two supply sources are declared first. The module instan-<br>tiates a PMOS and an NMOS transistor. The output  <i>Y</i>  is common to both transistors <br>at their drain terminals. The input is also common to both transistors at their gate <br>terminals. The source terminal of the PMOS transistor is connected to PWR and the <br>source terminal of the NMOS transistor is connected to GRD. <br>
<b> HDL  Example  A.1  </b><br>
 <br>// CMOS inverter of Fig. A.4(a)<br>
 <br><b>module</b>  inverter (Y, A);<br>   <b>input</b>  A;<br>   <b>output</b>  Y;<br>   <b>supply1</b>   PWR;<br>   <b>supply0</b>   GRD;<br>   <b>pmos</b>  (Y, PWR, A); <br>
// (Drain, source, gate)<br>
   <b>nmos</b>  (Y, GRD, A); <br>
// (Drain, source, gate)<br>
 <br><b>endmodule</b> <br>
 <br>The second module, set forth in HDL Example A.2, describes the twoinput CMOS <br>
NAND circuit of  Fig.  A.4  (b). There are two PMOS transistors connected in parallel, <br>with their source terminals connected to PWR. There are also two NMOS transistors <br>connected in series and with a common terminal  <i>W1</i> . The drain of the first NMOS is <br>connected to the output, and the source of the second NMOS is connected to GRD. <br>
<b> HDL  Example  A.2  </b><br>
 <br>// CMOS two-input NAND of Fig. A.4(b)<br>
 <br><b>module</b>  NAND2 (Y, A, B);<br>   <b>input</b>  A, B;<br>   <b>output</b>  Y;<br>   <b>supply1</b>   PWR;<br>   <b>supply0</b>   GRD;<br>   <b>wire</b>  W1; <br>
// terminal between two nmos<br>
   <b>pmos</b>  (Y, PWR, A); <br>
// source connected to Vdd<br>
   <b>pmos</b>  (Y, PWR, B); <br>
// parallel connection<br>
<hr>
<A name=537></a><b>Section A.3  SwitchLevel Modeling With HDL    519</b><br>
   <b>nmos</b>  (Y, W1, A); <br>
// serial connection<br>
   <b>nmos</b>  (W1, GRD, B); <br>
// source connected to ground<br>
 <br><b>endmodule</b> <br>
<b> <br>Transmission Gate </b><br>
 <br>The transmission gate is instantiated in Verilog HDL with the keyword  <b>cmos</b> . It has an <br>output, an input, and two control signals, as shown in Fig. A.6. It is referred to as a  <b>cmos</b> <br>switch. The relevant code is as follows: <br>
 <br><b>cmos</b>  (output, input, ncontrol, pcontrol); // general description <br>
 <br><b>cmos</b>  (Y, X, N, P);  // transmission gate of  Fig.   A.6  (b)  <br>
 <br>Normally, ncontrol and pcontrol are the complement of each other. The  <b>cmos</b>   switch <br>does not need power sources, since   <i>VDD</i>  and ground are connected to the substrates of <br>the MOS transistors. Transmission gates are useful for building multiplexers and flip<br>flops with CMOS circuits. <br>
 <br>HDL Example A.3 describes a circuit with  <b>cmos</b>  switches. The exclusiveOR circuit <br>
of  Fig.  A.8   has two transmission gates and two inverters. The two inverters are instan-<br>tiated within the module describing a CMOS inverter. The two  <b>cmos</b>  switches are <br>instantiated without an instance name, since they are primitives in the language. A test <br>module is included to test the circuit's operation. Applying all possible combinations <br>of the two inputs, the result of the simulator verifies the operation of the exclusiveOR <br>circuit. The output of the simulation is as follows: <br>
 <i>A </i>= 0 <i>B </i>= 0 <i>Y </i>= 0<br>
<i>A </i>= 0 <i>B </i>= 1 <i>Y </i>= 1<br><i>A </i>= 1 <i>B </i>= 0 <i>Y </i>= 1<br><i>A </i>= 1 <i>B </i>= 1 <i>Y </i>= 0   <br>
<b> HDL  Example  A.3  </b><br>
 <br>//CMOS_XOR with CMOS switches, Fig. A.8<br>
 <br><b>module</b>  CMOS_XOR (A, B, Y);<br>   <b>input</b>  A, B;<br>   <b>output</b>  Y;<br>   <b>wire</b>  A_b, B_b;<br>   // instantiate inverter<br>
   inverter v1 (A_b, A);<br>
   inverter v2 (B_b, B);<br>
   // instantiate cmos switch<br>
   <b>cmos</b>  (Y, B, A_b, A); <br>
//(output, input, ncontrol, pcontrol)<br>
   <b>cmos</b>  (Y, B_b, A, A_b);<br> <br><b>endmodule</b> <br>
<hr>
<A name=538></a><b>520    Appendix  Semiconductors and CMOS Integrated Circuits</b><br>
 <br>// CMOS inverter Fig. A.4(a)<br>
 <br><b>module</b>  inverter (Y, A);<br>   <b>input</b>  A;<br>   <b>output</b>  Y;<br>   <b>supply1</b>   PWR;<br>   <b>supply0</b>   GND;<br>   <b>pmos</b>  (Y, PWR, A); <br>
//(Drain, source, gate)<br>
   <b>nmos</b>  (Y, GND, A); <br>
//(Drain, source, gate)<br>
 <br><b>endmodule</b> <br> <br>// Stimulus to test CMOS_XOR<br>
 <br><b>module</b>  test_CMOS_XOR;<br>   <b>reg</b>  A,B;<br>   <b>wire</b>  Y;<br>   //Instantiate CMOS_XOR<br>
   CMOS_XOR X1 (A, B, Y);<br>
   // Apply truth table<br>
   <b>initial</b> <br>   <b>begin</b> <br>   A = 1'b0; B = 1'b0;<br>
   #5 A = 1'b0; B = 1'b1;<br>
   #5 A = 1'b1; B = 1'b0;<br>
   #5 A = 1'b1; B = 1'b1;<br>
 <br><b>end</b> <br> <br>// Display results<br>
 <br><b>initial</b> <br>   <b>$monitor</b>  (&quot;A =%b  B= %b  Y =%b&quot;, A, B, Y);<br> <br><b>endmodule</b> <br>
<b> <br>W E B   S E A R C H   T O P I C S </b><br>
 Conductor <br> Semiconductor <br> Insulator <br> <br>Electrical properties of materials <br> Valence  electron <br> Diode <br> Transistor <br> CMOS  process <br> <br>CMOS logic gate <br> CMOS  inverter    <br>
<hr>
<A name=539></a><b> <br>Answers to Selected Problems </b><br>
<b> <br>C H A P T E R   1 </b><br>
<b>  1.2 </b><br>
<b>  (a)  </b>32,768  <b>(b)</b> 67,108,864  <b>(c)</b> 6,871,947,674 <br>
 <br>
<b>  1.3 </b><br>
<b>  (a)     </b>(4310)5 = 580       <b>(b)</b>     (198)12 = 260 <br>
<b>  1.5 </b><br>
<b>  (a)  </b>6  <b>(b)</b> 8  <b>(c)</b> 11 <br>
 <br>
<b>  1.6 </b><br>
<b>  <br></b>8<b> </b><br>
<b>  1.7 </b><br>
<b>     <br></b>(62315)8<b> </b><br>
<b>  1.9 </b><br>
<b>  <br></b>22.3125<b> </b>(all three)  <br>
<b>  1.12 </b><br>
<b>  (a)  </b>10000 and 110111    <b>(b)</b>  62 and 958  <br>
<b>  1.19 </b><br>
<b>  (a)  </b>010087  <b>(b)</b> 008485  <b>(c)</b> 991515  <b>(d)</b> 989913 <br>
 <br>
<b>  1.24 </b><br>
<b>  (a)  6</b>      <b>3</b>      <b>1</b>      <b>1</b>      <b>Decimal</b> <br>
<b> <br></b>0<b> </b><br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 1 <br>
 1 <br>
 2 <br>
 0 <br>
 1 <br>
 0 <br>
 0 <br>
 3 <br>
 0 <br>
 1 <br>
 1 <br>
 0 <br>
 4  (<i>or</i> 0101) <br>
 0 <br>
 1 <br>
 1 <br>
 1 <br>
 5 <br>
 1 <br>
 0 <br>
 0 <br>
 0 <br>
 6 <br>
 1 <br>
 0 <br>
 1 <br>
 0 <br>
 7  (<i>or</i> 1001) <br>
 1 <br>
 0 <br>
 1 <br>
 1 <br>
 8 <br>
 1 <br>
 1 <br>
 0 <br>
 0 <br>
 9 <br>
<b>521</b><br>
<hr>
<A name=540></a><b>522    Answers to Selected Problems</b><br>
<b>  1.29 </b><br>
<b>  <br></b>Steve Jobs  <br>
<b>  1.31 </b><br>
<b>     <br></b>62 + 32 = 94<b> </b>printing characters  <br>
<b>  1.32 </b><br>
<b>  <br></b>bit 6 from the right  <br>
<b>  1.33 </b><br>
<b>  (a)  </b>897  <b>(b)</b> 564 <b>(c)</b> 871 <b>(d)</b>  2,199   <br>
<b> <br>C H A P T E R   2 </b><br>
<b>  2.2 </b><br>
<b>  (a)  </b><i>x</i>    <b>(b)</b>  <i>x</i>    <b>(c)</b>  <i>y</i>    <b>(d)</b> 0 <br>
 <br>
<b>  2.3 </b><br>
<b>  (a)  </b>B  <b>(b)</b>   <i>z</i>(<i>x </i>+ <i>y</i>)       <b>(c)</b>   <i>x y </i>    <b>(d)</b>   <i>x</i>(<i>w </i>+ <i>y</i>)       <b>(e)</b> 0 <br>
 <br>
<b>  2.4 </b><br>
<b>  (a)     </b><i>AB </i>+ <i>C </i>    <b>(b)</b>   <i>x </i>+ <i>y </i>+ <i>z</i>    <b>(c)</b> B  <b>(d)</b>   <i>A </i>(<i>B </i>+ <i>C A</i>) <br>
<b>  2.9 </b><br>
<b>  (a)     </b><i>xy </i>+ <i>x y </i> <br>
<b>  2.11 </b><br>
<b>     <br></b><i>F</i>(<i>x</i>, <i>y</i>, <i>z</i>) =<br>
(1, 4, 5, 6, 7)<b> </b><br>
<b>  2.12 </b><br>
<b>  (a)  </b>10100000  <b>(c)</b> 00011101  <b>(d)</b> 01001110 <br>
 <br>
<b>  2.14 </b><br>
<b>  (b)     </b>(<i>x </i>+ <i>y </i>) + (<i>x </i>+ <i>y</i>) + (<i>y </i>+ <i>z </i>)  <br>
<b>  2.15 </b><br>
<b>     <br></b><i>T</i>1 = <i>A </i>(<i>B </i>+ <i>C </i>)<b> </b><br>
<b> </b><br>
<b> <br></b><i>T</i><br>
=<br>
2 = <i>A </i>+ <i>BC </i>= <i>T </i>1<b> </b><br>
<b>  2.17 </b><br>
<b>  (a)      </b>(3, 5, 6, 7) =<br>
(0,  1,  2,  4)     <br>
<b>  2.18 </b><br>
<b>  (c) </b><br>
<b>   <br></b><i>F </i>= <i>y z </i>+ <i>y</i>(<i>w </i>+ <i>x</i>) <br>
<b>  2.19 </b><br>
<b>      </b>(1, 3, 5, 7, 9, 11, 13, 15) =<br>
(0, 2, 4, 6, 8, 10, 12, 14)<b> </b><br>
<b>  2.22 </b><br>
<b>  (a)     </b><i>AB </i>+ <i>BC </i>= (<i>A </i>+ <i>C</i>)<i>B</i>    <b>(b)</b>   <i>x </i>+ <i>y </i>+ <i>z </i> <br>
<b> <br>C H A P T E R   3 </b><br>
<b>  3.1 </b><br>
<b>  (a) </b><br>
<b>   </b><i>xy </i>+ <i>x z </i>    <b>(b)</b>   <i>xy </i>+ <i>z </i>    <b>(c)</b>   <i>x </i>+ <i>y z</i>    <b>(d)</b>   <i>x y </i>+ <i>x z </i>+ <i>yz</i> <br>
<b>  3.2 </b><br>
<b>  (a) </b><br>
<b>   </b><i>x y </i>+ <i>xz</i>    <b>(b)</b>   <i>y </i>+ <i>x z</i> <br>
<b>  3.3 </b><br>
<b>  (a) </b><br>
<b>   </b><i>xy </i>+ <i>x z </i>    <b>(b)</b>   <i>x </i>+ <i>yz</i>    <b>(c)</b>   <i>z </i>+ <i>x y</i> <br>
<b>  3.4 </b><br>
<b>  (a) </b><br>
<i>y</i>    <b>(b)</b>   <i>BCD </i>+ <i>A BD </i>    <b>(c)</b>   <i>ABD </i>+ <i>ABC </i>+ <i>CD</i>   <br>
<b> </b><br>
<b>(d) </b><br>
<b>   <br></b><i>wx </i>+ <i>w x y</i><b> </b><br>
<b>  3.5 </b><br>
<b>  (a) </b><br>
<b>   </b><i>xz </i>+ <i>w y z </i>+ <i>wxy</i>    <b>(d)</b>   <i>BD </i>+ <i>B D </i>+ <i>A B</i>       or       <i>BD </i>+ <i>B D </i>+ <i>A D </i> <br>
<b>  3.6 </b><br>
<b>  (a) </b><br>
<b>   <br></b><i>B D </i>+ <i>A BD </i>+ <i>ABC </i>    <b>(b)</b>   <i>xy </i>+ <i>x z </i>+ <i>wx y</i> <br>
<b>  3.7 </b><br>
<b>  (a) </b><br>
<b>   </b><i>x y </i>+ <i>z</i>    <b>(c)</b>   <i>AC </i>+ <i>B D </i>+ <i>A BD </i>+ <i>B C</i>     (or  CD)  <br>
<b>  3.8 </b><br>
<b>  (a) </b><br>
<b>   <br></b><i>F</i>(<i>x</i>, <i>y</i>, <i>z</i>) =<br>
(3, 5, 6, 7)    <b>(b)</b>   <i>F</i> (<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>) =<br>
(1, 3, 5, 9, 12, 13, 14) <br>
<b>  3.9 </b><br>
<b>  (a)  </b>Essential: <i>xz</i> and   <i>x z </i>;     Nonessential:     <i>w x</i>     and     <i>w z </i> <br>
<b> </b><br>
<b> (b)     </b><i>F </i>= <i>B D </i>+ <i>AC </i>+ <i>A BD </i>+ (<i>CD</i> <b>or</b> <i>B C</i>)<b> </b><br>
<b>  3.10 </b><br>
<b>  (c) </b><br>
<b>   <br></b><i>F </i>= <i>BC </i>+ <i>AC </i>+ <i>A B D</i> <br>
<hr>
<A name=541></a><b>Answers to Selected Problems    523</b><br>
<b> </b><br>
<b> <br>Essential:  </b><i>BC </i>,<b> </b>AC <br>
<b> </b><br>
<b> <br>Nonessential: </b>AB, <b> </b><i>A B D</i>, <i>B CD</i>, <i>A C D</i> <br>
<b>  3.11 </b><br>
<b>  (a)     </b><i>F </i>= <i>A B D </i>+ <i>AD E </i>+ <i>B C D </i> <br>
<b>  3.12 </b><br>
<b>  (b)     </b><i>F </i>= (<i>A </i>+ <i>D </i>)(<i>B </i>+ <i>D </i>) <br>
<b>  3.13 </b><br>
<b>  (a)     </b><i>F </i>= <i>xy </i>+ <i>z </i>= (<i>x </i>+ <i>z </i>)(<i>y </i>+ <i>z </i>) <br>
<b>  3.15 </b><br>
<b>  (b)     </b><i>F </i>= <i>B D </i>+ <i>CD </i>+ <i>ABC D </i>=<br>
(0, 2, 6, 8, 10, 13, 14) <br>
<b> <br>3.17 </b><br>
<b> <br></b><i>F </i>= <i>AC </i>+ <i>BC </i>+ <i>BD</i><b> </b><br>
<b>  3.19 </b><br>
<b>  (a)     </b><i>F </i>= (<i>w </i>+ <i>z </i>)(<i>x </i>+ <i>z </i>)(<i>w </i>+ <i>x </i>+ <i>y </i>) <br>
<b>  3.30 </b><br>
<b>     <br></b><i>F </i>= (<i>A </i>{ <i>B</i>)(<i>C </i>{ <i>D</i>)<b> </b><br>
<b>  3.35 </b><br>
<b>  <br></b>The<b> </b>HDL description is available on the Companion Website. <br>
 <br>Line 1: Dash not allowed, use underscore: Exmpl_3. <br> <br>
 <br>Terminate line with semicolon (;). <br>
 Line  2:  <b>inputs</b> should be <b>input</b> (no s at the end). <br> <br>
 <br>Change last comma (,) to semicolon (;). Output is declared but does not <br>appear in the port list, and should be followed by a comma if it is in-<br>tended to be in the list of inputs. If <i>Output</i> is a mispelling of <b>output</b> and <br>is to declare output ports, C should be followed by a semicolon (;) and <br><i>F</i> should be followed by a semicolon (;). <br>
 <br>Line 3:  <i>B</i> cannot be declared as input (Line 2) and output (Line 3). Terminate the <br>
line with a semicolon (;). <br>
 Line  4:  <i>A</i> cannot be an output of the primitive if it is an input to the module <br> <br>Line 5: Too many entries for the not gate (only two allowed). <br> <br>Line 6: OR must be in lowercase: change to "or". <br> <br>Line 7:  <b>endmodule</b> is mispelled. Remove semicolon (no semicolon after endmodule). <br>
<b> <br>C H A P T E R   4 </b><br>
<b>  4.1 </b><br>
<b>  (a)     </b><i>F</i>1 = <i>A </i>+ <i>B C </i>+ <i>BD </i>+ <i>B D</i> <br>
<b> </b><br>
<b> </b><br>
<b> <br></b><i>F</i>2 = <i>A B </i>+ <i>D</i><b> </b><br>
<b>  4.2 </b><br>
<b> </b><br>
<b>     <br></b><i>F </i>= <i>ABC </i>+ <i>A D</i><b> </b><br>
<b> </b><br>
<b> </b><br>
<b> <br></b><i>G </i>= <i>ABC </i>+ <i>A D </i><b> </b><br>
<b>  4.3 </b><br>
<b>  (b)  </b>1024 rows and 14 columns  <br>
<b>  4.4 </b><br>
<b>  (a)     </b><i>F </i>= <i>x y </i>+ <i>x z </i> <br>
<b>  4.6 </b><br>
<b>     <br></b><i>F </i>= <i>xy </i>+ <i>xz </i>+ <i>yz</i><b> </b><br>
<b>  4.7 </b><br>
<b>  (a)     </b><i>w </i>= <i>A</i>   <i>x </i>= <i>A </i>{ <i>B</i>   <i>y </i>= <i>x </i>{ <i>C</i>   <i>z </i>= <i>y </i>{ <i>D</i> <br>
<b>  4.8 </b><br>
<b>     <br></b><i>w </i>= <i>AB </i>+ <i>AC D </i><b> </b><br>
<hr>
<A name=542></a><b>524    Answers to Selected Problems</b><br>
<b>  4.10 </b><br>
<b>  <br></b>Inputs: A, B, C, D; Outputs: <i>w, x, y, z</i> <br>
<b> </b><br>
<b> <br></b><i>z </i>= <i>D</i><b> </b><br>
<b> </b><br>
<b> </b><i>y </i>= <i>C </i>{ <i>D</i><b> </b><br>
<b> </b><br>
<b> </b><i>x </i>= <i>B </i>{ (<i>C </i>+ <i>D</i>)<b> </b><br>
<b> </b><br>
<b> <br></b><i>w </i>= <i>A </i>{ (<i>B </i>+ <i>C </i>+ <i>D</i>)<b> </b><br>
<b>  4.12 </b><br>
<b>  (b) </b><br>
<b>   <br></b><i>Diff </i>= <i>x </i>{ <i>y </i>{ <i>Bin</i> <br>
<b> </b><br>
<b> <br></b><i>Bout </i>= <i>x y </i>+ <i>x Bin </i>+ <i>yBin</i><b> </b><br>
<b>  4.13 </b><br>
<b>      </b>  <br>
 Sum <br>
<i> C </i><br>
<i> V </i><br>
<b> (a) </b><br>
 1101 <br>
 0 <br>
 1 <br>
<b> (b) </b><br>
 0001 <br>
 1 <br>
 1 <br>
<b> (c) </b><br>
 0100 <br>
 1 <br>
 0 <br>
<b> (d) </b><br>
 1011 <br>
 0 <br>
 1 <br>
<b> (e) </b><br>
 1111 <br>
 0 <br>
 0 <br>
<b>  4.14 </b><br>
<b>  <br></b>30<b> </b>ns  <br>
<b>  4.18 </b><br>
<b>     <br></b><i>w </i>= <i>A B C </i><b> </b><br>
<b> </b><br>
<b> </b><i>x </i>= <i>B </i>{ <i>C</i><b> </b><br>
<b> </b><br>
<b> </b><i>y </i>= <i>C</i><b> </b><br>
<b> </b><br>
<b> <br></b><i>z </i>= <i>D </i><b> </b><br>
<b>  4.22 </b><br>
<b>     <br></b><i>w </i>= <i>AB </i>+ <i>ACD</i><b> </b><br>
<b> </b><br>
<b> </b><i>x </i>= <i>B C </i>+ <i>B D </i>+ <i>BCD</i><b> </b><br>
<b> </b><br>
<b> </b><i>y </i>= <i>C D </i>+ <i>CD </i><b> </b><br>
<b> </b><br>
<b> <br></b><i>z </i>= <i>D </i><b> </b><br>
<b>  4.28 </b><br>
<b>  (a) </b><br>
<b>   <br></b><i>F</i>1 =<br>
(0,  5,  7)    <br>
<b> </b><br>
<b> </b><br>
<b> <br></b><i>F</i>2 =<br>
(2, 3, 4)<b> </b><br>
<b> </b><br>
<b> </b><br>
<b> <br></b><i>F</i>3 =<br>
(1, 6, 7)<b> </b><br>
<b>  4.29 </b><br>
<b>     </b><i>x</i><br>
=<br>
=<br>
= <i>D</i>0<i>D</i>1<b> </b><br>
<b> </b><br>
<b> </b><i>y</i><br>
=<br>
=<br>
=<br>
= <i>D</i>0<i>D</i>1 + <i>D</i>0<i>D</i>2<b> </b><br>
<b>  4.34 </b><br>
<b>     <br></b><i>F</i>(<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>) =<br>
(1, 6, 7, 9, 10, 11, 12)<b> </b><br>
<b>  4.35 </b><br>
<b>  (a) </b><br>
<b>   <br></b>When <i>AB </i>= 00, <i>F </i>= <i>D</i> <br>
<b> </b><br>
<b> </b><br>
<b> </b>When <i>AB </i>= 01, <i>F </i>= (<i>C </i>+ <i>D</i>) <b> </b><br>
<b> </b><br>
<b> </b><br>
<b> </b>When <i>AB </i>= 10, <i>F </i>= <i>CD</i><b> </b><br>
<b> </b><br>
<b> </b><br>
<b> </b>When <i>AB </i>= 11, <i>F </i>= 1<b> </b><br>
<b>  4.39 </b><br>
<b>  <br></b>The<b> </b>HDL description is available on the Companion Website. <br>
<b>  4.42 </b><br>
<b>  (c)  </b>The HDL description is available on the Companion Website. <br>
<hr>
<A name=543></a><b>Answers to Selected Problems    525</b><br>
<b>  4.50 </b><br>
<b>  <br></b>The<b> </b>HDL description is available on the Companion Website. <br>
<b>  4.56 </b><br>
<b>  <br>assign </b>match = (A == B); <br>
// Assumes <b>reg</b> [3: 0] A, B;  <br>
<b>  4.57 </b><br>
<b>  <br></b>The<b> </b>HDL description is available on the Companion Website. <br>
<b> <br>C H A P T E R   5 </b><br>
<b>  5.4 </b><br>
<b>  (b)     </b><i>PQ </i>+ <i>NQ</i> <br>
<b>  5.7 </b><br>
<b>     <br></b><i>S </i>= <i>x </i>{ <i>y </i>{ <i>Q</i><b> </b><br>
<b> </b><br>
<b> <br></b><i>Q</i>(<i>t </i>+ 1) = <i>xy </i>+ <i>xQ </i>+ <i>yQ</i><b> </b><br>
<b>  5.8 </b><br>
<b>  <br></b>A<b> </b>counter with a repeated sequence of 00, 01, 10  <br>
<b>  5.9 </b><br>
<b>  (a) </b><br>
<b>   </b><i>A</i>(<i>t </i>+ 1) = <i>xA </i>+ <i>AB</i> <br>
<b> </b><br>
<b> </b><br>
<b> <br></b><i>B</i>(<i>t </i>+ 1) = <i>xB </i>+ <i>A B</i><b> </b><br>
<b>  5.10 </b><br>
<b>  (c) </b><br>
<b>   </b><i>A</i>(<i>t </i>+ 1) = <i>xB </i>+ <i>x A </i>+ <i>yA </i>+ <i>y A B </i> <br>
<b> </b><br>
<b> </b><br>
<b> <br></b><i>B</i>(<i>t </i>+ 1) = <i>xA B </i>+ <i>x A B </i>+ <i>yA B </i><b> </b><br>
<b>  5.11 </b><br>
<b>      </b> Present  state: <br>
 00   00   01   00   01   11   00   01   11   10   00   01   11   10   10 <br>
 Input: <br>
 0   1   0   1   1   0   1   1   1   0   1   1   1   1   0 <br>
 Output: <br>
 0   0   1   0   0   1   0   0   0   1   0   0   0   0   1 <br>
 Next  state: <br>
 00   01   00   01   11   00   01   11   10   00   01   11   10   10   00 <br>
<b>  5.12 </b><br>
<b>       Present  state</b><br>
<b> Next  state</b><br>
<b> Output</b><br>
<b> </b><br>
<b>  0  1 </b><br>
<b>    0  1 </b><br>
<i> a </i><br>
<i>     f </i><br>
<i>b </i><br>
    0  0 <br>
<i> b </i><br>
<i>     d </i><br>
<i>a </i><br>
    0  0 <br>
<i> d </i><br>
<i>     g </i><br>
<i>a </i><br>
    1  0 <br>
<i> f </i><br>
<i>     f </i><br>
<i>b </i><br>
    1  1 <br>
<i> g </i><br>
<i>     g </i><br>
<i>d </i><br>
    0  1 <br>
<b>  5.13 </b><br>
<b>  (a)     </b> State: <br>
<i> <br>a f b c e d g h g g h a </i><br>
 <br>Input: <br>
 <br>0 1 1 1 0 0 1 0 0 1 1 <br>
 <br>Output: <br>
 <br>0 1 0 0 0 1 1 1 0 1 0 <br>
<b> </b><br>
<b> (b)      </b> State: <br>
<i> <br>a f b a b d g d g g d a </i><br>
 <br>Input: <br>
 <br>0 1 1 1 0 0 1 0 0 1 1 <br>
 <br>Output: <br>
 <br>0 1 0 0 0 1 1 1 0 1 0 <br>
<b>  5.15 </b><br>
<b>     <br></b><i>DQ </i>= <i>Q J </i>+ <i>QK </i><b> </b><br>
<hr>
<A name=544></a><b>526    Answers to Selected Problems</b><br>
<b>  5.16 </b><br>
<b>     <br></b><i>DA </i>= <i>Ax </i>+ <i>Bx</i><b> </b><br>
<b> </b><br>
<b> <br></b><i>DB </i>= <i>A x </i>+ <i>Bx </i><b> </b><br>
<b>  5.18 </b><br>
<b>     </b><i>JA </i>= <i>KA </i>= (<i>BF </i>+ <i>B F </i>)<i>E</i><b> </b><br>
<b> </b><br>
<b> </b><i>JB </i>= <i>KB </i>= <i>E</i><b> </b><br>
<b>  5.19 </b><br>
<b>  (a)     </b><i>DA </i>= <i>A B x</i>_<i>in</i> <br>
<b> </b><br>
<b> </b><br>
<b> <br></b><i>DB </i>= <i>A </i>+ <i>C x</i>_<i>in </i>+ <i>BCx</i>_<i>in</i><b> </b><br>
<b> </b><br>
<b> </b><br>
<b> <br></b><i>DC </i>= <i>Cx</i>_<i>in </i>+ <i>Ax</i>_<i>in </i>+ <i>A B x</i>_<i>in </i><b> </b><br>
<b> </b><br>
<b> </b><br>
<b> </b><i>y</i>_<i>out </i>= <i>A x</i>_<i>in</i><b> </b><br>
<b>  5.23 </b><br>
<b>  (a)     </b><i>RegA </i>= 125,        <i>RegB </i>= 125    <br>
<b> </b><br>
<b> (b)     </b><i>RegA </i>= 125,<b>   </b><i>RegB </i>= 30 <br>
<b>  5.26 </b><br>
<b>  (a) </b><br>
<b> </b><br>
<b> <br></b><i>Q</i>(<i>t </i>+ 1) = <i>JQ </i>+ <i>K Q</i><b> </b><br>
<b> </b><br>
<b> <br></b>When <i>Q </i>= 0, <i>Q</i>(<i>t </i>+ 1) = <i>J</i><b> </b><br>
<b> </b><br>
<b> <br></b>When <i>Q </i>= 1, <i>Q</i>(<i>t </i>+ 1) = <i>K </i><b> </b><br>
 <br><b>module</b> JK_Behavior (<b>output reg</b> Q, <b>input</b> J, K, CLK);<br>  <b>always</b> @ (<b>posedge</b> CLK)<br> <br>
<b>if</b> (Q == 0)  <br>
Q &lt;= J;<br>
 <br>
<b>else</b> <br>
Q &lt;= ~K;<br>
 <br><b>endmodule</b> <br>
<b> <br>  5.31 </b><br>
<b>  <br></b>The<b> </b>HDL description is available on the Companion Website. <br>
<b> </b><br>
<b> <br></b>Note: The<b> </b>statements must be written in an order that produces the effect of con-<br>current  assignments.   <br>
<b> <br>C H A P T E R   6 </b><br>
<b>  6.4 </b><br>
<b>  <br></b>0110;<b> </b>0011; 0001; 1000; 1100; 1110;  0111; 1011  <br>
<b>  6.8 </b><br>
<b>     </b><i>A </i>= 0010,<b> </b>0001, 1000, 1100.   Carry = 1,     1,  1,  0  <br>
<b>  6.9 </b><br>
<b>  (b)     </b><i>JQ </i>= <i>x y</i>; <i>KQ </i>= (<i>x </i>+ <i>y</i>)  <br>
<b>  6.14 </b><br>
<b>  (a)  </b>4  <br>
 <br>
<b>  6.15 </b><br>
<b>  <br></b>30 ns; 33.3 MHz  <br>
<b>  6.16 </b><br>
<b>     <br></b>1010 S 1011 S 0100<b> </b><br>
<b> </b><br>
<b> <br></b>1100 S 1101 S 0100<b> </b><br>
<b> </b><br>
<b> <br></b>1110 S 1111 S 0000<b> </b><br>
<hr>
<A name=545></a><b>Answers to Selected Problems    527</b><br>
<b> <br>6.17 </b><br>
<b> <br></b><i>DA</i>0 = <i>A</i>0 { <i>E</i><b> </b><br>
<b> </b><br>
<b> <br></b><i>DA</i>1 = <i>A</i>1 { (<i>A</i>0<i>E</i>)<b> </b><br>
<b> </b><br>
<b> <br></b><i>DA</i>2 = <i>A</i>2 { (<i>A</i>1<i>A</i>0<i>E</i>)<b> </b><br>
<b> </b><br>
<b> <br></b><i>DA</i>3 = <i>A</i>3 { (<i>A</i>2<i>A</i>1<i>A</i>0<i>E</i>)<b> </b><br>
<b>  6.19 </b><br>
<b>  (b)     </b><i>D</i><br>
=<br>
<i>Q</i>1 = <i>Q</i>1 <br>
<b> </b><br>
<b> </b><br>
<b> <br></b><i>D</i><br>
=<br>
=<br>
=<br>
<i>Q</i>2 = <i>Q</i>2<i>Q</i>1 + <i>Q</i>8<i>Q</i>2<i>Q</i>1<b> </b><br>
<b> </b><br>
<b> </b><br>
<b> <br></b><i>D</i><br>
=<br>
=<br>
=<br>
=<br>
<i>Q</i>4 = <i>Q</i>4<i>Q</i>1 + <i>Q</i>4<i>Q</i>2 + <i>Q</i>4<i>Q</i>2<i>Q</i>1<b> </b><br>
<b> </b><br>
<b> </b><br>
<b> <br></b><i>D</i><br>
=<br>
<i>Q</i>8 = <i>Q</i>8<i>Q</i>1 + <i>Q</i>4<i>Q</i>2<i>Q</i>1<b> </b><br>
<b>  6.21 </b><br>
<b>     </b><i>JA</i>0 = <i>LI</i>0 + <i>L C</i><b> </b><br>
<b> </b><br>
<b> <br></b><i>K</i><br>
=<br>
<i>A</i>0 = <i>LI</i>0 + <i>L C</i><b> </b><br>
<b>  6.24 </b><br>
<b>       </b><i>TA </i>= <i>A </i>{ <i>B</i><b> </b><br>
<b> </b><br>
<b> <br></b><i>TB </i>= <i>B </i>{ <i>C</i><b> </b><br>
<b> </b><br>
<b> <br></b><i>TC </i>= <i>AC </i>+ <i>A C</i><br>
(not self@starting)<b> </b><br>
<b> </b><br>
<b> <br></b>      = <i>AC </i>+ <i>A B C </i>  <br>
(self@starting)<b> </b><br>
<b>  6.26 </b><br>
<b>  <br></b>The clock generator has a period of 12.5 ns. Use a 2bit counter to count four pulses. <br>
<b>  6.28 </b><br>
<b>     <br></b><i>DA </i>= <i>A </i>{ <i>B</i><b> </b><br>
<b> </b><br>
<b> <br></b><i>DB </i>= <i>AB </i>+ <i>C</i><b> </b><br>
<b> </b><br>
<b> <br></b><i>DC </i>= <i>A B C </i><b> </b><br>
<b>  6.34 </b><br>
<b>  <br></b> <br>The HDL description is available on the Companion Website. Simulations results <br>for Problem 6.34 follow: <br>
0<br>
60<br>
120<br>
<i>Name</i><br>
<i>CLK</i><br>
<i>SI<br>SO</i><br>
 <br>
 <br>
<b>  6.35 </b><br>
<b>  (b)  </b>The HDL description is available on the Companion Website. <br>
<b>  6.37 </b><br>
<b>  <br></b>The HDL description is available on the Companion Website. <br>
<b>  6.38 </b><br>
<b>  (a)  </b>The HDL description is available on the Companion Website. <br>
<hr>
<A name=546></a><b>528    Answers to Selected Problems</b><br>
<b>  6.42 </b><br>
<b>   <br></b>Because <i>A</i> is a register variable, it retains whatever value has been assigned to it <br>until a new value is assigned. Therefore, the statement   <i>A</i>  6 = <i>A</i>     has  the  same <br>effect as if the statement was omitted. <br>
<b>  6.45 </b><br>
<b>   <br></b>The HDL description is available on the Companion Website. Simulations results <br>for Problem 6.45 follow: <br>
0<br>
70<br>
140<br>
210<br>
280<br>
<i>Name</i><br>
<i>clock</i><br>
<i>reset_bar</i><br>
<i>start</i><br>
<i>y_out</i><br>
 <br>
 <br>
<b>  6.50 </b><br>
<b>  (b)  </b> The HDL description is available on the Companion Website. Simulations <br>
results for Problem 6.50 follow: <br>
0<br>
30<br>
60<br>
90<br>
<i>reset_b</i><br>
<i>clock</i><br>
<i>count[2: 0]</i><br>
0<br>
1<br>
2<br>
4<br>
6<br>
0<br>
1<br>
2<br>
4<br>
6<br>
0<br>
1<br>
 <br>
 <br>
<b> <br>C H A P T E R   7 </b><br>
<b>  7.2 </b><br>
<b>  (a)     </b>213    <b>(b)</b>   231    <b>(c)</b>   226    <b>(d)</b>   221 <br>
<b>  7.3 </b><br>
<b>  <br></b>Address:<b> </b>1 0001 1011 = 011B     (hex) <br>
<b> </b><br>
<b> <br></b>Data: <b> </b>100 1011 1100 = 4BC<b> </b>(hex)  <br>
<hr>
<A name=547></a><b>Answers to Selected Problems    529</b><br>
<b>  7.7 </b><br>
<b>  (a)     </b>7 * 128     decoders,  256  AND  gates    <b>(b)</b>   <i>x </i>= 46; <i>y </i>= 112 <br>
<b>  7.8 </b><br>
<b>  (a)  </b>8 chips    <b>(b)</b> 18; <br>
15  <b>(c)</b>   3 * 8     decoder  <br>
<b>  7.10 </b><br>
<b>  <br></b>0001 1011 1011 1 <br>
<b>  7.11 </b><br>
<b>  <br></b>101 110 011 001 010  <br>
<b>  7.12 </b><br>
<b>  (a)  </b>0101 1010;    <b>(b)</b> 1100 <br>
0110;  <b>(c)</b> 1111 <br>
0100 <br>
<b>  7.13 </b><br>
<b>  (a)  </b>6  <b>(b)</b> 7  <b>(c)</b> 7 <br>
 <br>
<b>  7.14 </b><br>
<b>  (a)  </b>0101010  <br>
<b>  7.16 </b><br>
<b>  <br></b>24 pins  <br>
<b>  7.20 </b><br>
<b>  <br></b>Product terms:   <i>yz </i>, <i>xz </i>, <i>x y z</i>, <i>xy </i>, <i>x y</i>, <i>z</i> <br>
<b>  7.25 </b><br>
<b>     </b><i>A </i>= <i>yz </i>+ <i>xz </i>+ <i>x y z</i><b> </b><br>
<b> </b><br>
<b> <br></b><i>B </i>= <i>x y </i>+ <i>yz </i>+ <i>y z </i><b> </b><br>
<b> </b><br>
<b> <br></b><i>C </i>= <i>A </i>+ <i>xyz</i><b> </b><br>
<b> </b><br>
<b> <br></b><i>D </i>= <i>z </i>+ <i>x y</i><b> </b><br>
 <br>
<b> <br>C H A P T E R   8 </b><br>
<b>  8.1 </b><br>
<b>  (a)   </b>The transfer and increment occur concurrently, i.e., at the same clock edge. <br>
After the transfer, <i>R2</i> holds the contents that were in <i>R1</i> before the clock <br>edge, and <i>R2</i> holds its previous value incremented by 1. <br>
<b>  </b><br>
<b>(b)</b>  Decrement the content of <i>R3</i> by one. <br>
<b>  </b><br>
<b>(c)</b>  <br>
If <br>
<b> <br></b>(<i>S</i>1 = 1),     transfer  content  of  <i>R1</i> to <i>R0</i>. If (  <i>S</i>1 = 0     and     <i>S</i>2 = 1   ),  transfer <br>
content of <i>R2 </i>to<i> R0</i>.  <br>
<b>  8.7 </b><br>
<b>  <br></b>RTL notation: <br>
<b> </b><br>
 <br><i>S0</i>: Initial state: if   (start = 1)     then     (<i>RA </i>d data_<i>A</i>, <i>RB </i>d data_<i>B</i>, go to <i>S</i>1). <br>
<b> </b><br>
<b> <br></b><i>S1</i>:  5Carry, <i>RA</i>6 d <i>RA </i>+ (2&gt;s complement of <i>RB</i>), go to <i>S</i>2.<b> </b><br>
<b> </b><br>
 <br><i>S2</i>: If <b> </b>(borrow = 0)  go  to  <i>S0.</i> If   (borrow = 1)     then     <i>RA </i>d (2&gt;s complement <br>of <i>RA</i>),  go to <i>S</i>0. <br>
<hr>
<A name=548></a><b>530    Answers to Selected Problems</b><br>
<b> </b><br>
<b> <br></b>Block diagram and ASMD chart: <br>
<i>reset_b</i><br>
<i> S0<br> done</i><br>
<i>data_A data_B</i><br>
<i>borrow</i><br>
<i>8</i><br>
<i>8</i><br>
<i>start</i><br>
<i>Reg_A &lt;= data_A<br>Reg_B &lt;= data_B</i><br>
<i>1</i><br>
<i>Datapath</i><br>
<i>Load_A_B</i><br>
<i>Load_A_B</i><br>
<i>Reg_A</i><br>
<i>...</i><br>
<i>Reg_A &lt;= Reg_A + ~ Reg_B + 1</i><br>
<i>Subtract</i><br>
<i>Reg_B</i><br>
<i> S1</i><br>
<i>Controller</i><br>
<i>start</i><br>
<i>...</i><br>
<i> Subtract</i><br>
<i>Convert</i><br>
<i>carry</i><br>
<i>result</i><br>
<i>done</i><br>
<i>...</i><br>
<i>S2</i><br>
<i>reset_b</i><br>
<i>8</i><br>
<i>clock</i><br>
<i>borrow</i><br>
<i>Reg_A &lt;= ~Reg_A + 1</i><br>
<i>result</i><br>
<i>1</i><br>
<i>Convert</i><br>
<b> <br></b>The HDL description is available on the Companion Website. Simulations results for <br>Problems 8.7 follow: <br>
0<br>
40<br>
80<br>
120<br>
<i>Name</i><br>
<i>clock<br>reset_b</i><br>
<i>state[1: 0] </i> <br>
0<br>
x<br>
0<br>
1<br>
2<br>
0<br>
1<br>
2<br>
0<br>
1<br>
2<br>
0<br>
1<br>
2<br>
<i>start<br>Load_A_B<br>Subtract<br>carry<br>borrow<br>Convert</i><br>
<i>data_A[7: 0]</i><br>
50<br>
20<br>
50<br>
<i>RA[7: 0]</i><br>
00<br>
32<br>
1e<br>
14<br>
e2<br>
1e<br>
32<br>
00<br>
32<br>
<i>data_B[7: 0]</i><br>
20<br>
50<br>
<i>RB[7: 0]</i><br>
00<br>
14<br>
32<br>
<i>done<br>borrow<br>result[7: 0]</i><br>
0<br>
50<br>
30<br>
20 226 30<br>
50<br>
0<br>
50<br>
<hr>
<A name=549></a><b>Answers to Selected Problems    531</b><br>
<b>  8.8 </b><br>
<b>  <br></b>RTL notation: <br>
<b> </b><br>
<b> <br></b><i>S0</i>: if <b> </b>(start = 1) <i>AR </i>d input data, <i>BR </i>d input data, go to <i>S1</i>. <br>
<b> </b><br>
<b> <br></b><i>S1</i>: if <b> </b>(AR [15]) = 1(sign bit negative) then <i>CR </i>d <i>AR </i>   (shifted  right,  sign <br> extension).  <br>
 <br>
 <br>else if (positive nonzero) then   (Overflow d <i>BR</i>([15] { [14]), <i>CR </i>d <i>BR</i>(shifted <br>left)  <br>
<b> </b><br>
<b> <br></b>else if <b> </b>(<i>AR </i>= 0)     then     (<i>CR </i>d 0). <br>
<i>data_AR data_BR</i><br>
<i>AR_eq_0</i><br>
<i>AR_gt_0</i><br>
<i>16</i><br>
<i>16</i><br>
<i>AR_lt_0</i><br>
<i>Datapath</i><br>
<i>AR</i><br>
<i>Ld_AR_BR</i><br>
<i>...</i><br>
<i>Div_AR_x2_CR</i><br>
<i>Controller</i><br>
<i>BR</i><br>
<i>...</i><br>
<i>start</i><br>
<i>Mul_BR_x2_CR</i><br>
<i>CR</i><br>
<i>done</i><br>
<i>...</i><br>
<i>Clr_CR</i><br>
<i>reset_b</i><br>
<i>clock</i><br>
 <br>
<i>reset_b</i><br>
<i> S0<br> done</i><br>
<i>start</i><br>
<i>AR &lt;= data_A<br>BR&lt;= data_B</i><br>
<i>1</i><br>
<i>Ld_AR_BR</i><br>
<i>Note: Division by 2 of a<br>negative number</i><br>
<i> S1</i><br>
<i>represented in 16-bit 2s<br>complement format</i><br>
<i>CR &lt;= {AR[15], AR[15: 1]}</i><br>
<i>1</i><br>
<i>Note: Multiplication by</i><br>
<i>AR &lt; 0</i><br>
<i>Div_AR_x2_CR</i><br>
<i>2 of a positive number</i><br>
<i>CR &lt;= BR &lt;&lt; 1</i><br>
<i>represented in 16-bit 2s</i><br>
<i>1</i><br>
<i>complement format</i><br>
<i>AR &gt; 0</i><br>
<i>Mul_BR_x2_CR</i><br>
<i>CR &lt;= 0</i><br>
<i>Clr_CR</i><br>
 <br>
 <br>The HDL description is available on the Companion Website. Simulations results <br>for Problem 8.8 follow: <br>
<hr>
<A name=550></a><b>532    Answers to Selected Problems</b><br>
<i>Reset on-the-fly</i><br>
<i>Name</i><br>
0<br>
60<br>
120<br>
180<br>
240<br>
<i>reset_b</i><br>
<i>clock</i><br>
<i>start</i><br>
 <br>
<i>Divide by 2 and xfer to CR</i><br>
<i>Multiply by 2 and xfer to CR</i><br>
<i>AR_lt_0</i><br>
<i>AR_gt_0</i><br>
<i>AR_eq_0</i><br>
<i>state</i><br>
<i>Ld_AR_BR</i><br>
<i>Div_AR_x2_CR</i><br>
<i>Mul_BR_x2_CR</i><br>
<i>Clr_CR</i><br>
<i>done</i><br>
<i>data_AR[15: 0]</i><br>
50<br>
20<br>
50<br>
0<br>
65516<br>
20<br>
<i>AR[15: 0]</i><br>
0<br>
50<br>
0<br>
20<br>
50<br>
0<br>
65516<br>
20<br>
<i>AR[15: 0]</i><br>
0000<br>
0032<br>
0000<br>
0014<br>
0032<br>
0000<br>
ffec<br>
0014<br>
<i>AR_mag[15: 0]</i><br>
0<br>
50<br>
0<br>
20<br>
50<br>
0<br>
20<br>
<i>data_BR[15: 0]</i><br>
20<br>
50<br>
65535<br>
<i>BR[15: 0]</i><br>
0<br>
20<br>
0<br>
50<br>
65535<br>
<i>BR[15: 0]</i><br>
0000<br>
0014<br>
0000<br>
0032<br>
ffff<br>
<i>BR_mag[15: 0]</i><br>
0<br>
20<br>
0<br>
50<br>
1<br>
<i>CR[15: 0]</i><br>
0<br>
40<br>
0<br>
100<br>
0<br>
65526<br>
65534<br>
<i>CR[15: 0]</i><br>
0000<br>
0000<br>
0064<br>
0000<br>
fff6<br>
fffe<br>
<i>CR_mag[15: 0]</i><br>
0<br>
40<br>
0<br>
100<br>
0<br>
10<br>
2<br>
<i>Overflow</i><br>
<b>  8.9 </b><br>
<b>  <br></b>Design equations: <br>
<b> </b><br>
<b> <br></b>DS_idle = S_2 + S_idle Start'<br>
<b> </b><br>
<b> </b><br>
<b> <br></b>DS_1 = S_idle Start + S_1(A2 A3)'<b> </b><br>
<b> </b><br>
<b> <br></b>DS_2 = A2 A3 S_1<br>
<b> </b><br>
<b> </b><br>
<b> <br></b>The HDL description is available on the Companion Website. Simulations results <br>for Problem 8.9 follow: <br>
<hr>
<A name=551></a><b>Answers to Selected Problems    533</b><br>
0<br>
60<br>
120<br>
180<br>
240<br>
<i>Name</i><br>
<i>reset_b<br>clock</i><br>
<i>Start<br>A2<br>A3</i><br>
<i>state[2: 0]</i><br>
1<br>
2<br>
1<br>
2<br>
4<br>
1<br>
2<br>
<i>set_E<br>clr_E<br>set_F</i><br>
 <br>
<i>clr_A_F<br>incr_A</i><br>
<i>A[3: 0]</i><br>
0<br>
0<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
a b<br>
c<br>
d<br>
0<br>
1<br>
<i>E<br>F</i><br>
<b>  8.11 </b><br>
<b>     <br></b><i>DA </i>= <i>A B </i>+ <i>Ax</i><b> </b><br>
<b> </b><br>
<b> <br></b><i>DB </i>= <i>A B x </i>+ <i>A By </i>+ <i>xy</i><b> </b><br>
<b>  8.16 </b><br>
<b>  <br></b>RTL notation: <br>
<b> </b><br>
<b> <br></b><i>s0</i>: (initial<b>  </b>state) If  <br>
 <br>
<i>start </i>= 0 <br>
 go back to state <i>s0</i>,  If   (<i>start </i>= 1)     then <br>
 <br><i>BR </i>d <i>multiplicand</i>, <i>AR </i>d <i>multiplier</i>, <i>PR </i>d 0,     go  to  <i>s</i>1.  <br>
<b> </b><br>
<b> <br></b><i>s1</i>: (check <i>AR</i> for Zero)   <i>Zero </i>= 1 if  <i>AR </i>= 0, if  (<i>Zero </i>= 1)  then go back to <i>s0</i> <br>(<i>done</i>) If   (<i>Zero </i>= 0)     then  go  to  <i>s1</i>,     <i>PR </i>d <i>PR </i>+ <i>BR</i>, <i>AR </i>d <i>AR </i>- 1. <br>
<b> </b><br>
<b> <br></b>The internal architecture of the datapath consists of a doublewidth register to <br>hold the product (PR), a register to hold the multiplier (AR), a register to hold <br>the multiplicand (BR), a doublewidth parallel adder, and singlewidth parallel <br>adder. The singlewidth adder is used to implement the operation of decrement-<br>ing the multiplier unit. Adding a word consisting entirely of 1s to the multiplier <br>accomplishes the 2's complelment subtraction of 1 from the multiplier. Fig-<br>ure 8.16 (a) below shows the ASMD chart, block diagram, and controller of othe <br>circuit. Figure 8.16 (b) shows the internal architecture of the datapath. Figure <br>8.16 (c) shows the results of simulating the circuit. <br>
<hr>
<A name=552></a><b>534    Answers to Selected Problems</b><br>
<i>reset_b</i><br>
<i> s0</i><br>
<i>data_AR data_BR</i><br>
<i> done</i><br>
<i>16</i><br>
<i>16</i><br>
<i>AR</i><br>
<i> data_A</i><br>
<i>zero</i><br>
<i>BR</i><br>
<i> data_B</i><br>
<i>start</i><br>
<i>PR</i><br>
<i> 0</i><br>
<i>Datapath</i><br>
<i>1</i><br>
<i>AR</i><br>
<i>Ld_regs</i><br>
<i>Ld_regs</i><br>
<i>...</i><br>
<i>Add_decr</i><br>
<i>Controller</i><br>
<i>BR</i><br>
<i>PR</i><br>
<i> PR   BR</i><br>
<i> s1</i><br>
<i>...</i><br>
<i>start</i><br>
<i>AR</i><br>
<i> AR  1</i><br>
<i>PR</i><br>
<i>done</i><br>
<i>...</i><br>
 <br>
<i>1</i><br>
<i>Add_decr</i><br>
<i>Zero</i><br>
<i>reset_b</i><br>
<i>16</i><br>
<i>clock</i><br>
<i>PR</i><br>
<i>Note: Form Zero as the output of an OR gate whose inputs<br>are the bits of the register AR.</i><br>
<i>Add_decr</i><br>
<i>Controller</i><br>
<i>s0</i><br>
<i> s1</i><br>
<i>Zero</i><br>
<i>done</i><br>
<i>D</i><br>
<i>Start</i><br>
<i>clock</i><br>
<i>reset_b</i><br>
<i>Ld_regs</i><br>
(a) ASMD chart, block diagram, and controller<br>
<hr>
<A name=553></a><b>Answers to Selected Problems    535</b><br>
<i>data_BR</i><br>
16<br>
<i>Ld_regs</i><br>
1<br>
0<br>
mux<br>
16 <i>BR</i><br>
<i>Add_decr</i><br>
1<br>
0<br>
<i>...</i><br>
<i>All </i>0'<i>s</i><br>
mux<br>
32<br>
<i>data_AR</i><br>
16<br>
16<br>
16<br>
32<br>
Note: all registers have active-low<br>
<i>Ld_regs</i><br>
1<br>
0<br>
mux<br>
asynchronous reset<br>
32<br>
16<br>
<i>PR</i><br>
<i>AR</i><br>
...<br>
...<br>
<i>...</i><br>
<i>...</i><br>
 <br>
32<br>
16<br>
16<br>
mux<br>
<i>Ld_regs</i><br>
0<br>
1<br>
32<br>
0<br>
mux<br>
1<br>
0<br>
<i>Add_decr</i><br>
16<br>
<i>All </i>1'<i>s</i><br>
(b) Datapath<br>
0<br>
40<br>
80<br>
120<br>
160<br>
200<br>
<i>Name</i><br>
<i>reset_b</i><br>
<i>clock</i><br>
<i>start</i><br>
<i>Ld_regs</i><br>
<i>Add_decr</i><br>
<i>zero</i><br>
 <br>
<i>state</i><br>
<i>data_AR[7: 0]</i><br>
5<br>
3<br>
4<br>
<i>data_BR[7: 0]</i><br>
20<br>
9<br>
<i>AR[7: 0]</i><br>
0<br>
5<br>
4<br>
3<br>
2<br>
1<br>
0<br>
4<br>
3<br>
2<br>
1<br>
0<br>
4<br>
<i>BR[7: 0]</i><br>
0<br>
20<br>
9<br>
<i>done</i><br>
<i>PR[15: 0]</i><br>
0<br>
20 40 60 80<br>
100<br>
0<br>
9<br>
18 27<br>
36<br>
0<br>
(c) Simulation results<br>
<hr>
<A name=554></a><b>536    Answers to Selected Problems</b><br>
<b> <br>8.17 </b><br>
<b> <br></b>(2<i>n </i>- 1)(2<i>n </i>- 1) 6 (22<i>n </i>- 1) for <i>n </i>� 1<b> </b><br>
<b>  8.18 </b><br>
<b>  (a)  </b>The maximum product size is 32 bits available in registers <i>A</i> and <i>Q</i>. <br>
<b>  </b><br>
<b>(b) </b><br>
<i>P</i><b> </b>counter must have 5 bits to load 16 (binary 10000) initially. <br>
<b>  </b><br>
<b>(c) </b><br>
<i>Z</i><b> </b>(zero) detection is generated with a 5input NOR gate. <br>
<b>  8.20 </b><br>
<b>     <br></b>2(<i>n </i>+ 1)<i>t</i><b> </b><br>
<b>  8.21 </b><br>
<b>      </b><br>
State codes:<br>
G1<br>
G0<br>
S_idle<br>
0<br>
0<br>
S_add<br>
0<br>
1<br>
S_shift<br>
1<br>
0<br>
unused<br>
0<br>
0<br>
0<br>
0<br>
1<br>
1<br>
<i>G1</i><br>
Mux_1<br>
<i>D</i><br>
<i>Zero</i><br>
<i>Start</i><br>
2<br>
<i>Load_regs</i><br>
<i>C</i><br>
<i>E</i><br>
3<br>
<i>s1</i><br>
<i>s0</i><br>
<i>Q[0]</i><br>
 <br>
0<br>
<i>Add_regs</i><br>
1<br>
2<br>
 4 Decoder<br>
2<br>
<i>Shift_left</i><br>
3<br>
<i>s1</i><br>
<i>s0</i><br>
<i>Start</i><br>
0<br>
0<br>
1<br>
<i>G0</i><br>
Mux_2<br>
<i>D</i><br>
0<br>
2<br>
<i>C</i><br>
0<br>
3<br>
<i>clock</i><br>
<i>reset_b</i><br>
<b>  8.30 </b><br>
<b>  (a)     </b><i>E </i>= 1       <b>(b)</b>   <i>E </i>= 0 <br>
<b>  8.31 </b><br>
<b>     <br></b>A = 0110, B = 0010, C = 0000.<b> <br></b> <br>A * B = 1100    <br>
 <br>A   B = 0110    <br>
 <br>A &amp;&amp; C = 0    <br>
 <br>A + B = 1000    <br>
    <br>A �B = 0100    <br>
   A = 1    <br>
 <br>A - B = 0100    <br>
    <br>&amp;A = 0   A 6 B = 0 <br>
  C = 1111    <br>
  C = 1    <br>
 <br>A 7 B = 1    <br>
 <br>A &amp; B = 0010    <br>
 <br>A   B = 1    <br>
 <br>A ! = B = 1    <br>
<hr>
<A name=555></a><b>Answers to Selected Problems    537</b><br>
<b>  8.39</b><br>
 <br>
 <br>Block diagram and ASMD chart: <br>
<i>data_AR data_BR</i><br>
<i>Zero</i><br>
16<br>
16<br>
<i>Datapath</i><br>
<i>Ld_regs</i><br>
<i>AR</i><br>
<i>...</i><br>
<i>Add_decr</i><br>
<i>BR</i><br>
<i>Controller</i><br>
<i>...</i><br>
<i>Start</i><br>
<i>PR</i><br>
<i>...</i><br>
<i>done</i><br>
<i>reset_b</i><br>
16<br>
<i>Clock</i><br>
<i>PR</i><br>
<i>reset_b</i><br>
 <br>
<i>S0<br>done</i><br>
<i>AR</i><br>
data<i>_A</i><br>
<i>Start</i><br>
<i>BR</i><br>
data<i>_B</i><br>
<i>PR</i><br>
<i> 0</i><br>
<i>1</i><br>
<i>Ld_regs</i><br>
<i>S1</i><br>
<i>PR</i><br>
<i> PR  </i> BR<br>
<i>AR</i><br>
AR<br>
 <i>1</i><br>
1<br>
<i>Add_decr</i><br>
<i>Zero</i><br>
<b> <br></b>The HDL description is available on the Companion Website. Simulation results for <br>Problem  8.39  follow:      <br>
<hr>
<A name=556></a><b>538    Answers to Selected Problems</b><br>
<i>Name</i><br>
0<br>
30<br>
60<br>
90<br>
120<br>
<i>reset_b</i><br>
<i>clock</i><br>
 <br><b> </b><br>
<i>start</i><br>
<i>Ld_regs</i><br>
<i>Add_decr</i><br>
<i>zero</i><br>
<i>state</i><br>
<i>data_AR[7: 0]</i><br>
5<br>
3<br>
4<br>
<i>data_BR[7: 0]</i><br>
20<br>
9<br>
<i>AR[7: 0]</i><br>
0<br>
5<br>
4 0<br>
5<br>
4<br>
3<br>
2<br>
1<br>
0<br>
<i>BR[7: 0]</i><br>
0<br>
20<br>
0<br>
20<br>
<i>done</i><br>
<i>PR[15: 0]</i><br>
0<br>
0<br>
20<br>
40<br>
60<br>
80<br>
100<br>
<hr>
<A name=557></a> <br>Index <br>
<b> <br>A </b><br>
 chart,   365 � 368  <br>
 <br>ASCII NAK (negative acknowledge) <br>
  ABEL,   332   <br>
 <br>conditional box and examples,  367  <br>
control  character,   27   <br>
  Absorption  theorem,   45   <br>
 control  logic,   364  <br>
 <br><b>assign</b>   statement,   115 ,   164 ,   171 ,   228 , <br>
  Abstract  behavioral  model,   109   <br>
 control  unit,   364  <br>
 354 � 355 ,   361   <br>
 <br>Adders and subtractors (experiment) <br>
 datapath  unit,   364  <br>
  Associative  law,   39  <br>
 adder�subtractor  (four-bit),   456 � 457  <br>
 <br>decision box of an ASM chart,  366  <br>
 algebraic  proofs  of,   45   <br>
 full  adder,   455  <br>
 Mealy-type  signals,   366 � 368  <br>
  Asynchronous  sequential  circuit,   191    <br>
 half  adder,   455  <br>
 simplifi cations,   369  <br>
 magnitude  comparator,   457  <br>
 <br>state and decision boxes of,  366  <br>
<b> <br>B </b><br>
 parallel  adder,   455 � 456   <br>
 style  of  state  box,   365 � 366  <br>
  Backspace  (BS)  control,   26   <br>
  Additive  identity,   40   <br>
 timing  considerations,   369 � 370   <br>
  Base- <i>r</i>   system,   4 ,   10   <br>
 <br>Algebraic manipulation, of Boolean <br>
 <br><b>always</b>   block,   358   <br>
  Base-8  system,   4   <br>
function,   48 � 49   <br>
 <br><b>always</b>   statement,   164 ,   176 ,   217 ,   219 ,   228 , <br>
  BCD  adder,   144 � 146   <br>
 <br>Algorithmic state machine and <br>
 290 ,   354 � 355 ,   382   <br>
  BCD  code,   22 � 23   <br>
datapath (ASMD) charts, <br>
 <br>American Standard Code for <br>
  BCD  ripple  counter,   269 � 271   <br>
 370 � 371  <br>
Information Interchange <br>
  BCD  synchronous  counter,   275   <br>
 <br>controller and datapath hardware <br>
(ASCII),   24 � 26   <br>
 <br><b>begin</b>   keyword,   115 ,   177 ,   217   <br>
design,   376  <br>
  Analog-to-digital  converter,   2   <br>
  Behavioral  modeling,   174 � 176   <br>
 control  logic,   379 � 381 ,   396 ,   398  <br>
  ANDed  with  an  expression,   53   <br>
  Bidirectional  shift  register,   264 ,   352   <br>
 design  examples,   371 � 381  <br>
  AND  gate,   30 ,   32 � 33 ,   42 ,   46 � 47 ,   50 , <br>
  Bilateral  switch,   514 � 515   <br>
 <br>register transfer representation, <br>
 57 � 58 ,   60 ,   65 ,   90 ,   113 ,   321 ,   323   <br>
  Binary  adder�subtractor,  of <br>
 377 � 378  <br>
  ANDing  of  maxterms,   55   <br>
combinational  circuits,   133 � 144  <br>
 state  table,   378 � 379  <br>
  AND-invert  graphic  symbol,   92   <br>
 binary  adder,   136 � 138  <br>
 timing  sequence,   374 � 376   <br>
  AND-invert  symbol,   90 � 91   <br>
 binary  subtractor,   141 � 142  <br>
 <br>Algorithmic state machines (ASMs), <br>
  AND�NOR  diagrams,   98 � 99   <br>
 carry  propagation,   138 � 141  <br>
 363 � 371  <br>
  AND�OR  diagrams,   90 ,   98 � 99   <br>
 full  adder,   135 � 136  <br>
 <br>algorithmic state machine and <br>
  AND�OR�INVERT  function, <br>
 half  adder,   134  <br>
datapath (ASMD) charts, <br>
 97 � 98   <br>
 overfl ow,   143 � 144   <br>
 370 � 371  <br>
  Application-specifi c integrated circuit <br>
 <br>Binary and decimal numbers <br>
 design  examples,   371 � 381  <br>
(ASIC),   68   <br>
(experiment) <br>
 binary  code  assignment,   365 � 366  <br>
  Arithmetic  addition,   39   <br>
 BCD  count,   444 � 445  <br>
 block,   368 � 369  <br>
  Arithmetic  operations,   5   <br>
 binary  count,   443  <br>
<b>539</b><br>
<hr>
<A name=558></a><b>540    Index</b><br>
Binary and decimal numbers <i>(cont.)</i><br>
  Blocking  assignments,   219 � 220 ,   355   <br>
  Chip,   66   <br>
 counts,   446  <br>
  Block  statement,   115   <br>
  Clear  operation,   351   <br>
 oscilloscope,   444  <br>
  Boolean  algebra,   30 ,   47 ,   126  <br>
  Clocked  sequential  circuits,   191   <br>
 output  pattern,   445   <br>
 <br>application in gate-type circuits,  42  <br>
  Clock  generator,   191   <br>
  Binary  cell,   27   <br>
 axiomatic  defi nition  of,   40 � 43  <br>
  Clock-pulse  generator  (experiment), <br>
  Binary-coded  decimal  (BCD),   130 � 131  <br>
 basic  defi nitions,   38 � 40  <br>
 474 � 475  <br>
 additions,   20 � 21  <br>
 basic  theorems,   43 � 45  <br>
 circuit  operation,   473 � 474  <br>
 code,   22 � 23   <br>
 canonical  forms,   51 � 58  <br>
 IC  timer,   473   <br>
  Binary  codes,   2 ,   18 � 27  <br>
 conversion  between,   55 � 56  <br>
  Clock  pulses,   191   <br>
 <br>8, 4, -2, -1 code,  22 � 23  <br>
 duality,   43  <br>
  Closed  structure,   42   <br>
 <br>addition of decimal numbers,  21  <br>
 maxterms,   51 � 52  <br>
  2421  code,   22 � 23   <br>
 ASCII  character  code,   24 � 26  <br>
 ANDing  of,   55  <br>
  Code  converters  (experiment) <br>
 BCD  code,   20 � 23  <br>
 defi nition,   55  <br>
 <br>Gray code to equivalent binary,  452  <br>
 2421  code,   22 � 23  <br>
 product  of,   54 � 55  <br>
 nine's  complementer,   452  <br>
 error-detecting  code,   26 � 27  <br>
 miniterms,   51 � 52  <br>
 seven-segment  display,   452 � 453   <br>
 excess-3  code,   22 � 23  <br>
 defi nition,   55  <br>
  Coeffi cients, of binary number system,  4  <br>
 Gray  code,   23 � 24  <br>
 sum  of,   52 � 53  <br>
  Combinational  circuits: <br>
 <br>subtraction of decimal numbers,  21  <br>
 operator  procedure,   45 � 46  <br>
 analysis  procedure,   126 � 129  <br>
  Binary  digit,   <i>See</i>   Bit  <br>
 standard  forms,   56 � 58  <br>
 binary  adder�subtractor,   133 � 144  <br>
  Binary  information  processing,   29 � 30   <br>
 two-valued,   41 � 43   <br>
 binary  adder,   136 � 138  <br>
 <br>Binary information processing, of <br>
  Boolean  expressions,  for  HDL,   115 � 116   <br>
 binary  subtractor,   141 � 142  <br>
digital logic circuits,  30  <br>
  Boolean  function,   126  <br>
 carry  propagation,   138 � 141  <br>
  Binary  logic: <br>
 algebraic  manipulation,   48 � 49  <br>
 full  adder,   135 � 136  <br>
 defi nition  of,   30 � 31  <br>
 complement  of,   49 � 50  <br>
 half  adder,   134  <br>
 logic  gates,   31 � 33   <br>
 defi nition,   46  <br>
 overfl ow,   143 � 144  <br>
  Binary  multiplier,   146 � 148   <br>
 <br>implementation with gates,  48  <br>
 binary  multiplier,   146 � 148  <br>
 <br>Binary multiplier, HDL description of, <br>
 multilevel  NAND  circuit,   93 � 95  <br>
 block  diagram,   125 � 126  <br>
 402 � 411  <br>
 with  NAND  gates,   90 � 91  <br>
 decimal  adder,   144 � 146  <br>
 <br>behavioral description of a parallel <br>
 NOR  implementation,   95 � 97  <br>
 decoders,   150 � 155  <br>
multiplier,   409 � 411  <br>
 16  possible  functions,   58 � 60  <br>
 combinational  logic <br>
 datapath  unit,   403  <br>
 product-of-sums  form  of,   84 � 88  <br>
implementation,   154 � 155  <br>
 testing  the  multiplier,   405 � 409   <br>
 sum-of-products  form,   84 � 88  <br>
 <br>deriving output Boolean functions, <br>
  Binary  multiplier  (experiment), <br>
 <br>in truth table,  46  <br>
 127 � 128  <br>
 478 � 480  <br>
 two-level  implementation  of,   91 � 93   <br>
 design  procedure,   129 � 133  <br>
 block  diagram,   478  <br>
  Boolean  function  simplifi cation <br>
 code  conversion  example,   130 � 133  <br>
 <br>checking the multiplier,  479  <br>
(experiment) <br>
 encoders,   155 � 157  <br>
 control  of  registers,   478 � 479  <br>
 <br>Boolean functions in sum-of-<br>
 priority,   156 � 157  <br>
 datapath  design,   479  <br>
minterms form,  449  <br>
 feedback  path,   127  <br>
 <br>design of control,  479  <br>
 complement,   449  <br>
 <br>hardware description language <br>
 multiplication  example,   479   <br>
 gate  ICs,   448  <br>
(HDL)  of,   164 � 181  <br>
  Binary  numbers,   3 � 6 ,   9 � 10  <br>
 logic  diagram,   448   <br>
 behavioral  modeling,   174 � 176  <br>
 arithmetic  operations,   5 � 6  <br>
  Bubble,   60   <br>
 datafl ow  modeling,   171 � 174  <br>
 complement  of,   10 � 11  <br>
  Buffer  circuit,   60   <br>
 example  of  test  bench,   176 � 181  <br>
 sum  of  two,   6   <br>
  Built-in  system  functions,   178   <br>
 gate-level  modeling,   164 � 169  <br>
  Binary  operator: <br>
  Byte,   5 ,   26    <br>
 three-state  gates,   169 � 170  <br>
 *,   39  <br>
 magnitude  comparator,   148 � 150  <br>
 +,   39  <br>
<b> <br>C </b><br>
 multiplexer,   158 � 164  <br>
 �,   40  <br>
  Carriage  return  (CR)  control,   26   <br>
 <br>used in design of digital systems,  126  <br>
 defi nition,   38   <br>
  Cascaded  NAND  gates,   63   <br>
  Combinational  circuits  (experiment) <br>
  Binary  ripple  counter,   267 � 269   <br>
 <br><b>case</b>   expression,   176 ,   382   <br>
 decoder  implementation,   450 � 451  <br>
  Binary  signals,   3 ,   32   <br>
 <br><b>case</b>   items,   175   <br>
 design  example,   450  <br>
  Binary  storage,   27 � 30   <br>
 <br><b>case</b>   statement,   175 ,   362 ,   403   <br>
 majority  logic,   450  <br>
  Binary  synchronous  counter,   271 � 272  <br>
 <br><b>casex</b>   construct,   176   <br>
 parity  generator,   450   <br>
 with  parallel  load,   276 � 278  <br>
 <br><b>casex</b>   statement,   362   <br>
  Combinational  programmable  logic <br>
 up�down,   272 � 275   <br>
 <br><b>casez</b>   construct,   176   <br>
device  (PLD),   321   <br>
  Bipolar  transistors,   507   <br>
  Central  processing  unit,   2   <br>
  Comma,   179   <br>
  Bit,   2 ,   5   <br>
 <br>Characteristic tables, for fl ip-fl op,   201 � 202   <br>
  Commutative  law,   39 ,   42   <br>
<hr>
<A name=559></a><b>Index    541</b><br>
  Complementary  metal-oxide <br>
 <br>binary counter with parallel load, <br>
  Digital  logic  circuits: <br>
semiconductor  (CMOS),   67   <br>
 276 � 278  <br>
 <br>binary information process,  30  <br>
 <br>Complementary MOS (CMOS) circuits, <br>
 up�down  binary,   272 � 275  <br>
 symbols  for,   32   <br>
 510 � 513  <br>
 with  unused  states,   278 � 280   <br>
  Digital  logic  family,   66 � 67   <br>
 bilateral  switch,   514 � 515  <br>
  Counters  (experiment) <br>
  Digital  logic  gates,   60 � 65  <br>
 characteristics,   513  <br>
 <br>binary counter with parallel load, <br>
 extension  of  multiple  inputs,   62 � 63  <br>
 <br>CMOS fabrication process,  513  <br>
 462 � 463  <br>
 positive  and  negative  logic,   63 � 65   <br>
 <br>CMOS logic circuit,  513  <br>
 decimal  counter,   461  <br>
 <br>Digital logic gates (experiment) <br>
 <br>construction of exclusive-OR with <br>
 ripple  counter,   461  <br>
 NAND  circuit,   447 � 448  <br>
transmission gates,  515  <br>
 <br>synchronous four-bit binary <br>
 propagation  delay,   447  <br>
 74C  series,   513  <br>
counter,   461   <br>
 truth  table,   446  <br>
 four-to-one-line  multiplexer,   515  <br>
  Count  operation,   351   <br>
 <br>universal NAND gate,  447  <br>
 <br>IC type 74C04,  513  <br>
  Crosspoint,   317    <br>
 waveforms,   446 � 447   <br>
 <br>propagation delay time,  513  <br>
  Digital  systems,   1 � 3  <br>
 <br>static power dissipation of,  513  <br>
 information-fl ow  capabilities,   30   <br>
 transmission  gate,   514 � 517   <br>
<b> <br>D </b><br>
  Digital  versatile  disk  (DVD),   3   <br>
  Complements,   10 � 14 ,   44 ,   55 ,   87  <br>
  Datafl ow modeling, of combinational <br>
  Diminished  radix  complement,   10 � 11   <br>
 diminished  radix,   10 � 11  <br>
logic,   171 � 174   <br>
 <br><b>$display</b>   task,   178 � 179 ,   181   <br>
 radix,   11 � 12  <br>
  Datapath  unit,   364   <br>
  Distributive  law,   39 ,   42 ,   54 ,   57   <br>
 subtracion  with,   12 � 14   <br>
 <br>Decimal adder, of combinational <br>
 <br><i>D</i>   latch,   195 � 196 ,   457   <br>
 <br>Computer-aided design (CAD) systems, <br>
circuits,   144 � 146   <br>
  Documentation  language,   109   <br>
 67 � 68 ,   118   <br>
 <br>Decimal equivalent, of binary <br>
  Don't-care  conditions,   88   <br>
 <br>Computer-aided design of VLSI circuits, <br>
number,   4   <br>
  Don't-care  minterms,   88 � 90   <br>
 67 � 68   <br>
  Decimal  number  system,   4   <br>
  Dopants,   507   <br>
  Consensus  theorem,   49   <br>
  Declaration  of  module,   112   <br>
  Drain  terminal,   508   <br>
  Control  characters,   25   <br>
  Decoders,   150 � 155  <br>
  Duality  principle,   43   <br>
  Controller,  register-and-decoder <br>
 <br>combinational logic implementation, <br>
  Dual  theorem,   44    <br>
scheme for the design of a,  411  <br>
 154 � 155   <br>
  Control  logic,   396 � 402  <br>
 <br><b>default</b>   keyword,   176   <br>
<b> <br>E </b><br>
 ASMD  charts,   379 � 381 , <br>
  Degenerate  forms,  of  gates,   98 � 99   <br>
  Edge-sensitive  cyclic  behavior,   354   <br>
 396 ,   398  <br>
  Delay  control  operator,   218   <br>
  Edge-triggered   <i>D</i>   fl ip-fl op,   330   <br>
 block  diagram,   393  <br>
  DeMorgan's  theorem,   45 ,   49 � 50 ,   55 ,   62 , <br>
  Eight-bit  alphanumeric  character <br>
 <br><i>D</i>   fl ip-fl op,   401  <br>
 84 ,   91 � 92   <br>
code,   28   <br>
 Gray  code,   397 � 398  <br>
  Dependency  notation,   493 � 495   <br>
  Eight-bit  code,   27   <br>
 inputs   <i>Start</i>  and  <i>Zero</i> <br>
  Depletion  mode,   508   <br>
  8,  4,  �2,  �1  code,   22 � 23   <br>
decisions,   396  <br>
  Design  entry,   109   <br>
  Electrically  erasable  PROM,   320   <br>
 one  fl ip-fl op  per  state,   401 � 402  <br>
 <br>Design of combinational circuits, <br>
 <br>Electronic design automation (EDA),  68 <br>
 <br>one-hot assignment,  <br>
 129 � 133  <br>
 <br><b>else</b>   statement,   222   <br>
397 ,   401 � 402  <br>
 <br><i>D</i>   fl ip-fl op,   198 � 200 ,   255 ,   263  <br>
  Emitter-coupled  logic  (ECL),   67   <br>
 sequence-register-and-decoder <br>
 analysis,   210  <br>
  Encoders,   155 � 157  <br>
(manual)  method,   398 � 401  <br>
 characteristic  table,   202  <br>
 priority,   156 � 157   <br>
 state  assignment,   398  <br>
 <br>in combinational PAL,  330  <br>
  End-around  carry,   13   <br>
 steps  when  implementing,   397   <br>
 <br>in control logic,  401  <br>
 <br><b>end</b>   keyword,   115 ,   177 ,   217   <br>
  Counters: <br>
 <br>graphic symbol for the <br>
 <br><b>endprimitive</b>,    117   <br>
 defi ned,   255  <br>
edge-triggered,   200  <br>
 <br><b>endtable</b>,    117   <br>
 HDL  for: <br>
 hold  time,   199  <br>
  Enhancement  mode,   508   <br>
 ripple,   288 � 290  <br>
 master�slave,   517  <br>
  Erasable  PROM,   320   <br>
 synchronous,   287 � 288  <br>
 positive-edge-triggered,   203  <br>
  Error-detecting  and <br>
 Johnson,   282 � 283  <br>
 setup  time,   199   <br>
error-correcting codes: <br>
 ring,   280 � 282  <br>
  Diffused  channel,   508   <br>
 Hamming,   312 � 315  <br>
 ripple: <br>
  Digital  age,   1   <br>
 <br>single-error correction and double-<br>
 BCD,   269 � 271  <br>
  Digital  integrated  circuits,   66 � 67  <br>
error  detection,   315   <br>
 binary,   267 � 269  <br>
 fan-in,   67  <br>
  ETX  (end  of  text),   26   <br>
 symbols,   502 � 504  <br>
 fan-out,   67  <br>
  Event  control  expression,   175   <br>
 synchronous: <br>
 noise  margin,   67  <br>
  Event  control  operator,   218   <br>
 BCD,   275  <br>
 power  dissipation,   67  <br>
  Excess-3  code,   22 � 23 ,   130   <br>
 binary,   271 � 272  <br>
 propagation  delay,   67   <br>
  Exclusive-NOR  function,   103    <br>
<hr>
<A name=560></a><b>542    Index</b><br>
<b> <br>F </b><br>
  Four-bit  data-storage  register,   257   <br>
<b> <br>H </b><br>
  Fan-in,   67   <br>
  Four-bit  register,   256   <br>
  Half  adder,   167   <br>
  Fan-out,   67   <br>
  Four-bit  universal  shift  register,   265   <br>
  Hamming  code,   312 � 315   <br>
  Fault-free  circuit,   110   <br>
  Four-digit  binary  equivalent,   9   <br>
  Hand-held  devices,   190   <br>
  Fault  simulation,   110   <br>
  Four-to-one-line  multiplexer,   163   <br>
 <br>Hardware description language (HDL), <br>
  Field,   39   <br>
 <br>Four-variable Boolean functions, map <br>
 68 ,   108 � 118  <br>
  Field-programmable  gate  array <br>
minimization  of,   80 � 84   <br>
 algorithmic-based  behavioral <br>
(FPGA),   68 ,   299 ,   329 � 330 ,   438 , <br>
  Four-variable  K-map,   80 � 84   <br>
description,   381  <br>
 480 � 482 ,   <i>See also</i>  Xilinx FPGA  <br>
  Franklin,  Benjamin,   507   <br>
 of  binary  multiplier,   402 � 411  <br>
  File  separator  (FS)  control,   26   <br>
  Full-adder  (FA)  circuit,   261 � 262   <br>
 Boolean  expressions,   115 � 116  <br>
 <br><b>$finish</b>   statement,   178   <br>
  Functional  errors,   109   <br>
 circuit  demonstrating,   111  <br>
 <br><b>$finish</b>   system,   115   <br>
  Functional  verifi cation,   181   <br>
 combinational  circuits,   164 � 181  <br>
  Finite  state  machine  (FSM),   364   <br>
  Function  blocks,   332    <br>
 behavioral  modeling,   174 � 176  <br>
  Five-variable  K-map,   84   <br>
 datafl ow  modeling,   171 � 174  <br>
  Flash  memory  devices,   320   <br>
<b> <br>G </b><br>
 example  of  test  bench,   176 � 181  <br>
  Flip-fl op, defi ned,   192   <br>
  Gate  delays,   113 � 115   <br>
 three-state  gates,   169 � 170  <br>
  Flip-fl op circuits,  259  <br>
  Gate  instantiation,   112   <br>
 <br>description of design example, <br>
 ASMD,   371  <br>
  Gate-level  minimization,   73  <br>
 381 � 391  <br>
 characteristic  table,   201 � 202  <br>
 AND�OR�INVERT <br>
 gate  delays,   113 � 115  <br>
 <br><i>Clear_b</i>   input,   256  <br>
implementation,   99 � 100  <br>
 for  ripple  counter,   288 � 290  <br>
 <br>clear or direct reset,  203  <br>
 don't-care  conditions,   88 � 90  <br>
 RTL  description,   381 � 385  <br>
 <br>clock response in,  197  <br>
 <br>exclusive-OR (XOR) function, <br>
 structural  description,   381 ,   386 � 391  <br>
 <br><i>D</i>   fl ip-fl op,   198 � 200 ,   255 ,   263  <br>
 103 � 108  <br>
 switch-level  modeling,   517 � 520  <br>
 analysis,   210  <br>
 odd  function,   104 � 106  <br>
 for  synchronous  counter,   287 � 288  <br>
 characteristic  table,   202  <br>
 <br>parity generation and checking, <br>
 testing  of  design  description,   385 � 386  <br>
 <br>in combinational PAL,  330  <br>
 106 � 108  <br>
 transmission  gate,   519 � 520  <br>
 <br>graphic symbol for the <br>
 <br>hardware description language <br>
 user-defi ned primitives (UDPs), <br>
edge-triggered,   200  <br>
(HDL),   108 � 118  <br>
 116 � 118   <br>
 hold  time,   199  <br>
 Boolean  expressions,   115 � 116  <br>
  Hardware  signal  generators,   115   <br>
 master�slave,   517  <br>
 gate  delays,   113 � 115  <br>
  HDL-based  design  methodology,   3   <br>
 positive-edge-triggered,   203  <br>
 user-defi ned primitives (UDPs), <br>
  Heuristics,   30   <br>
 setup  time,   199  <br>
 116 � 118  <br>
 <br>Hexadecimal (base-16) number system, <br>
 direct  inputs,   203  <br>
 map  method: <br>
 4 � 5 ,   8 � 10   <br>
 input  equation,   209 � 210  <br>
 <br>fi ve-variable K-map,  84  <br>
  High-impedance  state,   162 � 163   <br>
 <br><i>JK</i>   fl ip-fl op,   200 � 201 ,   263  <br>
 four-variable  K-map,   80 � 84  <br>
  Holes,   507   <br>
 analysis,   210 � 213  <br>
 <br>prime implicants of a function, <br>
  Horizontal  tabulation  (HT)  control,   26   <br>
 characteristic  equation,   203  <br>
 82 � 84  <br>
  Huntington  postulates,   42    <br>
 characteristic  table,   202  <br>
 three-variable  K-map,   75 � 76  <br>
 master�slave,   198 ,   517  <br>
 two-variable  K-map,   74 � 75  <br>
<b> <br>I </b><br>
 positive-edge-triggered,   199  <br>
 NAND  circuits,   90 � 91  <br>
  7493  IC,   439 ,   442 � 443   <br>
 signal  transition,   197  <br>
 nondegenerate  forms,   98 � 99  <br>
  IC  type  74194,   470   <br>
 symbols,   497 � 499  <br>
 OR�AND�INVERT <br>
  IC  type  fl ip-fl op,   459 � 460   <br>
 <br><i>T</i>  (toggle) fl ip-fl op,   200 � 201  <br>
implementation,   100  <br>
  Identity  element,   39   <br>
 analysis,   213 � 214  <br>
 product-of-sums  simplifi cation, <br>
 <br><b>if-else</b>   statement,   174   <br>
 characteristic  equation,   203  <br>
 84 � 88 ,   90  <br>
 <br><b>if</b>   statement,   222   <br>
 characteristic  table,   202   <br>
 <br>tabular summary and example, <br>
 <br><b>if-then</b>   statement,   353   <br>
  Flip-fl op  input  equations,   209 � 210   <br>
 100 � 102   <br>
  Implicit  combinational  logic,   116   <br>
  Flip-fl ops (experiment) <br>
  Gates  with  multiple  inputs,   33   <br>
  Incompletely  specifi ed  functions,   88   <br>
 <br><i>D</i>   latch,   457  <br>
  Gate  voltage,   508   <br>
 <br><b>initial</b>   block,   177 ,   179 ,   358   <br>
 <br>IC type fl ip-fl op,   459 � 460  <br>
  General-purpose  digital  computer,   2   <br>
 <br><b>initial</b>   statement,   115 ,   177 ,   217 � 219   <br>
 master�slave   <i>D</i>   fl ip-fl op,   458  <br>
  Giga  (G)  bytes,   5   <br>
 <br><b>input</b>   declaration,   117   <br>
 positive-edge-triggered  fl ip-fl op,   459  <br>
  Graphical  user  interfaces  (GUIs),   1   <br>
  3-input  NAND  gate,   63   <br>
 <br><i>SR</i>   latch,   457   <br>
  Graphic  symbols,   32   <br>
  3-input  NOR  gate,   63   <br>
 <br><b>forever</b>   loop,   359   <br>
  Gray  code,   23 � 24 ,   397 � 398   <br>
  Input�output  signals  for  gates,   33   <br>
 <br><b>fork</b>  ...  <b>join</b>   block,   226   <br>
 <br>Gray code to equivalent <br>
  Input�output  units,   2   <br>
 <br><b>for</b>   loop,   360   <br>
binary,   452    <br>
  Instantiation  of  module,   112   <br>
<hr>
<A name=561></a><b>Index    543</b><br>
 <br><b>integer</b>    <i>k,</i>    360   <br>
 <br>Boolean function simplifi cation <br>
 block  diagram,   475  <br>
 <br><b>integer</b>   keyword,   176   <br>
(experiment 3) <br>
 carry  circuit,   476  <br>
  Integrated  circuits: <br>
 <br>Boolean functions in <br>
 <br>checking the circuit,  477  <br>
 <br>computer-aided design of VLSI <br>
sum-ofminterms form,  449  <br>
 circuit  operation,   477 � 478  <br>
circuits,   67 � 68  <br>
 complement,   449  <br>
 control  of  register,   475 � 476  <br>
 digital  integrated  circuits,   66 � 67  <br>
 gate  ICs,   448  <br>
 detailed  circuit,   477  <br>
 fan-in,   67  <br>
 logic  diagram,   448  <br>
 <br>sequential circuits (experiment 9) <br>
 fan-out,   67  <br>
 clock-pulse  generator <br>
 design  of  counter,   460 � 461  <br>
 noise  margin,   67  <br>
(experiment  15),   474 � 475  <br>
 state  diagram,   460  <br>
 power  dissipation,   67  <br>
 circuit  operation,   473 � 474  <br>
 <br>up�down counter with enable,  460  <br>
 propagation  delay,   67  <br>
 IC  timer,   473  <br>
 <br>serial addition (experiment 12) <br>
 levels  of  integration,   66   <br>
 <br>code converters (experiment 5) <br>
 serial  adder,   466 � 467  <br>
  Integrated  circuits  (ICs),   438 � 439  <br>
 <br>Gray code to equivalent binary,  452  <br>
 serial  adder�subtractor,   467  <br>
 required  for  experiments,   442   <br>
 nine's  complementer,   452  <br>
 <br>testing the adder,  467  <br>
  Internet,   2   <br>
 seven-segment  display,   452 � 453  <br>
 <br>shift registers (experiment 11) <br>
  Inverse  of  an  element,   39   <br>
 <br>combinational circuits (experiment 4) <br>
 <br>bidirectional shift register,  465  <br>
  Inverter  circuit,   509   <br>
 decoder  implementation,   450 � 451  <br>
 <br>bidirectional shift register with <br>
  Inverter  gate,   66   <br>
 design  example,   450  <br>
parallel load (IC type 74157), <br>
  Invert-OR  graphic  symbol,   93   <br>
 majority  logic,   450  <br>
 465 � 466  <br>
  iPod  TouchTM,   1    <br>
 parity  generator,   450  <br>
 feedback  shift  register,   464 � 465  <br>
 <br>counters (experiment 10) <br>
 <br>IC shift register,  463  <br>
<b> <br>J </b><br>
 <br>binary counter with parallel load, <br>
 ring  counter,   463 � 464  <br>
 <br><i>JK</i>   fl ip-fl op,   200 � 201 ,   263 ,   371  <br>
 462 � 463  <br>
 <br>Verilog HDl simulation experiments <br>
 analysis  of,   210 � 213  <br>
 decimal  counter,   461  <br>
and rapid prototyping with <br>
 characteristic  equation,   203  <br>
 ripple  counter,   461  <br>
FPGAs: <br>
 characteristic  table,   202    <br>
 <br>synchronous four-bit binary <br>
 experiment  1,   482 � 483  <br>
counter,  461 <br>
 experiment  2,   483 � 484  <br>
<b> <br>K </b><br>
 <br>digital logic gates (experiment 2) <br>
 experiment  4,   484  <br>
  Karnaugh  map,   73   <br>
 NAND  circuit,   447 � 448  <br>
 experiment  5,   484  <br>
  Kilo  (K)  bytes,   5   <br>
 propagation  delay,   447  <br>
 experiment  7,   484  <br>
  K-map,   <i>See</i>   Karnaugh  map   <br>
 truth  table,   446  <br>
 experiment  8,   485  <br>
 <br>universal NAND gate,  447  <br>
 experiment  9,   485  <br>
<b> <br>L </b><br>
 waveforms,   446 � 447  <br>
 experiment  10,   485  <br>
  Laboratory  experiments: <br>
 <br>fl ip-fl ops (experiment 8) <br>
 experiment  11,   485 � 486  <br>
 <br>adders and subtractors (experiment 7) <br>
 <br><i>D</i>   latch,   457  <br>
 experiment  13,   486  <br>
 adder�subtractor  (four-bit), <br>
 <br>IC type fl ip-fl op,   459 � 460  <br>
 experiment  14,   486  <br>
 456 � 457  <br>
 master�slave   <i>D</i>   fl ip-fl op,   458  <br>
 experiment  16,   486  <br>
 full  adder,   455  <br>
 positive-edge-triggered <br>
 experiment  17,   486 � 487   <br>
 half  adder,   455  <br>
fl ip-fl op,   459  <br>
  Lamp  handball  (experiment) <br>
 magnitude  comparator,   457  <br>
 <br><i>SR</i>   latch,   457  <br>
 circuit  analysis,   472  <br>
 parallel  adder,   455 � 456  <br>
 <br>lamp handball (experiment 14) <br>
 counting  number  of  losses,   472 � 473  <br>
 <br>binary and decimal numbers <br>
 circuit  analysis,   472  <br>
 <br>IC type 74194,  470  <br>
(experiment 1) <br>
 counting  number  of  losses,   472 � 473  <br>
 <br>lamp Ping-Pong game,  473  <br>
 BCD  count,   444 � 445  <br>
 <br>IC type 74194,  470  <br>
 logic  diagram,   470 � 472  <br>
 binary  count,   443  <br>
 <br>lamp Ping-Pong game,  473  <br>
 playing  the  game,   472   <br>
 counts,   446  <br>
 logic  diagram,   470 � 472  <br>
  Lamp  Ping-Pong  game,   473   <br>
 oscilloscope,   444  <br>
 <br>playing the game,  472  <br>
  Large-scale  integration  (LSI) <br>
 output  pattern,   445  <br>
 <br>memory unit (experiment 13) <br>
devices,   66   <br>
 <br>binary multiplier (experiment 17), <br>
 IC  RAM,   467 � 468  <br>
  Latches,   193 � 196 ,   220 � 223  <br>
 478 � 480 <br>
 memory  expansion,   469  <br>
 <br><i>D</i>   latch,   195 � 196 ,   457  <br>
 block  diagram,   478  <br>
 ROM  simulator,   469  <br>
 NAND  latch,   194  <br>
 <br>checking the multiplier,  479  <br>
 testing  RAM,   468 � 469  <br>
 NOR  latch,   194  <br>
 control  of  registers,   478 � 479  <br>
 <br>multiplexer design (experiment 6) <br>
 <br><i>SR</i>   latch,   193 � 195 ,   457   <br>
 datapath  design,   479  <br>
 design  specifi cations,   453 � 454  <br>
  Latch-free  design,   425 � 426   <br>
 <br>design of control,  479  <br>
 <br>parallel adder and accumulator <br>
  Level-sensitive  cyclic  behavior,   354   <br>
 multiplication  example,   479  <br>
(experiment 16) <br>
  Load  operation,   351   <br>
<hr>
<A name=562></a><b>544    Index</b><br>
  Logic-circuit  diagram,   46 � 47   <br>
 <br>Moore model of fi nite state machine, <br>
 circuit  operation,   477 � 478  <br>
  Logic  circuits,   3   <br>
 214 � 217   <br>
 control  of  register,   475 � 476  <br>
 <br>Logic families, of digital integrated <br>
 <br>Moore-type zero detector sequential <br>
 detailed  circuit,   477   <br>
circuits,   67   <br>
circuit,   228   <br>
  Parallel-load  control,   264   <br>
  Logic  gates,   31 � 33   <br>
  Most  signifi cant bit (MSB),  358  <br>
 <br><b>parameter</b>   statement,   224   <br>
  Logic  simulators,   125   <br>
  Multiple-IC  MSI  design,   126   <br>
  Parity  bit,   26   <br>
  Logic  synthesis,   109 ,   361 � 363    <br>
  Multiplexer  design  (experiment), <br>
  Parity  error,   26 � 27   <br>
 453 � 454   <br>
 <br><i>P-</i> channel  MOS,   509   <br>
<b> <br>M </b><br>
  Multiplexers,   158 � 164  <br>
 <br><b>pmos</b>   keyword,   517   <br>
  Macrocells,   330 � 331   <br>
 design  with,   411 � 422  <br>
  Polarity  indicator,   65   <br>
  Magnitude  comparator,   148 � 150   <br>
 testing  of  ones  counter,   421 � 422    <br>
  Port  list,   112   <br>
  Map  minimization  method: <br>
 <br><b>posedge</b>   keyword,   219 � 222 ,   354   <br>
 <br>fi ve-variable K-map,  84  <br>
<b> <br>N </b><br>
  Positive-edge-triggered  fl ip-fl op,   459   <br>
 four-variable  K-map,   80 � 84  <br>
  Name  association  mechanism,   178   <br>
  Positive  integers,   14   <br>
 <br>prime implicants of a function,  82 � 84  <br>
  NAND  circuits,   90 � 91 ,   447 � 448   <br>
  Positive-logic  AND  gate,   65   <br>
 three-variable  K-map,   75 � 76  <br>
  NAND  gate,   58 ,   60 ,   63 ,   66 ,   90 � 93 ,   <br>
  Positive  logic  polarity,   64   <br>
 two-variable  K-map,   74 � 75   <br>
439 ,   510   <br>
 <br>Postulates of a mathematical system,  39  <br>
  Mask  programming,   320   <br>
  NAND  latch,   194   <br>
 <br>Postulates of Boolean algebra, <br>
  Master�slave  fl ip-fl op,   198  <br>
  NAND�NAND  diagrams,   98 � 99   <br>
 43 � 44   <br>
 <br><i>D</i>   fl ip-fl op,   458 ,   517   <br>
 <br><i>N</i>   bits,   27   <br>
  Power  dissipation,   67   <br>
 <br>Mathematical system, postulates of a,  39  <br>
 <br><i>N-</i> channel  MOS,   509 � 510   <br>
  Predefi ned  primitives,   112   <br>
  Maxterms,   51 � 52  <br>
  Negative-logic  OR  gate,   65   <br>
 <br>Prime implicants of a function, <br>
 ANDing  of,   55  <br>
  Negative  logic  polarity,   64   <br>
 82 � 84   <br>
 defi nition,   55  <br>
 <br><b>negedge</b>   keyword,   219 ,   222 ,   354   <br>
 <br><b>primitive</b>  ...  <b>endprimitive</b> <br>
 product  of,   54 � 55   <br>
  Netlist,   109   <br>
keyword pair,  116 <br>
 <br>Mealy model of fi nite state machine, <br>
  Nine's  complementer,   452   <br>
  Primitive  gates,   165   <br>
 214 � 217   <br>
 <br><b>nmos</b>   keyword,   517   <br>
 <br><b>primitive</b>   keyword,   117   <br>
 <br><i>Mealy_Zero_Detector,</i>    226 � 227   <br>
  Noise  margin,   67   <br>
  Processor  registers,   29   <br>
  Medium-scale  integration  (MSI) <br>
  Nonblocking  assignments,   219 � 220 ,   355   <br>
  Product-of-maxterms  form,   87   <br>
circuits,   66 ,   126 ,   439   <br>
  Nondegenerate  forms,  of  gates,   98 � 99   <br>
  Product  of  sums,   57   <br>
  Memory  chips,   66   <br>
  NOR  gate,   60 ,   63 ,   66 ,   90 ,   510   <br>
 <br>Product-of-sums form, of Boolean <br>
  Memory  decoding: <br>
  NOR  latch,   194   <br>
function,   84 � 88 ,   90   <br>
 coincident,   309 � 312  <br>
  NOR�NOR  diagrams,   98 � 99   <br>
  Program,   1   <br>
 internal  construction,   307 � 309   <br>
  NOT  gate,   30 ,   32 ,   42 ,   58 ,   113   <br>
 <br>Programmable array logic (PAL), <br>
  Memory  registers,   29   <br>
 <br><i>N</i> -type  dopant,   507   <br>
 299 ,   321  <br>
  Memory  unit,   2 ,   29   <br>
  Number-base  conversions,   6 � 8    <br>
 buffer�inverter  gate,   325  <br>
  Memory  unit  (experiment) <br>
 commercial,   325  <br>
 IC  RAM,   467 � 468  <br>
<b> <br>O </b><br>
 fuse  map  of,   328 � 329  <br>
 memory  expansion,   469  <br>
  Octal  number  system,   4 ,   8 � 10   <br>
 programming  table,   327   <br>
 ROM  simulator,   469  <br>
  Odd  function,   62   <br>
 <br>Programmable logic array (PLA) <br>
 testing  RAM,   468 � 469   <br>
  One-hot  assignment,   397 ,   401 � 402   <br>
 <br>Boolean functions implemented <br>
  Metal-oxide  semiconductor  (MOS),   67   <br>
  Open  Verilog  International  (OVI),   110   <br>
in,   322  <br>
  Metal-oxide  silicon  semiconductors,   507  <br>
  OR�AND  diagrams,   98 � 99   <br>
 custom-made,   324  <br>
 basic  structure,   508  <br>
  OR�AND�INVERT  function,   98   <br>
 <br>fuse map of,  323  <br>
 types  of,   508   <br>
  ORed  with   <i>xx</i> ',   54   <br>
 <br>internal logic of,  322  <br>
  Miniterms,   51 � 52  <br>
  OR  gate,   30 ,   32 � 33 ,   42 ,   46 � 47 ,   50 ,   57 � 58 , <br>
 programming  table,   323  <br>
 defi nition,   55  <br>
 60 ,   65 ,   90 ,   113 ,   316 ,   323   <br>
 size  of,   324   <br>
 don't-care,   88 � 90  <br>
  OR�NAND  diagrams,   98 � 99   <br>
 <br>Programmable logic device (PLD),  66 , <br>
 <br>and prime implicants,  83  <br>
 <br><b>output</b>   declaration,   117    <br>
 68 ,   299   <br>
 sum  of,   52 � 53   <br>
  Programmable  read-only  memory <br>
  Minterm,   51   <br>
<b> <br>P </b><br>
(PROM),   320   <br>
  Module,   111   <br>
 <br>Parallel adder and accumulator <br>
  Propagation  delay,   67 ,   110 ,   447   <br>
 <br><b>module</b>  ...  <b>endmodule</b>  keyword pair, <br>
(experiment) <br>
 <br><i>P</i> -type  device,   507 � 508    <br>
 116 ,   169   <br>
 block  diagram,   475  <br>
 <br><b>$monitor</b>   statement,   178 ,   180   <br>
 carry  circuit,   476  <br>
<b> <br>Q </b><br>
 <br><b>$monitor</b>   system  task,   179   <br>
 <br>checking the circuit,  477  <br>
  Qualifying  symbols,   491 � 493    <br>
<hr>
<A name=563></a><b>Index    545</b><br>
<b> <br>R </b><br>
 operators,   355 � 358  <br>
  Serial  addition  (experiment) <br>
  Race-free  design,   422 � 425   <br>
 procedural  assignments,   355  <br>
 serial  adder,   466 � 467  <br>
  Radix  complement,   11 � 12   <br>
 HDL  descriptions: <br>
 serial  adder�subtractor,   467  <br>
 <br><i>R</i> -allowable  digits,   5   <br>
 of  binary  circuits,   402 � 411  <br>
 testing  the  adder,   467   <br>
  Random-access  memory  (RAM), <br>
 <br>of combinational circuits, <br>
  Set  of  elements,   38   <br>
 299 � 307  <br>
 381 � 391  <br>
  Set  of  natural  numbers,   39   <br>
 <br>memory description in HDL,<br>
 latch-free  design,   425 � 426  <br>
  Set  of  operators,   38   <br>
   303 � 304  <br>
 with  multiplexers,   411 � 422  <br>
  Set  of  real  numbers,   39   <br>
 symbol,   504 � 505  <br>
 notation,   351 � 354  <br>
  Shift-left  control,   264   <br>
 timing  waveforms,   304 � 306  <br>
 procedural  assignments,   355  <br>
  Shift  operation,   351   <br>
 types  of  memories,   306 � 307  <br>
 propagation  delays,   353  <br>
  Shift  registers  (experiment) <br>
 write  and  read  operations,   302 � 303   <br>
 race-free  design,   422 � 425  <br>
 <br>bidirectional shift register,  465  <br>
  Read-only  memory  (ROM),   299 , <br>
 <br>sequential binary multiplier, <br>
 <br>bidirectional shift register with <br>
 315 � 321  <br>
 391 � 396  <br>
parallel load (IC type 74157), <br>
 block  diagram,   316  <br>
 <br>type of operations,  353  <br>
 465 � 466  <br>
 combinational  circuit <br>
 Verilog  HDL  for,   426   <br>
 feedback  shift  register,   464 � 465  <br>
implementation,   318  <br>
 <br><b>reg</b>   keyword,   168 ,   175 ,   177 ,   179 , <br>
 <br>IC shift register,  463  <br>
 <br>example of 32�8,  316  <br>
 220 � 221 ,   360   <br>
 ring  counter,   463 � 464   <br>
 hardware  procedure,   317  <br>
 <br><b>repeat</b>   loop,   358   <br>
  Shift-right  control,   264   <br>
 <br>inputs and outputs,  316  <br>
 <br><i>Ripple_carry_4_bit_adder,</i>    169   <br>
  Signals,   2  <br>
 <br>internal binary storage of,  317  <br>
  Ripple  counter: <br>
 assignment  of,   64   <br>
 <br>truth table of,  317  <br>
 BCD,   269 � 271  <br>
  Signed  binary  numbers,   14 � 18  <br>
 types,   320   <br>
 binary,   267 � 269  <br>
 arithmetic  addition,   16 � 17  <br>
  Record  separator  (RS)  control,   26   <br>
 HDL  for,   288 � 290    <br>
 arithmetic  subtraction,   17 � 18  <br>
  Rectangular-shape  symbols,   488 � 491   <br>
 signed-complement  system,   15  <br>
  Register  (s),   27  <br>
<b> <br>S </b><br>
 signed-magnitude  convention,   15   <br>
 defi ned,   255  <br>
  Schematic  capture,   68   <br>
  Signed-complement  system,   15 ,   21   <br>
 <br>of excess-3 code,  27  <br>
  Schematic  entry,   68   <br>
  Signed-magnitude  convention,   15   <br>
 four-bit,   256  <br>
  Semiconductors,   507   <br>
  Signed-10's-complement  system,   21   <br>
 HDL  for,   284 � 287  <br>
  Sensitivity  list,   175   <br>
  Silicon  crystalline  structure,   507   <br>
 <br>loading or updating,  257  <br>
  Sequential  binary  multiplier: <br>
 <br><i>Simple_Circuit,</i>    112 � 113   <br>
 <br>with parallel load,  257  <br>
 ASMD  chart,   394 � 396  <br>
 <br><i>Simple_Circuit_ prop_delay,</i>    114   <br>
 shift,   258 � 266  <br>
 <br>interface between the controller and <br>
  Single-pass  behavior,   217   <br>
 serial  addition,   261 � 263  <br>
the datapath,  393  <br>
 <br>Small-scale integration (SSI) circuits, <br>
 <br>serial transfer of information, <br>
 <br>numerical example for binary <br>
 439   <br>
 259 � 261  <br>
multiplier,   396  <br>
  Small-scale  integration  (SSI)  devices,   66   <br>
 universal,   263 � 266  <br>
 register  confi guration,   392 � 393  <br>
  Software  programs,   68   <br>
 symbol,   499 � 502  <br>
 <br>registers needed for the data <br>
  Source  terminal,   508   <br>
 transfer  of  information  among,   28 � 30   <br>
processor  subsystem,   395   <br>
  Spartan TM ,   333 ,   339 � 344   <br>
 <br>Register transfer level (RTL),  3  <br>
  Sequential  circuits  (experiment) <br>
 <br><i>SR</i>   latch,   193 � 195 ,   457   <br>
 <br>algorithmic state machines (ASMs), <br>
 design  of  counter,   460 � 461  <br>
  Standard  cells,   126   <br>
 363 � 371  <br>
 state  diagram,   460  <br>
 <br>Standard form of Boolean algebra, <br>
 block,   368 � 369  <br>
 <br>up�down counter with enable,  460  <br>
 56 � 58   <br>
 chart,   365 � 368 ,   370 � 371  <br>
  Sequential  programmable  devices, <br>
  Standard  product,   51   <br>
 <br>relationship between control <br>
 329 � 346  <br>
  Standard  sums,   51   <br>
logic and data-processing <br>
 AND�OR  sum-of-products <br>
  State  table,   378 � 379   <br>
operations,  364  <br>
function,   330  <br>
  STX  (start  of  text),   26   <br>
 simplifi cations,   369  <br>
 <br>complex programmable logic device <br>
  Sum  of  products,   56 ,   62 ,   88 ,   91   <br>
 timing  considerations,   369 � 370  <br>
(CPLD),   329 ,   331  <br>
  Sum  terms,   57   <br>
 <br>combinational circuit functions,  354  <br>
 confi guration,   331  <br>
 <br><b>supply1</b>  and  <b>supply0</b>   keyword,   518   <br>
 control  logic,   396 � 402  <br>
 <br>fi eld-programmable gate array <br>
  Switching  algebra,   43   <br>
 in  HDL,   354 � 363  <br>
(FPGA),   329 � 330 ,   332  <br>
  Switch-level  modeling,   517 � 520   <br>
 <br>fl owchart for modeling, verifi cation, <br>
 <br>input�output (I/O) blocks,  330  <br>
  Symbols,   61 ,   171  <br>
and synthesis,  363  <br>
 registered,   330  <br>
 !,   171  <br>
 logic  synthesis,   361 � 363  <br>
 <br>sequential (or simple) programmable <br>
 %,   178  <br>
 loop  statements,   358 � 361  <br>
logic device (SPLD),  329  <br>
 &amp;,   171  <br>
<hr>
<A name=564></a><b>546    Index</b><br>
Symbols <i>(cont.)</i><br>
 for  registers,   499 � 502  <br>
  Theorems  of  Boolean  algebra,   43 � 45  <br>
 &amp;&amp;,   171  <br>
 <br>ripple counter (RCTR),  491  <br>
 proofs,   44 � 45   <br>
 ,   53  <br>
 semicolon  (;),   112 ,   174  <br>
 <br>Thermal agitation, impact on <br>
 *  /,   111  <br>
 shift  left,   492  <br>
semiconductor,   507   <br>
 +,   171  <br>
 <br>shift register (SRG),  491  <br>
  Three-input  exclusive-OR  gate,   64   <br>
 /  *,   111  <br>
 shift  right,   492  <br>
  Three-input  NAND  gate,   91   <br>
 =  =,   171  <br>
 <br>slashes (  <i>//</i>   ),   111  <br>
  Three-state  buffer  gate,   162   <br>
 @,   174 � 175 ,   354 ,   425 � 426  <br>
 three-state  output,   492  <br>
  Three-state  buffers,   163   <br>
 ^,   171  <br>
 Verilog  HDL  operators,   356   <br>
  Three-state  gates,   162 � 164 ,   169 � 170   <br>
 |,   171  <br>
  Synchronous  counter: <br>
  Three-variable  K-map,   75 � 76   <br>
 "| " ,   174  <br>
 BCD,   275  <br>
 <br><b>$time</b>,    178   <br>
 �,   171  <br>
 binary,   271 � 272  <br>
 <br><b>timescale</b>   compiler,   113   <br>
 ?:,   171  <br>
 with  parallel  load,   276 � 278  <br>
  Timing  diagrams,   32   <br>
 <br>(&amp;), (/), and (~),  115  <br>
 up�down,   272 � 275  <br>
  Timing  verifi cation,   110 ,   181   <br>
 <br>,   58  <br>
 HDL  for,   287 � 288   <br>
  Transfer  function,   60   <br>
 <br>active-low input or output,  492  <br>
  Synchronous  sequential  circuit,   191   <br>
 <br>Transfer of information, among <br>
 adder  (),   491  <br>
  Synchronous  sequential  logic: <br>
registers,   28 � 30   <br>
 <br>AND gate or function (&amp;),  491  <br>
 <br>clocked sequential circuits, analysis <br>
  Transistors,   2   <br>
 <br>arithmetic logic unit (ALU),  491  <br>
of,   204 � 217  <br>
  Transistor�transistor  logic  (TTL),   67   <br>
 <br>arithmetic operators (+, �, *, /),  356  <br>
 design  of,   236 � 245  <br>
  Trigger,   196   <br>
 <br>buffer gate or inverter,  491  <br>
 <br><i>D</i>   fl ip-fl ops, analysis of,  210  <br>
 <br><b>tri</b>   keyword,   170   <br>
 <br>coder, decoder, or code converter <br>
 <br>fl ip-fl op  input  equations,   209 � 210  <br>
  Truth  table,   31 ,   46 ,   52 � 53 ,   86 ,   109 ,   129  <br>
(X/Y),   491  <br>
 <br><i>JK</i>   fl ip-fl ops,  analysis  of,   210 � 213  <br>
 <br>and Boolean algebra,  45  <br>
 for  combinational  elements,   495 � 497  <br>
 <br>Mealy and Moore models of fi nite <br>
 <br>for the 16 functions of two binary <br>
 <br>contents of register equals binary <br>
state  machines,   214 � 217  <br>
variables,   58  <br>
 15 ,   492  <br>
 state  diagram  of,   207 � 209  <br>
 ROM,   317   <br>
 countdown,   492  <br>
 state  equation  of,   205 � 206  <br>
 <br><i>T_Simple_Circuit_prop_delay,</i>    114   <br>
 counter  (CTR),   491  <br>
 state  table  of,   206 � 207  <br>
 <br><i>T</i>  (toggle) fl ip-fl op,   200 � 201  <br>
 for  counters,   502 � 504  <br>
 structural  description  of,   228 � 230  <br>
 analysis,   213 � 214  <br>
 countup,   492  <br>
 <br><i>T</i>   fl ip-fl ops,  analysis  of,   213 � 214  <br>
 characteristic  equation,   203  <br>
 <br>data input to a storage element,  492  <br>
 design  procedure: <br>
 characteristic  table,   202   <br>
 demultiplexer  (DMUX),   491  <br>
 excitation  table,   239 � 241  <br>
  Two-level  gating  structure,   57   <br>
 <br>for digital logic circuits,  32  <br>
 <br>logic diagram of three-bit binary <br>
  Two-level  implementation,   56 � 57   <br>
 <br>dynamic indicator input,  492  <br>
counter,   245  <br>
  of  Boolean  function,   91 � 93   <br>
 enable  input,   492  <br>
 <br>maps for three-bit binary <br>
  Two-to-one-line  multiplexer,   163 ,   174   <br>
 <br>even function or even parity element <br>
counter,   245  <br>
  Two-valued  Boolean  algebra,   41 � 43  <br>
(2k),   491  <br>
 using   <i>D</i>   fl ip-fl ops,   238 � 239  <br>
 defi nition,   41  <br>
 <br>exclusive-OR gate or function <br>
 using   <i>JK</i>   fl ip-fl ops,   241 � 243  <br>
 rules  of  binary  operation,   41 � 42   <br>
(= 1 ),   491  <br>
 using   <i>T</i>   fl ip-fl ops,   243 � 245  <br>
  Two-variable  K-map,   74 � 75    <br>
 <br>exponentiation operator (**),  356  <br>
 HDL  models: <br>
 <br>fl ip-fl op inputs,  492  <br>
 behavioral  modeling,   217 � 220  <br>
<b> <br>U </b><br>
 for  fl ip-fl ops,   497 � 499  <br>
 <br>fl ip-fl ops  and  latches,   220 � 223  <br>
  Unidirectional  shift  register,   264   <br>
 <br>logic negation input or output,  492  <br>
 state  diagram,   223 � 227  <br>
  Universal  gate,   90   <br>
 <br>magnitude comparator (COMP),  491  <br>
 sequential  circuits,   190 � 192  <br>
  Universal  NAND  gate,   447   <br>
 <br>of MOS transistor,  509  <br>
 state  assignment,   235 � 236  <br>
  Universal  shift  register,   263 � 266   <br>
 multiplexer  (MUX),   491  <br>
 state  reduction,   231 � 235  <br>
  User-defi ned primitives (UDPs), <br>
 multiplier  (),   491  <br>
 storage  elements: <br>
 116 � 118    <br>
 <br>odd function or odd parity element <br>
 <br>fl ip-fl ops,   196 � 204  <br>
(2k+1),   491  <br>
 latches,   193 � 196   <br>
 open-collector  output,   492  <br>
  System  primitives,   116    <br>
<b> <br>V </b><br>
 <br>OR gate or function (1),  491  <br>
  Vectors,   166   <br>
 <br>output with special amplifi cation,   492  <br>
<b> <br>T </b><br>
  Verifi cation,   181   <br>
 (),   55  <br>
 <br><b>table</b>,    117   <br>
  Verilog  2001,   426   <br>
 for  RAM,   504 � 505  <br>
  Tera  (T)  bytes,   5   <br>
  Verilog  2005,   426   <br>
 <br>random-access memory (RAM),  491  <br>
  Test  bench,   109   <br>
  Verilog  HDL,   68 ,   115 ,   118 ,   332 , <br>
 <br>read-only memory (ROM),  491  <br>
 <br><i>T</i>   fl ip-fl ops,  analysis  of,   213 � 214   <br>
 354 ,   438  <br>
<hr>
<A name=565></a><b>Index    547</b><br>
 <br>fl owchart,   363  <br>
  Virtex TM ,   333 ,   344 � 346   <br>
  Xilinx  FPGA: <br>
 <br>logical and relational operators,  357  <br>
  Voltage-operated  logic  circuits,   31    <br>
 basic  architecture,   333  <br>
 <br>logic operators for binary words,  357  <br>
 confi gurable logic block <br>
 looping  statements,   358 � 361  <br>
(CLB),   334  <br>
<b> <br>W </b><br>
 operator  precedence,   359  <br>
 distributed  RAM,   334  <br>
 <br><b>while</b>   loop,   359   <br>
 operators,   355 � 358  <br>
 enhancements,   337 � 339  <br>
  Wired-AND  gate,   97   <br>
 <br>register transfer operation,  354  <br>
 <br>interconnect lines of,<br>
  Wired  logic,   97   <br>
 switch-level  modeling  in,   517 � 520   <br>
   334 � 336  <br>
 <br><b>wire</b>   keyword,   112 ,   170 ,   179   <br>
  Verilog  module,   112   <br>
 <br>I/O block (IOB),  337  <br>
 <br><b>$write</b>,    178    <br>
  Verilog  statements,   115   <br>
 series,   333  <br>
  Verilog  system  tasks,   178 � 181   <br>
 Spartan  II,   340 � 344  <br>
 <br>Very large-scale integration (VLSI) <br>
<b> <br>X </b><br>
 Spartan  XL  chips,   339 � 340  <br>
circuits,   66 � 67 ,   126  <br>
  XC2000,   333   <br>
 Virtex,   344 � 346   <br>
 gate  array,   332   <br>
  XC3000,   333   <br>
  XOR  gate,   323   <br>
  VHDL,   332   <br>
  XC4000,   333   <br>
  XOR  operation,   315      <br>
<hr>
<A name="outline"></a><h1>Document Outline</h1>
<ul><li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<ul><li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
</ul><li>��
<ul><li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
</ul><li>��
<ul><li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
</ul><li>��
<ul><li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
</ul><li>��
<ul><li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
</ul><li>��
<ul><li>��
<li>��
<li>��
<li>��
<li>��
<li>��
</ul><li>��
<ul><li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
</ul><li>��
<ul><li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
</ul><li>��
<ul><li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
</ul><li>��
<ul><li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
</ul><li>��
<li>��
<li>��
<ul><li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
<li>��
</ul></ul><hr>
</BODY>
</HTML>
